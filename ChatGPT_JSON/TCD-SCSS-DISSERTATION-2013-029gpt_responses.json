{"Page 1": {"response": "<h3>\n<strong>\n  Exploring Real-World Applications of Cellular Automata in Simulating Flocking Behavior\n </strong>\n</h3>\n<p>\n This dissertation by\n <strong>\n  James Shannon\n </strong>\n investigates the use of\n <strong>\n  cellular automata\n </strong>\n (CA) for simulating\n <strong>\n  flocking behavior\n </strong>\n . The work was presented to the\n <strong>\n  University of Dublin\n </strong>\n as part of the requirements for the\n <strong>\n  Master of Science in Computer Science\n </strong>\n (Interactive Entertainment Technology) degree, completed in\n <strong>\n  August 2013\n </strong>\n .\n</p>\n<p>\n The primary focus is on how\n <strong>\n  cellular automata\n </strong>\n , which model complex systems using simple, grid-based rules, can be applied to simulate natural phenomena like flocking behavior seen in animals (e.g., birds, fish). The study explores how CA can effectively mimic these behaviors and offers a potential solution to challenges faced in more traditional simulation methods.\n</p>\n"}, "Page 2": {"response": "<h3>\n<strong>\n  Declaration of Originality\n </strong>\n</h3>\n<p>\n<strong>\n  James Shannon\n </strong>\n affirms that the dissertation is entirely his own work, except where explicitly noted otherwise. He confirms that this work has not been submitted for any degree at the\n <strong>\n  University of Dublin\n </strong>\n or any other institution. The declaration is signed on\n <strong>\n  August 29th, 2013\n </strong>\n .\n</p>\n"}, "Page 3": {"response": "<h3>\n<strong>\n  Permission to Lend and Copy\n </strong>\n</h3>\n<p>\n<strong>\n  James Shannon\n </strong>\n grants permission for the\n <strong>\n  Trinity College Library\n </strong>\n to lend or make copies of the dissertation upon request. This allows others to access and use the dissertation for academic purposes. The permission was given on\n <strong>\n  August 29th, 2013\n </strong>\n .\n</p>\n"}, "Page 4": {"response": "<h3>\n<strong>\n  Acknowledgements\n </strong>\n</h3>\n<p>\n<strong>\n  James Shannon\n </strong>\n expresses gratitude to his\n <strong>\n  supervisor, Dr. M\u00fache\u00edl Mac an Airchinnigh\n </strong>\n , and the\n <strong>\n  course director, Dr. John Dingliana\n </strong>\n , for their valuable\n <strong>\n  advice\n </strong>\n and\n <strong>\n  feedback\n </strong>\n during the academic year. He also thanks his\n <strong>\n  family\n </strong>\n for their\n <strong>\n  support\n </strong>\n throughout the year. The acknowledgements were made at the\n <strong>\n  University of Dublin, Trinity College\n </strong>\n , in\n <strong>\n  August 2013\n </strong>\n .\n</p>\n"}, "Page 13": {"response": "<h3>\n Dissertation Outline and Approach\n</h3>\n<h4>\n Goals of the Research\n</h4>\n<p>\n The objective is to create a new cellular automaton that effectively approximates flocking behavior, similar to the continuous Boids algorithm, but in a discrete form. The new method must meet two key requirements:\n</p>\n<ul>\n<li>\n<strong>\n   Efficiency\n  </strong>\n  : It must be efficient enough to be used in real-time applications.\n </li>\n<li>\n<strong>\n   Scalability\n  </strong>\n  : The approach should be able to scale effectively in dynamic scenes that become more complex.\n </li>\n</ul>\n<h4>\n 5.3 Dissertation Outline\n</h4>\n<p>\n The dissertation will be structured as follows:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    State of the Art\n   </strong>\n   : This chapter will thoroughly explain the concept of flocking behavior in nature and how it is defined. It will explore the\n   <strong>\n    Boids algorithm\n   </strong>\n   , the first computational algorithm for flocking, which has played a crucial role in simulating flocking behavior. Additionally, the optimization technique for Boids,\n   <strong>\n    Bin-Lattice Spatial Subdivision\n   </strong>\n   , will be examined in detail, highlighting how it improves performance over the basic unoptimized version of Boids. The unoptimized version of Boids will serve as the benchmark for the research to ensure a fair comparison during performance testing.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Cellular Automata and Flocking\n   </strong>\n   : Following the discussion of Boids, the dissertation will explain both\n   <strong>\n    elementary\n   </strong>\n   and\n   <strong>\n    two-dimensional cellular automata\n   </strong>\n   . Understanding these concepts is vital for the new approach to flocking. The chapter will compare the way flocking behavior is defined with how cellular automata generate complex behaviors. The reasoning for why cellular automata could be a viable foundation for developing a new flocking technique will also be explored.\n  </p>\n</li>\n</ol>\n"}, "Page 14": {"response": "<h3>\n Dissertation Structure and Research Approach\n</h3>\n<h4>\n 5.3 Dissertation Outline (Continued)\n</h4>\n<p>\n The dissertation will cover the following key chapters:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Conway\u2019s Game of Life\n   </strong>\n   : This chapter will introduce Conway's Game of Life, a well-known example of two-dimensional cellular automata. It will be used to demonstrate how simple rules applied to a large grid can lead to complex, emergent behaviors, helping to justify why cellular automata are a strong foundation for simulating flocking behavior.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Research Approach\n   </strong>\n   : The chapter will outline the initial strategy for addressing the flocking problem using cellular automata. It will include a review of relevant research papers on practical applications of cellular automata, highlighting the methods used by others to solve similar problems.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Implementation\n   </strong>\n   : This section will provide a detailed explanation of the new algorithm developed for the research. It will break down the algorithm step-by-step, supported by diagrams, and show how it approximates flocking behavior while maintaining the principles used in the Boids algorithm. The focus will be on how the algorithm works in discrete space as opposed to the continuous space used in Boids.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Testing and Evaluation\n   </strong>\n   : The performance of both the Boids and the cellular automata-based approaches will be tested under varying conditions. This chapter will describe the experiments conducted, present results in graphical form, and analyze the outcomes. It will also evaluate the success of the new algorithm in achieving the goals of the project.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Conclusion and Future Work\n   </strong>\n   : The final chapter will assess how well the project goals were met and discuss potential future applications of the new algorithm.\n  </p>\n</li>\n</ol>\n"}, "Page 15": {"response": "<h3>\n 6.1 Overview of Flocking Behavior\n</h3>\n<p>\n Flocking is a complex and fascinating natural phenomenon that has been widely studied. It refers to the way in which groups of autonomous agents, such as birds, insects, or fish, interact to form coordinated, fluid movement patterns. While the exact mechanisms behind this behavior remain somewhat unclear, it has been modeled through various algorithms.\n</p>\n<p>\n One key feature of flocking behavior is the apparent illusion of a \"centralized controller\" guiding the movement of the flock. In reality, however, the coordination arises from the individual behaviors of the agents, which together lead to a more complex group dynamic.\n</p>\n<p>\n To better understand and simulate this phenomenon, we must first define the characteristics of a flock and its members. These key traits include:\n</p>\n<ul>\n<li>\n<strong>\n   Self-Organizing Autonomous Agents\n  </strong>\n  : Flocks consist of independent agents that follow simple rules to interact with one another.\n </li>\n<li>\n<strong>\n   Emergent Behavior\n  </strong>\n  : The group's movement is not dictated by a single leader but emerges from the collective actions of all members.\n </li>\n<li>\n<strong>\n   Dynamic Leadership\n  </strong>\n  : Within the flock, certain agents may temporarily take on the role of a leader, influencing the formation's direction. As they tire, other agents may step forward to lead.\n </li>\n<li>\n<strong>\n   Responsive to Internal and External Forces\n  </strong>\n  : The flock adjusts its behavior based on both internal factors, such as the position and movement of other agents, and external factors, like obstacles or changes in the environment, to maintain cohesion and reach its goal.\n </li>\n</ul>\n"}, "Page 16": {"response": "<h3>\n 6.2 Boids Flocking Algorithm\n</h3>\n<p>\n The simulation of flocking behavior has been an area of focus in computer applications for decades, with the aim of mimicking the interactions between autonomous agents in large, complex formations, similar to those seen in nature. The most prominent algorithm developed for this purpose is the Boids algorithm, created by Craig Reynolds. Initially designed to simulate bird flocks, this model has been adapted to other scenarios, such as simulating bat swarms in\n <em>\n  Batman Returns\n </em>\n (1992) and the wildebeest stampede in\n <em>\n  The Lion King\n </em>\n (1994).\n</p>\n<p>\n The Boids algorithm models the behavior of autonomous agents (referred to as \"boids\") and how they interact with each other within a flock. It is based on three simple steering principles that dictate how each boid moves in response to its neighbors within its cone of sight (the immediate area it can perceive). According to Reynolds, this behavior is described as \u201can independent actor navigating according to its local perception of the dynamic environment.\u201d\n</p>\n<p>\n The three main principles in Boids are:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Separation\n   </strong>\n   : This principle ensures that each boid avoids overcrowding and potential collisions by steering away from nearby neighbors that fall within a predefined threshold distance.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Cohesion\n   </strong>\n   : This principle causes boids to steer towards the average position of their neighboring boids, helping to keep the flock together and maintain its structure.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Alignment\n   </strong>\n   : This principle allows a boid to adjust its heading to match the average direction of the neighboring boids, aligning its movement with the group.\n  </p>\n</li>\n</ol>\n<p>\n These three principles combine to create realistic flocking behavior, where individual boids interact based on their local environment, resulting in the formation of large, coordinated structures.\n</p>\n"}, "Page 17": {"response": "<h3>\n Boids Algorithm: Basic Functionality and Principles\n</h3>\n<p>\n The Boids algorithm relies on three core principles\u2014\n <strong>\n  separation\n </strong>\n ,\n <strong>\n  cohesion\n </strong>\n , and\n <strong>\n  alignment\n </strong>\n \u2014to simulate flocking behavior. These principles govern how each boid interacts with its neighbors and maintains the structure of the flock. Here\u2019s a breakdown of these principles and how they function in the basic, un-optimized version of the algorithm:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Separation\n   </strong>\n   : Each boid steers away from its neighbors if they come too close, preventing overcrowding and potential collisions.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Cohesion\n   </strong>\n   : Boids steer towards the average position of their nearby neighbors, helping to maintain the flock's overall structure. However, larger external forces, like obstacles, can override this behavior, forcing the flock to break up to avoid collisions with those obstacles.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Alignment\n   </strong>\n   : Each boid adjusts its heading to match the average heading of its neighbors, ensuring that it moves in the same direction as the others around it.\n  </p>\n</li>\n</ol>\n<h3>\n Basic Algorithm Workflow\n</h3>\n<p>\n In the unoptimized version of the Boids algorithm, the following steps occur:\n</p>\n<ul>\n<li>\n<strong>\n   Scene Awareness\n  </strong>\n  : Every boid has access to the entire simulation space.\n </li>\n<li>\n<strong>\n   Defining Local Neighborhoods\n  </strong>\n  : Each boid defines its own \"cone of vision,\" which is a local area around it where it can perceive and interact with other boids. This neighborhood has a defined radius and angle (usually based on the boid\u2019s flight direction).\n </li>\n<li>\n<strong>\n   Ignoring Distant Boids\n  </strong>\n  : Boids only consider other boids within their neighborhood. Any boids outside this area are completely ignored during the boid's update.\n </li>\n<li>\n<strong>\n   Interaction with Neighbors\n  </strong>\n  : Using the three principles (separation, cohesion, and alignment), each boid interacts with the boids within its neighborhood. These interactions result in the formation of flocks, or smaller groups, depending on the applied forces. These flocks can either move towards a goal (like a food source) or roam freely while internal forces keep the flock intact.\n </li>\n</ul>\n<p>\n By following these basic steps, the Boids algorithm creates realistic flocking behavior, although the current version is unoptimized for larger, more dynamic simulations.\n</p>\n"}, "Page 18": {"response": "<h3>\n Alignment Principle in Boids Algorithm\n</h3>\n<p>\n The\n <strong>\n  Alignment\n </strong>\n rule ensures that all boids in a flock travel at a consistent speed and direction, creating a unified movement. Here\u2019s how it works:\n</p>\n<ol>\n<li>\n<strong>\n   Velocity Averaging\n  </strong>\n  : Each boid looks at the velocities of its neighbors within its cone of vision.\n </li>\n<li>\n<strong>\n   Velocity Adjustment\n  </strong>\n  : After averaging the velocities of the surrounding boids, the result is divided by a damping weight. In the given example, this damping weight is set to 8.\n </li>\n<li>\n<strong>\n   Tuning for Desired Effect\n  </strong>\n  : The damping weight can be adjusted (tuned) to control the force of alignment. By modifying this value, we can change the influence alignment has on the flock, allowing it to either be stronger (more cohesive) or weaker (less noticeable) based on the desired effect for the flock's behavior.\n </li>\n</ol>\n<p>\n This principle helps the flock maintain a smooth, cohesive motion with uniform velocity.\n</p>\n"}, "Page 21": {"response": "<h3>\n Further Optimizations for Boids Algorithm\n</h3>\n<h4>\n<strong>\n  Overcoming Computational Challenges with Spatial Subdivision\n </strong>\n</h4>\n<p>\n To handle the massive computational load of querying agent positions in large-scale flock simulations,\n <strong>\n  spatial subdivision\n </strong>\n is employed. This method involves organizing agents into a spatial data structure (also referred to as a \"spatial database\") based on their locations within the simulation space. This pre-sorting of agent positions drastically reduces the number of checks needed, as agents only need to interact with others in their immediate vicinity.\n</p>\n<p>\n Additional\n <strong>\n  heuristic improvements\n </strong>\n to this spatial subdivision approach have been explored in research, providing further optimizations to the algorithm\u2019s performance.\n</p>\n<h4>\n<strong>\n  Probabilistic Sphere Event Algorithm (PSEA)\n </strong>\n</h4>\n<p>\n Another promising optimization is the\n <strong>\n  Probabilistic Sphere Event Algorithm (PSEA)\n </strong>\n , introduced by Zoran Popovic in his 1994 paper \"The Rapid Simulation of Proximal-Interaction Particle Systems\". PSEA improves the simulation of particle systems where particles are in close proximity and interact with one another.\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Application\n   </strong>\n   : Initially designed for molecular simulations and particle collision detection, PSEA has been proven to outperform spatial subdivision techniques in terms of efficiency.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Trade-off Between Speed and Accuracy\n   </strong>\n   : PSEA offers a tunable trade-off, where users can adjust the algorithm to balance between speed and accuracy depending on the specific needs of the simulation. This makes it adaptable to various scenarios, providing a more efficient approach for simulations that involve proximal interactions.\n  </p>\n</li>\n</ol>\n"}, "Page 20": {"response": "<h3>\n Optimizing Boids Algorithm\n</h3>\n<h4>\n<strong>\n  Limitations of the Basic Boids Algorithm\n </strong>\n</h4>\n<p>\n The Boids algorithm, while effective, faces some performance challenges:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Inefficiency in Large Scenes\n   </strong>\n   : Each boid needs to check the position of every other boid in the scene to determine which ones are within its cone of vision. This can be highly inefficient, especially when simulating large flocks.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Exponential Growth in Calculations\n   </strong>\n   : As the number of boids increases, the number of calculations required grows rapidly. The algorithm has a complexity of O(n\u00b2), meaning that as the number of agents increases, each boid's search for neighbors becomes exponentially more computationally expensive.\n  </p>\n</li>\n</ol>\n<h4>\n<strong>\n  Optimizing with Bin-Lattice Spatial Subdivision\n </strong>\n</h4>\n<p>\n To address these inefficiencies, the\n <strong>\n  Bin-Lattice Spatial Subdivision\n </strong>\n technique is used to optimize the Boids algorithm. Here\u2019s how it works:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Dividing the Application Space\n   </strong>\n   : The environment is divided into discrete sections, or bins, which allows each boid to only search for neighbors within a smaller, localized area instead of checking the entire scene.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Reduced Search Space\n   </strong>\n   : By breaking the environment into manageable sections, the number of potential neighbors each boid must check is dramatically reduced, making the algorithm more efficient.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Handling Complex Scenes\n   </strong>\n   : This technique enables the simulation of large flocks with hundreds or even thousands of boids while interacting with both static and dynamic obstacles in a more computationally feasible way.\n  </p>\n</li>\n</ol>\n"}, "Page 22": {"response": "<h3>\n Overview of Cellular Automata\n</h3>\n<h4>\n<strong>\n  Origins and Development\n </strong>\n</h4>\n<p>\n Cellular automata (CA) were first conceptualized in the 1940s by\n <strong>\n  Stanislaw Ulam\n </strong>\n and\n <strong>\n  John Von Neumann\n </strong>\n while working at the\n <strong>\n  Los Alamos National Laboratory\n </strong>\n . Though the concept was explored during the 1950s and 1960s, it gained widespread attention with the creation of\n <strong>\n  Conway's Game of Life\n </strong>\n in the 1970s. This two-dimensional cellular automaton sparked significant interest beyond academic circles. The field was further popularized by\n <strong>\n  Stephen Wolfram's\n </strong>\n 2002 book\n <em>\n  \"A New Kind of Science\"\n </em>\n , which explored cellular automata in-depth and proposed their potential for applications in areas like processing, lattice gas modeling, and cryptography.\n</p>\n<h4>\n<strong>\n  Definition and Structure\n </strong>\n</h4>\n<p>\n A\n <strong>\n  cellular automaton\n </strong>\n is a discrete model consisting of a grid of cells, each of which can exist in a finite number of states, commonly \"on\" or \"off\". These cells are typically arranged in a grid, which can either be\n <strong>\n  Moore Neighbourhood\n </strong>\n (surrounding 8 cells) or\n <strong>\n  von Neumann neighbourhood\n </strong>\n (surrounding 4 cells). The grid can be expressed in any number of dimensions, and its size may be finite or infinite, depending on the specific implementation.\n</p>\n<p>\n Cellular automata are\n <strong>\n  Turing complete\n </strong>\n when equipped with the appropriate rule sets, meaning they can theoretically perform any computation that a Turing machine can, given sufficient time and resources.\n</p>\n<h4>\n<strong>\n  Types and Applications\n </strong>\n</h4>\n<ul>\n<li>\n  The simplest form of cellular automata is\n  <strong>\n   one-dimensional\n  </strong>\n  . In this setup, each cell has two possible states, typically \"on\" or \"off\". A cell's\n  <strong>\n   neighbourhood\n  </strong>\n  is defined as the two cells next to it, represented as (i-1, i+1) in an array where \"i\" denotes the cell\u2019s position.\n </li>\n<li>\n  Cellular automata are widely studied in fields such as\n  <strong>\n   computability theory\n  </strong>\n  ,\n  <strong>\n   mathematics\n  </strong>\n  , and\n  <strong>\n   theoretical biology\n  </strong>\n  for their complex behaviour emerging from simple rules.\n </li>\n</ul>\n"}, "Page 34": {"response": "<h3>\n<strong>\n  Hexagonal vs Square Grid in Flocking Algorithms\n </strong>\n</h3>\n<h4>\n<strong>\n  Hexagonal Grid vs Square Grid:\n </strong>\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Grid Comparison\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     hexagonal grid\n    </strong>\n    provides\n    <strong>\n     smoother turns\n    </strong>\n    for the flock's movement compared to the\n    <strong>\n     square grid\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     Square grid\n    </strong>\n    movement results in\n    <strong>\n     spaced-out diagonal lines\n    </strong>\n    , making the flock's path more rigid and less natural.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Collision Avoidance\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    In the\n    <strong>\n     square grid\n    </strong>\n    implementation,\n    <strong>\n     collision avoidance\n    </strong>\n    is problematic. For example, agents can get\n    <strong>\n     trapped behind obstacles\n    </strong>\n    (e.g., blue obstacles in the center of the screen). This results in\n    <strong>\n     stagnant movement\n    </strong>\n    .\n   </li>\n<li>\n    The\n    <strong>\n     hexagonal grid\n    </strong>\n    resolves this issue. With its\n    <strong>\n     more diagonal-based neighborhoods\n    </strong>\n    , agents can\n    <strong>\n     navigate around obstacles\n    </strong>\n    more effectively, ensuring smoother movement through the environment.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n<strong>\n  Agent Neighborhood Size:\n </strong>\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Single-Layer Neighborhoods\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    A\n    <strong>\n     single-layer neighborhood\n    </strong>\n    (agents only interact with immediate neighbors) is\n    <strong>\n     too small\n    </strong>\n    for effective movement and obstacle detection.\n   </li>\n<li>\n    Agents may only detect obstacles or other agents when they are\n    <strong>\n     too close\n    </strong>\n    , leading to\n    <strong>\n     immediate repulsion forces\n    </strong>\n    and\n    <strong>\n     abrupt turning\n    </strong>\n    . This results in\n    <strong>\n     unnatural, jerky movement\n    </strong>\n    and\n    <strong>\n     loss of flock structure\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Extended Two-Layer Neighborhoods\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    To improve the\n    <strong>\n     cohesion\n    </strong>\n    and\n    <strong>\n     stability\n    </strong>\n    of the flock, the decision was made to extend the agent's\n    <strong>\n     neighborhood\n    </strong>\n    to\n    <strong>\n     two layers\n    </strong>\n    .\n   </li>\n<li>\n    A\n    <strong>\n     two-layer neighborhood\n    </strong>\n    allows agents to detect obstacles and nearby agents from a\n    <strong>\n     greater distance\n    </strong>\n    , enabling smoother, more\n    <strong>\n     realistic movement\n    </strong>\n    and better overall\n    <strong>\n     flock stability\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n</ol>\n<hr/>\n<h4>\n<strong>\n  Key Concepts\n </strong>\n :\n</h4>\n<ol>\n<li>\n<strong>\n   Hexagonal Grid\n  </strong>\n  : Provides smoother turns and better collision avoidance for agents compared to the square grid.\n </li>\n<li>\n<strong>\n   Square Grid\n  </strong>\n  : Leads to more rigid movement and issues with collision avoidance.\n </li>\n<li>\n<strong>\n   Single-Layer Neighborhood\n  </strong>\n  : Too small, causing abrupt movements and destabilization in the flock.\n </li>\n<li>\n<strong>\n   Two-Layer Neighborhood\n  </strong>\n  : Extends detection range, allowing for more cohesive and stable flock behavior.\n </li>\n</ol>\n<hr/>\n<h3>\n<strong>\n  Conclusion\n </strong>\n :\n</h3>\n<ul>\n<li>\n  Switching from a\n  <strong>\n   square grid\n  </strong>\n  to a\n  <strong>\n   hexagonal grid\n  </strong>\n  significantly improves the\n  <strong>\n   smoothness\n  </strong>\n  and\n  <strong>\n   efficiency\n  </strong>\n  of flock movement, addressing\n  <strong>\n   collision avoidance\n  </strong>\n  issues.\n </li>\n<li>\n  Extending the\n  <strong>\n   neighborhood size\n  </strong>\n  from\n  <strong>\n   one layer to two\n  </strong>\n  helps prevent\n  <strong>\n   jerky turns\n  </strong>\n  , promoting\n  <strong>\n   realistic movement\n  </strong>\n  and better *\n </li>\n</ul>\n"}, "Page 35": {"response": "<h3>\n<strong>\n  Hexagonal vs Square Grid in Flocking Algorithms\n </strong>\n</h3>\n<h4>\n<strong>\n  Hexagonal Grid vs Square Grid:\n </strong>\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Grid Comparison\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     hexagonal grid\n    </strong>\n    provides\n    <strong>\n     smoother turns\n    </strong>\n    for the flock's movement compared to the\n    <strong>\n     square grid\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     Square grid\n    </strong>\n    movement results in\n    <strong>\n     spaced-out diagonal lines\n    </strong>\n    , making the flock's path more rigid and less natural.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Collision Avoidance\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    In the\n    <strong>\n     square grid\n    </strong>\n    implementation,\n    <strong>\n     collision avoidance\n    </strong>\n    is problematic. For example, agents can get\n    <strong>\n     trapped behind obstacles\n    </strong>\n    (e.g., blue obstacles in the center of the screen). This results in\n    <strong>\n     stagnant movement\n    </strong>\n    .\n   </li>\n<li>\n    The\n    <strong>\n     hexagonal grid\n    </strong>\n    resolves this issue. With its\n    <strong>\n     more diagonal-based neighborhoods\n    </strong>\n    , agents can\n    <strong>\n     navigate around obstacles\n    </strong>\n    more effectively, ensuring smoother movement through the environment.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n<strong>\n  Agent Neighborhood Size:\n </strong>\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Single-Layer Neighborhoods\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    A\n    <strong>\n     single-layer neighborhood\n    </strong>\n    (agents only interact with immediate neighbors) is\n    <strong>\n     too small\n    </strong>\n    for effective movement and obstacle detection.\n   </li>\n<li>\n    Agents may only detect obstacles or other agents when they are\n    <strong>\n     too close\n    </strong>\n    , leading to\n    <strong>\n     immediate repulsion forces\n    </strong>\n    and\n    <strong>\n     abrupt turning\n    </strong>\n    . This results in\n    <strong>\n     unnatural, jerky movement\n    </strong>\n    and\n    <strong>\n     loss of flock structure\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Extended Two-Layer Neighborhoods\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    To improve the\n    <strong>\n     cohesion\n    </strong>\n    and\n    <strong>\n     stability\n    </strong>\n    of the flock, the decision was made to extend the agent's\n    <strong>\n     neighborhood\n    </strong>\n    to\n    <strong>\n     two layers\n    </strong>\n    .\n   </li>\n<li>\n    A\n    <strong>\n     two-layer neighborhood\n    </strong>\n    allows agents to detect obstacles and nearby agents from a\n    <strong>\n     greater distance\n    </strong>\n    , enabling smoother, more\n    <strong>\n     realistic movement\n    </strong>\n    and better overall\n    <strong>\n     flock stability\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n</ol>\n<hr/>\n<h4>\n<strong>\n  Key Concepts\n </strong>\n :\n</h4>\n<ol>\n<li>\n<strong>\n   Hexagonal Grid\n  </strong>\n  : Provides smoother turns and better collision avoidance for agents compared to the square grid.\n </li>\n<li>\n<strong>\n   Square Grid\n  </strong>\n  : Leads to more rigid movement and issues with collision avoidance.\n </li>\n<li>\n<strong>\n   Single-Layer Neighborhood\n  </strong>\n  : Too small, causing abrupt movements and destabilization in the flock.\n </li>\n<li>\n<strong>\n   Two-Layer Neighborhood\n  </strong>\n  : Extends detection range, allowing for more cohesive and stable flock behavior.\n </li>\n</ol>\n<hr/>\n<h3>\n<strong>\n  Conclusion\n </strong>\n :\n</h3>\n<ul>\n<li>\n  Switching from a\n  <strong>\n   square grid\n  </strong>\n  to a\n  <strong>\n   hexagonal grid\n  </strong>\n  significantly improves the\n  <strong>\n   smoothness\n  </strong>\n  and\n  <strong>\n   efficiency\n  </strong>\n  of flock movement, addressing\n  <strong>\n   collision avoidance\n  </strong>\n  issues.\n </li>\n<li>\n  Extending the\n  <strong>\n   neighborhood size\n  </strong>\n  from\n  <strong>\n   one layer to two\n  </strong>\n  helps prevent\n  <strong>\n   jerky turns\n  </strong>\n  , promoting\n  <strong>\n   realistic movement\n  </strong>\n  and better *\n </li>\n</ul>\n"}, "Page 36": {"response": "<h3>\n Notes on the Realistic Flock Algorithm:\n</h3>\n<p>\n<strong>\n  1. Introduction to Flocking in Simulations:\n </strong>\n Flocking is a concept used in simulations to model the behavior of groups of agents, such as birds or fish, moving together in a coordinated manner. These agents respond to each other\u2019s positions, movements, and obstacles in their environment. The goal is to ensure that the agents maintain realistic and cohesive group behavior.\n</p>\n<p>\n<strong>\n  2. Neighbourhood Concept in Flocking:\n </strong>\n</p>\n<ul>\n<li>\n  The\n  <strong>\n   neighbourhood\n  </strong>\n  refers to the area around an agent where it detects nearby objects or other agents.\n </li>\n<li>\n  The agent uses this information to make decisions such as avoiding obstacles, aligning with others, and moving towards the center of the group.\n </li>\n</ul>\n<p>\n<strong>\n  3. Initial Neighbourhood (Figure 8.3 - Left):\n </strong>\n</p>\n<ul>\n<li>\n  In the\n  <strong>\n   initial neighbourhood\n  </strong>\n  diagram (on the left), the area around the agent is\n  <strong>\n   too small\n  </strong>\n  to effectively detect incoming obstacles or agents.\n </li>\n<li>\n  As a result, the agent might miss objects in its path or other agents in its vicinity, which can cause unrealistic behavior, such as last-minute evasive maneuvers or collision risks.\n </li>\n</ul>\n<p>\n<strong>\n  4. Final Neighbourhood (Figure 8.3 - Right):\n </strong>\n</p>\n<ul>\n<li>\n  In the\n  <strong>\n   final neighbourhood\n  </strong>\n  (on the right), the area around the agent is\n  <strong>\n   larger\n  </strong>\n  and better at detecting obstacles and other agents.\n </li>\n<li>\n  This enables the agent to take into account not only\n  <strong>\n   obstacles\n  </strong>\n  but also\n  <strong>\n   the positions and directions of nearby agents\n  </strong>\n  .\n </li>\n<li>\n  The agent uses this information to:\n  <ul>\n<li>\n<strong>\n     Avoid collisions\n    </strong>\n    : By steering away from obstacles or other agents.\n   </li>\n<li>\n<strong>\n     Steer towards the center of the local group\n    </strong>\n    : This means the agent moves towards the average position of the agents in its neighbourhood, promoting cohesive group behavior.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n<strong>\n  5. Avoiding Last-Minute Evasive Maneuvers:\n </strong>\n</p>\n<ul>\n<li>\n  With a properly sized neighbourhood, the agent can\n  <strong>\n   anticipate\n  </strong>\n  possible collisions or changes in the environment ahead of time, rather than waiting until the last moment to react.\n </li>\n<li>\n  This leads to more\n  <strong>\n   realistic\n  </strong>\n  and smooth movements in the simulation.\n </li>\n</ul>\n<p>\n<strong>\n  6. Overcoming Problems in the Algorithm:\n </strong>\n</p>\n<ul>\n<li>\n  In the early stages of the project, the\n  <strong>\n   small neighbourhood\n  </strong>\n  posed challenges because it didn't allow for enough data about surrounding agents or obstacles.\n </li>\n<li>\n  Through experimentation and testing, the issues were addressed, and the\n  <strong>\n   final version\n  </strong>\n  of the algorithm was developed, which included a larger, more effective neighbourhood size for detecting obstacles and agents.\n </li>\n</ul>\n<p>\n<strong>\n  7. Key Ideas and Concepts:\n </strong>\n</p>\n<ul>\n<li>\n<strong>\n   Neighbourhood size\n  </strong>\n  : A crucial factor that determines how effectively an agent can perceive and react to its surroundings.\n </li>\n<li>\n<strong>\n   Obstacle detection\n  </strong>\n  : The agent needs to detect obstacles and other agents early to make smooth, realistic movements.\n </li>\n<li>\n<strong>\n   Cohesion\n  </strong>\n  : The agent\u2019s movement towards the center of the group to maintain a realistic flocking behavior.\n </li>\n<li>\n<strong>\n   Evasive maneuvers\n  </strong>\n  : Last-minute reactions that are avoided by correctly sizing the neighbourhood for better anticipation.\n </li>\n</ul>\n<p>\n In conclusion, the flocking algorithm relies heavily on the\n <strong>\n  neighbourhood size\n </strong>\n to detect obstacles and the positions of other agents. The\n <strong>\n  final neighbourhood\n </strong>\n design helps agents avoid collisions and move cohesively, leading to a more realistic simulation of group behavior.\n</p>\n"}, "Page 39": {"response": "<h3>\n Overview of Agent Behavior in Flocking Algorithms\n</h3>\n<p>\n This section discusses how agents interact in a flocking algorithm, based on principles from the\n <strong>\n  Boids algorithm\n </strong>\n , and how forces are applied to determine the movement and behavior of agents. It outlines four key steps for calculating the direction of movement, considering various factors such as cohesion, obstacle avoidance, and agent interactions.\n</p>\n<hr/>\n<h3>\n 1.\n <strong>\n  Boids Algorithm - Cohesion Rule (Discrete Version)\n </strong>\n</h3>\n<ul>\n<li>\n  The\n  <strong>\n   cohesion rule\n  </strong>\n  is a key principle in flocking behaviors, where agents tend to move towards the average position of their neighbors to stay in a group.\n </li>\n<li>\n  In this case, the rule is\n  <strong>\n   discrete\n  </strong>\n  , meaning the agents follow a step-by-step process instead of continuously adjusting in real-time. This discrete approach can be thought of as a simplified version of the\n  <strong>\n   cohesion rule\n  </strong>\n  from the Boids algorithm.\n </li>\n</ul>\n<hr/>\n<h3>\n 2.\n <strong>\n  Adding Forces Together (The First 3 Steps)\n </strong>\n</h3>\n<ul>\n<li>\n  The algorithm combines\n  <strong>\n   three primary forces\n  </strong>\n  acting on the agent, which determine its movement and interactions:\n  <ul>\n<li>\n<strong>\n     Cohesion\n    </strong>\n    : Move towards the center of mass of nearby agents.\n   </li>\n<li>\n<strong>\n     Separation\n    </strong>\n    : Avoid crowding or colliding with nearby agents.\n   </li>\n<li>\n<strong>\n     Alignment\n    </strong>\n    : Align with the average direction of nearby agents.\n   </li>\n</ul>\n</li>\n<li>\n  These three forces are calculated during the first three steps. Each step produces a\n  <strong>\n   directional vector\n  </strong>\n  , which is essentially the preferred movement direction for the agent.\n </li>\n</ul>\n<hr/>\n<h3>\n 3.\n <strong>\n  Applying Damping Weights\n </strong>\n</h3>\n<ul>\n<li>\n  After the first three steps,\n  <strong>\n   damping weights\n  </strong>\n  are applied to each force. Damping adjusts the strength of each force based on urgency:\n  <ul>\n<li>\n    For instance,\n    <strong>\n     obstacle avoidance\n    </strong>\n    may be prioritized over\n    <strong>\n     agent avoidance\n    </strong>\n    if an agent is dangerously close to a\n    <strong>\n     static obstacle\n    </strong>\n    (like a wall).\n   </li>\n<li>\n    The damping weights scale the forces according to the situation, ensuring that the agent responds appropriately to immediate threats (like obstacles) while also considering other agents in the flock.\n   </li>\n</ul>\n</li>\n</ul>\n<hr/>\n<h3>\n 4.\n <strong>\n  Final Direction Calculation\n </strong>\n</h3>\n<ul>\n<li>\n  The forces are combined, and their resulting vector (the\n  <strong>\n   final direction vector\n  </strong>\n  ) determines where the agent will move.\n </li>\n<li>\n  The agent rotates to align with this final direction.\n </li>\n<li>\n  To decide which direction the agent should go next, the\n  <strong>\n   agent's neighborhood\n  </strong>\n  is treated as a\n  <strong>\n   360-degree circle\n  </strong>\n  . The agent decides which quadrant or\n  <strong>\n   cell\n  </strong>\n  to move into based on the final direction vector.\n </li>\n</ul>\n<hr/>\n<h3>\n Diagram Explanation\n</h3>\n<ul>\n<li>\n<strong>\n   White Arrows\n  </strong>\n  : These represent the\n  <strong>\n   directional vectors\n  </strong>\n  calculated at each of the three steps.\n </li>\n<li>\n<strong>\n   Yellow Square\n  </strong>\n  : This is the\n  <strong>\n   destination\n  </strong>\n  of the flock.\n </li>\n<li>\n<strong>\n   Green Circle\n  </strong>\n  : This denotes the\n  <strong>\n   current agent\n  </strong>\n  whose behavior is being analyzed.\n </li>\n<li>\n<strong>\n   Blue Circle\n  </strong>\n  : Represents an\n  <strong>\n   agent within the current agent's neighborhood\n  </strong>\n  , influencing its movement.\n </li>\n</ul>\n<hr/>\n<h3>\n Summary of Key Points\n</h3>\n<ul>\n<li>\n  The algorithm integrates\n  <strong>\n   cohesion, separation\n  </strong>\n  , and\n  <strong>\n   alignment\n  </strong>\n  forces, adjusting them with\n  <strong>\n   damping\n  </strong>\n  to ensure safe and coherent agent movement.\n </li>\n<li>\n  By considering\n  <strong>\n   obstacle avoidance\n  </strong>\n  and\n  <strong>\n   agent interactions\n  </strong>\n  , the system enables agents to move in a way that is natural and responsive to both their neighbors and their environment.\n </li>\n<li>\n  The agents' movement is determined by a\n  <strong>\n   combination of forces\n  </strong>\n  with attention to urgency, allowing for a realistic and efficient flocking behavior.\n </li>\n</ul>\n<hr/>\n<p>\n This approach offers a structured yet flexible way for agents to move and interact, making it suitable for simulations of group behaviors and dynamic environments.\n</p>\n"}, "Page 52": {"response": "<h3>\n 9.4 Additional Observations and Conclusions\n</h3>\n<p>\n An interesting finding is that the\n <strong>\n  Boids implementation\n </strong>\n has poorer\n <strong>\n  scalability\n </strong>\n than the cellular automata approach. If both algorithms were implemented in\n <strong>\n  C++\n </strong>\n , it is likely that the performance gap would become even more pronounced, further highlighting the efficiency advantages of the cellular automata method.\n</p>\n<ul>\n<li>\n<strong>\n   Grid Comparison\n  </strong>\n  : When comparing the\n  <strong>\n   hexagonal grid\n  </strong>\n  to the\n  <strong>\n   square cell grid\n  </strong>\n  , the differences in\n  <strong>\n   overall curvature\n  </strong>\n  (how smooth the movement paths are) were found to be\n  <strong>\n   negligible\n  </strong>\n  . This is likely due to the limited number of movement options available to an agent per step in the square grid. However, the\n  <strong>\n   hexagonal grid\n  </strong>\n  still stands out as the better option overall, not only due to the\n  <strong>\n   smoother movement\n  </strong>\n  it produces but also because of its better\n  <strong>\n   efficiency\n  </strong>\n  . The square grid, while functional, does have significant\n  <strong>\n   collision avoidance issues\n  </strong>\n  that make the hexagonal grid the optimal choice under current conditions.\n </li>\n</ul>\n"}, "Page 50": {"response": "<h3>\n 9.3.4 Square vs. Hexagonal Grid (Continued)\n</h3>\n<p>\n In the experiment comparing the\n <strong>\n  square grid\n </strong>\n to the\n <strong>\n  hexagonal grid\n </strong>\n , the test was conducted under the same conditions as the previous\n <strong>\n  algorithmic complexity experiment\n </strong>\n (Experiment 3).\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Search Complexity\n   </strong>\n   : The results showed that the\n   <strong>\n    square grid\n   </strong>\n   required\n   <strong>\n    25% more\n   </strong>\n   checks compared to the\n   <strong>\n    hexagonal grid\n   </strong>\n   . This is due to the square grid having a total neighbourhood size of\n   <strong>\n    24\n   </strong>\n   cells, while the hexagonal grid only has\n   <strong>\n    18\n   </strong>\n   cells in its neighbourhood.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Memory Usage\n   </strong>\n   : The hexagonal grid also has the advantage of\n   <strong>\n    using less memory\n   </strong>\n   . This is because it requires fewer cells to be sorted into each agent\u2019s neighbourhood as they move through the grid.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Efficiency\n   </strong>\n   : The reduced number of cells in the hexagonal grid contributes not only to\n   <strong>\n    faster processing speeds\n   </strong>\n   but also to\n   <strong>\n    lower memory consumption\n   </strong>\n   compared to the square grid. This gives the hexagonal grid a performance advantage, especially as the number of agents increases.\n  </p>\n</li>\n</ul>\n"}, "Page 24": {"response": "<h3>\n Cellular Automata: Rule Transformations and Reversibility\n</h3>\n<h4>\n<strong>\n  Class 4 Cellular Automata and Universal Computation\n </strong>\n</h4>\n<p>\n Class 4 cellular automata, as defined by Stephen Wolfram, are among the most complex types, producing intricate patterns that interact in complex ways over time. While small changes in their initial configuration may take a long time to manifest, any shifts in the pattern tend to spread indefinitely. Some of these automata have been theorized to be capable of\n <strong>\n  universal computation\n </strong>\n , meaning they can simulate any computational process, given the correct setup. Wolfram has specifically demonstrated this property in\n <strong>\n  Rule 110\n </strong>\n and\n <strong>\n  Conway's Game of Life\n </strong>\n , both of which are examples of cellular automata that exhibit universal computation.\n</p>\n<h4>\n<strong>\n  Reversibility in Cellular Automata\n </strong>\n</h4>\n<p>\n A key property of cellular automata is\n <strong>\n  reversibility\n </strong>\n , which means that for every given configuration, there exists a prior configuration from which it could have evolved. Cellular automata can be viewed as functions that take one configuration and apply rules to generate a new one. If a cellular automaton is reversible with respect to time, it implies that we can trace the system backward to a previous state, making it bijective \u2014 where each configuration has a unique predecessor. If a cellular automaton is reversible, its reverse process is also considered to be a valid cellular automaton.\n</p>\n<h4>\n<strong>\n  Elementary Cellular Automata and Rule Transformations\n </strong>\n</h4>\n<p>\n In\n <strong>\n  elementary cellular automata\n </strong>\n , the simulation's next generation is determined by applying specific rules to the current state of the cells. There are\n <strong>\n  256 possible rules\n </strong>\n in this category, each influencing how a cell\u2019s state evolves in the next generation. However, many of these rules exhibit similar patterns with slight variations, often due to geometric transformations applied to the underlying patterns.\n</p>\n<p>\n Two significant transformations of these rules are:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Mirrored Rule\n   </strong>\n   : This transformation involves reflecting a given rule along a vertical axis. The mirrored rule is computationally equivalent to the original rule but changes its orientation. For example,\n   <strong>\n    Rule 110\n   </strong>\n   , when mirrored, becomes\n   <strong>\n    Rule 124\n   </strong>\n   . A set of 64 out of the 256 elementary cellular automata are\n   <strong>\n    amphirical\n   </strong>\n   , meaning they are identical to their mirrored version.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Complementary Rule\n   </strong>\n   : This transformation swaps the 0s and 1s of a rule, flipping its values. When applied to\n   <strong>\n    Rule 110\n   </strong>\n   , the complementary rule results in\n   <strong>\n    Rule 137\n   </strong>\n   , which behaves equivalently but with the opposite binary values. Out of the 256 automata, 16 have rules that are identical to their complementary forms.\n  </p>\n</li>\n</ol>\n<p>\n These transformations allow for a more comprehensive understanding of the variety of behaviours possible in elementary cellular automata, highlighting the subtle differences that govern the patterns they generate.\n</p>\n"}, "Page 30": {"response": "<h3>\n Breaking Down the Flocking Behavior for Cellular Automata\n</h3>\n<p>\n The key challenge in adapting\n <strong>\n  flocking behavior\n </strong>\n to\n <strong>\n  cellular automata\n </strong>\n was converting continuous space concepts, such as flight paths and movement, into discrete space problems. This conversion was crucial for modeling the behavior in cellular automata.\n</p>\n<h3>\n 7.2 Understanding the Conversion Process\n</h3>\n<p>\n In addition to studying existing research papers, a detailed analysis of the\n <strong>\n  Boids algorithm\n </strong>\n was conducted. The three main principles of the Boids algorithm\u2014\n <strong>\n  separation\n </strong>\n ,\n <strong>\n  cohesion\n </strong>\n , and\n <strong>\n  alignment\n </strong>\n \u2014were broken down to understand their roles in flocking behavior and how they could be translated into discrete space for cellular automata.\n</p>\n<ul>\n<li>\n<strong>\n   Separation\n  </strong>\n  involves ensuring that boids (or agents) avoid crowding each other, which was easily adaptable to a cellular automata grid.\n </li>\n<li>\n<strong>\n   Cohesion\n  </strong>\n  ensures that boids move towards the center of the flock, which could also be applied to the grid.\n </li>\n<li>\n<strong>\n   Alignment\n  </strong>\n  , which involves steering boids towards the average velocity of their neighbors, was deemed unnecessary for this simulation. Since cellular automata work on a discrete grid without considering velocities,\n  <strong>\n   alignment\n  </strong>\n  was not applicable.\n </li>\n</ul>\n<p>\n Once these principles were understood, the next step was to design a new algorithm tailored to cellular automata, specifically aimed at simulating basic flocking behavior within a cell-based system. This new algorithm was constructed step-by-step to ensure it could efficiently model the desired behavior.\n</p>\n"}, "Page 5": {"response": "<h3>\n<strong>\n  Abstract\n </strong>\n</h3>\n<p>\n<strong>\n  James Shannon\n </strong>\n explores the use of\n <strong>\n  cellular automata\n </strong>\n (CA) for simulating\n <strong>\n  flocking behavior\n </strong>\n , a natural phenomenon seen in birds, fish, and insects. Flocking offers several advantages, such as improved\n <strong>\n  food discovery\n </strong>\n , easier\n <strong>\n  mate finding\n </strong>\n , and increased\n <strong>\n  protection from predators\n </strong>\n .\n</p>\n<p>\n The first computer-based simulation of flocking behavior was the\n <strong>\n  Boids algorithm\n </strong>\n , developed by\n <strong>\n  Craig Reynolds\n </strong>\n in 1987. This algorithm simulates how\n <strong>\n  autonomous agents\n </strong>\n (like birds) react to their environment and collectively display complex group behavior that individual agents alone cannot exhibit.\n</p>\n<p>\n Despite being used for decades, flocking simulations remain\n <strong>\n  computationally expensive\n </strong>\n and do not scale well as the number of agents increases, making them inefficient for larger simulations.\n</p>\n"}, "Page 6": {"response": "<h3>\n<strong>\n  New Approach for Efficient Flocking Simulation\n </strong>\n</h3>\n<p>\n This dissertation proposes a new solution to address the\n <strong>\n  inefficiency\n </strong>\n of traditional flocking simulations, which hinder their use in\n <strong>\n  real-time applications\n </strong>\n like\n <strong>\n  video games\n </strong>\n . The approach utilizes\n <strong>\n  two-dimensional cellular automata\n </strong>\n (CA), which is well-suited for simulating complex behaviors using simple, discrete rule sets.\n</p>\n<p>\n The goal is to explore how CA can simulate\n <strong>\n  flocking behavior\n </strong>\n efficiently, similar to the\n <strong>\n  Boids algorithm\n </strong>\n , but in a way that allows it to be used effectively in real-time applications. The new CA-based technique aims to balance\n <strong>\n  realistic flocking\n </strong>\n with the\n <strong>\n  computational efficiency\n </strong>\n required for real-time performance. To evaluate its effectiveness, the\n <strong>\n  Boids algorithm\n </strong>\n will be implemented as a benchmark for comparison.\n</p>\n"}, "Page 7": {"response": "<h3>\n<strong>\n  Contents Overview\n </strong>\n</h3>\n<p>\n This section outlines the structure and key sections of the dissertation:\n</p>\n<ol>\n<li>\n<strong>\n   Acknowledgements\n  </strong>\n  \u2013 Gratitude towards those who contributed to the research.\n </li>\n<li>\n<strong>\n   Abstract\n  </strong>\n  \u2013 A brief summary of the dissertation's objectives and goals.\n </li>\n<li>\n<strong>\n   List of Tables\n  </strong>\n  \u2013 A reference to all tables included in the dissertation.\n </li>\n<li>\n<strong>\n   List of Figures\n  </strong>\n  \u2013 A reference to all figures included in the dissertation.\n </li>\n<li>\n<strong>\n   Chapter 1: Introduction\n  </strong>\n  \u2013 Introduces the topic, motivation, goals, and outlines the dissertation.\n  <ul>\n<li>\n<strong>\n     Motivation\n    </strong>\n    \u2013 Reasons for the research.\n   </li>\n<li>\n<strong>\n     Goals\n    </strong>\n    \u2013 Main objectives of the dissertation.\n   </li>\n<li>\n<strong>\n     Dissertation Outline\n    </strong>\n    \u2013 Overview of the content and structure.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Chapter 2: State of the Art\n  </strong>\n  \u2013 Reviews existing research and concepts relevant to the dissertation.\n  <ul>\n<li>\n<strong>\n     Overview of Flocking Behavior\n    </strong>\n    \u2013 Explains natural flocking behavior.\n   </li>\n<li>\n<strong>\n     Boids Flocking Algorithm\n    </strong>\n    \u2013 Detailed discussion of the\n    <strong>\n     Boids algorithm\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     Optimizing Boids\n    </strong>\n    \u2013 Improvements to the Boids algorithm.\n   </li>\n<li>\n<strong>\n     Overview of Cellular Automata\n    </strong>\n    \u2013 Introduction to\n    <strong>\n     cellular automata\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     Elementary Cellular Automata\n    </strong>\n    \u2013 Discusses simple cellular automata models.\n   </li>\n<li>\n<strong>\n     Cellular Automata in 2 Dimensions\n    </strong>\n    \u2013 Focus on\n    <strong>\n     2D cellular automata\n    </strong>\n    .\n    <ul>\n<li>\n<strong>\n       Conway\u2019s Game of Life\n      </strong>\n      \u2013 A famous example of cellular automata.\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<strong>\n   Research Approach\n  </strong>\n  \u2013 Details on how the research was conducted.\n  <ul>\n<li>\n<strong>\n     Initial Research Phases\n    </strong>\n    \u2013 The early steps in the research process.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Implementation\n  </strong>\n  \u2013 Describes the practical application of the research.\n  <ul>\n<li>\n<strong>\n     Agent Description\n    </strong>\n    \u2013 Defines the agents used in the simulation.\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n This outline sets the stage for understanding the structure and focus of the dissertation.\n</p>\n"}, "Page 8": {"response": "<h3>\n<strong>\n  Detailed Dissertation Outline (Continued)\n </strong>\n</h3>\n<ol start=\"8\">\n<li>\n<p>\n<strong>\n    Implementation\n   </strong>\n   \u2013 This section covers the practical aspects of the research, including challenges and methods used in the simulation.\n  </p>\n<ul>\n<li>\n<strong>\n     Initial Implementation Problems\n    </strong>\n    \u2013 Discusses early issues encountered in setting up the simulation.\n   </li>\n<li>\n<strong>\n     Algorithm\n    </strong>\n    \u2013 Describes the core algorithm used for flocking simulation.\n   </li>\n<li>\n<strong>\n     Collision Avoidance\n    </strong>\n    \u2013 Details how the system handles avoiding collisions between agents.\n   </li>\n<li>\n<strong>\n     Basic Boids Implementation\n    </strong>\n    \u2013 Explains the implementation of the\n    <strong>\n     Boids algorithm\n    </strong>\n    within the simulation.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Results and Evaluation\n   </strong>\n   \u2013 Focuses on testing and assessing the performance of the simulation.\n  </p>\n<ul>\n<li>\n<strong>\n     Testing Conditions\n    </strong>\n    \u2013 Describes the conditions under which the tests were conducted.\n   </li>\n<li>\n<strong>\n     Results\n    </strong>\n    \u2013 Presents the outcomes of the tests.\n   </li>\n<li>\n<strong>\n     Experiments\n    </strong>\n    \u2013 Discusses various experiments performed to evaluate the simulation:\n    <ul>\n<li>\n<strong>\n       Frame Rate\n      </strong>\n      \u2013 Measures the performance in terms of frame rate.\n     </li>\n<li>\n<strong>\n       Scalability\n      </strong>\n      \u2013 Assesses how well the system performs as the number of agents increases.\n     </li>\n<li>\n<strong>\n       Algorithmic Complexity\n      </strong>\n      \u2013 Analyzes the complexity of the algorithm in computational terms.\n     </li>\n<li>\n<strong>\n       Square vs. Hexagonal Grid\n      </strong>\n      \u2013 Compares two different grid types used in the simulation.\n     </li>\n</ul>\n</li>\n<li>\n<strong>\n     Evaluation\n    </strong>\n    \u2013 Provides an overall assessment of the results.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Conclusions\n   </strong>\n   \u2013 Summarizes the findings and conclusions drawn from the research.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Future Work\n   </strong>\n   \u2013 Discusses potential improvements and future directions for the research.\n  </p>\n</li>\n</ol>\n<ul>\n<li>\n<strong>\n   Optimization\n  </strong>\n  \u2013 Ways to improve the performance of the system.\n </li>\n<li>\n<strong>\n   Multi-Cell Obstacles and Agents\n  </strong>\n  \u2013 Introducing more complex elements, such as obstacles and varied agents.\n </li>\n<li>\n<strong>\n   Optimized Boids Testing\n  </strong>\n  \u2013 Testing the\n  <strong>\n   Boids algorithm\n  </strong>\n  with optimizations.\n </li>\n<li>\n<strong>\n   Colony Building\n  </strong>\n  \u2013 Extending the research to simulate colony-building behaviors.\n </li>\n<li>\n<strong>\n   Flight Path Simulation\n  </strong>\n  \u2013 Simulating more complex flight paths.\n </li>\n<li>\n<strong>\n   Crowd Motion\n  </strong>\n  \u2013 Exploring applications related to crowd dynamics and movement.\n </li>\n</ul>\n<p>\n This outline further delves into the practical implementation, testing, and potential future applications of the flocking simulation.\n</p>\n"}, "Page 9": {"response": "<h3>\n<strong>\n  Bibliography\n </strong>\n</h3>\n<p>\n This section lists all the references and sources cited throughout the dissertation, providing the foundation of research and studies that support the work. It is found on page\n <strong>\n  50\n </strong>\n .\n</p>\n"}, "Page 10": {"response": "<h3>\n<strong>\n  List of Tables\n </strong>\n</h3>\n<p>\n This section lists the tables included in the dissertation, which present key data and visual comparisons:\n</p>\n<ul>\n<li>\n<strong>\n   9.1 FPS Comparison Graph\n  </strong>\n  \u2013 Displays a comparison of\n  <strong>\n   frames per second (FPS)\n  </strong>\n  across different simulation conditions (\n  <strong>\n   Page 36\n  </strong>\n  ).\n </li>\n<li>\n<strong>\n   9.2 Scalability Graph\n  </strong>\n  \u2013 Shows how the simulation's performance changes as the number of agents increases (\n  <strong>\n   Page 37\n  </strong>\n  ).\n </li>\n<li>\n<strong>\n   9.3 Algorithmic Complexity Graph\n  </strong>\n  \u2013 Illustrates the complexity of the simulation's algorithm with respect to various factors (\n  <strong>\n   Page 38\n  </strong>\n  ).\n </li>\n<li>\n<strong>\n   9.4 Square vs. Hexagonal Grid Graph\n  </strong>\n  \u2013 Compares the performance and results of using\n  <strong>\n   square grids\n  </strong>\n  vs.\n  <strong>\n   hexagonal grids\n  </strong>\n  in the simulation (\n  <strong>\n   Page 40\n  </strong>\n  ).\n </li>\n</ul>\n"}, "Page 11": {"response": "<h3>\n<strong>\n  List of Figures\n </strong>\n</h3>\n<p>\n This section outlines the figures included in the dissertation, which visually represent important concepts and results:\n</p>\n<ul>\n<li>\n<strong>\n   2.1 Pseudo code of the 1st principle of the Boids algorithm\n  </strong>\n  \u2013 Shows the pseudo code for the first behavior principle in the\n  <strong>\n   Boids algorithm\n  </strong>\n  (\n  <strong>\n   Page 7\n  </strong>\n  ).\n </li>\n<li>\n<strong>\n   2.2 Pseudo code of the 2nd principle of the Boids algorithm\n  </strong>\n  \u2013 Displays the pseudo code for the second principle of the\n  <strong>\n   Boids algorithm\n  </strong>\n  (\n  <strong>\n   Page 7\n  </strong>\n  ).\n </li>\n<li>\n<strong>\n   2.3 Pseudo code of the 3rd principle of the Boids algorithm\n  </strong>\n  \u2013 Presents the pseudo code for the third principle of the\n  <strong>\n   Boids algorithm\n  </strong>\n  (\n  <strong>\n   Page 8\n  </strong>\n  ).\n </li>\n<li>\n<strong>\n   8.1 Examples of both types of cell grid\n  </strong>\n  \u2013 Illustrates the two types of cell grids used in the simulation (\n  <strong>\n   Page 21\n  </strong>\n  ).\n </li>\n<li>\n<strong>\n   8.2 Examples of turn smoothness on both grid types\n  </strong>\n  \u2013 Demonstrates how turns are smoothed on both grid types (\n  <strong>\n   Page 24\n  </strong>\n  ).\n </li>\n<li>\n<strong>\n   8.3 Examples of both neighbourhoods on different grid types\n  </strong>\n  \u2013 Shows examples of how neighborhoods are defined on each grid type (\n  <strong>\n   Page 25\n  </strong>\n  ).\n </li>\n<li>\n<strong>\n   8.4 Diagram explaining the 4 steps of the algorithm\n  </strong>\n  \u2013 Breaks down the four key steps involved in the simulation's algorithm (\n  <strong>\n   Page 27\n  </strong>\n  ).\n </li>\n<li>\n<strong>\n   8.5 Diagram showing each vector computed during the algorithm\n  </strong>\n  \u2013 Visualizes the vectors calculated during the simulation (\n  <strong>\n   Page 28\n  </strong>\n  ).\n </li>\n<li>\n<strong>\n   8.6 Diagram showing before and after collision avoidance\n  </strong>\n  \u2013 Compares agent positions before and after applying collision avoidance (\n  <strong>\n   Page 30\n  </strong>\n  ).\n </li>\n<li>\n<strong>\n   8.7 Diagram showing similarities between Boids and Cellular Automata collision avoidance flaw\n  </strong>\n  \u2013 Compares the flaws in collision avoidance between\n  <strong>\n   Boids\n  </strong>\n  and\n  <strong>\n   Cellular Automata\n  </strong>\n  (\n  <strong>\n   Page 30\n  </strong>\n  ).\n </li>\n<li>\n<strong>\n   8.8 Screenshot of the Boids algorithm running\n  </strong>\n  \u2013 A screenshot showing the\n  <strong>\n   Boids algorithm\n  </strong>\n  in action (\n  <strong>\n   Page 32\n  </strong>\n  ).\n </li>\n<li>\n<strong>\n   8.9 Screenshot of the Boids algorithm running (non-directional)\n  </strong>\n  \u2013 A screenshot showing a\n  <strong>\n   non-directional\n  </strong>\n  version of the\n  <strong>\n   Boids algorithm\n  </strong>\n  (\n  <strong>\n   Page 32\n  </strong>\n  ).\n </li>\n<li>\n<strong>\n   11.5 Diagram of close range hazard avoidance in flight path simulation paper approach\n  </strong>\n  \u2013 Illustrates how close-range hazard avoidance is handled in the\n  <strong>\n   flight path simulation\n  </strong>\n  (\n  <strong>\n   Page 47\n  </strong>\n  ).\n </li>\n<li>\n<strong>\n   11.6 Diagram of close range hazard avoidance in flight path simulation new approach\n  </strong>\n  \u2013 Shows the new approach for\n  <strong>\n   close-range hazard avoidance\n  </strong>\n  in\n  <strong>\n   flight path simulation\n  </strong>\n  (\n  <strong>\n   Page 48\n  </strong>\n  ).\n </li>\n</ul>\n"}, "Page 12": {"response": "<h3>\n Introduction to Flocking and the Research Goals\n</h3>\n<h4>\n 5.1 Motivation\n</h4>\n<p>\n Flocking refers to the behavior where autonomous agents, such as birds, fish, or other entities, interact with their surroundings and neighboring agents to create complex, collective motion. This process, while fascinating, is computationally intensive, especially as the size of the flock increases. Due to this high computational cost, flocking is often used as a pre-rendered visual effect in movies (e.g.,\n <em>\n  The Lion King\n </em>\n and\n <em>\n  Batman Returns\n </em>\n ) rather than in real-time applications like video games. However, as video games demand more complex effects and features, it's crucial to address the inefficiencies of flocking and develop new methods to make it feasible for real-time use without excessive computational expense.\n</p>\n<h4>\n 5.2 Goals\n</h4>\n<p>\n The aim of this research is to explore how 2D cellular automata can help reduce the cost of simulating flocking behavior for real-time applications. The main objectives of this dissertation are:\n</p>\n<ul>\n<li>\n  Identify the core characteristics of flocking behavior and simplify them.\n </li>\n<li>\n  Convert these simplified characteristics from a continuous approach (like traditional flocking algorithms) to a discrete one.\n </li>\n<li>\n  Apply these simplified rules to a 2D cellular automata framework to simulate flocking behavior.\n </li>\n</ul>\n"}, "Page 19": {"response": "<h3>\n Cohesion and Separation Principles in Boids Algorithm\n</h3>\n<h4>\n<strong>\n  Cohesion\n </strong>\n</h4>\n<p>\n The\n <strong>\n  Cohesion\n </strong>\n rule ensures that boids stay together and maintain the overall structure of the flock. Here\u2019s how it functions:\n</p>\n<ol>\n<li>\n<strong>\n   Position Averaging\n  </strong>\n  : Each boid checks the positions of all other boids within its neighborhood.\n </li>\n<li>\n<strong>\n   Averaging Positions\n  </strong>\n  : The positions of the neighboring boids are averaged, and the resulting vector points towards the center of the flock.\n </li>\n<li>\n<strong>\n   Damping for Control\n  </strong>\n  : The resulting position vector can be scaled by a damping weight (e.g., 100) to adjust the force of cohesion. This scaling helps control how strongly boids try to move towards the center of the flock.\n </li>\n<li>\n<strong>\n   Result\n  </strong>\n  : This forces the boids to fly inward, keeping the flock compact and maintaining its formation, making the behavior appear more realistic.\n </li>\n</ol>\n<h4>\n<strong>\n  Separation\n </strong>\n</h4>\n<p>\n The\n <strong>\n  Separation\n </strong>\n rule helps prevent overcrowding and collisions within the flock:\n</p>\n<ol>\n<li>\n<strong>\n   Distance Check\n  </strong>\n  : Each boid checks the distance to its neighbors using a Euclidean distance check combined with a threshold.\n </li>\n<li>\n<strong>\n   Steering Away\n  </strong>\n  : If a boid is too close to another, it calculates the direction to steer away by subtracting the position of the neighbor from its own position.\n </li>\n<li>\n<strong>\n   Avoiding Collisions\n  </strong>\n  : Typically, no damping is applied to separation forces since it could increase the likelihood of mid-air collisions, which would disrupt the flock.\n </li>\n<li>\n<strong>\n   Effect\n  </strong>\n  : This principle helps ensure that boids maintain a safe distance from each other, preventing chaotic clumping or collisions within the flock.\n </li>\n</ol>\n"}, "Page 25": {"response": "<h3>\n Rule Transformations and Notable Elementary Cellular Automata\n</h3>\n<h4>\n<strong>\n  Combined Mirrored and Complementary Rule\n </strong>\n</h4>\n<p>\n When both the\n <strong>\n  mirrored\n </strong>\n and\n <strong>\n  complementary\n </strong>\n transformations are applied to a rule, a new type called the\n <strong>\n  mirrored complementary rule\n </strong>\n is produced. Out of the 256 possible elementary cellular automata rules,\n <strong>\n  8 rules\n </strong>\n are equivalent to their mirrored complementary forms. For example, when the combined rule transformation is applied to\n <strong>\n  Rule 110\n </strong>\n , it results in\n <strong>\n  Rule 193\n </strong>\n . These transformations help explore the vast variety of possible rule behaviours, further enriching the study of cellular automata.\n</p>\n<h4>\n<strong>\n  Prominent Rules in Elementary Cellular Automata\n </strong>\n</h4>\n<p>\n Two of the most significant and frequently studied rules in elementary cellular automata are\n <strong>\n  Rule 110\n </strong>\n and\n <strong>\n  Rule 30\n </strong>\n , each with distinct properties and implications for computation and nature.\n</p>\n<h5>\n<strong>\n  Rule 110\n </strong>\n</h5>\n<p>\n<strong>\n  Rule 110\n </strong>\n is a fascinating elementary cellular automaton known for its behaviour that falls between stability and chaos. It has been proven to be\n <strong>\n  Turing complete\n </strong>\n , which means it has the computational power to simulate any Turing machine, a fundamental concept in computer science. Among the 88 unique cellular automata rules, Rule 110 is the only one that is known to be Turing complete. This makes it one of the simplest systems that can perform any computation that a modern computer can, given enough time.\n <strong>\n  Class 4\n </strong>\n behaviour, seen in\n <strong>\n  Rule 110\n </strong>\n , indicates that it is not entirely stable nor fully chaotic, instead showing complex interactions that can lead to unpredictable results.\n</p>\n<h5>\n<strong>\n  Rule 30\n </strong>\n</h5>\n<p>\n<strong>\n  Rule 30\n </strong>\n , in contrast, is classified as a\n <strong>\n  Class 3\n </strong>\n rule, meaning it displays\n <strong>\n  chaotic\n </strong>\n and\n <strong>\n  aperiodic\n </strong>\n behaviour. Despite its simple rules, it produces complex and unpredictable patterns, illustrating how simple systems can evolve into complex, chaotic behaviour. This behaviour has been linked to\n <strong>\n  emergent phenomena\n </strong>\n in nature, such as the patterns found on the shell of the\n <strong>\n  Conus textile\n </strong>\n species of cone snail. Rule 30 has also been used in applications like\n <strong>\n  random number generation\n </strong>\n and even cryptography, where it has been considered for use in\n <strong>\n  stream ciphers\n </strong>\n . The rule has a\n <strong>\n  mirror image\n </strong>\n (Rule 86),\n <strong>\n  complementary rule\n </strong>\n (Rule 135), and\n <strong>\n  mirrored complementary rule\n </strong>\n (Rule 149), all of which exhibit various transformations that add to its complexity.\n</p>\n<p>\n Rule 30\u2019s chaotic nature is particularly evident in how it is\n <strong>\n  sensitive to initial conditions\n </strong>\n and\n <strong>\n  mixes\n </strong>\n patterns. This means that even slight changes in the starting configuration can lead to drastically different outcomes, which is a hallmark of chaotic systems.\n</p>\n"}, "Page 23": {"response": "<h3>\n Cellular Automata Types and Classifications\n</h3>\n<h4>\n<strong>\n  Neighbourhood and States\n </strong>\n</h4>\n<p>\n In a\n <strong>\n  two-dimensional\n </strong>\n cellular automaton using a\n <strong>\n  Moore neighbourhood\n </strong>\n , each cell interacts with its eight surrounding cells. These interactions lead to 2\u00b3 (8) possible states for the set of three cells that form the neighbourhood. Therefore, in such a system, there are 2\u2079 (512) potential rule sets, corresponding to the different configurations of states that can occur in the neighbourhood of a cell. This variety makes cellular automata highly flexible, allowing for the simulation of a wide range of complex behaviours.\n</p>\n<h4>\n<strong>\n  Wolfram's Classification of Cellular Automata\n </strong>\n</h4>\n<p>\n In his book\n <em>\n  A New Kind of Science\n </em>\n ,\n <strong>\n  Stephen Wolfram\n </strong>\n categorized cellular automata into four classes based on their behaviour over time. These classifications range from simple, predictable patterns to highly complex, chaotic behaviours. The classes are as follows:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Class 1\n   </strong>\n   : These automata quickly evolve into stable, homogeneous patterns. Any initial randomness in the system dissipates rapidly, leaving behind a uniform state.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Class 2\n   </strong>\n   : Patterns in these automata evolve into stable or oscillating structures. While some randomness disappears, small traces remain, and any local changes tend to stay confined to a small area without spreading.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Class 3\n   </strong>\n   : These automata generate pseudo-random or chaotic patterns. Any stable structures that form are usually destroyed by the surrounding noise. Local changes spread throughout the system, creating unpredictable and continually evolving patterns.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Class 4\n   </strong>\n   : The most complex of all, these automata generate intricate structures that interact in interesting ways. These local structures can survive for long periods of time. While some elements of Class 2 behaviour can also emerge in these systems, they take a long time to develop from the initial random state.\n  </p>\n</li>\n</ul>\n<p>\n Each class of cellular automata offers insights into how complex, emergent behaviours can arise from simple rules and interactions.\n</p>\n"}, "Page 26": {"response": "<h3>\n Cellular Automata in 2 Dimensions\n</h3>\n<h4>\n<strong>\n  Neighbourhood Types in 2D Cellular Automata\n </strong>\n</h4>\n<p>\n 2D cellular automata share many characteristics with their 1D counterparts, but with more complex neighbourhood structures due to the additional dimension. There are two main types of neighbourhoods used in 2D cellular automata:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Von Neumann Neighbourhood\n   </strong>\n   : This neighbourhood consists of\n   <strong>\n    5 cells\n   </strong>\n   . It includes the central cell and its\n   <strong>\n    4 orthogonal neighbours\n   </strong>\n   (top, bottom, left, and right). In some cases, if the central cell is excluded, the neighbourhood is reduced to just\n   <strong>\n    4 cells\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Moore Neighbourhood\n   </strong>\n   : This neighbourhood is more expansive, involving\n   <strong>\n    8 cells\n   </strong>\n   around the central cell. These cells form a surrounding\n   <strong>\n    square\n   </strong>\n   , with each corner cell included. If the central cell is counted, the total number of cells becomes\n   <strong>\n    9\n   </strong>\n   .\n  </p>\n</li>\n</ol>\n<h4>\n<strong>\n  Simulation Process in 2D Cellular Automata\n </strong>\n</h4>\n<p>\n In a 2D simulation, the\n <strong>\n  entire grid of cells\n </strong>\n is updated\n <strong>\n  simultaneously\n </strong>\n . The cells' next state (or the state for the next generation) is determined using simple rules that take into account the current states of their neighbours.\n</p>\n<p>\n In advanced simulations, such as Conway\u2019s\n <strong>\n  Game of Life\n </strong>\n , the grid is often treated as an\n <strong>\n  infinite plane\n </strong>\n , allowing the simulation to progress endlessly. This infinite grid is primarily limited by\n <strong>\n  processing power\n </strong>\n , as the number of cells to update and calculate increases with each generation.\n</p>\n"}, "Page 27": {"response": "<h3>\n Conway\u2019s Game of Life\n</h3>\n<p>\n Conway\u2019s\n <strong>\n  Game of Life\n </strong>\n , developed in the 1970s by John Conway, is one of the most famous examples of a 2D cellular automaton. It played a significant role in reigniting interest in the field of cellular automata. Despite the complex behaviors it produces, the rules governing the Game of Life are relatively simple.\n</p>\n<h4>\n<strong>\n  Rules of the Game\n </strong>\n</h4>\n<p>\n In Conway\u2019s Game of Life, each cell has two possible states:\n <strong>\n  alive (1)\n </strong>\n or\n <strong>\n  dead (0)\n </strong>\n . The state of each cell in the next generation is determined using the\n <strong>\n  8-cell Moore neighbourhood\n </strong>\n , meaning the central cell considers its 8 surrounding cells to decide its next state.\n</p>\n<p>\n The two core rules are:\n</p>\n<ol>\n<li>\n<strong>\n   Rebirth\n  </strong>\n  : A dead cell becomes alive in the next generation if it has exactly 3 living neighbors.\n </li>\n<li>\n<strong>\n   Survival or Death\n  </strong>\n  : A living cell stays alive if it has 2 or 3 living neighbors. If it has fewer than 2 neighbors, it dies from\n  <strong>\n   loneliness\n  </strong>\n  . If it has more than 3 neighbors, it dies from\n  <strong>\n   overcrowding\n  </strong>\n  .\n </li>\n</ol>\n<p>\n In essence, rule 2 describes the conditions under which a living cell survives or dies based on its neighbors. Rule 1 dictates the birth of new cells from exactly 3 neighboring live cells.\n</p>\n<h4>\n<strong>\n  Philosophical Insight\n </strong>\n</h4>\n<p>\n Joel L. Schiff, in his book\n <em>\n  Cellular Automata: A Discrete View of the World\n </em>\n , provides an insightful description of the Game of Life, saying, \"Of course, this is not really a game you play in the conventional sense, but rather a microcosm of another universe that one can explore since we know its physics entirely.\"\n</p>\n<h4>\n<strong>\n  Complexity and Classification\n </strong>\n</h4>\n<p>\n The Game of Life is classified as a\n <strong>\n  class 4\n </strong>\n cellular automaton due to its highly complex behavior, which evolves in unpredictable and intricate ways over time. It is also an\n <strong>\n  outer totalistic rule\n </strong>\n , meaning that the state of the central cell depends on the sum of its surrounding cells' states.\n</p>\n<p>\n This automaton exemplifies how simple rules can give rise to complex, life-like patterns, making it an influential study in the field of cellular automata and computational theory.\n</p>\n"}, "Page 28": {"response": "<h3>\n Universal Computation in Conway\u2019s Game of Life\n</h3>\n<p>\n In addition to its fascinating dynamics,\n <strong>\n  Conway\u2019s Game of Life\n </strong>\n has also been proposed as a potential\n <strong>\n  universal computing system\n </strong>\n . In 1982, Conway presented a proof outline suggesting that\n <strong>\n  Glider Guns\n </strong>\n \u2014a particular type of pattern in the Game of Life\u2014could be used to transmit data across the grid. This transmission of \"glider pulses\" can be thought of as analogous to the electrical pulses that power computer systems, making the Game of Life a candidate for universal computation.\n</p>\n<p>\n The gliders in the Game of Life, which are self-replicating patterns that travel across the grid, can be used to encode and transfer information. This discovery further highlights the power of cellular automata, demonstrating that even simple, rule-based systems can potentially perform complex computational tasks, similar to what conventional computers do.\n</p>\n"}, "Page 29": {"response": "<h3>\n Research Approach\n</h3>\n<p>\n This chapter outlines the approach taken during the initial stages of the project to study how other research papers, dealing with practical applications of\n <strong>\n  cellular automata\n </strong>\n , tackled their respective problems. These papers broke down complex challenges into smaller, manageable parts and applied cellular automata models to solve them.\n</p>\n<h3>\n 7.1 Initial Research Phases\n</h3>\n<p>\n Simulating\n <strong>\n  flocking behavior\n </strong>\n using 2D cellular automata was a novel idea, as there were no published works on this specific topic. This made determining the best approach to the problem challenging, as there was no roadmap or reference material available. However, while there were no flocking applications specifically involving cellular automata, there was relevant research in a related field:\n <strong>\n  crowd motion\n </strong>\n .\n</p>\n<p>\n A key paper in this area was written by\n <strong>\n  Hubert Ludwig Klupfel\n </strong>\n in 2003, titled\n <strong>\n  \u201cA Cellular Automaton Model for Crowd Movement and Egress Simulation\u201d\n </strong>\n . This paper was invaluable for understanding how to break down the problem and apply cellular automata to simulate crowd behavior. Another practical application of cellular automata was in\n <strong>\n  music generation\n </strong>\n , where elementary and 2D cellular automata were used to create musical compositions. The 2005 paper\n <strong>\n  \u201cCellular Automata in MIDI-based Computer Music\u201d\n </strong>\n provided further insight into this field.\n</p>\n<p>\n During the initial research phase, a list of relevant papers addressing real-world applications of cellular automata was compiled. The key task was to analyze these papers to understand how their authors simplified continuous features (like music or movement) and adapted them to cellular automata, offering a blueprint for solving similar problems.\n</p>\n"}, "Page 31": {"response": "<h3>\n Implementation of the Flocking Simulation\n</h3>\n<p>\n The\n <strong>\n  Boids algorithm\n </strong>\n and the newly developed approach for simulating flocking behavior in cellular automata were both implemented using\n <strong>\n  C#\n </strong>\n and\n <strong>\n  Microsoft's XNA framework\n </strong>\n . This choice was driven by the project's time constraints and the simplicity it offered for both implementation and result visualization. To ensure a fair comparison, the\n <strong>\n  Boids algorithm\n </strong>\n was left unoptimized, as there were no optimizations available for the new approach at the time. A discussion on potential future work regarding the optimization of the Boids algorithm is covered in Chapter 7.\n</p>\n<h3>\n 8.1 Agent Description\n</h3>\n<p>\n In this simulation, all\n <strong>\n  agents\n </strong>\n behave in the same way, applying the same set of simple rules simultaneously to produce their behavior. Here\u2019s how each agent is implemented:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Agent Positioning\n   </strong>\n   : Each agent occupies a single cell in the grid.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Neighborhood Setup\n   </strong>\n   : Each agent is surrounded by a two-layered hexagonal neighborhood, which consists of\n   <strong>\n    18 cells\n   </strong>\n   in total. If a\n   <strong>\n    square grid\n   </strong>\n   is used instead of hexagons, the neighborhood contains\n   <strong>\n    24 cells\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Outer Layer\n   </strong>\n   : The outer layer of the neighborhood is responsible for detecting obstacles and other agents before they get too close to the agent. This layer helps prevent collisions or unwanted close encounters.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Inner Layer\n   </strong>\n   : The inner layer calculates the\n   <strong>\n    directional forces\n   </strong>\n   required for separating the agent from nearby agents once they get within the minimum distance. This layer works similarly to the radius check in the\n   <strong>\n    Boids algorithm\n   </strong>\n   , helping ensure agents do not crowd each other.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Movement Constraints\n   </strong>\n   : Each agent can only move within its own neighborhood, meaning it cannot move beyond the surrounding cells, maintaining a discrete form of motion within the grid.\n  </p>\n</li>\n</ul>\n"}, "Page 32": {"response": "<h3>\n Agent Movement and Neighborhood Setup\n</h3>\n<p>\n In the simulation, each\n <strong>\n  agent\n </strong>\n follows a set of specific rules regarding its movement and interactions within the grid. Here\u2019s a breakdown of how the agent functions:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Neighborhood Shift\n   </strong>\n   : As an agent moves from one cell to another, its\n   <strong>\n    neighborhood\n   </strong>\n   also shifts to stay in the same relative position, ensuring consistent behavior and interaction with its surroundings.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Perception\n   </strong>\n   : An agent can detect any\n   <strong>\n    obstacles\n   </strong>\n   or\n   <strong>\n    other agents\n   </strong>\n   located within its\n   <strong>\n    neighborhood\n   </strong>\n   , giving it the ability to react and adapt its behavior based on nearby entities.\n  </p>\n</li>\n</ul>\n<h3>\n Neighborhood Layouts: Square vs. Hexagonal Grids\n</h3>\n<p>\n Figure 8.1 below illustrates how the\n <strong>\n  two-layer neighborhood\n </strong>\n looks when implemented in both square and hexagonal grid layouts.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Square Grid\n   </strong>\n   : In a square grid, the agent has a larger set of potential moves (24 cells), but the movement is restricted to 45-degree angles, which results in a more rigid, less fluid simulation.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Hexagonal Grid\n   </strong>\n   : The hexagonal grid offers fewer options for movement (18 cells), but it provides smoother, more natural paths, which leads to a more fluid simulation experience overall.\n  </p>\n</li>\n</ul>\n<h3>\n Agent Simplicity\n</h3>\n<p>\n The\n <strong>\n  agents\n </strong>\n were designed to be as simple as possible, with no unnecessary attributes or information. This keeps the implementation straightforward. While additional features like\n <strong>\n  textures\n </strong>\n or\n <strong>\n  rotational values\n </strong>\n might be necessary in more complex applications, such as video games, these are beyond the scope of this project.\n</p>\n"}, "Page 40": {"response": "<h3>\n Direction Calculation and Movement\n</h3>\n<p>\n As shown in\n <strong>\n  Figure 8.5\n </strong>\n , the agent in the simulation calculates its movement by considering several key factors:\n</p>\n<ul>\n<li>\n<strong>\n   Direction to Destination\n  </strong>\n  : The agent calculates the straight path to its target destination.\n </li>\n<li>\n<strong>\n   Avoidance of Encroaching Agents\n  </strong>\n  : The agent calculates the direction needed to avoid colliding with nearby agents.\n </li>\n<li>\n<strong>\n   Center of Mass\n  </strong>\n  : The agent also determines the direction towards the center of mass of nearby agents, encouraging group cohesion.\n </li>\n</ul>\n<p>\n The\n <strong>\n  next move\n </strong>\n is then determined by combining these factors. The movement can be fine-tuned by adjusting\n <strong>\n  damping weights\n </strong>\n , which control how much influence each factor has on the agent's decision, allowing for precise adjustments in behavior.\n</p>\n<h3>\n Collision Avoidance Challenges\n</h3>\n<p>\n In the\n <strong>\n  Boids algorithm\n </strong>\n , collision avoidance works more effectively since the agents have access to more detailed information about their environment. This is because Boids operate in a continuous space, meaning agents can detect objects and other agents from a broader range. In contrast, the\n <strong>\n  cellular automata\n </strong>\n approach faces challenges in collision avoidance because agents only have access to the immediate\n <strong>\n  neighborhood of cells\n </strong>\n . They can only detect and avoid obstacles that enter their discrete neighborhood, limiting their ability to react to distant objects.\n</p>\n<p>\n Some potential solutions to improve\n <strong>\n  collision avoidance\n </strong>\n in the cellular automata approach include:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Layer for Continuous Movement\n   </strong>\n   : For applications like games, a layer could be added on top of the cellular automata system, allowing agents to move smoothly in a continuous manner. The cellular automata model could be used to generate a series of\n   <strong>\n    waypoints\n   </strong>\n   , which the agents would then follow in a non-cellular manner, reducing the rigid movement typical of cellular automata.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Expanding Neighborhood Based on Velocity\n   </strong>\n   : Another solution could involve adjusting the\n   <strong>\n    neighborhood size\n   </strong>\n   based on the agent's\n   <strong>\n    velocity\n   </strong>\n   . Faster agents could have a larger view of their surroundings, allowing them to detect obstacles earlier and avoid them more effectively.\n  </p>\n</li>\n</ul>\n"}, "Page 41": {"response": "<h3>\n Collision Avoidance in Boids and Cellular Automata\n</h3>\n<p>\n<strong>\n  Figures 8.6 and 8.7\n </strong>\n show the behavior of\n <strong>\n  collision avoidance\n </strong>\n in both the\n <strong>\n  Boids algorithm\n </strong>\n and the\n <strong>\n  cellular automata\n </strong>\n approach.\n</p>\n<p>\n In\n <strong>\n  Figure 8.6\n </strong>\n , the\n <strong>\n  Boids collision avoidance\n </strong>\n system is shown operating without any advanced enhancements. While it generally functions well, there is still a noticeable flaw.\n</p>\n<p>\n<strong>\n  Figure 8.7\n </strong>\n highlights a similar issue in both the\n <strong>\n  Boids algorithm\n </strong>\n and the\n <strong>\n  square cell cellular automata\n </strong>\n implementation. In both cases, an agent gets\n <strong>\n  stuck behind an obstacle\n </strong>\n . Specifically, in the images:\n</p>\n<ul>\n<li>\n  On the left, the agent is trapped beneath a\n  <strong>\n   square obstacle\n  </strong>\n  , unable to move.\n </li>\n<li>\n  On the right, the agent (marked by a green cell) is stuck beside a\n  <strong>\n   blue obstacle\n  </strong>\n  .\n </li>\n</ul>\n<p>\n This flaw occurs when the agents are given similar\n <strong>\n  start\n </strong>\n and\n <strong>\n  destination points\n </strong>\n , with the\n <strong>\n  obstacle\n </strong>\n positioned in the same location relative to the agents. In both approaches, the agents fail to properly navigate around the obstacle, highlighting a common issue in\n <strong>\n  collision avoidance\n </strong>\n .\n</p>\n"}, "Page 42": {"response": "<h3>\n Boids Algorithm Implementation\n</h3>\n<p>\n<strong>\n  Basic Boids Setup\n </strong>\n<br/>\n The\n <strong>\n  Boids algorithm\n </strong>\n was implemented using the\n <strong>\n  XNA framework\n </strong>\n in a manner similar to the\n <strong>\n  cellular automata approach\n </strong>\n to maintain consistency across platforms and ensure unbiased performance tests. The simulation was run in a basic\n <strong>\n  800x600 pixel scene\n </strong>\n with\n <strong>\n  variable numbers of agents\n </strong>\n , and features like\n <strong>\n  static obstacles\n </strong>\n that could be added or removed during runtime.\n</p>\n<p>\n<strong>\n  Collision Avoidance\n </strong>\n<br/>\n In this implementation, no\n <strong>\n  advanced obstacle avoidance\n </strong>\n was included, as it could impact the program's\n <strong>\n  frame rate\n </strong>\n , which would distort the results of the performance tests. Additionally,\n <strong>\n  Bin-Lattice spatial subdivision optimizations\n </strong>\n were omitted to keep the cellular automata approach unoptimized and basic.\n</p>\n<p>\n<strong>\n  Clamping Rules for Edge Collision\n </strong>\n<br/>\n Both\n <strong>\n  Boids\n </strong>\n and\n <strong>\n  cellular automata\n </strong>\n share identical\n <strong>\n  clamping rules\n </strong>\n . In Boids, agents\n <strong>\n  bounce back off\n </strong>\n the grid's edges due to opposing forces applied to their velocities. In cellular automata, when agents come too close to another, an opposing force is applied, causing them to move a cell in the opposite direction from the edge.\n</p>\n<p>\n<strong>\n  Boids Simulation Example\n </strong>\n<br/>\n A screenshot of the Boids simulation shows\n <strong>\n  400 agents\n </strong>\n navigating toward a destination while avoiding\n <strong>\n  two obstacles\n </strong>\n in the middle of the screen. The agents are seen avoiding these obstacles at\n <strong>\n  close range\n </strong>\n , demonstrating the basic\n <strong>\n  collision avoidance\n </strong>\n of the system.\n</p>\n"}, "Page 43": {"response": "<h3>\n Boids Simulation Without a Destination\n</h3>\n<p>\n<strong>\n  Second Screenshot of Boids Implementation\n </strong>\n<br/>\n In this second screenshot, the\n <strong>\n  Boids agents\n </strong>\n are not assigned a final destination to move toward. Instead, the agents form several smaller\n <strong>\n  flocks\n </strong>\n , which navigate the screen based purely on\n <strong>\n  internal flocking forces\n </strong>\n and the\n <strong>\n  rebound forces\n </strong>\n from the edges of the screen space. Without a destination, the agents simply interact with one another, moving based on their inherent flocking behaviors.\n</p>\n"}, "Page 44": {"response": "<h3>\n 9. Results and Evaluation\n</h3>\n<p>\n The purpose of this chapter is to present the results of the tests conducted to compare the\n <strong>\n  cellular automata approach\n </strong>\n with the\n <strong>\n  Boids algorithm\n </strong>\n . The tests focused on assessing the\n <strong>\n  performance\n </strong>\n of both methods under various criteria, including\n <strong>\n  frame rate\n </strong>\n ,\n <strong>\n  scalability\n </strong>\n , and\n <strong>\n  algorithmic complexity\n </strong>\n . The results are illustrated with graphs to provide a clear visual comparison.\n</p>\n<h4>\n 9.1 Testing Conditions\n</h4>\n<p>\n To ensure\n <strong>\n  fair performance testing\n </strong>\n , both the\n <strong>\n  Boids algorithm\n </strong>\n and the\n <strong>\n  cellular automata approach\n </strong>\n were implemented without optimization. The tests were conducted sequentially using\n <strong>\n  Visual Studio unit testing\n </strong>\n classes, and the performance of both algorithms was measured under consistent conditions.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Testing Setup\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     Boids algorithm\n    </strong>\n    was simulated in an\n    <strong>\n     800x600 pixel space\n    </strong>\n    .\n   </li>\n<li>\n    The\n    <strong>\n     cellular automata approach\n    </strong>\n    used an\n    <strong>\n     800x800 hexagonal grid\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Experiment 1\n   </strong>\n   :\n   <br/>\n   Both approaches started with\n   <strong>\n    200 agents\n   </strong>\n   , and the number of agents was increased by 200 at a time. The\n   <strong>\n    time step\n   </strong>\n   between frame updates was recorded at each interval, and the data was compiled into a\n   <strong>\n    line graph\n   </strong>\n   for comparison.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Experiment 2\n   </strong>\n   :\n   <br/>\n   This experiment focused on measuring the increase in\n   <strong>\n    complexity\n   </strong>\n   as new agents were added. Both approaches started with\n   <strong>\n    100 agents\n   </strong>\n   , and the number of agents was increased by\n   <strong>\n    25\n   </strong>\n   at fixed intervals.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Experiment 3\n   </strong>\n   :\n   <br/>\n   This test was similar to the second experiment but included an\n   <strong>\n    object counter\n   </strong>\n   to ensure that the correct number of\n   <strong>\n    checks\n   </strong>\n   were recorded during the simulation.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Experiment 4\n   </strong>\n   :\n   <br/>\n   A straightforward comparison was made between the implementations of the\n   <strong>\n    agent neighbourhoods\n   </strong>\n   used in both algorithms.\n  </p>\n</li>\n</ul>\n<p>\n These tests were designed to evaluate how the two algorithms perform under conditions of increasing complexity and to assess the impact of additional agents and features on overall performance.\n</p>\n"}, "Page 45": {"response": "<h3>\n 9.2 Results\n</h3>\n<p>\n Testing was conducted to compare the\n <strong>\n  cellular automata approach\n </strong>\n with an\n <strong>\n  un-optimized version\n </strong>\n of the\n <strong>\n  Boids algorithm\n </strong>\n . The findings are as follows:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Efficiency\n   </strong>\n   :\n   <br/>\n   The\n   <strong>\n    cellular automata approach\n   </strong>\n   outperformed the\n   <strong>\n    Boids algorithm\n   </strong>\n   in terms of efficiency. The new approach was able to\n   <strong>\n    simulate over 1200 agents\n   </strong>\n   while maintaining a stable\n   <strong>\n    60 frames per second\n   </strong>\n   (fps), which was the set upper limit for the experiment. On the other hand, the\n   <strong>\n    Boids algorithm\n   </strong>\n   began to show a slight slowdown after about\n   <strong>\n    200 agents\n   </strong>\n   , which worsened significantly once the agent count reached\n   <strong>\n    450 agents\n   </strong>\n   , making the program\n   <strong>\n    unusable\n   </strong>\n   when there were\n   <strong>\n    800 agents\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Scalability\n   </strong>\n   :\n   <br/>\n   The\n   <strong>\n    cellular automata approach\n   </strong>\n   demonstrated good scalability. As more agents were added, the time required to compute one step of the simulation increased proportionally to the number of agents, and this increase remained consistent until the simulation began to slow down after\n   <strong>\n    1200 agents\n   </strong>\n   .\n  </p>\n<p>\n   In contrast, when agents were added to the\n   <strong>\n    Boids simulation\n   </strong>\n   , the time required for each new agent to be added grew\n   <strong>\n    exponentially\n   </strong>\n   . This is because each agent in the Boids algorithm had to\n   <strong>\n    search through all other agents\n   </strong>\n   , resulting in an increase in\n   <strong>\n    computational load\n   </strong>\n   for each agent. This behavior reinforced the\n   <strong>\n    O(n\u00b2)\n   </strong>\n   complexity of the Boids algorithm, where\n   <strong>\n    n\n   </strong>\n   is the number of agents.\n  </p>\n</li>\n</ul>\n"}, "Page 46": {"response": "<h3>\n 9.3 Experiments\n</h3>\n<h4>\n 9.3.1 Frame Rate\n</h4>\n<p>\n<strong>\n  Table 9.1\n </strong>\n presents the results of the first experiment, and the key observations are as follows:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Both algorithms\n   </strong>\n   can maintain\n   <strong>\n    60 frames per second\n   </strong>\n   (fps) with up to approximately\n   <strong>\n    200 agents\n   </strong>\n   . However, the\n   <strong>\n    Boids algorithm\n   </strong>\n   begins to\n   <strong>\n    lose efficiency quickly\n   </strong>\n   as the number of agents increases.\n  </p>\n</li>\n<li>\n<p>\n   By the time the\n   <strong>\n    Boids simulation\n   </strong>\n   reaches\n   <strong>\n    600 agents\n   </strong>\n   , the frame rate drops significantly, making it unsuitable for larger, real-time applications.\n  </p>\n</li>\n<li>\n<p>\n   The\n   <strong>\n    cellular automata approach\n   </strong>\n   performs better, maintaining a frame rate close to\n   <strong>\n    60 fps\n   </strong>\n   up to\n   <strong>\n    1600 agents\n   </strong>\n   . After this point, the frame rate starts to noticeably drop to around\n   <strong>\n    40 fps\n   </strong>\n   .\n  </p>\n</li>\n</ul>\n"}, "Page 47": {"response": "<h3>\n 9.3.2 Scalability\n</h3>\n<p>\n<strong>\n  Table 9.2\n </strong>\n summarizes the results from the second experiment, with the following key observations:\n</p>\n<ul>\n<li>\n<p>\n   The\n   <strong>\n    cellular automata approach\n   </strong>\n<strong>\n    scales linearly\n   </strong>\n   with the complexity of the scene. As more agents are added, the time required to compute each frame increases proportionally.\n  </p>\n</li>\n<li>\n<p>\n   The\n   <strong>\n    Boids algorithm\n   </strong>\n   , on the other hand,\n   <strong>\n    scales poorly\n   </strong>\n   , with increasingly larger time steps as more agents are added. When the scene reaches\n   <strong>\n    800 agents\n   </strong>\n   , the time required to compute each frame is around\n   <strong>\n    60 milliseconds\n   </strong>\n   . This behavior is expected, as the Boids algorithm has a known\n   <strong>\n    O(n\u00b2) complexity\n   </strong>\n   when unoptimized.\n  </p>\n</li>\n</ul>\n"}, "Page 48": {"response": "<h3>\n 9.3.3 Algorithmic Complexity\n</h3>\n<p>\n<strong>\n  Table 9.3\n </strong>\n outlines the results of the third experiment, which aimed to measure the maximum number of objects each approach needs to process during a single frame.\n</p>\n<ul>\n<li>\n<p>\n   Both approaches began with\n   <strong>\n    100 agents\n   </strong>\n   , and the number of agents was increased by\n   <strong>\n    100\n   </strong>\n   at each step until one of the approaches became unusable.\n  </p>\n</li>\n<li>\n<p>\n   By the time the scene had\n   <strong>\n    800 agents\n   </strong>\n   , the\n   <strong>\n    Boids algorithm\n   </strong>\n   had to perform over\n   <strong>\n    600,000 checks\n   </strong>\n   per frame, comparing every agent against all others (except itself) to check if they were within their radius.\n  </p>\n</li>\n<li>\n<p>\n   The\n   <strong>\n    number of checks\n   </strong>\n   required for each frame in the Boids algorithm can be expressed by the following formula:\n  </p>\n<p>\n<strong>\n    Number of Checks = (Number of Agents * Number of Agents) \u2013 Number of Agents\n   </strong>\n</p>\n</li>\n</ul>\n<p>\n This means that for each frame, every agent checks every other agent to determine their position and velocity, which increases the processing load significantly.\n</p>\n"}, "Page 49": {"response": "<h3>\n 9.3.4 Square vs. Hexagonal Grid\n</h3>\n<p>\n The\n <strong>\n  fourth experiment\n </strong>\n focused on comparing the performance of the two types of cell grids:\n <strong>\n  square\n </strong>\n and\n <strong>\n  hexagonal\n </strong>\n . While the hexagonal grid produced smoother movement for the flock, the efficiency of both grids had not yet been tested.\n</p>\n<ul>\n<li>\n<strong>\n   Hexagonal grid\n  </strong>\n  : This grid offers smoother movement for agents, but it was important to assess if the\n  <strong>\n   square grid\n  </strong>\n  would be significantly more efficient, even with its more rigid movement patterns. If the square grid proved to be much more efficient, the trade-off in terms of less fluid movement might have been acceptable.\n </li>\n</ul>\n<h3>\n Search Space Comparison\n</h3>\n<ul>\n<li>\n<p>\n   The\n   <strong>\n    Boids approach\n   </strong>\n   requires checking all agents against each other, which grows exponentially. For instance, with\n   <strong>\n    800 agents\n   </strong>\n   , Boids required over\n   <strong>\n    600,000 checks\n   </strong>\n   per frame.\n  </p>\n</li>\n<li>\n<p>\n   In contrast, the\n   <strong>\n    cellular automata approach\n   </strong>\n   only requires each agent to check its own neighbourhood. The equation for the number of checks needed in cellular automata is:\n  </p>\n<p>\n<strong>\n    Number of Checks = (Number of Agents * Neighbourhood Size) \u2013 Number of Agents\n   </strong>\n</p>\n</li>\n<li>\n<p>\n   At\n   <strong>\n    800 agents\n   </strong>\n   , the new approach needed fewer checks, with a maximum of about\n   <strong>\n    15,000 checks\n   </strong>\n   for the hexagonal grid and\n   <strong>\n    20,000 checks\n   </strong>\n   for the square grid. This is significantly lower than the Boids approach, which needed\n   <strong>\n    600,000+ checks\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n   This dramatic difference in the number of checks translates to a\n   <strong>\n    massive saving in time and computing power\n   </strong>\n   for the cellular automata approach, making it far more efficient than Boids.\n  </p>\n</li>\n</ul>\n"}, "Page 51": {"response": "<h3>\n 9.4 Evaluation\n</h3>\n<p>\n The\n <strong>\n  cellular automata approach\n </strong>\n successfully simulates flocking behavior, though in a\n <strong>\n  discrete form\n </strong>\n . While it doesn't exactly replicate the Boids algorithm, it mirrors key traits such as\n <strong>\n  close-range collision avoidance\n </strong>\n . The flock can either be\n <strong>\n  directed toward a specific position\n </strong>\n or allowed to move freely around the screen, where smaller groups form and merge into larger flocks.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Obstacle Avoidance\n   </strong>\n   : While the cellular automata approach works for\n   <strong>\n    obstacle avoidance\n   </strong>\n   , it is somewhat limited. Since agents can only detect objects within their\n   <strong>\n    neighbourhoods\n   </strong>\n   , they cannot account for obstacles outside this local range. However, there are potential improvements based on research in\n   <strong>\n    crowd motion\n   </strong>\n   and\n   <strong>\n    cellular automata applications\n   </strong>\n   , which are discussed in the chapter on\n   <strong>\n    future work\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Performance and Efficiency\n   </strong>\n   : The cellular automata approach has been shown to be\n   <strong>\n    much more efficient\n   </strong>\n   than the Boids algorithm in the tests, performing well in\n   <strong>\n    real-time applications\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Implementation Details\n   </strong>\n   : Both algorithms were developed in\n   <strong>\n    C# using the XNA framework\n   </strong>\n   . This choice helped speed up the development process and reduced implementation challenges, especially given the project\u2019s\n   <strong>\n    time constraints\n   </strong>\n   . However, it is believed that implementing both algorithms in\n   <strong>\n    C++\n   </strong>\n   , commonly used in\n   <strong>\n    triple-A games\n   </strong>\n   , would likely lead to even\n   <strong>\n    faster performance\n   </strong>\n   . This would allow the simulation to handle more agents efficiently. By using\n   <strong>\n    pointers\n   </strong>\n   for handling agent neighbourhoods and optimizing\n   <strong>\n    data structures\n   </strong>\n   , a\n   <strong>\n    significant performance boost\n   </strong>\n   could be achieved. Additionally, switching to\n   <strong>\n    low-level OpenGL functions\n   </strong>\n   for rendering (such as using simple colored pixels instead of textures) would further improve efficiency.\n  </p>\n</li>\n</ul>\n"}, "Page 53": {"response": "<h3>\n 10. Conclusions\n</h3>\n<p>\n This chapter evaluates the outcomes of the project and assesses how well the objectives, outlined at the beginning, have been met.\n</p>\n<p>\n At the start, several key goals were identified for the project:\n</p>\n<ul>\n<li>\n<strong>\n   Identify and Simplify Flocking Behavior\n  </strong>\n  : The project aimed to define the key characteristics of flocking behavior and reduce them to their simplest form to make the problem more manageable.\n </li>\n<li>\n<strong>\n   Convert Continuous Flocking to Discrete Simulation\n  </strong>\n  : The goal was to adapt the principles of continuous flocking into a discrete simulation.\n </li>\n<li>\n<strong>\n   Apply the New Approach to Cellular Automata\n  </strong>\n  : Investigating how the new discrete rule set could be applied within the framework of cellular automata space was a key objective.\n </li>\n<li>\n<strong>\n   Develop a Cellular Automata Model for Flocking\n  </strong>\n  : The project aimed to develop a cellular automata model that could simulate flocking behavior in a discrete form, comparable to the existing continuous Boids algorithm.\n </li>\n<li>\n<strong>\n   Ensure Scalability\n  </strong>\n  : The new approach needed to scale well as complexity increased.\n </li>\n<li>\n<strong>\n   Ensure Efficiency\n  </strong>\n  : The approach had to be efficient enough for real-time applications.\n </li>\n</ul>\n<p>\n Through research and analysis of academic papers on flocking behavior, algorithms, and crowd motion, the project developed a clearer understanding of how flocks behave and how this behavior can be simulated. By simplifying the problem and breaking it down into smaller, more manageable sections, the project was able to convert the principles of continuous flocking simulation, specifically the Boids algorithm, into a discrete form suitable for cellular automata.\n</p>\n<p>\n With this new, more concrete definition, the problem could be addressed in a more fundamental way, laying the groundwork for the implementation of the cellular automata approach.\n</p>\n"}, "Page 54": {"response": "<h3>\n 10.1 Key Insights and Approach to Flocking Simulation\n</h3>\n<p>\n The project used previous research to demonstrate how an agent can move within cellular space and how various external factors (such as environmental conditions, threat levels, and nearby agents) influence its movement. A key step in adapting continuous flocking principles to discrete space was the application of these external factors in the form of discrete decisions.\n</p>\n<h3>\n Converting Continuous Principles to Discrete Decisions\n</h3>\n<p>\n Instead of agents reacting immediately to every external stimulus (such as an agent moving too close or an obstacle entering their neighborhood), they take several factors into account. The urgency of each situation is considered: for example, if an obstacle is two cells away versus being just one step away, the agent will apply different levels of urgency to decide its next move. This decision-making process uses a combination of factors, such as avoidance and goal-seeking, and dampens their influence based on how urgent the situation is. The goal is to make a balanced movement decision that optimally addresses all needs.\n</p>\n<h3>\n External Knowledge and Guidance\n</h3>\n<p>\n One important aspect of the cellular automata approach is the incorporation of external knowledge. While agents can only see within their immediate neighborhoods, they possess prior knowledge of the outside world. This mirrors how migratory birds, for instance, can navigate over vast distances while relying on their internal understanding of direction. In the flocking simulation, this external knowledge is used to guide the entire flock toward a destination while allowing individual agents to handle their own internal behaviors, such as avoidance and flock cohesion.\n</p>\n<h3>\n Efficiency and Scalability of the Approach\n</h3>\n<p>\n The simplicity of these rules, combined with the absence of large data structures and sorting mechanisms, made the cellular automata approach much more efficient than the Boids algorithm, particularly in testing. The approach scales well because it avoids the need for complex sorting, which is a characteristic of the Boids algorithm. The new approach demonstrated linear scalability, meaning the computational effort required grows at a steady rate as more agents are added to the simulation. This makes it more suited for real-time applications where agent numbers may vary.\n</p>\n<p>\n Future work could involve testing how the new approach performs against a fully optimized Boids algorithm that uses advanced techniques like bin-lattice spatial subdivision, to see if the new approach can still outperform a highly optimized version.\n</p>\n"}, "Page 55": {"response": "<h3>\n 10.2 Algorithmic Complexity and Real-Time Application Suitability\n</h3>\n<p>\n The new approach to flocking, which uses cellular automata, has a significant advantage in terms of scalability and efficiency. The algorithmic complexity of this approach is\n <strong>\n  O(n)\n </strong>\n , meaning the time required for the simulation increases linearly with the number of agents in the scene. This is in contrast to the\n <strong>\n  O(n\u00b2)\n </strong>\n complexity of the traditional Boids algorithm, where the time required grows exponentially as more agents are added.\n</p>\n<p>\n Because of its\n <strong>\n  linear scalability\n </strong>\n and\n <strong>\n  higher efficiency\n </strong>\n , the new approach is much better suited for\n <strong>\n  real-time applications\n </strong>\n . This makes it more practical for scenarios where a large number of agents need to be simulated quickly and efficiently.\n</p>\n"}, "Page 56": {"response": "<h3>\n 11. Future Work\n</h3>\n<h4>\n 11.1 Optimization\n</h4>\n<p>\n The current implementation of the cellular automata-based flocking algorithm is in its basic form, and there are several opportunities for optimizing its performance:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Separating Axis Theorem\n   </strong>\n   : One possible optimization involves using the\n   <strong>\n    Separating Axis Theorem\n   </strong>\n   . This method could help improve the efficiency of neighbourhood searches by detecting when agents overlap, similar to how physics engines use it for collision detection between 2D or 3D models during the broad phase. This could reduce unnecessary checks and make the algorithm faster.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    C++ Implementation and OpenGL\n   </strong>\n   : Another optimization would involve implementing the algorithm in\n   <strong>\n    C++\n   </strong>\n   instead of using\n   <strong>\n    XNA\n   </strong>\n   , which was chosen due to time constraints. By using\n   <strong>\n    low-level OpenGL functions\n   </strong>\n   for rendering the scene, there could be a noticeable performance improvement. C++ allows for more efficient memory management and faster execution, and OpenGL can render the agents as simple pixels rather than textures, further boosting performance.\n  </p>\n</li>\n</ul>\n<h4>\n 11.2 Multi-Cell Obstacles and Agents\n</h4>\n<p>\n Currently, the approach only supports single-cell agents and obstacles. Larger objects, like mountains or walls, which span multiple cells, are not handled by this implementation. To accommodate such objects, modifications to the current algorithm would be necessary.\n</p>\n<p>\n A potential solution for managing multi-cell obstacles is to use\n <strong>\n  bin-lattice spatial subdivision\n </strong>\n , similar to how it's used in the Boids algorithm. This technique involves breaking down larger objects into smaller segments based on the agent's proximity. As an agent approaches a large object, it would interact with these smaller segments rather than the entire object at once. This allows for more efficient handling of complex obstacles and improves the agent's ability to navigate around them.\n</p>\n"}, "Page 57": {"response": "<h3>\n 11. Future Work\n</h3>\n<h4>\n 11.2 Multi-Cell Obstacles and Agents (Continued)\n</h4>\n<p>\n To handle larger obstacles, such as mountains or walls, which occupy multiple cells, the approach can be expanded. The solution would involve breaking these larger objects into smaller sub-entities that agents can interact with just as they do with individual, single-cell objects. This modification would allow agents to deal with these complex obstacles more efficiently, as they would interact with smaller chunks based on their proximity.\n</p>\n<h4>\n 11.3 Optimized Boids Testing\n</h4>\n<p>\n The current tests for the new cellular automata-based approach have only been conducted against an un-optimized version of the\n <strong>\n  Boids algorithm\n </strong>\n . A future avenue for research would be to optimize the Boids algorithm using\n <strong>\n  bin-lattice spatial subdivision\n </strong>\n . After optimizing Boids, it would be essential to conduct further testing, comparing the performance of both the optimized Boids algorithm and the optimized cellular automata approach. These tests should be based on similar criteria to the experiments already conducted, focusing on performance, scalability, and efficiency.\n</p>\n<h4>\n 11.4 Colony Building\n</h4>\n<p>\n One potential application for the new approach is in modeling how social insects like bees and ants build their colonies, communicate, and forage for food. To achieve this, the concept of\n <strong>\n  pheromones\n </strong>\n \u2014a critical element in insect communication\u2014would need to be reintroduced into the algorithm. Insects use pheromones to leave trails to food sources and communicate with others in the colony. The algorithm would need to implement this feature in an efficient manner, ensuring that the pheromone behavior is accurately modeled to simulate insect-like colony building and foraging activities.\n</p>\n"}, "Page 58": {"response": "<h3>\n 11.5 Flight Path Simulation\n</h3>\n<p>\n Accurately modeling flight paths for multiple aircraft is a highly complex challenge. This task involves accounting for variables such as flight schedules, external factors like weather, and potential environmental hazards. The new algorithm could be used to simulate and optimize flight paths for aircraft, helping to improve efficiency and safety.\n</p>\n<p>\n One way to approach this would be by integrating\n <strong>\n  reinforced learning\n </strong>\n techniques with the algorithm. This combination could be used to continuously optimize flight paths, reducing the risk of mid-air collisions. This application is not new; a 2005 research paper titled\n <em>\n  \u201cCellular Automata Modelling of En Route and Arrival Self-Spacing for Autonomous Aircrafts\u201d\n </em>\n explored a similar idea. In this paper, each aircraft broadcasts its position in all directions within its surrounding airspace. If another aircraft enters this radius, the two would exchange positional data and calculate optimal paths to avoid a collision. The algorithm's existing collision-avoidance capabilities may be well-suited for this type of simulation, and the primary requirement for testing could simply be gathering the appropriate data for experimentation.\n</p>\n"}, "Page 59": {"response": "<h3>\n Flight Path Simulation: Collision Avoidance and Hazard Detection\n</h3>\n<p>\n The diagram above illustrates an aircraft navigating a field with randomly placed \"no-fly\" or hazardous zones. These zones could represent bad weather, nearby aircraft, or solid obstacles like mountains. The aircraft detects these hazards from a distance of 1 cell and takes evasive action to avoid them.\n</p>\n<p>\n Similarly, the cellular automata approach demonstrates a comparable collision avoidance method. In this case, the agent navigates a similar environment, but with a\n <strong>\n  2-cell neighbourhood depth\n </strong>\n as opposed to the 1-cell range in the previous example. This expanded neighbourhood depth allows the agent to detect hazardous areas more quickly. Additionally, the agent's movement is influenced by multiple forces, such as its tendency to move toward its destination, the presence of multiple obstacles, and the need to avoid hazards.\n</p>\n<p>\n Though the agent might approach a hazardous area within one cell, the\n <strong>\n  damping weights\n </strong>\n applied to these forces ensure that obstacle avoidance becomes the highest priority. As a result, the agent adjusts its path to avoid colliding with the hazardous zone, even if it temporarily moves close to it. This system ensures that the agent can safely navigate the field without hitting any dangerous objects.\n</p>\n"}, "Page 60": {"response": "<h3>\n Crowd Motion Simulation: Autonomous Agent Behavior\n</h3>\n<p>\n Crowd motion simulations focus on the movement of agents in close proximity to each other, such as fish, vehicles, or even people. Examples of crowd motion include scenarios like people boarding or exiting a train, vehicles moving in traffic, or prey fleeing from predators while avoiding obstacles.\n</p>\n<p>\n While previous research on cellular automata has explored crowd motion, the new algorithm presented here could offer a more accurate simulation compared to earlier attempts. Setting up experiments to test this would be relatively simple, given the similarity between crowd motion and the flocking behavior the algorithm was originally designed to simulate.\n</p>\n<p>\n The experiment setup could involve creating scenes with randomly placed obstacles and a goal for an agent to reach. A small function could track the agent\u2019s movement directions as it avoids these obstacles. The results could then be analyzed by graphing or visually representing the movement patterns, similar to the flight path simulation examples shown earlier. This would provide insights into how effectively the algorithm models crowd motion in various scenarios.\n</p>\n"}, "Page 61": {"response": "<h3>\n Bibliography\n</h3>\n<ol>\n<li>\n<strong>\n   Craig W. Reynolds\n  </strong>\n  , \"Flocks, Herds, and Schools: A Distributed Behavioural Model,\"\n  <em>\n   SIGGRAPH\n  </em>\n  , 1987\n </li>\n<li>\n<strong>\n   Jae Moon Lee &amp; Hye-Kyung Cho\n  </strong>\n  , \"A Simple Heuristic to Find Efficiently k-Nearest Neighbours in Flocking Behaviours,\"\n  <em>\n   MATHCC\n  </em>\n  , 2006\n </li>\n<li>\n<strong>\n   Craig Reynolds\n  </strong>\n  , \"Interaction with Groups of Autonomous Characters,\" Research and Development Group, Sony Computer Entertainment America, 2000\n </li>\n<li>\n<strong>\n   Craig Reynolds\n  </strong>\n  , \"Not Bumping Into Things,\"\n  <em>\n   SIGGRAPH\n  </em>\n  , 1988\n </li>\n<li>\n<strong>\n   Hanan Samet\n  </strong>\n  , \"Applications of Spatial Data Structures,\" 1989\n </li>\n<li>\n<strong>\n   Zoran Popovic\n  </strong>\n  , \"The Rapid Simulation of Proximal-Interaction Particle Systems,\" 1994\n </li>\n<li>\n<strong>\n   Stephen Wolfram\n  </strong>\n  ,\n  <em>\n   A New Kind of Science\n  </em>\n  , Full Book, 2002\n </li>\n<li>\n<strong>\n   Joel L. Schiff\n  </strong>\n  ,\n  <em>\n   Cellular Automata: A Discrete View of the World\n  </em>\n  , Full Book\n </li>\n<li>\n<strong>\n   Hubert Ludwig Klupfel\n  </strong>\n  , \"A Cellular Automaton Model for Crowd Movement and Egress Simulation\"\n </li>\n<li>\n<strong>\n   David M. Bourg, Glenn Seemann\n  </strong>\n  , \"AI for Game Developers, Chapter 4,\" Book\n </li>\n<li>\n<strong>\n   Craig Reynolds\n  </strong>\n  , \"Steering Behaviours for Autonomous Characters\"\n </li>\n<li>\n<strong>\n   OJ O'Loan, M R Evans\n  </strong>\n  , \"Alternating Steady State in One-Dimensional Flocking\"\n </li>\n<li>\n<strong>\n   Lee Spector, Jon Klein, Chris Perry, Mark Feinstein\n  </strong>\n  , \"Emergence of Collective Behaviour in Evolving Populations of Flying Agents\"\n </li>\n<li>\n<strong>\n   Joel L. Schiff\n  </strong>\n  ,\n  <em>\n   Cellular Automata: A Discrete View of the World, Chapter 4.1, pg. 93\n  </em>\n  , \"The Game of Life\"\n </li>\n</ol>\n"}, "Page 62": {"response": "<h3>\n Bibliography (Continued)\n</h3>\n<ol start=\"15\">\n<li>\n<strong>\n   Divan Burger, Megan Duncan, Apurva Kumar, Leon van Dyk, Melissa Ingels\n  </strong>\n  , \u201cHxCas Software\u201d\n </li>\n<li>\n<strong>\n   Martin Barksten, David Rydberg\n  </strong>\n  , \u201cExtending Reynolds\u2019 Flocking Model to a Simulation of Sheep in the Presence of a Predator,\u201d\n  <em>\n   KTH Computer Science and Communication\n  </em>\n</li>\n<li>\n<strong>\n   The Lion King\n  </strong>\n  , Directed by Roger Allers and Rob Minkoff,\n  <em>\n   Walt Disney Pictures\n  </em>\n  , 1994, Film\n </li>\n<li>\n<strong>\n   Batman Returns\n  </strong>\n  , Directed by Tim Burton,\n  <em>\n   Warner Bros\n  </em>\n  , 1992, Film\n </li>\n<li>\n<strong>\n   Charles Kim, Khalid Abubakar, and Obinna Obah\n  </strong>\n  , \u201cCellular Automata Modelling of En Route and Arrival Self-Spacing for Autonomous Aircrafts,\u201d\n  <em>\n   Department of Electrical and Computer Engineering, Howard University\n  </em>\n  , 2005\n </li>\n<li>\n<strong>\n   Charles Kim, Khalid Abubakar, and Obinna Obah\n  </strong>\n  , \"Cellular Automata Modelling of En Route and Arrival Self-Spacing for Autonomous Aircrafts,\"\n  <em>\n   Department of Electrical and Computer Engineering, Howard University\n  </em>\n  , 2005, Image of single flight obstacle avoidance\n </li>\n<li>\n<strong>\n   Dave Burraston, Ernest Edmonds, Dan Livingstone, and Eduardo Reck Miranda\n  </strong>\n  , \u201cCellular Automata in MIDI-based Computer Music,\u201d\n  <em>\n   Creativity and Cognition Studios, Faculty of Information Technology, University of Technology, Sydney, Australia\n  </em>\n  , 2005\n </li>\n<li>\n<strong>\n   Zhenqiang Gong, Nicholos J. Matzke, Bard Ermentrout, Dawn Song, Jann E. Vendett, Montgomery Slatkin, and George Oster\n  </strong>\n  , \u201cEvolution of Patterns on Conus Shells,\u201d\n  <em>\n   Departments of Electrical Engineering and Computer Science and Integrative Biology, University of California, Berkeley, CA\n  </em>\n  ,\n  <em>\n   Department of Mathematics, University of Pittsburgh, Pittsburgh, PA\n  </em>\n  and\n  <em>\n   Departments of Molecular and Cell Biology and Environmental Science, Policy and Management, University of California, Berkeley, CA\n  </em>\n  , 2011\n </li>\n</ol>\n"}}