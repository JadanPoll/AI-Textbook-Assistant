{"Page 5": {"response": "<p>\n<strong>\n  USB Basics: A Comprehensive Overview\n </strong>\n</p>\n<p>\n<strong>\n  What USB Can Do\n </strong>\n<br/>\n USB (Universal Serial Bus) is a versatile standard that connects a wide variety of devices to computers or other electronic systems. It allows devices to communicate, transfer data, and power each other.\n</p>\n<p>\n<strong>\n  Benefits for Users\n </strong>\n<br/>\n For users, USB offers simplicity, flexibility, and convenience. It supports plug-and-play functionality, allowing devices to be easily connected or disconnected without needing to restart the system. USB also supports power delivery, enabling charging of devices while transferring data.\n</p>\n<p>\n<strong>\n  Benefits for Developers\n </strong>\n<br/>\n For developers, USB provides a standardized and widely adopted interface, simplifying the design and implementation of new devices. The availability of development tools and resources allows for rapid prototyping and integration of USB-based systems into various applications.\n</p>\n<p>\n<strong>\n  Beyond the Hype\n </strong>\n<br/>\n While USB is widely popular, it\u2019s essential to understand its limits and challenges. Despite its advantages, some areas like speed and distance limitations still require consideration when choosing USB for certain tasks.\n</p>\n<p>\n<strong>\n  Evolution of an Interface\n </strong>\n<br/>\n The USB standard has evolved significantly over time, with key versions improving speed, power handling, and capabilities.\n</p>\n<p>\n<strong>\n  Original USB\n </strong>\n<br/>\n The first USB version, released in 1996, focused on simplifying and replacing various other serial ports. It supported data transfer rates up to 12 Mbps.\n</p>\n<p>\n<strong>\n  USB 2.0\n </strong>\n<br/>\n Released in 2000, USB 2.0 greatly increased data transfer speeds, up to 480 Mbps, and improved power delivery options, making it suitable for a wider range of devices.\n</p>\n<p>\n<strong>\n  USB On-The-Go\n </strong>\n<br/>\n USB On-The-Go (OTG), introduced in 2001, allows devices to act as both hosts and peripherals, enabling direct communication between USB devices without the need for a computer.\n</p>\n<p>\n<strong>\n  Wireless USB\n </strong>\n<br/>\n Wireless USB, introduced later, allows for USB functionality without cables by using high-speed wireless connections, making it more flexible for portable and mobile devices.\n</p>\n<p>\n<strong>\n  USB versus IEEE-1394\n </strong>\n<br/>\n USB and IEEE-1394 (FireWire) are two different communication standards, with USB offering broader support for consumer electronics and lower cost, while IEEE-1394 supports higher data transfer rates and is used in more professional environments.\n</p>\n<p>\n<strong>\n  USB versus Ethernet\n </strong>\n<br/>\n While both USB and Ethernet are used for data transfer, USB is typically used for short-range communication, while Ethernet supports longer-range networking and higher data throughput, especially in wired networking environments.\n</p>\n<p>\n<strong>\n  Bus Components\n </strong>\n<br/>\n The USB bus consists of different components, including the host, devices, and hubs, which all work together to facilitate data and power transfer across the system.\n</p>\n<p>\n<strong>\n  Topology\n </strong>\n<br/>\n The USB network topology is typically a tiered structure, with a host at the center and peripheral devices branching off through hubs, ensuring efficient management and communication across devices.\n</p>\n<p>\n<strong>\n  Defining Terms\n </strong>\n<br/>\n Understanding key USB terms, such as \u201chost,\u201d \u201cdevice,\u201d \u201chub,\u201d and \u201cendpoint,\u201d is essential for working with USB technologies. These terms define the roles and connections within a USB network.\n</p>\n"}, "Page 6": {"response": "<h3>\n USB Transfer Protocols Overview\n</h3>\n<p>\n<strong>\n  Division of Labor\n </strong>\n<br/>\n In USB communication, the workload is divided between the\n <strong>\n  host\n </strong>\n and the\n <strong>\n  peripheral\n </strong>\n devices. The host manages the primary flow of data and coordinates communication, while the peripheral\u2019s responsibility is to follow the instructions from the host and transfer or receive data.\n</p>\n<p>\n<strong>\n  Host's Duties\n </strong>\n<br/>\n The host controls all interactions on the USB bus. It initiates and manages communication, assigns power, and organizes the data flow. Its main task is to query, configure, and control the connected devices.\n</p>\n<p>\n<strong>\n  Peripheral\u2019s Duties\n </strong>\n<br/>\n The peripheral responds to the host's instructions. It sends data or receives it based on the host's requests and can signal the host for special conditions or data availability.\n</p>\n<p>\n<strong>\n  Speed Considerations\n </strong>\n<br/>\n Transfer speed is crucial and depends on the host\u2019s capabilities, the USB version, and device specifications. High-speed data exchanges rely on both devices supporting faster transfer protocols.\n</p>\n<p>\n<strong>\n  Developing a Device\n </strong>\n<br/>\n Creating a device requires understanding the protocol and its communication components.\n</p>\n<ul>\n<li>\n<strong>\n   Elements in the Link\n  </strong>\n  : This refers to the components that make up the USB connection, including cables, connectors, and the physical devices.\n </li>\n<li>\n<strong>\n   Tools for Development\n  </strong>\n  : Development tools, like simulators and USB analyzers, help monitor and troubleshoot the USB device's behavior during development.\n </li>\n<li>\n<strong>\n   Steps in Developing a Project\n  </strong>\n  : These steps generally include designing the hardware, developing the firmware, and testing the device for proper communication with the host.\n </li>\n</ul>\n<h3>\n Inside USB Transfers\n</h3>\n<p>\n<strong>\n  Transfer Basics\n </strong>\n<br/>\n USB transfers are structured forms of data movement between the host and device, categorized based on the type of data and communication needs.\n</p>\n<p>\n<strong>\n  Enumeration Communications\n </strong>\n<br/>\n This is the process where the host identifies and configures a device, checking its capabilities and assigning resources.\n</p>\n<p>\n<strong>\n  Application Communications\n </strong>\n<br/>\n These transfers facilitate the actual data exchange after enumeration, enabling applications to request and transmit data between the host and peripheral.\n</p>\n<p>\n<strong>\n  Managing Data on the Bus\n </strong>\n<br/>\n The USB bus is managed through specific protocols that ensure data integrity, timing, and correctness during transfers.\n</p>\n<p>\n<strong>\n  Host Speed and Bus Speed\n </strong>\n<br/>\n The speed at which data is transferred depends on both the host's capabilities and the type of USB protocol in use (e.g., USB 2.0 vs. USB 3.0).\n</p>\n<p>\n<strong>\n  Elements of a Transfer\n </strong>\n<br/>\n Each transfer includes the data to be sent, instructions, and control messages to ensure the correct flow and error-free transmission.\n</p>\n<p>\n<strong>\n  Device Endpoints\n </strong>\n<br/>\n Endpoints are the sources and sinks of data on a device. These are specific communication points where data is either sent from or received by the device.\n</p>\n<p>\n<strong>\n  Pipes\n </strong>\n<br/>\n Pipes connect the endpoints to the host. These pathways ensure that the data flows in an organized and efficient manner.\n</p>\n<p>\n<strong>\n  Types of Transfers\n </strong>\n<br/>\n USB transfers can be categorized based on the type of data exchanged (e.g., control, bulk, interrupt, or isochronous).\n</p>\n<p>\n<strong>\n  Stream and Message Pipes\n </strong>\n</p>\n<ul>\n<li>\n<strong>\n   Stream pipes\n  </strong>\n  allow continuous data flow.\n </li>\n<li>\n<strong>\n   Message pipes\n  </strong>\n  are used for structured, discrete data chunks.\n </li>\n</ul>\n<p>\n<strong>\n  Initiating a Transfer\n </strong>\n<br/>\n A transfer is initiated by the host, which sends requests to the peripheral. These can be for control, data, or status updates.\n</p>\n<p>\n<strong>\n  Transactions: The Building Blocks of a Transfer\n </strong>\n<br/>\n A transfer is broken into smaller components called transactions, which ensure that data is correctly moved between devices.\n</p>\n<p>\n<strong>\n  Transaction Phases\n </strong>\n<br/>\n Transactions are composed of phases that include data setup, data transfer, and acknowledgment of successful completion.\n</p>\n<p>\n<strong>\n  Ensuring Successful Transfers\n </strong>\n<br/>\n Various mechanisms, like error-checking and handshaking, ensure that transfers are completed successfully.\n</p>\n<ul>\n<li>\n<strong>\n   Handshaking\n  </strong>\n  : This process is a series of signals between the host and peripheral to confirm that the transfer is proceeding as expected.\n </li>\n<li>\n<strong>\n   Reporting Status\n  </strong>\n  : Especially in control transfers, the status is communicated back to the host to report errors or completion.\n </li>\n</ul>\n<p>\n<strong>\n  Error Checking\n </strong>\n<br/>\n Errors during transfers are detected and handled through checks like CRC (Cyclic Redundancy Check) and retry mechanisms, ensuring data integrity.\n</p>\n<h3>\n Transfer Types\n</h3>\n<p>\n<strong>\n  Control Transfers\n </strong>\n<br/>\n Control transfers are used for management and configuration tasks, like setting device parameters or getting information about the device.\n</p>\n<ul>\n<li>\n<strong>\n   Availability\n  </strong>\n  : Control transfers are always available.\n </li>\n<li>\n<strong>\n   Structure\n  </strong>\n  : These transfers consist of a setup packet, data packet, and status packet.\n </li>\n<li>\n<strong>\n   Data Size\n  </strong>\n  : Typically small data sizes, often used for commands and configurations.\n </li>\n<li>\n<strong>\n   Speed\n  </strong>\n  : Control transfers are slower but reliable.\n </li>\n<li>\n<strong>\n   Error Detection\n  </strong>\n  : Errors are handled through retries and status responses.\n </li>\n</ul>\n<p>\n<strong>\n  Bulk Transfers\n </strong>\n<br/>\n Used for large, non-time-sensitive data transfers, like file transfers.\n</p>\n<ul>\n<li>\n<strong>\n   Availability\n  </strong>\n  : Available for large amounts of data but are dependent on available bandwidth.\n </li>\n<li>\n<strong>\n   Structure\n  </strong>\n  : Bulk transfers use the same structure as control transfers but handle larger data sizes.\n </li>\n<li>\n<strong>\n   Data Size\n  </strong>\n  : These transfers can handle large blocks of data.\n </li>\n<li>\n<strong>\n   Speed\n  </strong>\n  : Speed depends on bus availability but can be faster than control transfers.\n </li>\n<li>\n<strong>\n   Error Handling\n  </strong>\n  : Errors in bulk transfers are handled through retries.\n </li>\n</ul>\n"}, "Page 7": {"response": "<h3>\n USB Transfer Types and Enumeration\n</h3>\n<p>\n<strong>\n  Interrupt Transfers\n </strong>\n<br/>\n Interrupt transfers are used for data that needs to be exchanged at regular intervals, but not continuously.\n</p>\n<ul>\n<li>\n<strong>\n   Availability\n  </strong>\n  : These transfers are typically used for small, periodic data exchanges.\n </li>\n<li>\n<strong>\n   Structure\n  </strong>\n  : Interrupt transfers use a fixed-length packet to send or receive data at specific intervals.\n </li>\n<li>\n<strong>\n   Data Size\n  </strong>\n  : The data is typically small, suited for quick, periodic updates.\n </li>\n<li>\n<strong>\n   Speed\n  </strong>\n  : These transfers are slower compared to bulk transfers due to periodic timing requirements.\n </li>\n<li>\n<strong>\n   Error Handling\n  </strong>\n  : Interrupt transfers handle errors by retrying the transfer if an error occurs, ensuring data integrity.\n </li>\n</ul>\n<p>\n<strong>\n  Isochronous Transfers\n </strong>\n<br/>\n Isochronous transfers are designed for real-time data, like audio or video, where timing is critical.\n</p>\n<ul>\n<li>\n<strong>\n   Availability\n  </strong>\n  : Always available but limited by the bus's real-time requirements.\n </li>\n<li>\n<strong>\n   Structure\n  </strong>\n  : They use a more predictable, time-based data transfer structure, ensuring that the data is delivered at exact intervals.\n </li>\n<li>\n<strong>\n   Data Size\n  </strong>\n  : Often involves data that must be delivered in a steady stream, such as audio or video.\n </li>\n<li>\n<strong>\n   Speed\n  </strong>\n  : Requires a constant, reliable data rate to ensure smooth data flow.\n </li>\n<li>\n<strong>\n   Error Handling\n  </strong>\n  : Errors are detected but are often corrected by compensating with slight data omissions or adjustments.\n </li>\n</ul>\n<p>\n<strong>\n  More about Time-Critical Transfers\n </strong>\n<br/>\n Time-sensitive transfers, like isochronous, require special attention to ensure data arrives on time.\n</p>\n<ul>\n<li>\n<strong>\n   Bus Bandwidth\n  </strong>\n  : The total available bandwidth on the USB bus can limit the number of isochronous transfers that can be handled simultaneously.\n </li>\n<li>\n<strong>\n   Device Capabilities\n  </strong>\n  : Devices must be capable of handling continuous data streams and meeting time requirements for successful isochronous transfers.\n </li>\n<li>\n<strong>\n   Host Capabilities\n  </strong>\n  : The host controller must support the timing and bandwidth needs of time-critical transfers.\n </li>\n<li>\n<strong>\n   Host Latencies\n  </strong>\n  : Low latency on the host side is necessary to avoid delays in transferring time-critical data.\n </li>\n</ul>\n<h3>\n Enumeration: How the Host Learns about Devices\n</h3>\n<p>\n<strong>\n  The Process\n </strong>\n<br/>\n When a device is connected to the USB, the host must enumerate it\u2014detect and configure it\u2014before it can be used. This process involves identifying the device and its capabilities.\n</p>\n<p>\n<strong>\n  Enumeration Steps\n </strong>\n</p>\n<ol>\n<li>\n<strong>\n   Device Connection\n  </strong>\n  : The device is physically connected to the USB port.\n </li>\n<li>\n<strong>\n   Device Identification\n  </strong>\n  : The host sends a request to the device to identify itself.\n </li>\n<li>\n<strong>\n   Configuration\n  </strong>\n  : The device sends back descriptors that describe its capabilities, power needs, and communication protocols.\n </li>\n<li>\n<strong>\n   Ready for Use\n  </strong>\n  : Once configuration is complete, the device is ready for communication.\n </li>\n</ol>\n<p>\n<strong>\n  Enumerating a Hub\n </strong>\n<br/>\n If the device is a hub, the enumeration process includes detecting the hub's presence and its connected devices, then enumerating each device attached to the hub in turn.\n</p>\n<p>\n<strong>\n  Device Removal\n </strong>\n<br/>\n When a device is removed, the host must recognize the disconnection and ensure that all resources allocated to the device are released.\n</p>\n<p>\n<strong>\n  Tips for Successful Enumeration\n </strong>\n<br/>\n Ensure proper timing, check that the device is properly powered, and handle retries in case of failed attempts. Devices should provide clear, compliant descriptors for successful enumeration.\n</p>\n<h3>\n Descriptors\n</h3>\n<p>\n Descriptors are data structures that provide details about the device, its configurations, interfaces, and endpoints. These are essential for the host to understand how to interact with the device.\n</p>\n<p>\n<strong>\n  Types of Descriptors\n </strong>\n</p>\n<ul>\n<li>\n<strong>\n   Device Descriptor\n  </strong>\n  : Contains fundamental device information, including the USB version, device class, vendor ID, and product ID.\n </li>\n<li>\n<strong>\n   Device_qualifier Descriptor\n  </strong>\n  : Provides additional details about the device's capabilities, specifically when it supports multiple USB speeds (e.g., high-speed and full-speed).\n </li>\n<li>\n<strong>\n   Configuration Descriptor\n  </strong>\n  : Describes the device\u2019s power requirements, supported configurations, and the number of interfaces.\n </li>\n<li>\n<strong>\n   Other_speed_configuration Descriptor\n  </strong>\n  : Used for dual-speed devices to indicate configuration details for other speeds.\n </li>\n<li>\n<strong>\n   Interface Association Descriptor\n  </strong>\n  : Associates multiple interfaces with the same functional unit, often used for multi-functional devices like printers.\n </li>\n<li>\n<strong>\n   Interface Descriptor\n  </strong>\n  : Describes the specific functions or capabilities of each interface in a device.\n </li>\n<li>\n<strong>\n   Endpoint Descriptor\n  </strong>\n  : Details the characteristics of a device\u2019s endpoints, like direction, type, and size.\n </li>\n<li>\n<strong>\n   String Descriptor\n  </strong>\n  : Contains human-readable strings that describe the device or its features.\n </li>\n<li>\n<strong>\n   Other Standard Descriptors\n  </strong>\n  : Additional descriptors that provide further specifications for unique device types.\n </li>\n<li>\n<strong>\n   Microsoft OS Descriptor\n  </strong>\n  : Used for devices that require special drivers on Windows systems.\n </li>\n</ul>\n<p>\n<strong>\n  Descriptors in 2.0-Compliant Devices\n </strong>\n<br/>\n USB 2.0 devices have specific descriptors that help the host identify them and ensure compatibility. These descriptors also provide information on the device\u2019s speed capabilities.\n</p>\n<p>\n<strong>\n  Making 1.x Descriptors 2.0-Compliant\n </strong>\n<br/>\n To make USB 1.x descriptors compliant with 2.0, the device firmware and descriptors need to be updated to reflect the new features and capabilities of USB 2.0.\n</p>\n<p>\n<strong>\n  Detecting the Speed of a Dual-Speed Device\n </strong>\n<br/>\n A device that supports both high-speed and full-speed modes must communicate its capabilities during enumeration so the host can select the appropriate speed for data transfers. The device\u2019s\n <strong>\n  Device_qualifier Descriptor\n </strong>\n is used to detect this speed capability.\n</p>\n"}, "Page 8": {"response": "<h3>\n Control Transfers and Chip Choices for USB Devices\n</h3>\n<h4>\n<strong>\n  Control Transfers: Structured Requests for Critical Data\n </strong>\n</h4>\n<p>\n<strong>\n  Elements of a Control Transfer\n </strong>\n<br/>\n Control transfers are crucial for exchanging configuration and command data between the host and the device. They follow a structured three-stage process: Setup, Data, and Status.\n</p>\n<ul>\n<li>\n<strong>\n   Setup Stage\n  </strong>\n  : This is where the host sends a request to the device. It contains information about the type of operation, the target endpoint, and parameters for the transfer.\n </li>\n<li>\n<strong>\n   Data Stage\n  </strong>\n  : This stage occurs if there is data to transfer. Depending on the request, this could involve sending data to the device or receiving data from the device.\n </li>\n<li>\n<strong>\n   Status Stage\n  </strong>\n  : After the data exchange, the host confirms the success or failure of the transfer. The status stage ensures that both the host and device are synchronized.\n </li>\n</ul>\n<p>\n<strong>\n  Handling Errors\n </strong>\n<br/>\n Errors in control transfers are handled through retries and status updates. If something goes wrong in the data transfer, the host may reattempt the transfer or handle the error according to predefined rules.\n</p>\n<p>\n<strong>\n  Device Firmware\n </strong>\n<br/>\n Device firmware plays a vital role in processing control transfer requests. It defines how the device responds to setup requests and handles data and status stages efficiently.\n</p>\n<h4>\n<strong>\n  The Requests\n </strong>\n</h4>\n<p>\n Control transfers involve specific requests for device management. These requests allow the host to configure and control the device\u2019s operation. Each request is defined by a unique code.\n</p>\n<ul>\n<li>\n<strong>\n   Get_Status\n  </strong>\n  : This request retrieves the current status of the device or interface.\n </li>\n<li>\n<strong>\n   Clear_Feature\n  </strong>\n  : Clears a specific feature, like disabling a feature on the device.\n </li>\n<li>\n<strong>\n   Set_Feature\n  </strong>\n  : Enables a specific feature on the device, such as setting a device-specific function.\n </li>\n<li>\n<strong>\n   Set_Address\n  </strong>\n  : Changes the address of a USB device. This is typically done during enumeration.\n </li>\n<li>\n<strong>\n   Get_Descriptor\n  </strong>\n  : Requests a descriptor, which provides details about the device, configurations, or interfaces.\n </li>\n<li>\n<strong>\n   Set_Descriptor\n  </strong>\n  : Used by the host to set specific device descriptors.\n </li>\n<li>\n<strong>\n   Get_Configuration\n  </strong>\n  : Retrieves the current configuration settings of the device.\n </li>\n<li>\n<strong>\n   Set_Configuration\n  </strong>\n  : Configures the device with a specific configuration value.\n </li>\n<li>\n<strong>\n   Get_Interface\n  </strong>\n  : Retrieves the current interface settings of the device.\n </li>\n<li>\n<strong>\n   Set_Interface\n  </strong>\n  : Modifies the interface settings of the device.\n </li>\n<li>\n<strong>\n   Synch_Frame\n  </strong>\n  : Used in isochronous transfers to synchronize the data exchange with time-sensitive operations.\n </li>\n</ul>\n<p>\n<strong>\n  Other Control Requests\n </strong>\n</p>\n<ul>\n<li>\n<strong>\n   Class-specific Requests\n  </strong>\n  : These are requests tailored for a particular device class, such as audio or HID devices, and are defined by the USB class specifications.\n </li>\n<li>\n<strong>\n   Vendor-specific Requests\n  </strong>\n  : These requests allow device manufacturers to define custom functionality not covered by standard USB protocols.\n </li>\n</ul>\n<h3>\n Chip Choices for USB Devices\n</h3>\n<h4>\n<strong>\n  Components of a USB Device\n </strong>\n</h4>\n<p>\n A typical USB device consists of several components that work together to enable communication and functionality.\n</p>\n<p>\n<strong>\n  The USB Controller\n </strong>\n<br/>\n The USB controller is the core component that manages the communication between the device and the USB bus. It handles data transfer, device enumeration, and control flow.\n</p>\n<p>\n<strong>\n  Other Device Components\n </strong>\n<br/>\n In addition to the controller, devices may contain other essential components like memory, power management units, and interfaces for connecting to external systems or sensors.\n</p>\n<h4>\n<strong>\n  Simplifying Device Development\n </strong>\n</h4>\n<p>\n To streamline the development of USB devices, it's important to understand the specific device requirements, available chips, and their documentation. Choosing the right chips and components will help simplify the design and reduce development time.\n</p>\n<h4>\n<strong>\n  Device Requirements\n </strong>\n</h4>\n<p>\n Device requirements include understanding the USB standard (e.g., USB 2.0 or 3.0) and selecting chips that support the necessary transfer speeds, power management, and interface capabilities. Documentation from chip manufacturers is crucial for ensuring proper integration into the device design.\n</p>\n<h4>\n<strong>\n  Chip Documentation\n </strong>\n</h4>\n<p>\n Comprehensive documentation, including datasheets, reference manuals, and development guides, is essential when selecting chips. This documentation outlines how to configure and use the chip effectively within a USB device.\n</p>\n<h4>\n<strong>\n  Driver Choices\n </strong>\n</h4>\n<p>\n Choosing the appropriate drivers is crucial for enabling communication between the host and the device. Some chips require specific drivers, while others may work with standard USB drivers available in the operating system.\n</p>\n<h4>\n<strong>\n  Debugging Tools\n </strong>\n</h4>\n<p>\n Using debugging tools such as USB protocol analyzers and logic analyzers can help track down issues during the development process. These tools allow developers to monitor the data flow and troubleshoot any issues related to USB communication.\n</p>\n<h3>\n<strong>\n  Specific USB Controllers and Chips\n </strong>\n</h3>\n<p>\n Different manufacturers offer USB controllers designed for various applications. Here are some popular chip choices:\n</p>\n<ul>\n<li>\n<strong>\n   Controllers with Embedded CPUs\n  </strong>\n  : Some USB controllers come with embedded CPUs, simplifying the design by integrating both the controller and processing unit into a single chip.\n </li>\n<li>\n<strong>\n   Microchip PIC18F4550\n  </strong>\n  : This is a popular microcontroller that supports USB 2.0 full-speed communication and is widely used in embedded systems.\n </li>\n<li>\n<strong>\n   Cypress EZ-USB\n  </strong>\n  : Known for its flexibility and ease of integration, the EZ-USB family is used in a variety of USB applications, from simple devices to more complex ones requiring high-speed data transfer.\n </li>\n<li>\n<strong>\n   Cypress enCoRe II\n  </strong>\n  : This chip is designed for low-power, cost-effective USB applications, supporting both USB 2.0 and various low-power modes.\n </li>\n<li>\n<strong>\n   Freescale MC68HC908JB16\n  </strong>\n  : A microcontroller with USB support, suitable for simple USB peripherals.\n </li>\n<li>\n<strong>\n   Freescale MCF5482 ColdFire\n  </strong>\n  : A more powerful option that combines a ColdFire processor with USB capabilities, ideal for complex USB-based systems.\n </li>\n</ul>\n"}, "Page 9": {"response": "<h3>\n USB Controllers, Device Classes, and Host Communication\n</h3>\n<h4>\n<strong>\n  Controllers that Interface to External CPUs\n </strong>\n</h4>\n<p>\n Certain USB controllers are designed to work alongside external CPUs, allowing for more flexible and scalable USB device development. These controllers manage USB communications while the external CPU handles the device logic.\n</p>\n<ul>\n<li>\n<strong>\n   National Semiconductor USBN9603\n  </strong>\n  : A USB controller that interfaces with external CPUs, offering a simple way to add USB functionality to embedded systems.\n </li>\n<li>\n<strong>\n   Philips Semiconductors ISP1181B\n  </strong>\n  : This chip provides USB 2.0 high-speed support, and it\u2019s designed to easily integrate with various processors and external CPUs.\n </li>\n<li>\n<strong>\n   Philips Semiconductors ISP1581\n  </strong>\n  : Similar to the ISP1181B, this USB controller offers robust support for high-speed data transfer and simplifies USB integration for external CPUs.\n </li>\n<li>\n<strong>\n   PLX Technology NET2272\n  </strong>\n  : A controller that offers USB 2.0 high-speed support, specifically for embedded applications requiring fast data transfer and external CPU interaction.\n </li>\n<li>\n<strong>\n   FTDI Chip FT232BM and FT245BM\n  </strong>\n  : These are popular USB-to-serial chips that allow devices to communicate with PCs or microcontrollers over a USB interface, commonly used for data communication or custom device projects.\n </li>\n</ul>\n<h3>\n<strong>\n  Device Classes\n </strong>\n</h3>\n<p>\n Device classes group USB devices with similar functions or features. They standardize communication between devices and the host, allowing for easier integration and support.\n</p>\n<h4>\n<strong>\n  About Classes\n </strong>\n</h4>\n<p>\n Device classes allow USB devices to present standardized functionality to the host system. When a device is connected, the host queries the device\u2019s class to determine the proper handling of data transfer, device configuration, and operation.\n</p>\n<h4>\n<strong>\n  Device Working Groups\n </strong>\n</h4>\n<p>\n Various working groups develop and maintain device class specifications to ensure standardization and interoperability between devices across different manufacturers.\n</p>\n<h4>\n<strong>\n  Elements of a Class Specification\n </strong>\n</h4>\n<p>\n A class specification outlines the required features, functions, and behavior of devices within that class. These documents define how devices should communicate with hosts, the type of descriptors they must provide, and the expected responses to certain control requests.\n</p>\n<h4>\n<strong>\n  Defined Classes\n </strong>\n</h4>\n<p>\n Here are some common USB device classes:\n</p>\n<ul>\n<li>\n<strong>\n   Audio\n  </strong>\n  : Devices such as speakers, microphones, and audio interfaces. They use specific protocols to manage sound data transfer and synchronization.\n </li>\n<li>\n<strong>\n   Chip/Smart Card Interface\n  </strong>\n  : Includes devices like smart card readers, where the device interfaces with chip-based security cards for authentication and data exchange.\n </li>\n<li>\n<strong>\n   Communication Devices: Modems and Networks\n  </strong>\n  : This class includes devices like USB modems and network adapters, which handle data communication between the host and networks.\n </li>\n<li>\n<strong>\n   Content Security\n  </strong>\n  : Used for protecting digital content, such as encryption and authentication devices that help prevent unauthorized access to content.\n </li>\n<li>\n<strong>\n   Device Firmware Upgrade\n  </strong>\n  : Devices in this class support firmware upgrades via USB to improve functionality or fix bugs.\n </li>\n<li>\n<strong>\n   Human Interface\n  </strong>\n  : Includes devices like keyboards, mice, touchscreens, and other user input devices. These devices interact with the user directly.\n </li>\n<li>\n<strong>\n   IrDA Bridge\n  </strong>\n  : Devices that support infrared communication, typically used for bridging between USB and infrared communication protocols.\n </li>\n<li>\n<strong>\n   Mass Storage\n  </strong>\n  : Includes USB flash drives, hard drives, and other storage devices that allow the host to read and write data to the device.\n </li>\n<li>\n<strong>\n   Printers\n  </strong>\n  : Devices in this class allow the host to send print jobs to a printer over USB.\n </li>\n<li>\n<strong>\n   Still Image Capture: Cameras and Scanners\n  </strong>\n  : Devices that capture or scan images, like digital cameras or document scanners, transferring image data to the host.\n </li>\n<li>\n<strong>\n   Test and Measurement\n  </strong>\n  : Devices that assist with testing or measuring electrical or physical properties, such as oscilloscopes or sensors.\n </li>\n<li>\n<strong>\n   Video\n  </strong>\n  : Devices like webcams and video capture cards that handle video data transmission to and from the host.\n </li>\n</ul>\n<h4>\n<strong>\n  Implementing Non-standard Functions\n </strong>\n</h4>\n<p>\n Some devices don\u2019t fit into a predefined USB class and require custom handling. These devices might implement non-standard functions or require specialized drivers.\n</p>\n<ul>\n<li>\n<strong>\n   Standard or Custom Driver?\n  </strong>\n  : Deciding whether to use a generic USB driver or develop a custom one for non-standard devices.\n </li>\n<li>\n<strong>\n   Converting from RS-232\n  </strong>\n  : Converting an RS-232 serial communication port to a USB interface using adapters or specialized chips.\n </li>\n<li>\n<strong>\n   Converting from the Parallel Port\n  </strong>\n  : Adapting legacy parallel port devices to USB for easier integration into modern systems.\n </li>\n<li>\n<strong>\n   PC-to-PC Communications\n  </strong>\n  : Enables direct USB communication between two computers for file sharing or network-like interactions.\n </li>\n<li>\n<strong>\n   Using a Generic Driver\n  </strong>\n  : For devices that don\u2019t require specialized functionality, a generic driver may be used to handle basic USB operations.\n </li>\n</ul>\n<h3>\n<strong>\n  How the Host Communicates\n </strong>\n</h3>\n<p>\n The host communicates with USB devices through a series of drivers, which abstract the complexity of USB interactions and ensure that higher-level applications can access the device's functionality.\n</p>\n<h4>\n<strong>\n  Device Driver Basics\n </strong>\n</h4>\n<p>\n Device drivers are software components that allow the operating system to interact with USB devices. The driver translates higher-level commands from applications into commands that the USB controller can understand.\n</p>\n<h4>\n<strong>\n  Insulating Applications from the Details\n </strong>\n</h4>\n<p>\n USB drivers help insulate applications from the details of the underlying hardware, so that the application doesn\u2019t need to know how the data is physically transferred over USB. This allows developers to focus on the functionality of their software, not the low-level communication protocols.\n</p>\n<h4>\n<strong>\n  Options for USB Devices\n </strong>\n</h4>\n<p>\n When designing or integrating USB devices, there are options for how they interact with the host. These options include the use of standard drivers, custom drivers, or direct communication through system APIs.\n</p>\n<h4>\n<strong>\n  User and Kernel Modes\n </strong>\n</h4>\n<p>\n USB communication typically operates in two modes: user mode and kernel mode.\n</p>\n<ul>\n<li>\n<strong>\n   User mode\n  </strong>\n  is where applications run and interact with USB devices through higher-level drivers.\n </li>\n<li>\n<strong>\n   Kernel mode\n  </strong>\n  is where the operating system kernel manages hardware resources, including USB drivers that communicate directly with USB devices.\n </li>\n</ul>\n<h4>\n<strong>\n  WDM Drivers\n </strong>\n</h4>\n<p>\n Windows Driver Model (WDM) drivers are a set of standard drivers for Windows systems that support a wide variety of devices, including USB peripherals.\n</p>\n<h4>\n<strong>\n  Layered Drivers\n </strong>\n</h4>\n<p>\n Layered drivers allow for modular driver development, where different layers of functionality are handled by different driver components. This allows flexibility in how drivers handle USB device communication.\n</p>\n<h4>\n<strong>\n  Communication Flow\n </strong>\n</h4>\n<p>\n Communication between the host and a USB device follows a structured flow, where data is exchanged based on requests, responses, and status checks. The flow ensures that data integrity and synchronization are maintained.\n</p>\n<h4>\n<strong>\n  More Examples\n </strong>\n</h4>\n<p>\n Real-world examples of USB communication flow include printing a document to a USB printer, transferring files to a USB storage device, or streaming audio from a USB microphone to a computer. These examples demonstrate the importance of both software drivers and hardware controllers in managing the flow of data.\n</p>\n"}, "Page 10": {"response": "<h3>\n Custom Driver Creation and Device Matching\n</h3>\n<h4>\n<strong>\n  Creating a Custom Driver\n </strong>\n</h4>\n<p>\n<strong>\n  Writing a Driver from Scratch\n </strong>\n<br/>\n Writing a custom USB driver involves creating software that enables communication between the host system and a specific device. This requires deep knowledge of the USB protocol, operating system APIs, and how devices communicate over USB. Drivers handle requests, manage data, and ensure the device works correctly with the host.\n</p>\n<p>\n<strong>\n  Using a Driver Toolkit\n </strong>\n<br/>\n Driver toolkits are libraries or frameworks that provide pre-built functions to help simplify the development of custom drivers. They offer tools for debugging, testing, and building drivers, reducing the need to code every aspect from scratch.\n</p>\n<p>\n<strong>\n  Using GUIDs (Globally Unique Identifiers)\n </strong>\n<br/>\n GUIDs are used to uniquely identify devices, device interfaces, and device setup requirements. They ensure that the correct driver is matched with the correct device, preventing conflicts or mismatches during installation and operation.\n</p>\n<ul>\n<li>\n<strong>\n   Device Setup GUIDs\n  </strong>\n  : These are used to associate a driver with the device setup process. The setup GUID specifies how a device should be configured when a driver is installed.\n </li>\n<li>\n<strong>\n   Device Interface GUIDs\n  </strong>\n  : These identify the type of device interface that the driver will use. They ensure that the driver can interact with the device using the appropriate communication protocols.\n </li>\n</ul>\n<h3>\n<strong>\n  Matching a Driver to a Device\n </strong>\n</h3>\n<h4>\n<strong>\n  Using the Device Manager\n </strong>\n</h4>\n<p>\n The Device Manager in Windows helps manage installed hardware and drivers. It allows users to see all connected devices and their associated drivers, as well as install, update, or troubleshoot drivers.\n</p>\n<p>\n<strong>\n  Viewing Devices\n </strong>\n<br/>\n In the Device Manager, users can view all recognized devices on the system. Each device is listed with its status, driver information, and properties.\n</p>\n<h4>\n<strong>\n  Property Pages and Registry Information\n </strong>\n</h4>\n<p>\n The Device Manager provides detailed property pages where users can view more information about each device. This includes configuration settings, driver details, and status.\n</p>\n<p>\n<strong>\n  Device Information in the Registry\n </strong>\n<br/>\n Windows stores information about connected devices and their drivers in the system registry. This includes keys that contain details about the hardware and driver configurations.\n</p>\n<ul>\n<li>\n<strong>\n   The Hardware Key\n  </strong>\n  : Contains information about the physical device and its properties.\n </li>\n<li>\n<strong>\n   The Class Key\n  </strong>\n  : Describes the class of the device, such as a mass storage device, printer, or audio device.\n </li>\n<li>\n<strong>\n   The Driver Key\n  </strong>\n  : Contains details about the driver used for the device, including its version and configuration.\n </li>\n<li>\n<strong>\n   The Service Key\n  </strong>\n  : Stores information about the services associated with the device, such as initialization routines and driver services.\n </li>\n</ul>\n<h4>\n<strong>\n  Inside INF Files\n </strong>\n</h4>\n<p>\n INF files are used for device driver installation. They contain instructions that tell the operating system how to install the driver, configure the device, and set up communication.\n</p>\n<ul>\n<li>\n<strong>\n   Syntax\n  </strong>\n  : INF files use a specific syntax for organizing data, including sections, commands, and values.\n </li>\n<li>\n<strong>\n   Sections\n  </strong>\n  : INF files are divided into sections that define different parts of the installation process, such as driver files, registry settings, and device setup.\n </li>\n<li>\n<strong>\n   Using Device Identification Strings\n  </strong>\n  : These strings are used to uniquely identify devices, allowing the operating system to match the device with the correct driver during installation.\n </li>\n</ul>\n<h4>\n<strong>\n  Finding a Match\n </strong>\n</h4>\n<p>\n Matching a driver to a device involves ensuring that the device's unique identification matches the identifiers in the INF file. The operating system compares the device's information with the setup instructions in the INF file to ensure compatibility.\n</p>\n<h4>\n<strong>\n  Do You Need to Provide an INF File?\n </strong>\n</h4>\n<p>\n INF files are generally required when a device driver is not included with the operating system. These files provide necessary information for the installation and configuration of the device driver. However, some devices may work with standard, pre-installed drivers without the need for an INF file.\n</p>\n<h4>\n<strong>\n  Tools and Diagnostic Aids\n </strong>\n</h4>\n<p>\n Tools like Device Manager, driver development kits, and debugging utilities help identify issues with device drivers. These tools allow for easier identification of mismatches, driver failures, or configuration issues during installation.\n</p>\n<h4>\n<strong>\n  Tips for Using INF Files\n </strong>\n</h4>\n<p>\n When working with INF files, it\u2019s essential to:\n</p>\n<ul>\n<li>\n  Ensure correct syntax and section formatting.\n </li>\n<li>\n  Include accurate device identification strings.\n </li>\n<li>\n  Test the INF file on different systems to verify compatibility.\n </li>\n</ul>\n<h4>\n<strong>\n  What the User Sees\n </strong>\n</h4>\n<p>\n The user interface typically displays device status and driver information through the Device Manager. Users can view whether a device is functioning correctly or if there are errors related to the driver.\n</p>\n<h3>\n<strong>\n  Detecting Devices\n </strong>\n</h3>\n<h4>\n<strong>\n  A Brief Guide to Calling API Functions\n </strong>\n</h4>\n<p>\n To detect and interact with USB devices programmatically, developers can use various API functions. These functions provide a way for applications to query, identify, and interact with USB devices.\n</p>\n<p>\n<strong>\n  Managed and Unmanaged Code\n </strong>\n<br/>\n Managed code refers to software written using higher-level languages (e.g., C#), while unmanaged code is written in lower-level languages (e.g., C or C++). Both types can interact with the USB system, but the APIs may differ.\n</p>\n<p>\n<strong>\n  Documentation\n </strong>\n<br/>\n Thorough documentation is crucial for understanding how to use these API functions. It provides guidelines, usage examples, and parameters for correctly implementing device detection and communication.\n</p>\n<h4>\n<strong>\n  Using Visual C++ .NET\n </strong>\n</h4>\n<p>\n Visual C++ .NET is a powerful development environment for writing unmanaged code, and it includes support for working with USB devices via Windows API functions.\n</p>\n<h4>\n<strong>\n  Using Visual Basic .NET\n </strong>\n</h4>\n<p>\n Visual Basic .NET (VB.NET) is a higher-level language that simplifies interaction with USB devices by abstracting lower-level details. Developers can use built-in functions and libraries to detect and communicate with devices.\n</p>\n<h4>\n<strong>\n  Finding Your Device\n </strong>\n</h4>\n<p>\n To detect a specific device, the application must search through available device information using functions that query connected devices. Each device is uniquely identified, allowing applications to pinpoint the desired device.\n</p>\n<h4>\n<strong>\n  Obtaining the Device Interface GUID\n </strong>\n</h4>\n<p>\n The device interface GUID is required to correctly identify the device and request communication with it. This GUID helps the system associate the device with its appropriate interface.\n</p>\n<h4>\n<strong>\n  Requesting a Pointer to a Device Information Set\n </strong>\n</h4>\n<p>\n This function returns a pointer to a set of information about all devices currently connected to the system. It\u2019s used to retrieve details about available devices.\n</p>\n<h4>\n<strong>\n  Identifying a Device Interface\n </strong>\n</h4>\n<p>\n Identifying a device interface involves checking the interface GUID to determine which interface is associated with the device, ensuring that the correct driver and application are used for communication.\n</p>\n<h4>\n<strong>\n  Requesting a Structure Containing the Device Path Name\n </strong>\n</h4>\n<p>\n The device path name is a unique identifier for the device\u2019s location in the system. This path name is used for communication between the host and the device.\n</p>\n<h4>\n<strong>\n  Extracting the Device Path Name\n </strong>\n</h4>\n<p>\n Once the device path name is obtained, it can be used to establish communication with the device and begin data exchange.\n</p>\n<h4>\n<strong>\n  Closing Communications\n </strong>\n</h4>\n<p>\n After the device interaction is complete, it\u2019s important to properly close the communication channel to free up system resources and ensure the device is safely disconnected.\n</p>\n"}, "Page 11": {"response": "<h3>\n Device Handle Management, Notifications, and Human Interface Devices (HID)\n</h3>\n<h4>\n<strong>\n  Obtaining and Managing a Handle\n </strong>\n</h4>\n<p>\n<strong>\n  Requesting a Communications Handle\n </strong>\n<br/>\n In order to communicate with a USB device, a handle is required. This handle acts as an identifier for a specific communication channel between the host and the device. It is obtained using the appropriate system API, which opens a connection to the device.\n</p>\n<p>\n<strong>\n  Closing the Handle\n </strong>\n<br/>\n Once the communication with the device is finished, it is important to close the handle. This releases the resources tied to the communication channel, ensuring that the system can safely manage connections to other devices.\n</p>\n<h4>\n<strong>\n  Detecting Attachment and Removal of Devices\n </strong>\n</h4>\n<p>\n<strong>\n  About Device Notifications\n </strong>\n<br/>\n Device notifications allow the system to monitor changes in the USB device landscape, such as when a device is attached or removed. This ensures that the host system is always aware of the devices currently available.\n</p>\n<p>\n<strong>\n  Registering for Device Notifications\n </strong>\n<br/>\n To receive notifications about device changes, applications must register with the operating system. This registration process involves specifying which events (attachment, removal, etc.) the application wants to track.\n</p>\n<p>\n<strong>\n  Capturing Device Change Messages\n </strong>\n<br/>\n Once an application is registered, it can begin receiving device change messages. These messages inform the application about the status of connected devices, such as whether a device has been attached or removed.\n</p>\n<p>\n<strong>\n  Reading Device Change Messages\n </strong>\n<br/>\n Applications can process device change messages to determine the nature of the event. These messages contain information such as the device's unique identifier and the type of event (e.g., device plugged in, unplugged).\n</p>\n<p>\n<strong>\n  Retrieving the Device Path Name in the Message\n </strong>\n<br/>\n Device change messages contain the device path name, which uniquely identifies the device on the system. Applications can extract this path to perform further operations with the specific device.\n</p>\n<p>\n<strong>\n  Stopping Device Notifications\n </strong>\n<br/>\n Once device notifications are no longer needed, the application can unregister from the notification system. This stops the flow of device change messages, conserving system resources.\n</p>\n<hr/>\n<h3>\n<strong>\n  Human Interface Devices (HID)\n </strong>\n</h3>\n<h4>\n<strong>\n  What is a HID?\n </strong>\n</h4>\n<p>\n A Human Interface Device (HID) is a type of USB device designed for user interaction, such as keyboards, mice, and game controllers. HID devices follow specific communication protocols to enable seamless interaction with the host system.\n</p>\n<h4>\n<strong>\n  Hardware and Firmware Requirements\n </strong>\n</h4>\n<p>\n<strong>\n  Hardware Requirements\n </strong>\n<br/>\n HID devices must meet specific hardware standards that enable them to communicate using standard USB protocols. This includes implementing the HID interface and supporting necessary electrical signaling for USB communication.\n</p>\n<p>\n<strong>\n  Firmware Requirements\n </strong>\n<br/>\n The firmware in HID devices is responsible for managing communication between the device and the host. It defines how input data is collected, formatted, and sent to the host, often using reports that are transferred via USB.\n</p>\n<h4>\n<strong>\n  Identifying a Device as a HID\n </strong>\n</h4>\n<p>\n A device can be identified as a HID by its USB descriptors, which indicate its class and provide necessary information about its functionality. The HID class allows devices to report user input to the host in a standardized way.\n</p>\n<hr/>\n<h3>\n<strong>\n  The HID Interface\n </strong>\n</h3>\n<p>\n The HID interface defines how HID devices communicate with the host system. It includes a set of descriptors that describe the capabilities of the device and how it interacts with the host.\n</p>\n<h4>\n<strong>\n  HID Class Descriptor\n </strong>\n</h4>\n<p>\n The HID class descriptor provides information about the device's capabilities, such as the supported report formats and the communication protocols the device can use.\n</p>\n<h4>\n<strong>\n  Report Descriptors\n </strong>\n</h4>\n<p>\n Report descriptors define how data is formatted and sent from the device to the host. These descriptors specify the types of reports the device can send (e.g., keyboard input, mouse movements) and the layout of data within each report.\n</p>\n<hr/>\n<h3>\n<strong>\n  HID-Specific Requests\n </strong>\n</h3>\n<p>\n HID devices communicate with the host using control and interrupt transfers. These transfers are used to send and receive reports, set idle times, and manage protocol states.\n</p>\n<h4>\n<strong>\n  Common HID Requests:\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   Get_Report\n  </strong>\n  : This request is used to retrieve the report from the device, typically for reading user input like keystrokes or mouse movements.\n </li>\n<li>\n<strong>\n   Get_Idle\n  </strong>\n  : Used to get the idle time, which specifies how long the device can wait before sending a report.\n </li>\n<li>\n<strong>\n   Get_Protocol\n  </strong>\n  : Retrieves the current protocol mode used by the device (either boot or report protocol).\n </li>\n<li>\n<strong>\n   Set_Report\n  </strong>\n  : This sends a report to the device, often used to change settings or send commands.\n </li>\n<li>\n<strong>\n   Set_Idle\n  </strong>\n  : Sets the idle time for the device.\n </li>\n<li>\n<strong>\n   Set_Protocol\n  </strong>\n  : Changes the protocol mode of the device (e.g., switching between boot protocol and report protocol).\n </li>\n</ul>\n<hr/>\n<h3>\n<strong>\n  Transferring Data with HID Devices\n </strong>\n</h3>\n<h4>\n<strong>\n  Sending and Receiving Reports\n </strong>\n</h4>\n<p>\n HID devices transfer data through reports, which contain information like keystrokes, button presses, or other user input. These reports are sent using either control or interrupt transfers.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Sending Reports via Interrupt Transfers\n   </strong>\n<br/>\n   Interrupt transfers are used for periodic communication where timely data delivery is required. HID devices commonly use this method to send reports to the host, such as mouse movement or keyboard presses.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Receiving Reports via Interrupt Transfers\n   </strong>\n<br/>\n   The host can also receive reports from the HID device using interrupt transfers. This ensures that the host receives timely updates about user input.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Sending Reports via Control Transfers\n   </strong>\n<br/>\n   Control transfers are used for smaller, non-periodic data exchanges, such as configuring the device or sending specific control commands.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Receiving Reports via Control Transfers\n   </strong>\n<br/>\n   Control transfers can also be used for receiving smaller data sets from the HID device. This may include settings, status updates, or configuration data.\n  </p>\n</li>\n</ul>\n<hr/>\n<h3>\n<strong>\n  Human Interface Devices: Reports\n </strong>\n</h3>\n<h4>\n<strong>\n  Report Structure\n </strong>\n</h4>\n<p>\n The report structure defines how data is organized within the report. It typically includes input data such as button presses, keycodes, or other user interactions. The structure ensures that the host can interpret the data correctly.\n</p>\n<h4>\n<strong>\n  Using the HID Descriptor Tool\n </strong>\n</h4>\n<p>\n The HID descriptor tool helps developers view and analyze the report descriptors and other device descriptors. This tool simplifies the process of understanding how the HID device formats its data and communicates with the host.\n</p>\n<h4>\n<strong>\n  Control and Data Item Values\n </strong>\n</h4>\n<p>\n Control items define the settings and configurations for the HID device, while data items define the actual user input or device output. These items help structure the data that is transmitted in reports.\n</p>\n<h4>\n<strong>\n  Item Types\n </strong>\n</h4>\n<p>\n Report descriptors include different item types, such as input, output, and feature items, that determine how the data should be handled. These items specify whether the data represents user input, device settings, or other configurations.\n</p>\n"}, "Page 12": {"response": "<h3>\n Human Interface Devices (HID) - Advanced Concepts\n</h3>\n<h4>\n<strong>\n  Report Descriptors and Item Types\n </strong>\n</h4>\n<p>\n<strong>\n  Main Item Type\n </strong>\n<br/>\n The main item type in a report descriptor indicates the type of data being transmitted, such as input, output, or feature data. It helps categorize the report\u2019s contents and structure for proper interpretation by the host.\n</p>\n<p>\n<strong>\n  Input, Output, and Feature Items\n </strong>\n</p>\n<ul>\n<li>\n<strong>\n   Input Items\n  </strong>\n  : Represent data sent from the device to the host, such as user input (keystrokes, button presses).\n </li>\n<li>\n<strong>\n   Output Items\n  </strong>\n  : Represent data sent from the host to the device, like LED control or setting adjustments.\n </li>\n<li>\n<strong>\n   Feature Items\n  </strong>\n  : Represent settings or configurations that can be queried or set, like device calibration or mode settings.\n </li>\n</ul>\n<p>\n<strong>\n  Collection and End Collection Items\n </strong>\n</p>\n<ul>\n<li>\n<strong>\n   Collection Items\n  </strong>\n  : Group related data items (e.g., grouping buttons on a keyboard) into collections for more organized communication.\n </li>\n<li>\n<strong>\n   End Collection Items\n  </strong>\n  : Mark the end of a data collection and indicate the end of a logical grouping.\n </li>\n</ul>\n<h4>\n<strong>\n  Global Item Type\n </strong>\n</h4>\n<p>\n The global item type defines the scope of the data. It specifies how the data in the report is treated across multiple items or collections. For example, the global items can specify the units of measurement or the size of data fields.\n</p>\n<p>\n<strong>\n  Identifying the Report\n </strong>\n<br/>\n Reports are identified by specific descriptors, which define the report\u2019s structure and contents. The identification process ensures the correct data format is used when communicating with the device.\n</p>\n<p>\n<strong>\n  Describing the Data\u2019s Use\n </strong>\n<br/>\n Descriptors describe how each piece of data in a report should be interpreted or used. This includes specifying whether the data is for user input, device configuration, or other purposes.\n</p>\n<p>\n<strong>\n  Converting Units\n </strong>\n<br/>\n Some data may require unit conversions, such as translating the raw data into meaningful measurements (e.g., converting raw sensor data into a specific unit of measure like degrees or pressure).\n</p>\n<p>\n<strong>\n  Converting Raw Data\n </strong>\n<br/>\n Raw data collected from a device needs to be processed and converted into a usable format. This includes transforming raw bitwise information into human-readable or device-understandable values.\n</p>\n<p>\n<strong>\n  Describing the Data\u2019s Size and Format\n </strong>\n<br/>\n The size and format of each data item in a report need to be defined so that the host can correctly interpret the incoming data. This ensures compatibility between different HID devices.\n</p>\n<p>\n<strong>\n  Saving and Restoring Global Items\n </strong>\n<br/>\n Global items, like units or data size, are saved and restored to maintain consistent data handling across collections or reports. This ensures data integrity when multiple reports are received.\n</p>\n<h4>\n<strong>\n  Local Item Type\n </strong>\n</h4>\n<p>\n Local item types provide additional details about individual data items within a collection. These items typically specify parameters related to the physical or functional characteristics of the device, such as button states or axis values.\n</p>\n<p>\n<strong>\n  Physical Descriptors\n </strong>\n<br/>\n Physical descriptors define how the device interacts physically with the user, such as pressure levels, button press intensity, or sensor data.\n</p>\n<p>\n<strong>\n  Padding\n </strong>\n<br/>\n Padding is used to ensure that data fields are correctly aligned in memory or in the report format. This ensures that the data structure adheres to specific memory boundaries or communication protocols.\n</p>\n<hr/>\n<h3>\n<strong>\n  Human Interface Devices: Host Application\n </strong>\n</h3>\n<h4>\n<strong>\n  HID API Functions\n </strong>\n</h4>\n<p>\n HID APIs provide a set of functions that allow developers to interact with HID devices. These functions handle tasks like requesting information, sending and receiving reports, and managing HID communications.\n</p>\n<p>\n<strong>\n  Requesting Information about the HID\n </strong>\n<br/>\n Functions allow applications to query specific details about the HID device, such as its capabilities, vendor ID, and product ID. This is critical for identifying the device and managing communication.\n</p>\n<p>\n<strong>\n  Sending and Receiving Reports\n </strong>\n<br/>\n HID communication revolves around sending and receiving reports. These reports contain data like user input or device states.\n</p>\n<p>\n<strong>\n  Providing and Using Report Data\n </strong>\n<br/>\n Reports are structured data sent to and from the device. Applications can either send data to the device (output reports) or read data from the device (input reports) to process user input or control the device.\n</p>\n<p>\n<strong>\n  Managing HID Communications\n </strong>\n<br/>\n Managing HID communications involves opening a communication channel with the device, sending and receiving reports, and closing the communication once the data exchange is complete.\n</p>\n<h4>\n<strong>\n  Identifying a Device\n </strong>\n</h4>\n<p>\n To correctly communicate with a device, it must be uniquely identified. This is done through querying the vendor ID, product ID, and other identifiers stored in the device descriptors.\n</p>\n<p>\n<strong>\n  Reading the Vendor and Product IDs\n </strong>\n<br/>\n The vendor and product IDs are unique identifiers that allow the host to differentiate between devices, ensuring the correct driver and configuration are used.\n</p>\n<p>\n<strong>\n  Getting a Pointer to a Buffer with Device Capabilities\n </strong>\n<br/>\n This function retrieves the capabilities of the device, such as the supported report formats, the number of buttons or controls, and other important parameters that help the host application interact with the device.\n</p>\n<p>\n<strong>\n  Getting the Device\u2019s Capabilities\n </strong>\n<br/>\n Applications can query the device\u2019s capabilities to determine its features, including input types, output controls, and supported report formats.\n</p>\n<p>\n<strong>\n  Getting the Capabilities of the Buttons and Values\n </strong>\n<br/>\n HID devices often have buttons or other controls that can send input to the host. This function retrieves details about the buttons or controls, such as their states or associated values.\n</p>\n<h4>\n<strong>\n  Sending and Receiving Reports\n </strong>\n</h4>\n<p>\n HID devices communicate using reports, which are data structures that represent information like user input or device status.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Sending an Output Report to the Device\n   </strong>\n<br/>\n   Output reports are used to send data from the host to the device, such as controlling LEDs, adjusting settings, or other device-specific functions.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Reading an Input Report from the Device\n   </strong>\n<br/>\n   Input reports allow the host to receive data from the device, such as keypresses, button states, or sensor readings.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Writing a Feature Report to the Device\n   </strong>\n<br/>\n   Feature reports allow the host to configure the device, such as setting operational modes, calibration settings, or other device-specific parameters.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Reading a Feature Report from a Device\n   </strong>\n<br/>\n   Feature reports are also used to retrieve configuration or status data from the device, such as getting the device\u2019s current mode or settings.\n  </p>\n</li>\n</ul>\n<p>\n<strong>\n  Closing Communications\n </strong>\n<br/>\n After completing communication, it is essential to close the connection to the HID device. This frees system resources and ensures that the device is safely disconnected.\n</p>\n<hr/>\n<h3>\n<strong>\n  Bulk Transfers for Any CPU\n </strong>\n</h3>\n<h4>\n<strong>\n  Two Projects\n </strong>\n</h4>\n<p>\n Two sample projects can help demonstrate bulk transfers: one that uses an asynchronous serial interface and another that utilizes a parallel interface. Both showcase the principles of bulk data transfer over USB.\n</p>\n<p>\n<strong>\n  Asynchronous Serial Interface\n </strong>\n<br/>\n The asynchronous serial interface involves sending data without synchronization signals. It is suitable for sending large amounts of data over USB, though it may require specific handling to ensure data integrity.\n</p>\n<p>\n<strong>\n  Parallel Interface\n </strong>\n<br/>\n Parallel interfaces allow for simultaneous data transmission across multiple channels. It can provide faster transfer speeds compared to serial interfaces but requires more system resources.\n</p>\n<h4>\n<strong>\n  Host Programming\n </strong>\n</h4>\n<p>\n Host programming involves writing software to interact with the USB device. This includes managing communication protocols, sending and receiving data, and handling errors.\n</p>\n<p>\n<strong>\n  Using the D2XX Direct Driver\n </strong>\n<br/>\n The D2XX Direct Driver allows for direct communication with USB devices without needing to go through the Windows driver stack. This can provide faster and more efficient data transfer for certain applications.\n</p>\n<p>\n<strong>\n  Selecting a Driver\n </strong>\n<br/>\n Choosing the right driver is critical for ensuring compatibility with the USB device. The driver must support the device's communication protocols and functionality.\n</p>\n"}, "Page 13": {"response": "<h3>\n USB Performance, Power Management, and Debugging\n</h3>\n<h4>\n<strong>\n  Performance Tips\n </strong>\n</h4>\n<p>\n<strong>\n  Speed Considerations\n </strong>\n<br/>\n When working with USB devices, speed is crucial. The performance of the system can be affected by factors like bus congestion, device capabilities, and the type of data being transferred. To maximize performance, consider the bus speed and the device\u2019s ability to handle high-speed data.\n</p>\n<p>\n<strong>\n  Minimizing Latency\n </strong>\n<br/>\n Latency refers to the delay between sending a command and receiving a response. To minimize latency, ensure the system is optimized by reducing unnecessary processing and utilizing high-priority data channels when possible. Proper driver implementation also helps in reducing delays.\n</p>\n<p>\n<strong>\n  Preventing Lost Data\n </strong>\n<br/>\n Lost data can occur when the device or bus cannot handle the rate of data transfer. To prevent this, manage the flow of data carefully and ensure that devices have enough bandwidth. Buffering and error checking mechanisms also help prevent data loss.\n</p>\n<h4>\n<strong>\n  EEPROM Programming\n </strong>\n</h4>\n<p>\n<strong>\n  EEPROM Data\n </strong>\n<br/>\n EEPROM (Electrically Erasable Programmable Read-Only Memory) is commonly used in USB devices to store configuration or persistent data. Data stored in EEPROM can be modified by the device during normal operation.\n</p>\n<p>\n<strong>\n  Editing the Data\n </strong>\n<br/>\n To edit EEPROM data, developers can send specific commands to the device that allows for data modification. The process typically involves addressing specific memory locations within the EEPROM and updating values based on the device's requirements.\n</p>\n<hr/>\n<h3>\n<strong>\n  USB Hubs: Connecting Devices and the Host\n </strong>\n</h3>\n<h4>\n<strong>\n  Hub Basics\n </strong>\n</h4>\n<p>\n USB hubs allow multiple devices to connect to a single USB port. They serve as intermediaries that route data between devices and the host computer, ensuring that multiple devices can operate simultaneously without overloading the host.\n</p>\n<p>\n<strong>\n  The Hub Repeater\n </strong>\n<br/>\n A hub repeater amplifies the USB signal, extending the distance over which the USB signal can travel. This is essential when connecting devices over long distances.\n</p>\n<p>\n<strong>\n  The Transaction Translator\n </strong>\n<br/>\n The transaction translator in a hub helps convert data between different speeds on the USB bus (for example, translating between full-speed and low-speed devices).\n</p>\n<p>\n<strong>\n  The Hub Controller\n </strong>\n<br/>\n The hub controller manages all communications between the host and the devices connected to the hub. It handles tasks such as routing data, managing power, and controlling device connections.\n</p>\n<h4>\n<strong>\n  Speed Considerations in Hubs\n </strong>\n</h4>\n<p>\n USB hubs operate at different speeds, depending on the type of connected devices. Hubs can handle multiple speeds (low-speed, full-speed, and high-speed) but may limit performance if too many high-speed devices are connected to a single hub.\n</p>\n<h4>\n<strong>\n  Maintaining an Idle Bus\n </strong>\n</h4>\n<p>\n When the USB bus is not in use, it must be kept in an idle state to conserve power and ensure smooth operation when devices are ready to communicate.\n</p>\n<h4>\n<strong>\n  How Many Hubs in Series?\n </strong>\n</h4>\n<p>\n There is a limit to how many hubs can be connected in series. The USB specification limits the total number of hubs in a series to 5, including the root hub. Exceeding this limit can lead to instability and performance degradation.\n</p>\n<h4>\n<strong>\n  The Hub Class\n </strong>\n</h4>\n<p>\n The hub class defines the specifications and protocols for USB hubs. It includes details like port management, power distribution, and the transaction translator\u2019s role.\n</p>\n<h4>\n<strong>\n  Hub Descriptors\n </strong>\n</h4>\n<p>\n Hub descriptors contain information about the capabilities of a hub, such as the number of ports it supports and the type of speeds it can handle. These descriptors help the host understand how to communicate with the hub.\n</p>\n<h4>\n<strong>\n  Hub-Class Requests\n </strong>\n</h4>\n<p>\n Hub-class requests allow the host to query and control hub functionality. These requests include operations like resetting hubs, configuring ports, or checking hub status.\n</p>\n<h4>\n<strong>\n  Port Indicators\n </strong>\n</h4>\n<p>\n Port indicators are used to show the status of individual ports on a hub, including whether a device is connected, whether it is powered, and whether it is active.\n</p>\n<hr/>\n<h3>\n<strong>\n  Managing Power in USB Devices\n </strong>\n</h3>\n<h4>\n<strong>\n  Powering Options\n </strong>\n</h4>\n<p>\n USB devices can be powered in a few different ways: through the bus (bus-powered) or by an external power supply (self-powered). Bus-powered devices rely on the USB port for power, while self-powered devices have their own power source.\n</p>\n<p>\n<strong>\n  Voltages\n </strong>\n<br/>\n USB typically operates at 5V, but devices may require different voltages for specific operations. USB provides 5V but can negotiate lower or higher voltages in specialized cases.\n</p>\n<p>\n<strong>\n  Which Peripherals Can Use Bus Power?\n </strong>\n<br/>\n Bus-powered peripherals are generally limited in their power requirements due to the current available from the USB port. Devices like mice and keyboards typically use bus power, but high-power devices like external hard drives often require an external power source.\n</p>\n<h4>\n<strong>\n  Power Needs\n </strong>\n</h4>\n<p>\n Devices have varying power needs based on their functionality. Some devices can run entirely off the USB bus, while others may require more power than what the bus can supply. Devices need to inform the host of their power needs during the enumeration process.\n</p>\n<h4>\n<strong>\n  Informing the Host\n </strong>\n</h4>\n<p>\n Devices inform the host about their power requirements via descriptors, which specify whether they are bus-powered or self-powered and how much current they draw.\n</p>\n<h4>\n<strong>\n  Hub Power\n </strong>\n</h4>\n<p>\n Hubs themselves also require power, and the amount of power they need depends on the number of connected devices. Hubs often feature an external power source to ensure adequate power distribution.\n</p>\n<h4>\n<strong>\n  Power Sources\n </strong>\n</h4>\n<p>\n USB power sources can either come from the host system or from external adapters. The power provided to a device must meet its operational requirements without overloading the USB port or hub.\n</p>\n<h4>\n<strong>\n  Over-Current Protection\n </strong>\n</h4>\n<p>\n Over-current protection ensures that devices do not draw more current than the system can handle. This is vital for preventing damage to the USB port, hub, or connected devices.\n</p>\n<h4>\n<strong>\n  Power Switching\n </strong>\n</h4>\n<p>\n Power switching is the ability to dynamically switch between different power sources or power-saving modes. This is crucial for managing power consumption, especially in portable devices.\n</p>\n<h4>\n<strong>\n  Saving Power\n </strong>\n</h4>\n<p>\n To extend battery life or reduce energy consumption, devices can enter power-saving states when not in active use. This includes using suspend and resume modes that allow devices to conserve power when idle.\n</p>\n<h4>\n<strong>\n  Global and Selective Suspends\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   Global Suspend\n  </strong>\n  : Suspends all devices on the USB bus.\n </li>\n<li>\n<strong>\n   Selective Suspend\n  </strong>\n  : Allows individual devices to enter low-power states while others remain active.\n </li>\n</ul>\n<h4>\n<strong>\n  Current Limits for Suspended Devices\n </strong>\n</h4>\n<p>\n When devices enter suspend mode, the amount of current they can draw is limited. This ensures that the bus remains stable while conserving energy.\n</p>\n<h4>\n<strong>\n  Resuming Communications\n </strong>\n</h4>\n<p>\n Devices in suspend mode can be resumed by the host when communication is needed. This allows devices to re-enter full operation as soon as they are required.\n</p>\n<h4>\n<strong>\n  Power Management under Windows\n </strong>\n</h4>\n<p>\n In Windows, USB devices can be managed for power efficiency using the operating system's power management features. This ensures devices are not consuming unnecessary power while idle.\n</p>\n<hr/>\n<h3>\n<strong>\n  Testing and Debugging USB Devices\n </strong>\n</h3>\n<h4>\n<strong>\n  Tools\n </strong>\n</h4>\n<p>\n Effective testing and debugging of USB devices require specialized tools to monitor and analyze USB traffic and ensure that devices are functioning as expected.\n</p>\n<h4>\n<strong>\n  Hardware Protocol Analyzers\n </strong>\n</h4>\n<p>\n Hardware protocol analyzers are physical devices used to monitor USB signals and capture data traffic between the host and USB devices. These tools allow for detailed examination of USB communication, helping identify errors or performance issues.\n</p>\n<h4>\n<strong>\n  Software Protocol Analyzers\n </strong>\n</h4>\n<p>\n Software protocol analyzers run on a computer and capture USB traffic for analysis. These tools provide a detailed breakdown of data exchanges, making them useful for debugging and optimizing USB communication.\n</p>\n<h4>\n<strong>\n  Traffic Generators\n </strong>\n</h4>\n<p>\n Traffic generators simulate USB data traffic to test the performance and robustness of devices and systems. These tools are used to stress-test devices and ensure they can handle high volumes of data transfer.\n</p>\n"}, "Page 14": {"response": "<h3>\n USB Signals, Testing, and Electrical Interface\n</h3>\n<h4>\n<strong>\n  Testing USB Devices\n </strong>\n</h4>\n<p>\n<strong>\n  Testing\n </strong>\n<br/>\n Testing USB devices is crucial for ensuring they function correctly. This includes compliance testing, where devices are checked to meet USB specifications, and WHQL (Windows Hardware Quality Labs) testing, which verifies that USB devices work with Windows operating systems.\n</p>\n<p>\n<strong>\n  Compliance Testing\n </strong>\n<br/>\n Compliance testing checks if a USB device conforms to the USB standard. This ensures that devices interact correctly with other USB components and systems, preventing interoperability issues.\n</p>\n<p>\n<strong>\n  WHQL Testing\n </strong>\n<br/>\n WHQL testing is a process where a USB device is tested and certified by Microsoft to ensure it works smoothly with Windows. Passing WHQL tests means the device meets Microsoft's quality and compatibility requirements for use with their operating systems.\n</p>\n<hr/>\n<h3>\n<strong>\n  Signals and Encoding in USB Communication\n </strong>\n</h3>\n<h4>\n<strong>\n  Bus States\n </strong>\n</h4>\n<p>\n<strong>\n  Low-Speed and Full-Speed Bus States\n </strong>\n<br/>\n USB communication involves different bus states. For low-speed and full-speed devices, the bus is divided into several states, such as \"idle,\" \"reset,\" and \"suspend.\" These states define the device's activity and power consumption.\n</p>\n<p>\n<strong>\n  High-Speed Bus States\n </strong>\n<br/>\n High-speed USB communication uses a more advanced set of bus states to handle faster data rates. It includes states like \"se0\" (Single-Ended Zero), indicating a low-speed signal, and \"j-state,\" which signals the beginning of a packet.\n</p>\n<h4>\n<strong>\n  Data Encoding\n </strong>\n</h4>\n<p>\n Data encoding ensures that data is transmitted correctly and efficiently over the USB bus. USB uses specific encoding schemes to represent data bits as electrical signals.\n</p>\n<p>\n<strong>\n  Staying Synchronized\n </strong>\n<br/>\n Synchronized communication ensures the receiver can correctly interpret data sent by the transmitter. USB uses a specific timing method to align data transmission, ensuring that the receiver stays in sync with the sender.\n</p>\n<h4>\n<strong>\n  Timing Accuracy\n </strong>\n</h4>\n<p>\n USB devices rely on precise timing to communicate. Accurate timing ensures data integrity and prevents errors in communication. This is especially critical in high-speed transfers.\n</p>\n<h4>\n<strong>\n  Packet Format\n </strong>\n</h4>\n<p>\n The USB packet format organizes data for transmission. The format includes fields such as the packet's start, the data content, and the packet's end, ensuring that the data is properly packaged for delivery.\n</p>\n<p>\n<strong>\n  Fields in the Packet\n </strong>\n<br/>\n Each USB packet contains specific fields such as the PID (Packet Identifier), data, and CRC (Cyclic Redundancy Check) to verify data integrity.\n</p>\n<p>\n<strong>\n  Inter-packet Delay\n </strong>\n<br/>\n The delay between packets is critical to maintain the timing of data transmission. Proper inter-packet delay prevents bus congestion and ensures a smooth flow of data.\n</p>\n<h4>\n<strong>\n  Test Modes\n </strong>\n</h4>\n<p>\n USB devices support different test modes to verify functionality and signal quality. These modes help ensure devices can handle communication under various conditions.\n</p>\n<p>\n<strong>\n  Entering and Exiting Test Modes\n </strong>\n<br/>\n Test modes are entered for diagnostic or development purposes. Devices can enter test mode using special commands and exit once testing is complete.\n</p>\n<p>\n<strong>\n  Test Modes Overview\n </strong>\n<br/>\n Test modes provide a way to test various aspects of USB functionality, such as signal integrity, speed, and timing. These modes help in troubleshooting and verifying device performance.\n</p>\n<hr/>\n<h3>\n<strong>\n  The Electrical Interface in USB Devices\n </strong>\n</h3>\n<h4>\n<strong>\n  Transceivers and Signals\n </strong>\n</h4>\n<p>\n<strong>\n  Transceivers\n </strong>\n<br/>\n Transceivers are responsible for converting data between the digital world of USB devices and the analog world of the electrical signals on the USB cable. These components are essential for enabling communication over USB.\n</p>\n<p>\n<strong>\n  Signal Types\n </strong>\n<br/>\n USB uses differential signals to transmit data, ensuring minimal interference and reliable communication. This is particularly important for high-speed communication.\n</p>\n<h4>\n<strong>\n  Cable Segments\n </strong>\n</h4>\n<p>\n Cables are made up of segments that carry the data signals between devices and hosts. These segments must meet strict standards to ensure the integrity of the USB signal.\n</p>\n<p>\n<strong>\n  Low- and Full-speed Transceivers\n </strong>\n<br/>\n Low-speed and full-speed transceivers are designed for slower communication rates, using simpler circuitry and less sophisticated encoding than high-speed transceivers.\n</p>\n<p>\n<strong>\n  High-speed Transceivers\n </strong>\n<br/>\n High-speed transceivers use more complex technology to handle faster data rates. They are optimized to support high-frequency signals and maintain signal integrity over longer distances.\n</p>\n<h4>\n<strong>\n  Signal Voltages\n </strong>\n</h4>\n<p>\n USB signal voltages are crucial to communication. The voltage levels must remain within a defined range to ensure that the signal is correctly interpreted by both devices.\n</p>\n<p>\n<strong>\n  Low and Full Speeds\n </strong>\n<br/>\n For low-speed and full-speed USB devices, the voltage levels are typically around 3.6V to 5V. These devices use less precise signal processing compared to high-speed USB devices.\n</p>\n<p>\n<strong>\n  High Speed\n </strong>\n<br/>\n High-speed USB requires precise voltage levels to maintain fast data transfer rates and prevent signal degradation.\n</p>\n<h4>\n<strong>\n  Cables and Conductors\n </strong>\n</h4>\n<p>\n<strong>\n  Cable Types\n </strong>\n<br/>\n USB cables are designed to support specific speeds, such as low-speed, full-speed, or high-speed. High-quality cables are essential for maintaining data integrity during transfers.\n</p>\n<p>\n<strong>\n  Conductors\n </strong>\n<br/>\n The conductors inside USB cables transmit signals between devices. They must be well insulated to prevent signal interference and to ensure reliable communication.\n</p>\n<h4>\n<strong>\n  Connectors\n </strong>\n</h4>\n<p>\n USB connectors come in various shapes and sizes, such as Type-A, Type-B, and micro-USB. These connectors are designed to ensure secure connections between devices.\n</p>\n<p>\n<strong>\n  Detachable and Captive Cables\n </strong>\n<br/>\n Detachable cables are commonly used for ease of connection and flexibility, while captive cables are fixed to the device for durability and reliability.\n</p>\n<p>\n<strong>\n  Cable Length\n </strong>\n<br/>\n The length of the USB cable impacts signal quality and transfer speed. Longer cables may result in signal degradation, especially for high-speed connections.\n</p>\n<h4>\n<strong>\n  Ensuring Signal Quality\n </strong>\n</h4>\n<p>\n Maintaining high signal quality is essential for successful USB communication. Several methods are employed to ensure the integrity of the signal during data transmission.\n</p>\n<p>\n<strong>\n  Sources of Noise\n </strong>\n<br/>\n Electrical noise from external devices, interference, and poor shielding can degrade USB signal quality. Proper cable design and shielding help minimize these effects.\n</p>\n<p>\n<strong>\n  Balanced Lines\n </strong>\n<br/>\n Balanced lines use two conductors carrying opposite signals to cancel out interference, improving signal integrity over long distances.\n</p>\n<p>\n<strong>\n  Twisted Pairs\n </strong>\n<br/>\n Twisted pairs of wires help reduce electromagnetic interference by ensuring that the signals in each wire cancel each other out.\n</p>\n<p>\n<strong>\n  Shielding\n </strong>\n<br/>\n Shielding protects the signal from external noise by surrounding the conductors with a grounded conductive layer. This is especially important in environments with high electromagnetic interference.\n</p>\n<p>\n<strong>\n  Edge Rates\n </strong>\n<br/>\n Edge rates refer to the speed at which the voltage transitions in a signal. Fast edge rates ensure that data is transmitted efficiently, but too fast of a transition can lead to signal distortion.\n</p>\n<p>\n<strong>\n  Isolated Interfaces\n </strong>\n<br/>\n Isolated interfaces prevent electrical noise and interference from affecting the device, improving the reliability of the communication.\n</p>\n"}, "Page 15": {"response": "<h3>\n Wireless Links and USB On-The-Go (OTG)\n</h3>\n<h4>\n<strong>\n  Wireless Links for USB\n </strong>\n</h4>\n<p>\n<strong>\n  Cypress WirelessUSB\n </strong>\n<br/>\n Cypress WirelessUSB is a technology that allows USB devices to communicate wirelessly. It replaces traditional USB cables with a wireless connection while maintaining the same data transfer speeds and power capabilities. This wireless approach is ideal for applications requiring flexible device placement without physical connections.\n</p>\n<p>\n<strong>\n  The Wireless USB Initiative\n </strong>\n<br/>\n The Wireless USB Initiative aims to extend the capabilities of USB by enabling wireless connections between devices. This initiative allows devices that previously required cables to function without physical connections, creating more freedom in device placement and reducing clutter.\n</p>\n<p>\n<strong>\n  Other Options\n </strong>\n<br/>\n In addition to Cypress WirelessUSB, there are other wireless communication technologies, like Bluetooth and Wi-Fi, that can support similar functions. However, Wireless USB offers higher data transfer speeds compared to Bluetooth and lower latency than traditional Wi-Fi for certain uses.\n</p>\n<hr/>\n<h3>\n<strong>\n  Dual-role Devices with USB On-The-Go (OTG)\n </strong>\n</h3>\n<h4>\n<strong>\n  Device and Host in One\n </strong>\n</h4>\n<p>\n USB On-The-Go (OTG) allows a device to act as both a host and a device, providing more flexibility in how USB devices communicate. With OTG, devices like smartphones and cameras can connect directly to each other without needing a computer as an intermediary.\n</p>\n<h4>\n<strong>\n  Capabilities and Limits\n </strong>\n</h4>\n<p>\n OTG devices can switch between host and device roles depending on the situation. However, there are limitations on what functions an OTG device can handle. For example, while one device can act as a host to supply power to another, it might not be able to support full host functionality for high-performance peripherals like printers or external hard drives.\n</p>\n<h4>\n<strong>\n  Requirements for an OTG Device\n </strong>\n</h4>\n<p>\n For a device to be USB OTG-compliant, it needs certain hardware and software capabilities, such as the ability to power up and down the bus and support specific data transfer protocols. Additionally, it must be able to switch between host and device roles on the fly.\n</p>\n<h4>\n<strong>\n  The OTG Descriptor\n </strong>\n</h4>\n<p>\n The OTG Descriptor is a special part of the device\u2019s configuration that defines whether the device supports OTG functionality and how it can interact with other OTG devices. This descriptor provides the host with the information needed to initiate communication and switch between roles.\n</p>\n<h4>\n<strong>\n  Feature Codes for HNP\n </strong>\n</h4>\n<p>\n Host Negotiation Protocol (HNP) allows OTG devices to negotiate which device will act as the host and which will be the peripheral. Feature codes are used in the communication between devices to ensure that the correct roles are assigned and maintained during operation.\n</p>\n<h4>\n<strong>\n  OTG Controller Chips\n </strong>\n</h4>\n<p>\n OTG controller chips enable the functionality of OTG devices, ensuring that the devices can alternate between being a host and a peripheral without conflict. These chips handle the data exchange and power management that is unique to OTG devices.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Philips ISP1362\n   </strong>\n<br/>\n   The Philips ISP1362 is a popular OTG controller chip that supports both USB host and device functionality, making it ideal for mobile devices and portable gadgets that require flexible USB connectivity.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    TransDimension TD242LP\n   </strong>\n<br/>\n   The TD242LP is another OTG controller chip used in mobile and embedded devices. It supports both USB 2.0 high-speed communication and OTG features, enabling efficient data exchange.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Cypress CY7C67200 EZ-OTG\n   </strong>\n<br/>\n   The CY7C67200 EZ-OTG chip is designed for OTG applications, providing both host and device capabilities for devices like smartphones and tablets. It supports high-speed data transfer and dynamic role switching.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Philips ISP1261 Bridge Controller\n   </strong>\n<br/>\n   The ISP1261 is a bridge controller that allows seamless communication between different USB device types, functioning as a translator between USB OTG and standard USB devices. It ensures compatibility across various USB configurations.\n  </p>\n</li>\n</ul>\n<hr/>\n<p>\n These advancements in USB technology, including wireless solutions and OTG devices, enable more versatile and flexible use of USB connections, enhancing device interoperability and user experience.\n</p>\n"}, "Page 16": {"response": "<p>\n It seems there isn't any content provided in your most recent message. Could you please share the specific content you'd like me to help with? I'll be happy to restate and explain it in detail.\n</p>\n"}, "Page 17": {"response": "<h3>\n Introduction to USB Development\n</h3>\n<p>\n This book is aimed at developers who design and program devices that use the Universal Serial Bus (USB) interface. The goal is to introduce you to USB technology and guide you in getting your devices communicating efficiently and quickly.\n</p>\n<h4>\n<strong>\n  Versatility of USB\n </strong>\n</h4>\n<p>\n The USB interface is highly adaptable, supporting a wide variety of peripheral devices. Common USB peripherals include mice, keyboards, printers, drives, and audio/video devices. Additionally, USB is used for more specialized equipment, such as data-acquisition units, control systems, and unique devices with specialized functions.\n</p>\n<h4>\n<strong>\n  Understanding USB for Device Development\n </strong>\n</h4>\n<p>\n To successfully develop a device with USB connectivity, it\u2019s essential to understand how the USB interface functions. Specifically, you need to:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Understand USB Operations\n   </strong>\n   : Learn how the interface works, including the communication process between the device and the host.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Firmware Responsibilities\n   </strong>\n   : Recognize the tasks your device\u2019s firmware must handle to facilitate communication over the USB bus.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Class Drivers and Host Support\n   </strong>\n   : Understand what class drivers and other support mechanisms are available on the host systems to which your device will connect.\n  </p>\n</li>\n</ul>\n<h4>\n<strong>\n  Choosing the Right Components\n </strong>\n</h4>\n<p>\n Successful USB device development requires making the right decisions in:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Device Hardware\n   </strong>\n   : Selecting the appropriate hardware components for your device to function well on the USB bus.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Device Class\n   </strong>\n   : Understanding USB class standards, which help define the type of device and its communication protocols.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Development Tools and Technologies\n   </strong>\n   : Selecting the proper tools and technologies that support efficient USB device development.\n  </p>\n</li>\n</ul>\n<p>\n By mastering these aspects, you can ensure your device will function seamlessly with USB technology, enabling smooth communication with host systems.\n</p>\n"}, "Page 18": {"response": "<h3>\n What\u2019s Inside the Book\n</h3>\n<p>\n This book is designed to help developers involved in designing USB devices, writing device firmware, or creating applications that interact with USB devices. It provides practical insights and simplifies the process, helping you avoid common obstacles.\n</p>\n<h4>\n<strong>\n  Key Questions the Book Answers\n </strong>\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    How do USB devices communicate?\n   </strong>\n   USB communication may seem complex at first due to the size and depth of the USB 2.0 specification, which spans over 600 pages. However, this book doesn\u2019t attempt to cover every detail. Instead, it focuses on the critical information you need to enable efficient and reliable communication between your USB devices.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Should my device use a USB interface?\n   </strong>\n   USB isn't the best choice for every application. This book helps you evaluate whether USB is the right interface for your design. While USB is often the best option, you will learn how to determine which of USB\u2019s three speeds (low, full, or high) and four transfer types (control, bulk, interrupt, isochronous) are best suited to your application.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    What controller chip should my device use?\n   </strong>\n   All USB devices require an intelligent controller chip to implement the USB interface. There are many options available from various manufacturers, each offering chips with different architectures and features. This book provides descriptions of popular USB controller chips and gives tips to help you select the right chip based on your project\u2019s needs and your expertise.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    How do applications communicate with USB devices?\n   </strong>\n   PC applications interact with USB devices through device drivers assigned by the operating system. Some USB devices can use standard class drivers that are included with Windows, while others require custom drivers. This book introduces you to USB classes, helping you decide if your device can use a standard class driver. If a custom driver is necessary, the book explains what\u2019s involved in writing one and introduces you to the tools needed to develop it.\n  </p>\n</li>\n</ol>\n<p>\n By addressing these questions, the book ensures that you gain a clear understanding of USB device design, communication, and development, allowing you to proceed with your projects confidently and effectively.\n</p>\n"}, "Page 19": {"response": "<h3>\n What You Will Learn and How This Book Can Help\n</h3>\n<p>\n This book offers practical guidance on various aspects of USB device development, including:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Obtaining and Using Drivers\n   </strong>\n</p>\n<ul>\n<li>\n    The book explains how to speed up the development process by obtaining drivers from different sources, including custom solutions.\n   </li>\n<li>\n    Example code is provided for detecting and communicating with USB devices using Visual Basic .NET and Visual C++ .NET applications.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Writing Firmware for USB Communication\n   </strong>\n</p>\n<ul>\n<li>\n    Learn how to write firmware that allows your device to respond to requests and exchange data over the USB bus.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Deciding Between Bus Power or External Supply\n   </strong>\n</p>\n<ul>\n<li>\n    Many USB devices draw power from the bus itself. This book teaches you how to determine if your device can use bus power or if it needs its own power supply.\n   </li>\n<li>\n    It also explains the requirement for devices to limit their bus power usage during the suspend state.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Using USB On-The-Go for Peripheral Connectivity\n   </strong>\n</p>\n<ul>\n<li>\n    You\u2019ll learn how to implement USB On-The-Go (OTG) to allow your device to act as a limited-capability host, enabling it to communicate with other USB peripherals.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Ensuring Reliable Communication\n   </strong>\n</p>\n<ul>\n<li>\n    The book offers tips and example code to help ensure bug-free firmware and smooth device communication. It also covers how to ensure the host computer identifies your device and selects the correct driver.\n   </li>\n<li>\n    Additionally, information on debugging both software and hardware is included to resolve any issues that may arise.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n<strong>\n  Prerequisites for Understanding the Material\n </strong>\n</h4>\n<p>\n To fully benefit from this book, a basic understanding of digital logic, application programming for PCs, and embedded code for peripherals is helpful. However, prior knowledge of USB is not required.\n</p>\n<h3>\n What\u2019s New in the Third Edition?\n</h3>\n<p>\n The third edition of this book includes updates reflecting recent advancements in USB technology:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Expanded USB Specifications\n   </strong>\n</p>\n<ul>\n<li>\n    New and updated device-class specifications have been added, along with a supplement for USB On-The-Go.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    New Device-Controller Chips\n   </strong>\n</p>\n<ul>\n<li>\n    The release of several new device-controller chips provides more options for developers.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Improved Debugging and Compliance Testing Tools\n   </strong>\n</p>\n<ul>\n<li>\n    New tools for debugging and compliance testing make it easier to develop and verify USB devices.\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n This edition has been updated to ensure developers stay informed about the latest USB specifications and tools, helping you create modern, compliant, and functional USB devices.\n</p>\n"}, "Page 20": {"response": "<h3>\n What\u2019s New in the Third Edition and Additional Resources\n</h3>\n<p>\n The\n <strong>\n  Third Edition\n </strong>\n of\n <em>\n  USB Complete\n </em>\n has been extensively revised and updated to reflect key changes and improvements in USB technology, hardware, and programming, including:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Improved Device Class Support in Windows\n   </strong>\n</p>\n<ul>\n<li>\n    Windows now provides better support for managing USB device classes, simplifying the integration of USB devices into host systems.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Microsoft .NET Framework\n   </strong>\n</p>\n<ul>\n<li>\n    The growing popularity of Microsoft\u2019s .NET Framework as a platform for developing host applications is addressed in this edition. This provides developers with a modern, efficient way to create applications that interact with USB devices.\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n These developments motivated the creation of the\n <strong>\n  Third Edition\n </strong>\n , which includes updated content throughout to cover new USB hardware and programming practices.\n</p>\n<h3>\n More Information, Updates, and Corrections\n</h3>\n<p>\n For additional information on developing USB devices and communicating software, visit the\n <strong>\n  USB Central page\n </strong>\n at\n <strong>\n  Lakeview Research\n </strong>\n (\n <a rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n  www\n  .Lvr\n  .com\n </a>\n ). The page includes:\n</p>\n<ul>\n<li>\n<strong>\n   Code examples\n  </strong>\n</li>\n<li>\n<strong>\n   Links to articles, products, and tools\n  </strong>\n</li>\n<li>\n<strong>\n   Additional resources\n  </strong>\n  for USB device development\n </li>\n</ul>\n<p>\n If you have suggestions, code contributions, or other relevant information, you can contact the author directly at\n <a rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\">\n  jan\n  @Lvr\n  .com\n </a>\n . Corrections and updates to the book will also be posted on the website, and any errors you spot can be reported for correction.\n</p>\n<h3>\n Acknowledgements\n</h3>\n<p>\n Writing about USB is a massive undertaking, and the author extends gratitude to the following contributors whose feedback has significantly improved the book:\n</p>\n<ul>\n<li>\n<strong>\n   Paul E. Berg\n  </strong>\n  , MCCI Vice President, Architecture, and Chair of the USB-IF Device Working Group.\n </li>\n<li>\n<strong>\n   David Goll\n  </strong>\n  , USB-IF\u2019s Video Device Working Group.\n </li>\n<li>\n<strong>\n   Lucio DiJasio\n  </strong>\n  and\n  <strong>\n   Rawin Rojvanit\n  </strong>\n  from Microchip Technology.\n </li>\n<li>\n<strong>\n   John Hyde\n  </strong>\n  of usb-by-example.com.\n </li>\n<li>\n<strong>\n   Geert Knapen\n  </strong>\n  , USB-IF\u2019s Audio Device Working Group.\n </li>\n<li>\n<strong>\n   Walter Oney\n  </strong>\n  of Walter Oney Software.\n </li>\n<li>\n<strong>\n   Marc Reinig\n  </strong>\n  of System Solutions.\n </li>\n</ul>\n<p>\n Despite the contributions, any errors in the book are the author's responsibility alone.\n</p>\n"}, "Page 21": {"response": "<h3>\n Acknowledgements (Continued)\n</h3>\n<p>\n The author extends further gratitude to those who provided invaluable support throughout the development of this book:\n</p>\n<ul>\n<li>\n<strong>\n   Glenn M. Roberts\n  </strong>\n  of\n  <strong>\n   Cypress Semiconductor\n  </strong>\n</li>\n<li>\n<strong>\n   Fred Dart\n  </strong>\n  and\n  <strong>\n   Keith Dingwall\n  </strong>\n  of\n  <strong>\n   FTDI Chip\n  </strong>\n</li>\n<li>\n<strong>\n   Wendy Dee\n  </strong>\n  of\n  <strong>\n   Keil Software\n  </strong>\n</li>\n<li>\n<strong>\n   Michael DeVault\n  </strong>\n  of\n  <strong>\n   DeVaSys Embedded Systems\n  </strong>\n</li>\n<li>\n<strong>\n   Alan Lowne\n  </strong>\n  of\n  <strong>\n   Saelig Company Inc.\n  </strong>\n</li>\n<li>\n<strong>\n   Laurent Guinnard\n  </strong>\n  of\n  <strong>\n   Ellisys\n  </strong>\n</li>\n<li>\n<strong>\n   Rich Moran\n  </strong>\n  of\n  <strong>\n   RPM Systems Corporation\n  </strong>\n</li>\n<li>\n<strong>\n   Bob Nathan\n  </strong>\n  of\n  <strong>\n   NCR Corporation\n  </strong>\n</li>\n</ul>\n<p>\n Additionally, appreciation is given to individuals who helped with earlier editions of the book, laying the foundation for the current edition. These include:\n</p>\n<ul>\n<li>\n<strong>\n   Joshua Buergel\n  </strong>\n</li>\n<li>\n<strong>\n   Gary Crowell\n  </strong>\n</li>\n<li>\n<strong>\n   Dave Dowler\n  </strong>\n</li>\n<li>\n<strong>\n   Mike Fahrion\n  </strong>\n</li>\n<li>\n<strong>\n   John M. Goodman\n  </strong>\n</li>\n<li>\n<strong>\n   Lane Hauck\n  </strong>\n</li>\n<li>\n<strong>\n   David James\n  </strong>\n</li>\n<li>\n<strong>\n   Christer Johansson\n  </strong>\n</li>\n<li>\n<strong>\n   Kosta Koeman\n  </strong>\n</li>\n<li>\n<strong>\n   Jon Lueker\n  </strong>\n</li>\n<li>\n<strong>\n   Brad Markisohn\n  </strong>\n</li>\n<li>\n<strong>\n   Amar Rajan\n  </strong>\n</li>\n<li>\n<strong>\n   Robert Severson\n  </strong>\n</li>\n<li>\n<strong>\n   Craig R. Smith\n  </strong>\n</li>\n<li>\n<strong>\n   Dave Wright\n  </strong>\n</li>\n</ul>\n<p>\n The author welcomes comments and feedback, hoping the book proves helpful for readers in their USB development endeavors.\n</p>\n"}, "Page 22": {"response": "<h3>\n Introduction to USB Complete\n</h3>\n<p>\n This book is designed for developers involved in the design and programming of devices that use the Universal Serial Bus (USB) interface. The goal is to help you quickly and efficiently integrate USB into your devices.\n</p>\n<p>\n The USB interface is widely used for many types of peripheral devices such as mice, keyboards, printers, drives, and audio/video devices. It is also suitable for specialized devices like data acquisition systems and control systems.\n</p>\n<p>\n To successfully develop a device with a USB interface, it's important to understand how USB works, what tasks the device firmware must perform to communicate on the bus, and how your device will interact with host computers. The right choice of hardware, class drivers, and development tools can significantly simplify the process.\n</p>\n<h3>\n Key Areas Covered:\n</h3>\n<ul>\n<li>\n<p>\n<strong>\n    USB Communication:\n   </strong>\n   Understand how USB devices communicate on the bus and the basics of USB transfers.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Device Selection:\n   </strong>\n   Learn how to choose the right USB interface for your device and determine if it can use USB\u2019s three speeds and four transfer types.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Controller Chips:\n   </strong>\n   Every USB device requires a controller to manage the USB interface. The book covers popular controller chips and provides guidance on selecting the right one for your project.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Host Communication:\n   </strong>\n   Learn how applications on the host computer communicate with USB devices, using either standard class drivers or custom drivers.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Device Firmware:\n   </strong>\n   Discover how to write firmware that allows your device to respond to requests and exchange data on the bus.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Power Requirements:\n   </strong>\n   Understand whether your device can be powered from the USB bus or needs its own power supply.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    USB On-The-Go:\n   </strong>\n   Learn how to make your device act as a limited host, allowing it to communicate with other USB peripherals.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Troubleshooting and Debugging:\n   </strong>\n   The book includes tips, example code, and information on debugging tools to help ensure your device works smoothly.\n  </p>\n</li>\n</ul>\n<p>\n By following the guidance provided in this book, you can avoid common pitfalls and quickly get your USB device up and running.\n</p>\n"}, "Page 23": {"response": "<h3>\n USB Basics\n</h3>\n<p>\n If you had the opportunity to design a peripheral interface from scratch, you'd probably want it to have several key qualities:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Ease of Use\n   </strong>\n   : The interface should be simple, with minimal setup or configuration needed.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Speed\n   </strong>\n   : It should be fast enough that it doesn't become a bottleneck for communication between devices.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Reliability\n   </strong>\n   : The interface must be dependable, with automatic retries when errors occur, ensuring smooth operation.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Versatility\n   </strong>\n   : It should support a wide range of peripherals, from simple devices to complex ones.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Affordability\n   </strong>\n   : The interface should be cost-effective, making it accessible to both manufacturers and consumers.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Power Efficiency\n   </strong>\n   : It should conserve energy, especially important for portable devices and to extend battery life in laptops and other mobile gadgets.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Operating System Support\n   </strong>\n   : The interface should be supported by major operating systems like Windows, so developers don\u2019t need to create custom low-level drivers for each device.\n  </p>\n</li>\n</ul>\n<p>\n USB (Universal Serial Bus) was designed with these qualities in mind. It has become a popular and effective interface for connecting a wide variety of devices.\n</p>\n"}, "Page 24": {"response": "<h3>\n Chapter 1: USB Basics\n</h3>\n<p>\n The Universal Serial Bus (USB) was designed to meet all the essential qualities for an effective peripheral interface. It solves many issues that older interfaces faced, making it a popular choice for connecting various types of devices to a computer. USB ports are now standard on almost every modern PC and Mac, allowing connections to peripherals like keyboards, mice, scanners, cameras, printers, drives, and even custom devices for specialized tasks.\n</p>\n<p>\n This chapter provides an introduction to USB, explaining its advantages and limitations, its history, recent updates, and what goes into designing and programming a device with a USB interface.\n</p>\n<h3>\n What USB Can Do\n</h3>\n<p>\n USB is a great option whenever you need to connect a device to a computer, whether it\u2019s for mass-produced standard peripherals or small-volume, unique designs. A successful interface must appeal to both users and developers, and USB manages to do this with several key features that benefit both groups.\n</p>\n<h3>\n Benefits for Users\n</h3>\n<p>\n From the user\u2019s perspective, USB offers several significant advantages, including ease of use, fast and reliable data transfer, flexibility, low cost, and energy efficiency. Here\u2019s a breakdown of what USB provides:\n</p>\n<h4>\n Ease of Use\n</h4>\n<p>\n One of the primary design goals of USB was to make it incredibly user-friendly. USB accomplishes this by offering a single interface that can be used with a wide range of devices. Instead of having to use different connectors and supporting hardware for every type of peripheral, USB simplifies things by using one universal interface for many different devices. This ease of use contributes significantly to USB\u2019s popularity.\n</p>\n"}, "Page 25": {"response": "<h3>\n USB Basics: Comparison with Other Interfaces\n</h3>\n<p>\n USB offers many advantages, but it\u2019s important to understand how it compares to other popular computer interfaces. Below is a comparison of various interfaces, their formats, device limits, distance capabilities, speed, and typical uses:\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Interface\n    </strong>\n</th>\n<th>\n<strong>\n     Format\n    </strong>\n</th>\n<th>\n<strong>\n     Number of Devices (Maximum)\n    </strong>\n</th>\n<th>\n<strong>\n     Distance (Maximum, feet)\n    </strong>\n</th>\n<th>\n<strong>\n     Speed (Maximum, bits/sec.)\n    </strong>\n</th>\n<th>\n<strong>\n     Typical Use\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     USB\n    </strong>\n</td>\n<td>\n    Asynchronous serial\n   </td>\n<td>\n    127\n   </td>\n<td>\n    16 (up to 96 ft. with 5 hubs)\n   </td>\n<td>\n    1.5M, 12M, 480M\n   </td>\n<td>\n    Mouse, keyboard, drive, audio, printer, other standard and custom peripherals\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Ethernet\n    </strong>\n</td>\n<td>\n    Serial\n   </td>\n<td>\n    1024\n   </td>\n<td>\n    1600\n   </td>\n<td>\n    10G\n   </td>\n<td>\n    General network communications\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     IEEE-1394b (FireWire 800)\n    </strong>\n</td>\n<td>\n    Serial\n   </td>\n<td>\n    64\n   </td>\n<td>\n    300\n   </td>\n<td>\n    3.2G\n   </td>\n<td>\n    Video, mass storage\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     IEEE-488 (GPIB)\n    </strong>\n</td>\n<td>\n    Parallel\n   </td>\n<td>\n    15\n   </td>\n<td>\n    60\n   </td>\n<td>\n    8M\n   </td>\n<td>\n    Instrumentation\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     IrDA\n    </strong>\n</td>\n<td>\n    Asynchronous serial infrared\n   </td>\n<td>\n    2\n   </td>\n<td>\n    6\n   </td>\n<td>\n    16M\n   </td>\n<td>\n    Printers, handheld computers\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     I2C\n    </strong>\n</td>\n<td>\n    Synchronous serial\n   </td>\n<td>\n    40\n   </td>\n<td>\n    18\n   </td>\n<td>\n    3.4M\n   </td>\n<td>\n    Microcontroller communications\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Microwire\n    </strong>\n</td>\n<td>\n    Synchronous serial\n   </td>\n<td>\n    8\n   </td>\n<td>\n    10\n   </td>\n<td>\n    2M\n   </td>\n<td>\n    Microcontroller communications\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     MIDI\n    </strong>\n</td>\n<td>\n    Serial current loop\n   </td>\n<td>\n    2 (more with flow-through mode)\n   </td>\n<td>\n    50\n   </td>\n<td>\n    31.5k\n   </td>\n<td>\n    Music, show control\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Parallel Printer Port\n    </strong>\n</td>\n<td>\n    Parallel\n   </td>\n<td>\n    2 (8 with daisy-chain support)\n   </td>\n<td>\n    10-30\n   </td>\n<td>\n    8M\n   </td>\n<td>\n    Printers, scanners, disk drives\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     RS-232 (EIA/TIA-232)\n    </strong>\n</td>\n<td>\n    Asynchronous serial\n   </td>\n<td>\n    2\n   </td>\n<td>\n    50-100\n   </td>\n<td>\n    20k (115k with some hardware)\n   </td>\n<td>\n    Modem, mouse, instrumentation\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     RS-485 (TIA/EIA-485)\n    </strong>\n</td>\n<td>\n    Asynchronous serial\n   </td>\n<td>\n    32 unit loads (up to 256 devices with some hardware)\n   </td>\n<td>\n    4000\n   </td>\n<td>\n    10M\n   </td>\n<td>\n    Data acquisition and control systems\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     SPI\n    </strong>\n</td>\n<td>\n    Synchronous serial\n   </td>\n<td>\n    8\n   </td>\n<td>\n    10\n   </td>\n<td>\n    2.1M\n   </td>\n<td>\n    Microcontroller communications\n   </td>\n</tr>\n</tbody>\n</table>\n<h3>\n Summary:\n</h3>\n<ul>\n<li>\n<strong>\n   USB\n  </strong>\n  is a versatile interface supporting up to 127 devices and offering speeds ranging from 1.5 Mbps to 480 Mbps, suitable for a variety of standard and custom peripherals like keyboards, drives, and printers.\n </li>\n<li>\n  In comparison, interfaces like\n  <strong>\n   Ethernet\n  </strong>\n  and\n  <strong>\n   IEEE-1394b\n  </strong>\n  (FireWire) offer higher speeds and greater distances, primarily used for networking and video/mass storage, respectively.\n </li>\n<li>\n  Older interfaces like\n  <strong>\n   RS-232\n  </strong>\n  and\n  <strong>\n   Parallel Printer Ports\n  </strong>\n  still find niche uses, particularly for modems, mice, and printers, but USB has largely replaced them in modern applications due to its speed, versatility, and ease of use.\n </li>\n</ul>\n<p>\n This table highlights the strengths of USB in supporting a broad range of devices with reasonable distances and speeds, making it a popular choice in both consumer and industrial applications.\n</p>\n"}, "Page 26": {"response": "<h3>\n USB Basics: Key Advantages for Users\n</h3>\n<p>\n USB is designed with ease of use and user-friendliness in mind. Below are the key features that make USB a popular choice for both users and developers:\n</p>\n<h4>\n 1.\n <strong>\n  Automatic Configuration\n </strong>\n</h4>\n<p>\n When a USB peripheral is connected to a PC, Windows automatically detects it and loads the appropriate driver. The first time the peripheral is connected, the system may ask the user to insert a driver disk, but after that, the installation process is entirely automatic. There's no need for a system restart to use the device.\n</p>\n<h4>\n 2.\n <strong>\n  Easy Connection\n </strong>\n</h4>\n<p>\n With USB, users do not need to open the computer to add an expansion card for each peripheral. A typical PC already includes multiple USB ports, and additional ports can be added using hubs. This makes it easy to connect various devices without needing any internal hardware modifications.\n</p>\n<h4>\n 3.\n <strong>\n  Simple Cables\n </strong>\n</h4>\n<p>\n USB cables are designed to be easy to use. The connectors are keyed, which means they can only be plugged in one way, preventing mistakes. The cables are compact and typically can reach up to 5 meters in length, while using hubs, a peripheral can be located up to 30 meters away from the host computer. The USB specification ensures that cables and connectors meet specific requirements for reliable operation.\n</p>\n<h4>\n 4.\n <strong>\n  Hot Plugging\n </strong>\n</h4>\n<p>\n USB allows for \"hot plugging,\" meaning you can connect and disconnect peripherals while the system is powered on, without causing damage to the PC or the device. The operating system will automatically detect when a device is attached and prepare it for use.\n</p>\n<h4>\n 5.\n <strong>\n  No User Settings Needed\n </strong>\n</h4>\n<p>\n USB peripherals do not require the user to set any configurations such as port addresses or interrupt request (IRQ) lines. There are no jumpers to adjust or configuration utilities to run. This simplifies the process, as there are no manual configurations needed from the user.\n</p>\n<h4>\n 6.\n <strong>\n  Freeing Up Hardware Resources\n </strong>\n</h4>\n<p>\n By using USB for as many peripherals as possible, you free up valuable hardware resources such as IRQ lines. While a PC dedicates certain resources (port addresses and one IRQ line) to the USB host controller, individual peripherals connected via USB do not need additional resources or require any programming on the PC. In contrast, peripherals using other interfaces may require dedicated port addresses, IRQ lines, and expansion slots.\n</p>\n<h4>\n 7.\n <strong>\n  Power Supply (Optional)\n </strong>\n</h4>\n<p>\n The USB interface includes power and ground lines that provide +5V from the host computer or hub. Peripherals that require up to 500 milliamps can draw all of their power from the USB bus, eliminating the need for an external power supply. This reduces the need for separate power adapters in many cases, making USB-powered peripherals more convenient to use.\n</p>\n<h3>\n Summary:\n</h3>\n<p>\n USB's user-friendly features, such as automatic configuration, easy connections, and hot-pluggable functionality, make it an ideal interface for a wide range of devices. It simplifies peripheral management by eliminating the need for complex setups, freeing up system resources, and offering convenient power options. These advantages contribute to USB\u2019s widespread adoption across many device types.\n</p>\n"}, "Page 27": {"response": "<h3>\n USB Basics: Key Features of USB\n</h3>\n<p>\n USB provides a range of features that make it a convenient and reliable interface for connecting peripherals to computers. Below are some of the main features of USB that benefit both users and developers:\n</p>\n<h4>\n 1.\n <strong>\n  Power Supply Options\n </strong>\n</h4>\n<p>\n One of USB's key advantages is the ability to power peripherals directly through the bus. USB provides +5V power to peripherals, with up to 500 milliamps available for each device. This removes the need for an external power supply in many cases. In contrast, other interfaces often require peripherals to include an internal power supply or rely on bulky external adapters, making USB devices more convenient and compact.\n</p>\n<h4>\n 2.\n <strong>\n  USB Speeds\n </strong>\n</h4>\n<p>\n USB supports three different speeds, allowing it to accommodate a variety of devices and data requirements:\n</p>\n<ul>\n<li>\n<strong>\n   High Speed\n  </strong>\n  : 480 Megabits per second (Mbps) \u2013 This is the fastest USB speed, suitable for devices that require rapid data transfer.\n </li>\n<li>\n<strong>\n   Full Speed\n  </strong>\n  : 12 Mbps \u2013 This is a moderate speed that is sufficient for many common peripherals like keyboards and printers.\n </li>\n<li>\n<strong>\n   Low Speed\n  </strong>\n  : 1.5 Mbps \u2013 This is the slowest speed, designed for simpler devices like mice that don't require high data rates.\n </li>\n</ul>\n<p>\n The USB host controllers in modern PCs support all three speeds. The data transfer rate for individual peripherals may be lower than the bus speed due to the need to share the bus with other devices. The theoretical maximum data transfer rates are:\n</p>\n<ul>\n<li>\n  High speed: 53 Megabytes per second (MB/s)\n </li>\n<li>\n  Full speed: 1.2 MB/s\n </li>\n<li>\n  Low speed: 0.8 KB/s\n </li>\n</ul>\n<h4>\n 3.\n <strong>\n  Low-Speed Devices\n </strong>\n</h4>\n<p>\n The inclusion of low speed in the USB specification was primarily aimed at supporting devices like mice. Low-speed cables are more flexible because they don\u2019t require as much shielding or twisted pairs, making them easier to use with devices that need mobility. Additionally, low-speed devices are generally cheaper to manufacture. Full-speed USB, on the other hand, replaced older interfaces like RS-232 (serial) and parallel ports by offering better data-transfer rates than these older technologies.\n</p>\n<h4>\n 4.\n <strong>\n  Reliability of USB\n </strong>\n</h4>\n<p>\n USB is designed to be a reliable interface, thanks to both its hardware and protocols. The hardware specifications for USB cables, drivers, and receivers ensure minimal noise interference, helping to reduce data errors. Additionally, the USB protocol includes error detection, allowing the system to identify errors in received data. When an error is detected, the system automatically notifies the sender to retransmit the data. This error-checking process is handled by the hardware, so no additional programming or user intervention is required.\n</p>\n<h3>\n Summary:\n</h3>\n<p>\n USB's combination of power convenience, speed options, and built-in reliability makes it an excellent choice for a wide range of devices. Whether you need low-speed connections for simple peripherals or high-speed transfers for more demanding devices, USB supports it all while ensuring minimal errors and automatic corrections. These advantages, along with the ease of use and widespread compatibility, make USB a preferred interface for many typ\n</p>\n"}, "Page 28": {"response": "<h3>\n USB Basics: Low Cost, Low Power, and Developer Benefits\n</h3>\n<p>\n USB is an ideal interface for connecting peripherals to computers due to its affordability, low power consumption, and developer-friendly features. Here\u2019s an overview of the additional advantages USB offers both users and developers.\n</p>\n<h4>\n 1.\n <strong>\n  Low Cost\n </strong>\n</h4>\n<p>\n Despite being more complex than older interfaces, USB is still inexpensive. The components required for USB devices, including the cables, are cost-effective. As a result, devices with USB interfaces are typically priced the same or even cheaper compared to devices using older or newer interfaces like IEEE-1394 (FireWire). This affordability makes USB an attractive choice for manufacturers and consumers alike.\n</p>\n<h4>\n 2.\n <strong>\n  Low Power Consumption\n </strong>\n</h4>\n<p>\n USB also helps conserve power, which is beneficial for both the environment and cost-saving. Power-saving circuits and code can automatically power down USB peripherals when not in use, yet they remain ready to respond when needed. This reduces power consumption, extends battery life in portable devices, and can even lead to longer times between recharges. For manufacturers, this means reduced energy usage and lower operational costs.\n</p>\n<h4>\n 3.\n <strong>\n  Wireless Communication Options\n </strong>\n</h4>\n<p>\n While USB was originally a wired interface, it now supports wireless options. There are devices available that use USB for communication with PCs wirelessly. This expands the flexibility of USB, allowing for more diverse and convenient applications.\n</p>\n<h3>\n Benefits for Developers\n</h3>\n<p>\n Many of the same features that benefit users also make USB easier for developers to work with. USB's standards and error-checking protocols streamline development by reducing the need for developers to address certain technical details. Below are some of the key developer benefits:\n</p>\n<h4>\n 1.\n <strong>\n  Versatility\n </strong>\n</h4>\n<p>\n USB's ability to support four different transfer types and three speeds allows it to handle a wide range of peripherals and applications. This versatility makes USB suitable for many different use cases, from simple devices like keyboards to more complex peripherals requiring high-speed data transfer. By selecting the appropriate transfer type and speed, developers can optimize USB\u2019s performance for their specific needs.\n</p>\n<h4>\n 2.\n <strong>\n  Predefined Standards\n </strong>\n</h4>\n<p>\n For hardware developers, USB simplifies the design process by offering defined cable standards and well-documented specifications for controller chips. These standards ensure that USB components and cables work together seamlessly, which reduces the risk of errors and minimizes the need for manual adjustments. Additionally, developers don\u2019t have to worry about specifying cable characteristics or implementing error-checking in software, as USB\u2019s protocol automatically handles these aspects.\n</p>\n<h4>\n 3.\n <strong>\n  Built-in Protocol Support\n </strong>\n</h4>\n<p>\n The USB protocol is highly flexible and designed to support a broad array of devices and data exchange scenarios. USB controllers and operating systems offer built-in support for this protocol, which makes development easier and faster. Moreover, developers benefit from the support and resources provided by the USB Implementers Forum, which offers tools, documentation, and other resources to aid in the development process.\n</p>\n<h3>\n Summary:\n</h3>\n<p>\n USB offers many advantages for both users and developers, from its low cost and power-saving capabilities to its flexibility and ease of use. For developers, USB's versatility, predefined standards, and built-in support reduce development time and complexity, making it a highly attractive option for creating devices that require reliable and efficient communication. Whether you're designing hardware, writing embedded code, or developing PC software, USB provides the tools needed for success.\n</p>\n"}, "Page 29": {"response": "<h3>\n USB Basics: Data Transfer, Flexibility, and Operating System Support\n</h3>\n<p>\n USB provides versatility in handling different types of data transfers and offers robust operating system support. Below is a breakdown of how USB handles various data transfer needs and the extensive operating system compatibility it supports.\n</p>\n<h4>\n 1.\n <strong>\n  Data Transfer Capabilities\n </strong>\n</h4>\n<p>\n USB is capable of handling both large and small data transfers efficiently, making it suitable for a wide variety of applications. It supports both time-sensitive and non-time-sensitive data, ensuring reliable communication for devices that require real-time access. For instance, USB can guarantee bandwidth or a maximum time between data transfers, which is crucial for applications requiring consistent data streams. This feature helps minimize delays and ensures that transfers stay close to real-time, even under complex operating system conditions.\n</p>\n<p>\n Unlike other interfaces, USB doesn\u2019t limit how its signal lines are used. For example, older interfaces like the parallel port were designed with specific functions in mind, such as communication with printers. Over time, however, the parallel port's limitations became evident as it was used for other types of devices, like scanners. USB, in contrast, doesn\u2019t assign specific functions to its signal lines, making it flexible and adaptable to a variety of peripherals.\n</p>\n<p>\n Additionally, USB includes predefined device classes for common peripherals, such as printers, keyboards, and drives. These device classes specify the required protocols and functions, making it easier for developers to build compatible devices without needing to reinvent the wheel.\n</p>\n<h4>\n 2.\n <strong>\n  Operating System Support\n </strong>\n</h4>\n<p>\n USB support is a fundamental feature in modern operating systems. Windows 98 was the first version of Windows to offer reliable USB support, and subsequent versions, including Windows 2000, Windows Me, Windows XP, and Windows Server 2003, have continued to support USB as a standard. This book primarily focuses on programming for USB within Windows, but it\u2019s important to note that USB support extends beyond Windows. Apple\u2019s macOS, the Linux operating system for PCs, and even some real-time kernels also provide USB support, making USB a universal solution across multiple platforms.\n</p>\n<p>\n For an operating system to claim support for USB, it must fulfill certain requirements. At the most basic level, an operating system must:\n</p>\n<ul>\n<li>\n<strong>\n   Detect and configure USB devices automatically\n  </strong>\n  : The OS should recognize when a USB device is connected and configure it without requiring manual intervention.\n </li>\n<li>\n<strong>\n   Load appropriate device drivers\n  </strong>\n  : The OS must load the correct drivers to allow communication between the connected USB device and the host system.\n </li>\n<li>\n<strong>\n   Provide an interface for device communication\n  </strong>\n  : The OS should facilitate data transfer between USB devices and software applications, allowing users and applications to access peripheral functionalities.\n </li>\n</ul>\n<h3>\n Summary\n</h3>\n<p>\n USB\u2019s versatility allows it to support both time-sensitive and non-time-sensitive data transfers for a wide variety of devices. Its flexibility, compared to other older interfaces, makes it ideal for almost any peripheral. Additionally, USB\u2019s comprehensive operating system support, including Windows, macOS, and Linux, makes it an accessible and reliable choice for developers looking to create compatible devices and software. Whether it\u2019s for real-time data needs or general peripheral communication, USB offers a powerful and flexible solution.\n</p>\n"}, "Page 30": {"response": "<h3>\n USB Operating System Support and Peripheral Requirements\n</h3>\n<p>\n USB's seamless integration into operating systems and its reliance on specific hardware in peripherals make it an ideal choice for device communication. Here's a clearer breakdown of how operating systems support USB devices and what peripheral hardware needs to function correctly.\n</p>\n<h4>\n 1.\n <strong>\n  Operating System Support for USB\n </strong>\n</h4>\n<p>\n Operating systems must provide several features for effective USB support:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Device Detection\n   </strong>\n   : The system must be able to detect when USB devices are attached or removed, automatically adjusting to changes in the connected hardware.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Communication with Devices\n   </strong>\n   : Once a device is connected, the operating system must communicate with it to understand the necessary data transfer protocols and ensure smooth operation.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Driver Mechanisms\n   </strong>\n   : The operating system must provide a mechanism that allows software drivers to communicate with both the computer\u2019s USB hardware and the applications that interact with USB devices.\n  </p>\n</li>\n</ul>\n<p>\n Beyond these core functionalities, operating systems also offer\n <strong>\n  class drivers\n </strong>\n for common devices. For example, Windows provides built-in drivers for devices such as keyboards, mice, printers, and audio devices. These drivers allow applications to access the devices without needing additional development from the user. However, if the operating system doesn\u2019t include a suitable driver for a specific peripheral, the vendor of that device must provide the driver.\n</p>\n<p>\n For peripherals that aren\u2019t part of the commonly supported classes, USB controller vendors often offer drivers to facilitate communication. These drivers are built to work with specific USB controllers and can be used by developers when creating custom devices.\n</p>\n<h4>\n 2.\n <strong>\n  Windows Driver Model (WDM)\n </strong>\n</h4>\n<p>\n Windows uses the\n <strong>\n  Windows Driver Model (WDM)\n </strong>\n , which defines a standardized framework for writing device drivers. This model simplifies driver development by allowing a single driver to work across multiple versions of Windows, from Windows 98 to the latest editions. However, in some cases, devices may need different drivers depending on the version of Windows being used, such as one for Windows 98/Me and another for Windows 2000/XP.\n</p>\n<p>\n One significant advantage of USB is that Windows includes low-level drivers that handle USB hardware communication. This built-in support makes writing USB device drivers easier compared to drivers for other interfaces, which often require more complex, low-level management.\n</p>\n<h4>\n 3.\n <strong>\n  Peripheral Hardware Requirements\n </strong>\n</h4>\n<p>\n On the hardware side, every USB device requires a\n <strong>\n  controller chip\n </strong>\n that manages the details of USB communication. This chip is crucial because it handles tasks such as:\n</p>\n<ul>\n<li>\n  Managing data transfers between the device and the host.\n </li>\n<li>\n  Ensuring the device follows USB protocols for error detection and retries.\n </li>\n<li>\n  Handling power management and communication timing.\n </li>\n</ul>\n<p>\n Some USB controllers offer additional features or specialized capabilities to meet the needs of particular devices. These controllers are essential for ensuring that the device can communicate effectively with the host system over the USB interface.\n</p>\n<h3>\n Summary\n</h3>\n<p>\n Operating system support for USB involves several essential functions, including device detection, communication, and driver management. Class drivers provided by the operating system simplify peripheral integration, though custom devices may require specific drivers from the peripheral vendor. The Windows Driver Model (WDM) helps developers create drivers that work across various Windows versions. On the hardware side, every USB device requires a controller chip to manage communication and adhere to USB protocols. This combination of software and hardware support makes USB a versatile and developer-friendly interface for a wide range of devices.\n</p>\n"}, "Page 31": {"response": "<h3>\n USB Controller Requirements and the USB Implementers Forum\n</h3>\n<h4>\n 1.\n <strong>\n  USB Controller and Peripheral Requirements\n </strong>\n</h4>\n<p>\n USB peripherals require a\n <strong>\n  USB controller\n </strong>\n to handle the communication with the host system. There are two main types of controllers:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Complete Microcontrollers\n   </strong>\n   : These controllers integrate a CPU, program memory, data memory, and a USB interface all in one chip. They are typically simpler to use because the necessary components are included on a single device.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    External CPU-based Controllers\n   </strong>\n   : Some controllers require an external CPU that communicates with the USB controller to manage the data transfer and communication with the host system.\n  </p>\n</li>\n</ul>\n<p>\n The USB peripheral is responsible for responding to data requests from the host, particularly those related to identifying and configuring the device. It also handles reading and writing other data on the bus. Depending on the controller, some functions may be pre-programmed in hardware, meaning there\u2019s no need for the developer to program these tasks.\n</p>\n<p>\n Many USB controllers are built on popular microcontroller architectures, such as\n <strong>\n  Intel\u2019s 8051\n </strong>\n or\n <strong>\n  Microchip Technology\u2019s PICMicro\u00ae\n </strong>\n . These controllers are enhanced with additional circuits and machine code to support USB communication. If you're already familiar with a particular microcontroller architecture that offers a USB-capable variant, you won\u2019t need to learn an entirely new architecture. Most chip manufacturers also provide sample code, which can significantly speed up the development process.\n</p>\n<h4>\n 2.\n <strong>\n  USB Implementers Forum (USB-IF)\n </strong>\n</h4>\n<p>\n One of the major advantages of developing USB-based devices is the\n <strong>\n  USB Implementers Forum (USB-IF)\n </strong>\n , a non-profit organization founded by the companies that developed the USB specification. The mission of USB-IF is to promote the adoption and advancement of USB technology. Here\u2019s what the USB-IF offers to developers:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Information and Documentation\n   </strong>\n   : USB-IF provides access to the official USB specification documents, white papers, FAQs, and a web forum for discussing USB-related topics. This wealth of information is crucial for both beginners and experienced developers working on USB projects.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Development Tools\n   </strong>\n   : The USB-IF offers various software and hardware tools to assist with product development and testing. These tools help ensure that USB devices meet the necessary standards for proper operation.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Compliance Testing\n   </strong>\n   : The USB-IF provides compliance tests to verify that devices are USB-compatible. They also organize workshops where developers can have their products tested and, if successful, earn the right to use the official USB logo on their devices.\n  </p>\n</li>\n</ul>\n<p>\n The resources provided by USB-IF are invaluable for ensuring that USB devices are designed and built to be compatible with the USB specification, helping to streamline the development process and ensure device quality.\n</p>\n<h3>\n Summary\n</h3>\n<p>\n USB peripherals rely on a controller to manage the communication with the host system. These controllers may either be self-contained microcontrollers or external CPU-based systems. The peripherals are responsible for responding to data transfer requests and handling bus communication. Many USB controllers are based on popular architectures like the 8051 or PICMicro\u00ae, which makes the development process easier for those already familiar with these systems.\n</p>\n<p>\n The USB Implementers Forum (USB-IF) provides substantial support for USB developers through documentation, development tools, and compliance testing. Their mission is to promote USB adoption, and their resources help ensure that USB devices are properly designed and meet the necessary standards for interoperability.\n</p>\n"}, "Page 32": {"response": "<h3>\n USB Interface Limits: Understanding Its Constraints\n</h3>\n<p>\n While USB offers many benefits, such as versatility, ease of use, and power efficiency, it does have limitations that make it unsuitable for certain applications. Here\u2019s a breakdown of some of the key limits of USB:\n</p>\n<h4>\n 1.\n <strong>\n  Speed Limitations\n </strong>\n</h4>\n<p>\n Although USB is competitive in terms of speed, it is not designed to handle every task. The maximum speed of USB (480 Megabits per second for high-speed devices) is fast enough for most common peripherals. However, it lags behind the\n <strong>\n  IEEE-1394b (Firewire 800)\n </strong>\n interface, which supports speeds up to 3.2 Gigabits per second. This makes Firewire a better choice for applications that require very high data transfer rates, such as video editing or high-performance storage.\n</p>\n<h4>\n 2.\n <strong>\n  Distance Limitations\n </strong>\n</h4>\n<p>\n USB was primarily designed for desktop expansion, where peripherals are typically located relatively close to the host computer. The maximum cable length for a USB connection is 5 meters. While this can be extended to 30 meters by using hubs (linking up to five hubs and a device), this still falls short compared to other interfaces. For instance,\n <strong>\n  RS-232\n </strong>\n ,\n <strong>\n  RS-485\n </strong>\n ,\n <strong>\n  IEEE-1394b\n </strong>\n , and\n <strong>\n  Ethernet\n </strong>\n can support much longer cable lengths.\n</p>\n<p>\n To extend USB\u2019s range beyond 30 meters, a common solution is to convert the USB interface into another interface, like\n <strong>\n  RS-485\n </strong>\n , for longer-distance cabling and peripheral connections.\n</p>\n<h4>\n 3.\n <strong>\n  Lack of Peer-to-Peer Communication\n </strong>\n</h4>\n<p>\n USB communication is always between a\n <strong>\n  host\n </strong>\n (typically a PC) and a\n <strong>\n  peripheral\n </strong>\n (such as a mouse, keyboard, or printer). The host controls the communication, and the peripheral responds. Unlike other interfaces such as\n <strong>\n  IEEE-1394\n </strong>\n , USB does not allow direct peer-to-peer communication. That means one device cannot directly communicate with another device without going through the host.\n</p>\n<p>\n There is a partial workaround to this limitation with\n <strong>\n  USB On-The-Go (OTG)\n </strong>\n . OTG allows devices to function as either peripherals or limited-capability hosts. For example, an OTG-enabled device could act as a host to communicate with another peripheral, but it cannot engage in full peer-to-peer communication. Another solution for host-to-host communication is using a\n <strong>\n  PC-to-PC network bridge cable\n </strong>\n , which enables two PCs to communicate with each other by passing data through intermediary devices connected to each PC.\n</p>\n<h3>\n Conclusion\n</h3>\n<p>\n While USB has many strengths that make it suitable for a wide range of applications, its limitations, particularly in terms of speed, distance, and the inability to support peer-to-peer communication, prevent it from being a one-size-fits-all solution. For tasks that require higher data transfer speeds, longer distances, or direct device-to-device communication, other interfaces like\n <strong>\n  Firewire\n </strong>\n ,\n <strong>\n  RS-485\n </strong>\n , or\n <strong>\n  Ethernet\n </strong>\n may be more appropriate. However, USB\u2019s widespread support and versatility still make it the interface of choice for many common peripheral devices.\n</p>\n"}, "Page 33": {"response": "<h3>\n USB Limitations and Challenges\n</h3>\n<p>\n While USB is widely used and effective for many types of peripherals, it does have certain limitations, especially when compared to other interfaces. Here are some notable constraints:\n</p>\n<h4>\n 1.\n <strong>\n  Broadcasting Limitation\n </strong>\n</h4>\n<p>\n USB does not support broadcasting, meaning it cannot send a message simultaneously to multiple devices on the bus. Instead, the host must send messages to each connected device individually. If broadcasting is essential for an application, other interfaces such as\n <strong>\n  IEEE-1394\n </strong>\n or\n <strong>\n  Ethernet\n </strong>\n should be considered, as they provide this capability.\n</p>\n<h4>\n 2.\n <strong>\n  Compatibility with Legacy Hardware\n </strong>\n</h4>\n<p>\n Older (legacy) computers and peripherals often lack USB ports. In such cases, converters can be used to connect legacy devices to a USB port. These converters typically work with peripherals using RS-232, RS-485, or Centronics-type parallel ports. However, these solutions are usually limited to devices that support conventional protocols compatible with the converter\u2019s driver. For example, most\n <strong>\n  parallel-port converters\n </strong>\n are designed specifically for printers, while\n <strong>\n  RS-232 converters\n </strong>\n tend to work with a broader range of devices.\n</p>\n<p>\n For PCs that do not natively support USB, one can add USB capabilities by installing USB host-controller hardware and an operating system that supports USB. This hardware is available in the form of\n <strong>\n  PCI expansion cards\n </strong>\n or through\n <strong>\n  replacement motherboards\n </strong>\n . However, these upgrades typically require\n <strong>\n  Windows 98\n </strong>\n or later, and older hardware may require costly upgrades to meet the necessary system requirements.\n</p>\n<p>\n In contrast, if the PC uses legacy interfaces (like RS-232 or parallel ports), it is not feasible to use a converter to translate USB signals to these older formats. The cost of creating such a converter would be too high and impractical for most applications.\n</p>\n<h4>\n 3.\n <strong>\n  Challenges with Older Operating Systems\n </strong>\n</h4>\n<p>\n Many older systems, such as those running\n <strong>\n  MS-DOS\n </strong>\n , do not natively support USB. While it is technically possible to write a USB driver for DOS, few peripheral vendors provide such drivers. However, devices like\n <strong>\n  USB mice and keyboards\n </strong>\n often have support in the system's BIOS, allowing these peripherals to work even without a dedicated driver. In general, without proper drivers, USB peripherals cannot be used on older operating systems. This lack of driver support can pose significant limitations for users who need to run older software or use older systems with USB peripherals.\n</p>\n<h3>\n Conclusion\n</h3>\n<p>\n USB offers many benefits for modern peripherals, but it has limitations, particularly when it comes to broadcasting, working with legacy systems, and interacting with older operating systems. For users dealing with legacy hardware, solutions like converters or upgrading the system\u2019s hardware may help, but these options can be costly or impractical. Additionally, USB's lack of support for broadcasting and peer-to-peer communication makes it less suitable for certain specialized applications.\n</p>\n"}, "Page 34": {"response": "<h3>\n Challenges Faced by Developers in USB Integration\n</h3>\n<p>\n While USB provides many advantages for peripheral communication, developers face several challenges, especially with programming complexities and legacy hardware integration.\n</p>\n<h4>\n 1.\n <strong>\n  Protocol Complexity\n </strong>\n</h4>\n<p>\n One of the key difficulties when working with USB is understanding and implementing its communication protocols. Unlike simpler interfaces, such as the original\n <strong>\n  parallel printer port\n </strong>\n on PCs (which just involved digital input and output), USB devices are intelligent and require more complex handling.\n</p>\n<ul>\n<li>\n<strong>\n   Peripheral Requirements\n  </strong>\n  : USB peripherals must be programmed to respond to specific requests and other events on the bus. Developers need to understand the\n  <strong>\n   USB protocols\n  </strong>\n  \u2014the rules for data exchange across the USB bus.\n </li>\n<li>\n<strong>\n   Device Drivers\n  </strong>\n  : While device drivers abstract many complexities for application programmers, they still need to be well-versed in USB protocols. This makes USB more challenging compared to other interfaces, which might only require basic hardware connections and simple data exchange.\n </li>\n<li>\n<strong>\n   Complex Communication\n  </strong>\n  : With USB, applications cannot directly read or write data to simple port addresses. They must communicate through class or device drivers, which in turn interact with lower-level drivers that manage the actual USB communication. This adds layers of complexity compared to older, simpler interfaces.\n </li>\n</ul>\n<h4>\n 2.\n <strong>\n  Support for Legacy Hardware and Systems\n </strong>\n</h4>\n<p>\n While the issue of supporting older hardware and operating systems is becoming less of a problem as systems are upgraded, it remains a challenge for developers.\n</p>\n<ul>\n<li>\n<strong>\n   Upgrading Systems\n  </strong>\n  : Legacy systems (those running outdated operating systems or using older hardware) may not have native USB support. Converters or hardware upgrades may be required to make these systems USB-compatible, which can be costly or impractical in some cases.\n </li>\n<li>\n<strong>\n   Driver Support\n  </strong>\n  : Even with newer systems, if a USB peripheral does not match any supported class drivers, developers must often create custom drivers. This can be a significant hurdle for small-scale developers or those working with less common devices.\n </li>\n</ul>\n<h4>\n 3.\n <strong>\n  Obtaining a Vendor ID\n </strong>\n</h4>\n<p>\n For developers creating USB peripherals, especially small-scale developers, an additional challenge is obtaining a\n <strong>\n  Vendor ID (VID)\n </strong>\n . This is necessary to uniquely identify their products on the USB bus. Without it, peripherals may not be properly recognized by operating systems, which adds another layer of administrative and technical work for developers.\n</p>\n<h3>\n Conclusion\n</h3>\n<p>\n While USB offers powerful features and wide application potential, its complexity\u2014especially in terms of programming and legacy system support\u2014can present significant hurdles. Developers need to navigate USB's detailed protocols, and manage the challenges of supporting older systems or creating custom drivers. Additionally, smaller developers must address administrative issues like obtaining a Vendor ID to ensure their peripherals are properly identified and supported. These challenges, however, are diminishing as newer systems replace older ones, and more support is integrated into modern operating systems.\n</p>\n"}, "Page 35": {"response": "<h3>\n USB Development and Costs\n</h3>\n<p>\n Developers face several challenges when working with USB peripherals, particularly when it comes to driver development, licensing, and fees. While there are tools to help with USB development, costs and regulations can be an obstacle, particularly for small-scale developers.\n</p>\n<h4>\n 1.\n <strong>\n  Driver Development and Tools\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   Using Existing Drivers\n  </strong>\n  : If a USB peripheral's controller is supported by a pre-existing USB driver from the controller-chip vendor, developers can use or adapt this driver to simplify their development process.\n </li>\n<li>\n<strong>\n   Writing Custom Drivers\n  </strong>\n  : If a suitable driver isn't available, developers may need to write their own. Fortunately, there are toolkits available that make the task of writing USB drivers easier and more manageable.\n </li>\n</ul>\n<h4>\n 2.\n <strong>\n  Licensing and Fees\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   Free Resources\n  </strong>\n  : The USB Implementers Forum (USB-IF) provides a wealth of free resources, including USB specifications, compliance testing software, and other related documents on its website. This makes it easy for developers to access the information needed for USB development without any upfront costs.\n </li>\n<li>\n<strong>\n   Vendor ID Costs\n  </strong>\n  : However, any company that plans to distribute a USB device must pay for a\n  <strong>\n   Vendor ID\n  </strong>\n  . As of now, obtaining a Vendor ID from the USB-IF costs around\n  <strong>\n   $1500\n  </strong>\n  . This fee helps ensure that each device is uniquely identified by its Vendor ID and Product ID.\n </li>\n<li>\n<strong>\n   Membership Perks\n  </strong>\n  : If developers become a member of the USB-IF (currently at a cost of\n  <strong>\n   $2500 per year\n  </strong>\n  ), they will receive a Vendor ID as part of their membership. Members also get access to other benefits, such as the ability to attend compliance workshops for testing their devices.\n </li>\n<li>\n<strong>\n   Alternative Solutions for Low-Volume Developers\n  </strong>\n  : For developers who produce small quantities of devices, the Vendor ID fee might seem prohibitive. In such cases, some controller-chip manufacturers allow developers to use the manufacturer's Vendor ID and a unique Product ID, which bypasses the need for an individual Vendor ID, as long as the device uses the chip manufacturer's drivers.\n </li>\n</ul>\n<h3>\n Evolution of USB and Interface Development\n</h3>\n<p>\n USB's success as an interface is partly due to the convenience of using existing technologies, as it reduces the need for new designs and ensures compatibility with older peripherals.\n</p>\n<h4>\n 1.\n <strong>\n  Reasons for Interface Evolution\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   Challenges with Older Interfaces\n  </strong>\n  : Older interfaces, such as the Centronics parallel interface and RS-232 serial ports, were designed to work with specific peripherals like printers and modems. Over time, these interfaces became bottlenecks as computing power increased and the variety of peripherals grew.\n </li>\n<li>\n<strong>\n   Advantages of Using Existing Interfaces\n  </strong>\n  : To speed up the design process and make peripherals compatible with existing devices, early computer designs chose to stick with legacy interfaces. This was beneficial for users who did not want to replace their existing peripherals.\n </li>\n<li>\n<strong>\n   Limitations of Older Interfaces\n  </strong>\n  : While these older interfaces were serviceable for many years, they eventually became limiting factors. They offered slow communication speeds, limited options for expansion, and were unable to meet the growing demands of more powerful computers and increasingly complex peripheral devices.\n </li>\n</ul>\n<p>\n USB was designed to overcome many of the limitations that older interfaces had, offering faster speeds, better expansion capabilities, and more versatile support for a wide range of devices. The evolution of USB helped meet the growing demand for higher performance and compatibility across a wide variety of modern peripherals.\n</p>\n"}, "Page 36": {"response": "<h3>\n The Evolution of USB: From Tradition to Innovation\n</h3>\n<p>\n USB's development represents a significant break from traditional computer peripheral interfaces, driven by the need for improvements that outweighed the challenges and costs of change. This shift was what led to the creation of USB, which ultimately became the standard for modern peripheral connections.\n</p>\n<h4>\n 1.\n <strong>\n  The Push for Change\n </strong>\n</h4>\n<p>\n The transition from older interfaces to USB was motivated by the increasing demand for better performance, higher speeds, and greater flexibility in connecting peripherals. The desire for these enhancements was greater than the inconvenience of adapting to a new interface, making the switch to USB justifiable.\n</p>\n<h4>\n 2.\n <strong>\n  USB 2.0 Specification\n </strong>\n</h4>\n<p>\n The copyright for the USB 2.0 specification is shared among seven major corporations: Compaq, Hewlett-Packard, Intel, Lucent, Microsoft, NEC, and Philips. These companies, which are heavily involved in the computer hardware and software industries, played key roles in the development and promotion of USB 2.0. The USB Implementers Forum (USB-IF) manages the specification and offers documentation for developers and users on their website.\n</p>\n<h4>\n 3.\n <strong>\n  The Original USB (Version 1.0 and 1.1)\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   USB 1.0\n  </strong>\n  : The first version of the USB specification was released in\n  <strong>\n   January 1996\n  </strong>\n  , setting the foundation for universal connectivity across devices.\n </li>\n<li>\n<strong>\n   USB 1.1\n  </strong>\n  : In\n  <strong>\n   September 1998\n  </strong>\n  ,\n  <strong>\n   USB 1.1\n  </strong>\n  was introduced with a small but significant update: the addition of the\n  <strong>\n   interrupt OUT\n  </strong>\n  transfer type. USB 1.x refers to both versions 1.0 and 1.1.\n </li>\n</ul>\n<h4>\n 4.\n <strong>\n  USB 2.0 and Beyond\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   USB 2.0\n  </strong>\n  : Released in\n  <strong>\n   April 2000\n  </strong>\n  , this version of USB brought a major enhancement\u2014 the option to use\n  <strong>\n   high-speed\n  </strong>\n  data transfer, making USB much faster and more versatile than previous versions.\n </li>\n<li>\n<strong>\n   Engineering Change Notices (ECNs)\n  </strong>\n  : These revisions to the USB 2.0 specification introduced new connectors (like the mini-B connector), specified looser tolerances for bus pull-up and pull-down resistors, and defined new descriptor types, such as the\n  <strong>\n   Interface Association Descriptor\n  </strong>\n  .\n </li>\n</ul>\n<h4>\n 5.\n <strong>\n  Windows Support for USB\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   Windows 95 (OEM Service Release 2)\n  </strong>\n  : USB support first appeared on PCs with\n  <strong>\n   Windows 95\u2019s OEM Service Release 2\n  </strong>\n  , but it was limited and often buggy. Moreover, there weren\u2019t many USB peripherals available at the time, so USB\u2019s adoption was slow.\n </li>\n<li>\n<strong>\n   Windows 98\n  </strong>\n  : The release of\n  <strong>\n   Windows 98\n  </strong>\n  in\n  <strong>\n   June 1998\n  </strong>\n  marked a turning point. With more vendors offering USB peripherals and enhanced support, USB began to gain traction as a standard interface. The\n  <strong>\n   Windows 98 Second Edition (SE)\n  </strong>\n  further improved USB functionality by addressing many of the earlier bugs and limitations.\n </li>\n<li>\n<strong>\n   Windows Versions Supporting USB\n  </strong>\n  : This book focuses on PCs running\n  <strong>\n   Windows 98\n  </strong>\n  and later editions (Windows 2000, Windows Me, Windows XP, and Windows Server 2003). However,\n  <strong>\n   Windows NT4\n  </strong>\n  (which preceded Windows 98) does not support USB.\n </li>\n</ul>\n<h3>\n Conclusion\n</h3>\n<p>\n USB\u2019s evolution has been marked by improvements in speed, versatility, and ease of use, addressing the limitations of older peripheral interfaces. The growing support in Windows and other operating systems helped cement USB as the dominant connection standard for peripherals, with each new version of the specification further enhancing its capabilities.\n</p>\n"}, "Page 37": {"response": "<h3>\n USB 2.0: Speed and Compatibility Improvements\n</h3>\n<p>\n USB 2.0 was developed to address the need for higher speeds in USB peripherals, while maintaining backward compatibility with earlier versions like USB 1.1. This version significantly enhances USB's capabilities, making it more suitable for modern peripherals like printers, scanners, disk drives, and video devices.\n</p>\n<h4>\n 1.\n <strong>\n  Faster Data Transfer\n </strong>\n</h4>\n<p>\n One of the main improvements in USB 2.0 is its support for\n <strong>\n  480 Megabits per second (Mbps)\n </strong>\n transfer speed, which is\n <strong>\n  forty times faster\n </strong>\n than the full-speed USB 1.x interface. This upgrade allows USB to handle high-bandwidth peripherals more effectively.\n</p>\n<h4>\n 2.\n <strong>\n  Compatibility with Older USB Versions\n </strong>\n</h4>\n<p>\n USB 2.0 is\n <strong>\n  backwards compatible\n </strong>\n with USB 1.1, meaning that\n <strong>\n  USB 1.x devices\n </strong>\n can still use the same\n <strong>\n  connectors and cables\n </strong>\n as USB 2.0 devices. When a USB 2.0 peripheral is connected to a system with a USB 1.x port, it will still work, but at the slower speed supported by USB 1.x.\n</p>\n<p>\n To use the\n <strong>\n  high-speed mode\n </strong>\n of USB 2.0, however, certain conditions must be met:\n</p>\n<ul>\n<li>\n  The peripheral must be capable of high speed.\n </li>\n<li>\n  The peripheral must be connected to a\n  <strong>\n   USB 2.0 host\n  </strong>\n  computer.\n </li>\n<li>\n  All\n  <strong>\n   USB hubs\n  </strong>\n  between the host computer and the device must also be USB 2.0 compliant.\n </li>\n</ul>\n<p>\n Even when connecting a\n <strong>\n  USB 1.x device\n </strong>\n to a\n <strong>\n  USB 2.0 host\n </strong>\n through a USB 2.0 hub, the system can adjust to the slower speeds. The hub intelligently\n <strong>\n  converts between speeds\n </strong>\n , allowing for seamless communication, though it adds complexity to the hub's design. This feature ensures that\n <strong>\n  older devices\n </strong>\n still work with\n <strong>\n  newer USB 2.0 systems\n </strong>\n without requiring separate hubs for each device speed.\n</p>\n<h4>\n 3.\n <strong>\n  USB 2.0 Hubs and Devices\n </strong>\n</h4>\n<p>\n For a\n <strong>\n  USB 2.0 hub\n </strong>\n to be compliant, it must support all three speeds:\n <strong>\n  low speed\n </strong>\n ,\n <strong>\n  full speed\n </strong>\n , and\n <strong>\n  high speed\n </strong>\n . However, individual USB 2.0 devices can support different speeds or a combination of them, depending on their design.\n</p>\n<h4>\n 4.\n <strong>\n  Addressing Consumer Confusion\n </strong>\n</h4>\n<p>\n When USB 2.0 devices first became available, there was confusion about whether all of them supported\n <strong>\n  high-speed transfers\n </strong>\n . To reduce this confusion, the\n <strong>\n  USB Implementers Forum (USB-IF)\n </strong>\n introduced recommendations for labeling products. Devices that support\n <strong>\n  high speed\n </strong>\n should be marked as\n <strong>\n  \u201cHi-Speed USB\u201d\n </strong>\n , with packaging that clearly indicates\n <strong>\n  speed and compatibility\n </strong>\n . This labeling helps consumers understand which products are capable of the high-speed USB 2.0 transfer rate, rather than just relying on version numbers.\n</p>\n<h3>\n Conclusion\n</h3>\n<p>\n USB 2.0 greatly improved data transfer speeds, making USB a more viable option for high-bandwidth peripherals. It is backward compatible with USB 1.x devices, ensuring that older peripherals can still work with newer USB systems. The transition to USB 2.0 allowed for faster, more efficient data transfers while maintaining compatibility across different devices.\n</p>\n"}, "Page 38": {"response": "<h3>\n USB and Other Technologies: Comparing, Expanding, and Enhancing USB\n</h3>\n<h4>\n 1.\n <strong>\n  USB 2.0 Device Labeling and Packaging\n </strong>\n</h4>\n<p>\n To reduce confusion around\n <strong>\n  USB 2.0 devices\n </strong>\n and ensure clear communication to consumers, the\n <strong>\n  USB Implementers Forum (USB-IF)\n </strong>\n set forth packaging guidelines. Devices supporting\n <strong>\n  high speed\n </strong>\n should be labeled\n <strong>\n  \u201cHi-Speed USB\u201d\n </strong>\n or\n <strong>\n  \u201cCompatible with the USB 2.0 Specification.\u201d\n </strong>\n Products supporting only\n <strong>\n  low speed\n </strong>\n or\n <strong>\n  full speed\n </strong>\n are simply marked as\n <strong>\n  \u201cUSB\u201d\n </strong>\n with packaging stating that they are\n <strong>\n  \u201cCompatible with the USB 2.0 Specification\u201d\n </strong>\n and will work with both\n <strong>\n  USB\n </strong>\n and\n <strong>\n  Hi-Speed USB\n </strong>\n systems, peripherals, and cables.\n <strong>\n  Manufacturers\n </strong>\n are advised to avoid using\n <strong>\n  low speed\n </strong>\n or\n <strong>\n  full speed\n </strong>\n labels directly on consumer packaging to prevent misunderstandings.\n</p>\n<h4>\n 2.\n <strong>\n  USB On-The-Go (OTG)\n </strong>\n</h4>\n<p>\n The growing demand for direct communication between USB peripherals led to the introduction of\n <strong>\n  USB On-The-Go (OTG)\n </strong>\n . This feature allows devices to communicate directly with each other, without needing a computer host. For example, a user could connect a\n <strong>\n  printer directly to a camera\n </strong>\n or link\n <strong>\n  two drives\n </strong>\n together to exchange files. The\n <strong>\n  USB OTG Supplement\n </strong>\n to the USB 2.0 Specification was released in 2001, defining a\n <strong>\n  limited host function\n </strong>\n that peripherals can implement, enabling this direct communication.\n</p>\n<h4>\n 3.\n <strong>\n  Wireless USB\n </strong>\n</h4>\n<p>\n A major advancement being developed for USB is\n <strong>\n  Wireless USB\n </strong>\n , which will enable devices to communicate wirelessly at\n <strong>\n  up to 480 Mbps\n </strong>\n , maintaining the high-speed performance of USB 2.0. The\n <strong>\n  Wireless USB specification\n </strong>\n was expected to be available by\n <strong>\n  2005\n </strong>\n , providing an enhanced, wireless alternative to the traditional wired USB connections.\n</p>\n<h4>\n 4.\n <strong>\n  Comparing USB with IEEE-1394 (FireWire)\n </strong>\n</h4>\n<p>\n Another prominent interface standard for peripherals is\n <strong>\n  IEEE-1394\n </strong>\n , also known as\n <strong>\n  FireWire\n </strong>\n (particularly in Apple devices). While\n <strong>\n  IEEE-1394\n </strong>\n can offer\n <strong>\n  higher speeds\n </strong>\n and more\n <strong>\n  flexibility\n </strong>\n compared to USB, it tends to be more\n <strong>\n  expensive\n </strong>\n to implement.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Communication Model\n   </strong>\n   : In USB, a\n   <strong>\n    single host\n   </strong>\n   controls communications with multiple devices, simplifying the design of devices, which can remain inexpensive and less complex. On the other hand,\n   <strong>\n    IEEE-1394\n   </strong>\n   allows devices to communicate directly with each other, without needing a host, offering greater flexibility but requiring more complex and expensive electronics in the devices.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Data Broadcasting\n   </strong>\n   : IEEE-1394 can also broadcast data to multiple receivers simultaneously, making it ideal for applications that need to send data to multiple devices at once.\n  </p>\n</li>\n</ul>\n<h4>\n 5.\n <strong>\n  Which Interface is Better for Which Application?\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   IEEE-1394\n  </strong>\n  is better suited for applications that require\n  <strong>\n   extremely fast data transfers\n  </strong>\n  or the ability to\n  <strong>\n   broadcast\n  </strong>\n  data to multiple devices at once, such as in professional video editing or high-speed data streaming.\n </li>\n<li>\n<strong>\n   USB\n  </strong>\n  , with its more straightforward structure, is a better choice for applications where the priority is\n  <strong>\n   cost-effectiveness\n  </strong>\n  and\n  <strong>\n   simplicity\n  </strong>\n  in connecting a wide range of peripheral devices. USB\u2019s main advantages lie in its ease of use, compatibility with a broad array of devices, and simplicity in implementation, making it ideal for everyday consumer electronics like printers, keyboards, mice, and storage devices.\n </li>\n</ul>\n<h3>\n Conclusion\n</h3>\n<p>\n USB 2.0 is evolving with\n <strong>\n  new functionalities\n </strong>\n like\n <strong>\n  On-The-Go\n </strong>\n and\n <strong>\n  Wireless USB\n </strong>\n , providing more versatile options for modern computing needs. While USB is an affordable and simple solution for many devices,\n <strong>\n  IEEE-1394\n </strong>\n (FireWire) is preferred in applications demanding\n <strong>\n  faster speeds\n </strong>\n and the ability to send data to multiple devices simultaneously. Understanding the strengths and limitations of each interface helps developers choose the best option for specific use cases.\n</p>\n"}, "Page 39": {"response": "<h3>\n Comparing USB with Ethernet and Understanding Bus Components\n</h3>\n<h4>\n USB vs. Ethernet\n</h4>\n<p>\n When choosing between\n <strong>\n  USB\n </strong>\n and\n <strong>\n  Ethernet\n </strong>\n for connecting devices, it's important to consider the strengths and limitations of each interface:\n</p>\n<ul>\n<li>\n<strong>\n   Ethernet\n  </strong>\n  :\n  <ul>\n<li>\n    Can support\n    <strong>\n     longer cable lengths\n    </strong>\n    compared to USB.\n   </li>\n<li>\n    Has\n    <strong>\n     broadcasting\n    </strong>\n    capabilities, which allows communication with multiple devices at once.\n   </li>\n<li>\n<strong>\n     Supports Internet protocols\n    </strong>\n    in PCs and Ethernet-capable systems, making it ideal for network-based applications.\n   </li>\n<li>\n    However,\n    <strong>\n     Ethernet hardware\n    </strong>\n    is typically more\n    <strong>\n     complex\n    </strong>\n    and\n    <strong>\n     expensive\n    </strong>\n    compared to USB.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   USB\n  </strong>\n  :\n  <ul>\n<li>\n    More\n    <strong>\n     versatile\n    </strong>\n    with four different\n    <strong>\n     transfer types\n    </strong>\n    (e.g., control, interrupt, bulk, and isochronous), which makes it adaptable to a wider range of devices and applications.\n   </li>\n<li>\n<strong>\n     Variety of defined classes\n    </strong>\n    for different device types, making it easier to integrate diverse peripherals such as keyboards, printers, and scanners.\n   </li>\n<li>\n    Best suited for\n    <strong>\n     low- to moderate-speed\n    </strong>\n    ,\n    <strong>\n     cost-sensitive applications\n    </strong>\n    and commonly used for personal devices like drives, keyboards, and printers.\n   </li>\n<li>\n    Some devices may even include both\n    <strong>\n     USB and Ethernet\n    </strong>\n    interfaces to maximize compatibility.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n USB Bus Components\n</h4>\n<p>\n The\n <strong>\n  USB system\n </strong>\n consists of several key components that work together to enable communication between devices and the host system:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Host\n   </strong>\n   : This is typically a\n   <strong>\n    PC\n   </strong>\n   or another type of computer that manages communication on the USB bus. The host contains the following important components:\n  </p>\n<ul>\n<li>\n<strong>\n     Host Controller\n    </strong>\n    : Responsible for formatting and transmitting data over the USB bus, as well as receiving and converting incoming data into a format that the operating system can understand. It also manages the overall communication on the bus.\n   </li>\n<li>\n<strong>\n     Root Hub\n    </strong>\n    : This is the central component that connects the host to the USB devices. It has one or more connectors for attaching devices and is responsible for detecting when devices are connected or removed, processing requests from the host, and facilitating the data transfer between devices and the host controller.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Devices\n   </strong>\n   : These are the\n   <strong>\n    peripherals\n   </strong>\n   (like printers, scanners, and external drives) and\n   <strong>\n    hubs\n   </strong>\n   that connect to the USB bus. A\n   <strong>\n    hub\n   </strong>\n   is used to expand the number of available ports for connecting devices. Each device needs to have built-in\n   <strong>\n    circuits and code\n   </strong>\n   that allow it to communicate with the host system through the USB bus.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Cables and Connectors\n   </strong>\n   : USB specifies the\n   <strong>\n    types of cables\n   </strong>\n   and\n   <strong>\n    connectors\n   </strong>\n   that physically connect devices to hubs and the host, ensuring standardization and compatibility across various devices and systems.\n  </p>\n</li>\n</ul>\n<p>\n By understanding these components, developers can effectively design and work with USB systems, ensuring that data is properly transmitted and devices are correctly managed.\n</p>\n"}, "Page 40": {"response": "<h3>\n USB Topology: Tiered Star Configuration\n</h3>\n<p>\n USB uses a\n <strong>\n  tiered star topology\n </strong>\n to arrange the connections between the host and devices. Here's a breakdown of this structure:\n</p>\n<ul>\n<li>\n<strong>\n   Hub as the Center\n  </strong>\n  : At the core of each \"star\" is a\n  <strong>\n   hub\n  </strong>\n  , which serves as the central point for connecting various devices.\n </li>\n<li>\n<strong>\n   Connections to Devices\n  </strong>\n  : Each point on the \"star\" represents a\n  <strong>\n   device\n  </strong>\n  (such as a printer, keyboard, or storage device), and these devices are connected to ports on the hub.\n </li>\n<li>\n<strong>\n   Number of Ports\n  </strong>\n  : The hubs typically have 2, 4, or 7 ports to accommodate multiple devices.\n </li>\n<li>\n<strong>\n   Expandable\n  </strong>\n  : Additional hubs can be connected to expand the system further, allowing for more devices to be attached, creating a tiered structure.\n </li>\n</ul>\n<p>\n This configuration ensures efficient and scalable connectivity, where hubs can act as the central connection point for multiple devices, and the system can easily grow with additional hubs and devices.\n</p>\n"}, "Page 41": {"response": "<h3>\n USB Topology and Key Terms\n</h3>\n<h4>\n Tiered Star Topology and Communication\n</h4>\n<p>\n USB uses a\n <strong>\n  tiered star topology\n </strong>\n to connect devices to the host controller. Here's how this works:\n</p>\n<ul>\n<li>\n<strong>\n   Physical vs Logical Connections\n  </strong>\n  : The physical setup involves hubs and devices arranged in a star pattern, where each hub serves as a central connection point. However, for communication purposes, only the\n  <strong>\n   logical connection\n  </strong>\n  matters. The host and device don't need to worry about how many hubs the signal passes through.\n </li>\n<li>\n<strong>\n   Single Device Communication\n  </strong>\n  : USB allows only one device to communicate with the host controller at a time. To increase bandwidth and manage multiple devices, PCs can use multiple host controllers.\n </li>\n<li>\n<strong>\n   Hub Cascading\n  </strong>\n  : You can connect up to\n  <strong>\n   five external hubs in a series\n  </strong>\n  , creating a hierarchy or tier. This allows for a total of\n  <strong>\n   127 peripherals and hubs\n  </strong>\n  , including the root hub. However, managing this many devices through a single host controller may not be practical.\n </li>\n</ul>\n<p>\n In some cases, especially with\n <strong>\n  compound devices\n </strong>\n (which combine both a peripheral and a hub), devices might appear to be connected in a\n <strong>\n  daisy-chain\n </strong>\n style, but in reality, the USB system is more flexible and can accommodate more complex configurations.\n</p>\n<h4>\n Key USB Terms\n</h4>\n<p>\n In the world of USB, certain terms have specific meanings:\n</p>\n<ul>\n<li>\n<strong>\n   Function\n  </strong>\n  : A\n  <strong>\n   function\n  </strong>\n  refers to a device or capability provided to the host by a peripheral. Examples include a\n  <strong>\n   mouse\n  </strong>\n  ,\n  <strong>\n   speakers\n  </strong>\n  , or\n  <strong>\n   keyboard\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Hub\n  </strong>\n  : A\n  <strong>\n   hub\n  </strong>\n  is a device that connects multiple peripherals to the host controller. It allows communication between the host and peripherals.\n </li>\n<li>\n<strong>\n   Device\n  </strong>\n  : Any hardware that connects to the USB system and performs a specific function, such as a printer, scanner, or flash drive.\n </li>\n<li>\n<strong>\n   USB Port\n  </strong>\n  : A\n  <strong>\n   USB port\n  </strong>\n  is the physical interface on a computer or device where USB peripherals are connected. It differs from other ports like\n  <strong>\n   RS-232\n  </strong>\n  , which serve different purposes and have distinct\n </li>\n</ul>\n"}, "Page 42": {"response": "<h3>\n USB Device Configurations\n</h3>\n<p>\n There are several ways to configure USB devices when connecting them to a host PC. Here are a few possible setups for a PC that has two USB ports. These configurations highlight how devices, including hubs and peripherals, can be connected in various ways to maximize the use of the available ports, making the system flexible and adaptable to different needs.\n</p>\n"}, "Page 43": {"response": "<h3>\n Key USB Terms and Concepts\n</h3>\n<h4>\n Function\n</h4>\n<p>\n In USB terminology, a function is a device that provides a capability to the host. For example, a mouse, a set of speakers, or a data-acquisition unit can each be considered a function. A single physical device can contain more than one function, enabling it to serve multiple purposes.\n</p>\n<h4>\n Hub\n</h4>\n<p>\n A hub is a device that facilitates communication between the host and other USB devices. It has one upstream connector for connecting to the host and one or more downstream connectors that allow connections to other devices or embedded internal components. These downstream connectors are essentially USB ports.\n</p>\n<ul>\n<li>\n  A\n  <strong>\n   1.x hub\n  </strong>\n  repeats USB traffic, manages power, and responds to status and control messages.\n </li>\n<li>\n  A\n  <strong>\n   2.0 hub\n  </strong>\n  adds the ability to support high-speed transfers and can convert between different speeds if needed.\n </li>\n</ul>\n<h4>\n Device\n</h4>\n<p>\n In USB, a device refers to either a function or a hub. The exception is compound devices, which contain both a hub and one or more functions. These devices are treated as if the hub and functions are separate devices, each with its unique address on the bus.\n</p>\n<ul>\n<li>\n  A\n  <strong>\n   composite device\n  </strong>\n  is a device that offers multiple functions through independent interfaces. Although it only has one address on the bus, each interface has its own function and can require a different device driver on the host. For example, a composite device may have one interface for audio functionality and another for a control panel. Some documentation may use \"composite device\" to describe any device whose function is defined by its interface descriptor, regardless of whether there are multiple interfaces.\n </li>\n</ul>\n<h4>\n Port\n</h4>\n<p>\n A\n <strong>\n  port\n </strong>\n is essentially a location on a computer or device where circuits can be connected to peripherals. These circuits are typically attached to a connector, allowing the connection of cables. Some peripheral circuits are directly wired to a port. In the context of USB, software is used to monitor and control the circuits within these ports to facilitate com\n</p>\n"}, "Page 44": {"response": "<h3>\n USB Port and Communication Differences\n</h3>\n<h4>\n USB Ports vs. Traditional Ports\n</h4>\n<p>\n USB ports differ from many other types of ports like RS-232 in terms of how they handle data transmission. While traditional ports, such as RS-232, each have their own independent data path, USB ports share a single path to the host. With USB, multiple devices connect to the same data bus, and only one device or the host can transmit data at any given time. This shared data path means that all USB devices connected to a host share the bandwidth of that bus.\n</p>\n<p>\n For example, in RS-232, two ports can independently transmit and receive data simultaneously, each with its own dedicated cable and data path. In contrast, USB operates with a single shared data path, meaning devices cannot send data at the same time. A USB host can have multiple host controllers, each with its own dedicated bus, allowing for more efficient data management across devices.\n</p>\n<p>\n In addition to connecting devices through a host, USB allows hubs to exist externally to the host\u2019s controller, extending the number of devices that can connect to the system.\n</p>\n<h3>\n Responsibilities of the Host and Devices\n</h3>\n<h4>\n Host Responsibilities\n</h4>\n<p>\n The host computer plays a central role in managing communication between the connected USB devices. It is responsible for managing the data path and coordinating how and when data is transmitted. The host hardware consists of a\n <strong>\n  USB host controller\n </strong>\n and a\n <strong>\n  root hub\n </strong>\n , which together manage the USB ports and facilitate communication with connected devices.\n</p>\n<p>\n On the software side, the operating system provides the necessary framework for drivers to communicate with the USB hardware, ensuring proper coordination and data exchange between the host and the peripherals.\n</p>\n<h4>\n Device Responsibilities\n</h4>\n<p>\n While the host handles most of the communication management, each connected USB device must have the intelligence to respond to requests from the host and handle bus events. This means that even though the host controller is primarily responsible for managing data traffic, each device must be capable of receiving and responding to communication from the host as well as from th\n</p>\n"}, "Page 45": {"response": "<h3>\n Host Controller and Device Management\n</h3>\n<h4>\n USB Host Controller and Device Recognition\n</h4>\n<p>\n Most modern PCs come equipped with at least one USB host controller, often with multiple USB ports. These host controllers are essential for managing data exchanges between the computer and connected USB devices. If the motherboard does not include a USB host controller, it can be added through an expansion card connected to the PCI bus. In portable computers, USB controllers are available as PC cards.\n</p>\n<p>\n The host controller is responsible for managing the entire USB bus and ensuring that devices on the bus can communicate effectively. It must recognize what devices are connected and understand each device's capabilities. Since there are often multiple devices, each with different data transfer needs, it is the host\u2019s job to coordinate these communication efforts and ensure smooth data exchanges. Managing these various devices efficiently is a critical and complex task for the host controller.\n</p>\n<p>\n Fortunately, much of the complexity is handled by the host-controller hardware and the drivers provided by the operating system (such as Windows). This allows the host to manage devices without requiring direct interaction with the application's code. Devices that connect to the USB bus must have corresponding device drivers that allow the application to communicate with them. Some devices can use drivers that are built into Windows, while others may require drivers provided by the manufacturer.\n</p>\n<h4>\n Application and Driver Interaction\n</h4>\n<p>\n For developers, the good news is that most applications don\u2019t need to understand the intricate details of how USB works. Instead, they use standard operating system functions that are widely supported across programming languages to send and receive data from devices. The operating system handles the specifics of whether a device is using USB or another type of interface, simplifying application development.\n</p>\n<h4>\n Host Controller Tasks\n</h4>\n<p>\n The host controller performs several key functions, starting with\n <strong>\n  device detection\n </strong>\n . Upon powering up the system, it detects all attached USB devices via the hubs. This process is called\n <strong>\n  enumeration\n </strong>\n , where the host assigns a unique address to each device and requests further details about the device. Any time a device is added or removed, the host system updates its device list, ensuring that applications are always aware of the current state of the bus.\n</p>\n<p>\n In summary, the host controller plays a crucial role in the USB system, coordinating device communication, managing drivers, and ensuring that the bus operates efficiently even when multiple devi\n</p>\n"}, "Page 46": {"response": "<h3>\n Host Controller Responsibilities: Managing Data, Errors, and Power\n</h3>\n<h4>\n Managing Data Flow\n</h4>\n<p>\n The host controller is responsible for managing the flow of data on the USB bus. Multiple peripherals may want to transmit data simultaneously, so the host controller organizes the available time on the bus into time segments called\n <strong>\n  frames\n </strong>\n and\n <strong>\n  microframes\n </strong>\n . Each transmission is allocated a portion of a frame or microframe, depending on the bandwidth required.\n</p>\n<p>\n For transfers that require specific timing (such as real-time data), the host guarantees the required amount of time in each frame for the device. During the\n <strong>\n  enumeration\n </strong>\n process, the device\u2019s driver requests the necessary bandwidth. If sufficient bandwidth isn\u2019t available, the host prevents communication from starting until the requested bandwidth becomes available. If no guaranteed timing is required for certain transfers, they will use the remaining portion of the frames and may need to wait if the bus is already busy.\n</p>\n<h4>\n Error Checking\n</h4>\n<p>\n Error checking is another critical responsibility of the host controller. When the host transmits data, it adds error-checking bits. When a device receives the data, it performs its own calculations and compares the results to the error-checking bits sent by the host. If there\u2019s a mismatch, the device does not acknowledge the data, and the host will retransmit it.\n</p>\n<p>\n USB also supports one type of transfer that does not allow retransmission in order to maintain a steady transfer rate. The host also performs error checking on the data it receives from devices. If any errors are detected, the host can notify the device\u2019s driver, which can then alert the application to take the necessary corrective actions.\n</p>\n<h4>\n Power Management\n</h4>\n<p>\n In addition to handling data transmission, the host is also responsible for providing power to the connected devices. USB cables include +5V and ground wires, which supply power to the devices. The host provides power to devices during power-up or when they are attached, and it coordinates with the devices to ensure efficient power usage.\n</p>\n<p>\n High-power, bus-powered devices can draw up to 500 milliamps of current. For battery-powered hosts or hubs, managing power consumption is essential to optimize battery life. This system allows the host to control the power allocation to all devices on the bus, helping to conserve energy when possible.\n</p>\n<p>\n In summary, the host controller not only facilitates the transmission of data but also ensures error-free communication and effective power distribution acros\n</p>\n"}, "Page 47": {"response": "<h3>\n Peripheral Device Responsibilities: Responding to Communication and Data Exchange\n</h3>\n<h4>\n Power Management for Peripherals\n</h4>\n<p>\n The host provides power to connected devices through the USB cable. However, not all devices require the same amount of power. Some ports on the host may only support low-power devices, which are limited to drawing up to\n <strong>\n  100 milliamps\n </strong>\n . Devices that need more power can either draw it directly from the host (up to 500 milliamps for high-power devices) or use an independent power supply.\n</p>\n<h4>\n Data Exchange with Peripherals\n</h4>\n<p>\n The primary task of the host is to exchange data with peripherals. There are two main scenarios for data transfers:\n</p>\n<ol>\n<li>\n<strong>\n   Polling or Scheduled Transfers\n  </strong>\n  : In some cases, the device driver may request data exchanges to happen at specific intervals.\n </li>\n<li>\n<strong>\n   On-Demand Communication\n  </strong>\n  : In other cases, data exchange only occurs when triggered by an application or another software component.\n </li>\n</ol>\n<p>\n The device driver monitors the process and reports any issues to the application, ensuring proper data communication.\n</p>\n<h4>\n Peripheral Device's Role\n</h4>\n<p>\n The responsibilities of the peripheral are closely related to those of the host but with some important distinctions:\n</p>\n<ul>\n<li>\n<strong>\n   Initiating Communication\n  </strong>\n  : Unlike the host, a peripheral cannot initiate communication on its own. It must wait for a communication request from the host. An exception to this rule is the\n  <strong>\n   remote wakeup feature\n  </strong>\n  , which allows peripherals to request communication from the host.\n </li>\n<li>\n<strong>\n   Monitoring Bus Communication\n  </strong>\n  : The peripheral\u2019s USB controller is responsible for much of the device's functionality in hardware. The device\u2019s firmware (software instructions that control the device) supports this controller, with the amount of support varying depending on the chip.\n </li>\n</ul>\n<h4>\n Detecting Directed Communications\n</h4>\n<p>\n Each USB device monitors the bus for communications directed to its specific address. Here's how this works:\n</p>\n<ul>\n<li>\n  The peripheral checks if the address in an incoming communication matches its assigned device address.\n </li>\n<li>\n  If the address does not match, the device ignores the communication.\n </li>\n<li>\n  If the address matches, the device stores the incoming data in its\n  <strong>\n   receive buffer\n  </strong>\n  and triggers an interrupt to notify the system that data has arrived.\n </li>\n</ul>\n<p>\n Most of the operations related to monitoring and responding to communications are handled by the hardware of the USB chip, requiring minimal intervention from the device firmware until a communication matching the device's address is detected.\n</p>\n<p>\n In summary, peripherals mainly wait for the host to initiate communication. They are responsible for receiving data directed to them and notifying the system wh\n</p>\n"}, "Page 48": {"response": "<h3>\n Peripheral Device Responsibilities: Responding to Requests, Error Checking, and Power Management\n</h3>\n<h4>\n Responding to Standard Requests\n</h4>\n<p>\n When a USB device powers up or is attached to a powered system, it must respond to standard requests from the host, especially during the\n <strong>\n  enumeration\n </strong>\n process. After this initial communication, the host can send additional requests at any time. These requests allow the host to:\n</p>\n<ul>\n<li>\n  Query the device\u2019s capabilities.\n </li>\n<li>\n  Check the device\u2019s status.\n </li>\n<li>\n  Request specific actions from the device.\n </li>\n</ul>\n<p>\n Upon receiving a request, the device will:\n</p>\n<ul>\n<li>\n  Place the requested data or status information into a\n  <strong>\n   transmit buffer\n  </strong>\n  to send back to the host.\n </li>\n<li>\n  For some requests, such as selecting a configuration, the device may also perform other actions beyond just responding with information.\n </li>\n</ul>\n<p>\n The USB specification defines\n <strong>\n  eleven standard requests\n </strong>\n , although additional requests may be defined by a device\u2019s class or vendor. However, a device is not required to fulfill every request. It only needs to respond in a way that the host can understand. For example, if the host requests a configuration that the device does not support, the device will respond with a code indicating that the configuration is unavailable.\n</p>\n<h4>\n Error Checking\n</h4>\n<p>\n Like the host, the device is responsible for adding\n <strong>\n  error-checking bits\n </strong>\n to the data it sends. When the device receives data that includes error-checking bits, it performs the necessary calculations to check for errors. Based on the results, the device will either:\n</p>\n<ul>\n<li>\n  Acknowledge the successful receipt of data, or\n </li>\n<li>\n  Indicate an error, prompting the host to re-transmit the data.\n </li>\n</ul>\n<p>\n These error-checking functions are typically handled by the hardware of the USB controller, requiring no programming from the device's firmware. Additionally, when the device sends data, it detects the acknowledgment signal returned by the host to confirm that the data has been received successfully.\n</p>\n<h4>\n Managing Power\n</h4>\n<p>\n USB devices can either be\n <strong>\n  bus-powered\n </strong>\n or have their own external power supply. For\n <strong>\n  bus-powered\n </strong>\n devices, managing power is crucial:\n</p>\n<ul>\n<li>\n  When there is no communication on the bus, the device must limit the current it draws from the host to conserve energy.\n </li>\n<li>\n  If the host enters a low-power state, communication on the bus stops, including the periodic timing signals that the host typically sends.\n </li>\n<li>\n  Upon detecting no bus activity for\n  <strong>\n   three milliseconds\n  </strong>\n  , the device must enter a\n  <strong>\n   Suspend state\n  </strong>\n  , during which it must minimize its power usage by further limiting the current drawn from the bus.\n </li>\n</ul>\n<p>\n These power management tasks ensure that USB devices can conserve power when not in use, especially in battery-power\n</p>\n"}, "Page 49": {"response": "<h3>\n Power Management, Data Exchange, and Device Functions\n</h3>\n<h4>\n Power Management During Suspend State\n</h4>\n<p>\n USB devices that are\n <strong>\n  bus-powered\n </strong>\n must carefully manage power to avoid unnecessary energy consumption. When there is no activity on the bus, the device must enter the\n <strong>\n  Suspend state\n </strong>\n after detecting a three-millisecond period of inactivity. In this state, the device reduces its current consumption.\n</p>\n<ul>\n<li>\n  Devices that\n  <strong>\n   do not support remote wakeup\n  </strong>\n  should consume no more than\n  <strong>\n   500 microamperes\n  </strong>\n  while in the Suspend state.\n </li>\n<li>\n  Devices that\n  <strong>\n   support remote wakeup\n  </strong>\n  can draw up to\n  <strong>\n   2.5 milliamperes\n  </strong>\n  , but this is only applicable if the host has enabled the remote-wakeup feature.\n </li>\n</ul>\n<p>\n Even in the Suspend state, the device must remain active enough to detect bus activity and exit the Suspend state when communication resumes.\n</p>\n<h4>\n Exchanging Data with the Host\n</h4>\n<p>\n The main function of a USB device is to exchange data with the host. After a device is properly configured, it must be ready to handle communications, which may involve sending or receiving data or status information.\n</p>\n<p>\n When data is sent from the host to the device, the device must:\n</p>\n<ul>\n<li>\n  Acknowledge the receipt of data.\n </li>\n<li>\n  Indicate whether it is able to handle the data or if it is too busy to process the request.\n </li>\n</ul>\n<p>\n Similarly, when data is sent from the device to the host, the device must:\n</p>\n<ul>\n<li>\n  Respond by either transmitting the requested data or by providing a code indicating that no data is available or that the device is too busy to respond.\n </li>\n</ul>\n<p>\n The device's\n <strong>\n  controller chip\n </strong>\n handles the majority of the data formatting, including:\n</p>\n<ul>\n<li>\n  Adding\n  <strong>\n   error-checking bits\n  </strong>\n  for data being transmitted.\n </li>\n<li>\n  Performing error-checking on data received from the host.\n </li>\n<li>\n  Managing the transmission and reception of data bits on the bus.\n </li>\n</ul>\n<p>\n Devices like\n <strong>\n  mice\n </strong>\n ,\n <strong>\n  data-acquisition units\n </strong>\n , and\n <strong>\n  printers\n </strong>\n must also perform their specific tasks. For example:\n</p>\n<ul>\n<li>\n  A mouse must detect movement and button clicks.\n </li>\n<li>\n  A data-acquisition unit must read data from sensors.\n </li>\n<li>\n  A printer must convert received data into printed images.\n </li>\n</ul>\n<p>\n In summary, the device's firmware and hardware handle the necessary communication and data management with the host, allowing the device to focus on its specialized\n</p>\n"}, "Page 50": {"response": "<h3>\n USB Speeds and Transfer Types\n</h3>\n<h4>\n Device Controller Speeds\n</h4>\n<p>\n USB devices and hubs support varying speeds. Most hubs support\n <strong>\n  low-speed\n </strong>\n and\n <strong>\n  full-speed\n </strong>\n devices, except for certain hubs in compound devices, where all functions operate at a single speed. When using\n <strong>\n  low-speed\n </strong>\n or\n <strong>\n  full-speed\n </strong>\n peripherals, users don't need to worry about selecting or configuring speeds, as the system handles it automatically.\n</p>\n<p>\n High-speed peripherals are often\n <strong>\n  dual-speed devices\n </strong>\n that can operate both at\n <strong>\n  high speed\n </strong>\n and\n <strong>\n  full speed\n </strong>\n .\n <strong>\n  USB 1.x hosts\n </strong>\n and hubs do not support high-speed functionality, as high-speed wasn't part of the 1.x specification. However, to maintain compatibility,\n <strong>\n  high-speed devices\n </strong>\n must at least respond to basic requests (enumeration) at\n <strong>\n  full speed\n </strong>\n when connected to 1.x hosts or hubs. These devices typically also support full-speed operation in addition to high-speed.\n</p>\n<h4>\n Data Transfer Rates and Overhead\n</h4>\n<p>\n While the bus speed determines the maximum potential transfer rate, the actual data transfer rate between a peripheral and host is typically slower. This is due to overhead such as:\n</p>\n<ul>\n<li>\n<strong>\n   Identifying and synchronizing\n  </strong>\n  data\n </li>\n<li>\n<strong>\n   Error-checking bits\n  </strong>\n</li>\n<li>\n  The type of transfer being used\n </li>\n<li>\n  Bus congestion\n </li>\n</ul>\n<p>\n Therefore, the\n <strong>\n  actual data transfer rate\n </strong>\n depends on these factors and may not always reach the theoretical bus speed.\n</p>\n<h4>\n Time-Sensitive Data Transfers\n</h4>\n<p>\n USB supports two types of\n <strong>\n  time-sensitive transfers\n </strong>\n :\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Isochronous Transfers\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    These transfers have a\n    <strong>\n     guaranteed rate\n    </strong>\n    for data transfer, where the host can specify the exact number of bytes to transfer at regular intervals.\n   </li>\n<li>\n    The transfer intervals can be as frequent as every\n    <strong>\n     millisecond\n    </strong>\n    at full speed or every\n    <strong>\n     125 microseconds\n    </strong>\n    at high speed.\n   </li>\n<li>\n    However,\n    <strong>\n     isochronous transfers do not have error correction\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Interrupt Transfers\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    These transfers provide\n    <strong>\n     error correction\n    </strong>\n    and guarantee\n    <strong>\n     maximum latency\n    </strong>\n    , ensuring that the time between data transfer attempts doesn\u2019t exceed a certain period.\n   </li>\n<li>\n    The exact transfer rate is not fixed, but the maximum time between transfers is guaranteed.\n   </li>\n<li>\n    Transfer intervals vary based on speed:\n    <ul>\n<li>\n<strong>\n       Low-speed\n      </strong>\n      devices: 10\u2013255 milliseconds.\n     </li>\n<li>\n<strong>\n       Full-speed\n      </strong>\n      devices: 1\u2013255 milliseconds.\n     </li>\n<li>\n<strong>\n       High-speed\n      </strong>\n      devices: 125 microseconds to 4.096 seconds.\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>\n In summary, USB supports different speeds (low, full, and high) with specific transfer types optimized for\n <strong>\n  time-sensitive data\n </strong>\n and\n <strong>\n  error checking\n </strong>\n to meet the\n</p>\n"}, "Page 51": {"response": "<h3>\n USB Data Transfer and Development\n</h3>\n<h4>\n Bandwidth and Latency Management\n</h4>\n<p>\n Since the\n <strong>\n  USB bus\n </strong>\n is shared by multiple devices, there is no guarantee that a device will always receive the requested data rate or maximum latency. If the bus is too congested to support a device\u2019s requested transfer rate, the\n <strong>\n  host controller\n </strong>\n will reject the device's configuration attempt.\n</p>\n<p>\n To make sure a device can make use of the bandwidth reserved for it, both the\n <strong>\n  device driver\n </strong>\n and the\n <strong>\n  application software\n </strong>\n (or device firmware) must ensure that data is ready for transfer when the\n <strong>\n  host controller\n </strong>\n initiates the communication. Additionally, the receiver of the data must be ready to accept the incoming data.\n</p>\n<p>\n At\n <strong>\n  full speed\n </strong>\n and\n <strong>\n  high speed\n </strong>\n ,\n <strong>\n  bulk transfers\n </strong>\n are the fastest on an idle bus. These transfers can theoretically reach:\n</p>\n<ul>\n<li>\n<strong>\n   1.216 Megabytes per second\n  </strong>\n  at full speed\n </li>\n<li>\n<strong>\n   53.248 Megabytes per second\n  </strong>\n  at high speed\n </li>\n</ul>\n<p>\n However, the\n <strong>\n  host controller\n </strong>\n may limit the speed of a single\n <strong>\n  bulk transfer\n </strong>\n to a slower rate.\n</p>\n<p>\n Transfers that require guaranteed bandwidth, such as\n <strong>\n  high-speed interrupt\n </strong>\n and\n <strong>\n  isochronous transfers\n </strong>\n , offer a higher guaranteed rate, which can reach\n <strong>\n  24.576 Megabytes per second\n </strong>\n .\n</p>\n<p>\n For\n <strong>\n  low-speed\n </strong>\n devices, the theoretical maximum speed is\n <strong>\n  1.5 Megabits per second\n </strong>\n , but the guaranteed data transfer rate for a single transfer is\n <strong>\n  just 800 bytes per second\n </strong>\n , limited to\n <strong>\n  8 bytes every 10 milliseconds\n </strong>\n .\n</p>\n<h4>\n Developing a USB Device\n</h4>\n<p>\n Designing a USB device for a PC involves both hardware and software components. These include:\n</p>\n<ol>\n<li>\n<strong>\n   Controller Chip\n  </strong>\n  : A chip with a\n  <strong>\n   USB interface\n  </strong>\n  that enables communication between the device and the host.\n </li>\n<li>\n<strong>\n   USB Communication Code\n  </strong>\n  : Code that enables the device to handle\n  <strong>\n   USB communications\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Peripheral-Specific Hardware and Code\n  </strong>\n  : The device\u2019s internal functionality, such as data processing, input reading, and output writing, which also needs to be handled by hardware and software.\n </li>\n<li>\n<strong>\n   USB-Supporting Host\n  </strong>\n  : A host computer or device that supports USB connectivity and provides the necessary functionality for device communication.\n </li>\n</ol>\n<p>\n In summary, successful USB device development requires attention to both the hardware that handles communication and functionality, as well as the software that facilitates interaction with the host and manages data flow.\n</p>\n"}, "Page 52": {"response": "<h3>\n Developing a USB Device: Tools and Steps\n</h3>\n<h4>\n Necessary Components for USB Device Development\n</h4>\n<p>\n When designing a USB device, several elements are required both on the device and the host side to facilitate communication:\n</p>\n<ol>\n<li>\n<strong>\n   Device-Driver Software\n  </strong>\n  : On the host system, device-driver software enables\n  <strong>\n   applications\n  </strong>\n  to interact with the USB device.\n </li>\n<li>\n<strong>\n   Application Software\n  </strong>\n  : If the device is a\n  <strong>\n   standard type\n  </strong>\n  (e.g., mouse, keyboard, or disk drive), the operating system may already support it, meaning no special application software is necessary. However, if the device is non-standard, you will need custom software on the host to enable communication with the device.\n </li>\n<li>\n<strong>\n   Host Software\n  </strong>\n  : For non-standard peripherals, the host must have an application or custom software to enable users to access the device.\n </li>\n</ol>\n<h4>\n Development Tools for USB Projects\n</h4>\n<p>\n To create a USB peripheral, the following tools are essential:\n</p>\n<ul>\n<li>\n<strong>\n   Assembler or Compiler\n  </strong>\n  : This tool is used to create the\n  <strong>\n   device firmware\n  </strong>\n  , the code that runs inside the device\u2019s controller chip.\n </li>\n<li>\n<strong>\n   Device Programmer/Development Kit\n  </strong>\n  : This device stores the compiled or assembled firmware code in the controller\u2019s program memory.\n </li>\n<li>\n<strong>\n   Programming Language and Development Environment\n  </strong>\n  : For writing and debugging the\n  <strong>\n   host software\n  </strong>\n  , including the device driver, filter driver, or application code. For developing drivers specifically, you\u2019ll need access to\n  <strong>\n   Microsoft\u2019s Windows Driver Development Kit (DDK)\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Debugging Tools\n  </strong>\n  : It is highly recommended to use a\n  <strong>\n   monitor program\n  </strong>\n  for debugging device firmware and a\n  <strong>\n   protocol analyzer\n  </strong>\n  to observe USB traffic and ensure proper communication.\n </li>\n</ul>\n<h4>\n Steps in Developing a USB Project\n</h4>\n<p>\n When developing a USB project, it\u2019s important to break the process into manageable modules. Start by getting each piece working before progressing further. Key steps in the development process include:\n</p>\n<ol>\n<li>\n<strong>\n   Initial Decisions\n  </strong>\n  : Make decisions on how the project will be structured, considering aspects like firmware and host communication requirements.\n </li>\n<li>\n<strong>\n   Enumeration\n  </strong>\n  : Write and test code to ensure the device is detected and enumerated correctly by the host system.\n </li>\n<li>\n<strong>\n   Data Exchange\n  </strong>\n  : Once enumeration is successful, begin implementing the code to exchange small data blocks with the host or applications.\n </li>\n<li>\n<strong>\n   Application-Specific Code\n  </strong>\n  : Finally, add functionality specific to your application, building on the previously working data exchange functionality.\n </li>\n</ol>\n<p>\n By following these steps, you can systematically develop and test the functionality o\n</p>\n"}, "Page 53": {"response": "<h3>\n Initial Decisions and Enumerating a USB Device\n</h3>\n<h4>\n Making Initial Decisions\n</h4>\n<p>\n Before starting development on your USB device, you need to make important decisions and gather the necessary data:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Device Requirements\n   </strong>\n   : Identify the specific needs of your device, including:\n  </p>\n<ul>\n<li>\n<strong>\n     Data Transfer Needs\n    </strong>\n    : How much data does the device need to transfer, and what transfer speed is required?\n   </li>\n<li>\n<strong>\n     Error Correction\n    </strong>\n    : Does the device require error-correction during data transfer?\n   </li>\n<li>\n<strong>\n     Power Consumption\n    </strong>\n    : How much power will the device draw from the USB bus?\n   </li>\n<li>\n<strong>\n     Additional Functions\n    </strong>\n    : What other tasks does the device need to perform?\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Driver Selection\n   </strong>\n   : Based on the device\u2019s requirements, decide whether:\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     Windows built-in drivers\n    </strong>\n    will suffice.\n   </li>\n<li>\n    A\n    <strong>\n     generic device driver\n    </strong>\n    from a third-party source is required.\n   </li>\n<li>\n    A\n    <strong>\n     custom driver\n    </strong>\n    needs to be created.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Controller Chip Selection\n   </strong>\n   : Choose a\n   <strong>\n    controller chip\n   </strong>\n   that aligns with the requirements of your device and the chosen driver type.\n  </p>\n</li>\n</ol>\n<h4>\n Enumerating the USB Device\n</h4>\n<p>\n To ensure that Windows can recognize and communicate with your USB device, you must go through the enumeration process. Here\u2019s what needs to be done:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Write Enumeration Code\n   </strong>\n   : Develop the code that allows the controller chip to be enumerated by the host. This process typically involves:\n  </p>\n<ul>\n<li>\n<strong>\n     Sending Descriptors\n    </strong>\n    : The device must send descriptors, which are data structures detailing the device's USB capabilities and configuration.\n   </li>\n<li>\n<strong>\n     Responding to Requests\n    </strong>\n    : The chip must be capable of decoding and responding to the requests sent by the host during enumeration, including handling any events that occur.\n   </li>\n<li>\n    Many chip vendors provide\n    <strong>\n     example code\n    </strong>\n    that you can modify, and some chips may even require no user code to enumerate successfully.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Device Driver and INF File\n   </strong>\n   : Identify or create a\n   <strong>\n    device driver\n   </strong>\n   and an\n   <strong>\n    INF (Information) file\n   </strong>\n   . The INF file is a text file that tells Windows which driver to use for your device. If your device fits into a USB class already supported by Windows, you may be able to use an existing INF file from Windows.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Circuit Design for Testing\n   </strong>\n   : If needed, design and build the necessary circuit to test the chip and the firmware. Many chip manufacturers offer\n   <strong>\n    development boards\n   </strong>\n   that can assist with testing your design.\n  </p>\n</li>\n</ol>\n<p>\n By following these steps, you can ensure that your USB device is properly set up for communication with a host system and is ready to undergo further development.\n</p>\n"}, "Page 54": {"response": "<h3>\n Finalizing the Device Setup and Data Exchange\n</h3>\n<h4>\n Loading Code and Debugging\n</h4>\n<p>\n After preparing the initial code, follow these steps:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Load the Code\n   </strong>\n   : Upload the firmware to the device and connect it to the host system's USB port. Windows should automatically recognize and enumerate the device, adding it to the Control Panel and identifying it correctly.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Debug and Refine\n   </strong>\n   : If enumeration doesn\u2019t work as expected, troubleshoot and modify the code as necessary. Repeat this debugging process until enumeration is successful and everything works as intended.\n  </p>\n</li>\n</ol>\n<h4>\n Exchanging Data\n</h4>\n<p>\n Once the device is properly enumerated, you can proceed with adding the necessary components and functionality:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Add Functionality\n   </strong>\n   : Develop additional components and code to enable the device to perform its intended tasks. This could involve writing application-level code that communicates with and tests the device.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Final Testing\n   </strong>\n   : After debugging the application and firmware, program the finalized code into the device\u2019s controller chip and perform tests on the physical hardware.\n  </p>\n</li>\n</ol>\n<p>\n Before you proceed with testing data transfers, it's helpful to gain a deeper understanding of how the host system communicates with devices during enumeration and data exchange. This foundational knowledge will help you make informed decisions when selecting controller chips and device drivers, which will be further expl\n</p>\n"}, "Page 55": {"response": "<h3>\n Inside USB Transfers\n</h3>\n<p>\n This chapter introduces the fundamentals of USB transfers, which are essential for understanding how data moves between a host and USB devices. It provides the necessary background for understanding the four transfer types supported by USB, the enumeration process, and the standard requests involved in control transfers\u2014topics covered in more detail in the following chapters.\n</p>\n<p>\n While you don\u2019t need to absorb every bit of information to begin working on a USB project, understanding the basics of how transfers work can help when selecting transfer types, writing device firmware, and troubleshooting issues.\n</p>\n<p>\n The material in these chapters can be dense, especially if you're new to USB, so don\u2019t expect to grasp everything on your first read. However, you should come away with a general sense of how USB works and know where to find specific details when needed.\n</p>\n<p>\n For an authoritative and comprehensive guide on USB, refer to the\n <strong>\n  Universal Serial Bus Specification\n </strong>\n , available on the USB-IF\u2019s website. Note that the USB specification is more focused on the technical aspects of the USB interface and leaves out operating system or controller chip-specific details, which are often cri\n</p>\n"}, "Page 56": {"response": "<h3>\n Transfer Basics\n</h3>\n<p>\n USB communications can be broken into two main categories:\n <em>\n  enumeration communications\n </em>\n and\n <em>\n  application communications\n </em>\n .\n</p>\n<h4>\n Enumeration Communications\n</h4>\n<p>\n During\n <strong>\n  enumeration\n </strong>\n , the host system learns about the device and prepares it for data exchange. This process involves the device responding to a series of standard requests from the host. The device must recognize each request, provide the necessary information, and take any required actions. On a PC,\n <strong>\n  Windows\n </strong>\n manages this process, so developers don\u2019t need to write custom code for enumeration. However, Windows must find an\n <strong>\n  INF file\n </strong>\n that identifies the device's driver when the device is first attached. If all required files and the device firmware are correct, the enumeration process happens automatically and is transparent to users. More details on device drivers and INF files can be found in Chapter 9.\n</p>\n<h4>\n Application Communications\n</h4>\n<p>\n Once enumeration is complete and the correct driver has been loaded,\n <strong>\n  application communications\n </strong>\n begin. These involve data exchanges where applications on the host use standard functions (like the Windows API) to interact with the device. On the device side, data transfers typically involve either placing data to send in the USB controller's\n <strong>\n  transmit buffer\n </strong>\n or retrieving received data from the\n <strong>\n  receive buffer\n </strong>\n . After completing the transfer, the device must ensure it\u2019s ready for the next operation.\n</p>\n"}, "Page 57": {"response": "<h3>\n Managing Data on the Bus\n</h3>\n<p>\n USB uses two signal lines to carry data to and from all devices connected to the bus. These lines form a shared transmission path where all devices must take turns sending and receiving data. Unlike RS-232, which uses separate lines for transmitting (TX) and receiving (RX) data, USB uses a pair of wires to carry a\n <strong>\n  differential signal\n </strong>\n , with the directions alternating.\n</p>\n<p>\n The\n <strong>\n  host\n </strong>\n controls the overall data flow and ensures that transfers happen as efficiently as possible. It does so by breaking time into segments called\n <strong>\n  frames\n </strong>\n for low and full-speed transfers, or\n <strong>\n  microframes\n </strong>\n for high-speed transfers. These frames help manage the traffic on the bus.\n</p>\n<ul>\n<li>\n<strong>\n   Frames\n  </strong>\n  : At low and full speeds, a frame lasts 1 millisecond. The host can allocate portions of this frame to different transfers.\n </li>\n<li>\n<strong>\n   Microframes\n  </strong>\n  : For high-speed transfers, the host divides each frame into\n  <strong>\n   eight microframes\n  </strong>\n  , each lasting 125 microseconds. Each frame or microframe starts with a\n  <strong>\n   Start-of-Frame (SOF)\n  </strong>\n  timing reference, which helps the host synchronize the data exchange.\n </li>\n</ul>\n<p>\n In essence, the host schedules and manages when and how data is transferred by dividing time into manageable chunks and assigning each transfer a portion\n</p>\n"}, "Page 58": {"response": "<h3>\n USB Transfers and Host Speed Management\n</h3>\n<p>\n Each USB transfer is made up of one or more transactions.\n <strong>\n  Control transfers\n </strong>\n always involve multiple transactions because they consist of several stages, each made up of one or more transactions. Other transfer types may involve multiple transactions when there\u2019s more data than can fit in a single one.\n</p>\n<p>\n Depending on the host\u2019s scheduling and how quickly the device responds, a transfer\u2019s transactions might occur within a single frame or microframe, or they could span multiple frames or microframes.\n</p>\n<p>\n Since all devices share the same data path, each transaction must include a unique\n <strong>\n  device address\n </strong>\n to identify its destination. This ensures that data is correctly routed to the right device. Every piece of data a device sends is a response to a packet sent by the host.\n</p>\n<h3>\n Host and Bus Speed\n</h3>\n<p>\n USB 2.0 hosts on general-purpose PCs support\n <strong>\n  low\n </strong>\n ,\n <strong>\n  full\n </strong>\n , and\n <strong>\n  high speeds\n </strong>\n , while\n <strong>\n  1.x hosts\n </strong>\n only support low and full speeds.\n <strong>\n  Special-purpose hosts\n </strong>\n , like those in embedded systems, may not support all speed levels.\n</p>\n<ul>\n<li>\n  A\n  <strong>\n   1.x hub\n  </strong>\n  does not convert between speeds; it merely passes the data along the bus, adjusting the edge rate and signal polarity for low-speed devices.\n </li>\n<li>\n  A\n  <strong>\n   2.0 hub\n  </strong>\n  , on the other hand, acts like a remote processor with\n  <strong>\n   store-and-forward\n  </strong>\n  capabilities. It can convert between high-speed and low/full-speed traffic and helps optimize bus usage. This added intelligence in 2.0 hubs ensures high-speed bus compatibility even with 1.x hardware.\n </li>\n</ul>\n<p>\n In a high-speed USB bus,\n <strong>\n  traffic is only high-speed\n </strong>\n if:\n</p>\n<ol>\n<li>\n  The connected device is high-speed.\n </li>\n<li>\n  The host controller and all hubs between the host and device are USB 2.0 compliant.\n </li>\n</ol>\n<p>\n If a high-speed bus includes\n <strong>\n  1.x hubs\n </strong>\n , any bus segments beyond the hub (toward the devices) will operate at low or full speeds. However, traffic to and from low- and full-speed devices can still travel at high speed between the host a\n</p>\n"}, "Page 59": {"response": "<h3>\n Elements of a USB Transfer\n</h3>\n<p>\n A\n <strong>\n  USB transfer\n </strong>\n is made up of one or more\n <strong>\n  transactions\n </strong>\n , with each transaction containing\n <strong>\n  packets\n </strong>\n that hold information. To fully understand how transfers, transactions, and packets work, it's important to also understand\n <strong>\n  endpoints\n </strong>\n and\n <strong>\n  pipes\n </strong>\n , which play key roles in the transfer process.\n</p>\n<ul>\n<li>\n<strong>\n   USB hubs\n  </strong>\n  : A\n  <strong>\n   USB 2.0 hub\n  </strong>\n  switches to\n  <strong>\n   high speed\n  </strong>\n  when possible but will drop to\n  <strong>\n   low or full speed\n  </strong>\n  if necessary, depending on the connected devices and whether any\n  <strong>\n   1.x hubs\n  </strong>\n  are in the path.\n </li>\n<li>\n<strong>\n   Host controller speed\n  </strong>\n  : A\n  <strong>\n   1.x host controller\n  </strong>\n  only supports low and full speeds, even if the system has 2.0 hubs and high-speed devices connected to it. The system will still operate only at low or full speed in such cases.\n </li>\n</ul>\n"}, "Page 60": {"response": "<h3>\n Device Endpoints: the Source and Sink of Data\n</h3>\n<p>\n In USB communication,\n <strong>\n  endpoints\n </strong>\n are where data is either sent or received on a device. These endpoints are typically buffers, such as blocks of data memory or registers within the controller chip, which hold multiple bytes of data. An endpoint may store data received from the host or data waiting to be transmitted.\n</p>\n<p>\n The\n <strong>\n  host\n </strong>\n also uses buffers to hold data, but unlike devices, the host does not have endpoints. Instead, the host is responsible for initiating and completing communication with device endpoints.\n</p>\n<p>\n<strong>\n  Endpoint Definition\n </strong>\n :\n</p>\n<ul>\n<li>\n  A\n  <strong>\n   device endpoint\n  </strong>\n  is a uniquely addressable portion of a USB device that either sends or receives data during communication between the host and device.\n </li>\n<li>\n<strong>\n   Control Endpoint (Endpoint 0)\n  </strong>\n  : This endpoint is special because it can transfer data in both directions. All USB devices must have\n  <strong>\n   Endpoint 0\n  </strong>\n  configured as a control endpoint, which is used for control transfers between the host and device. Although rarely used, some devices support additional control endpoints.\n </li>\n<li>\n<strong>\n   Endpoint Addressing\n  </strong>\n  : Each endpoint has an address, which consists of an endpoint number (ranging from 0 to 15) and a direction:\n  <ul>\n<li>\n<strong>\n     IN endpoint\n    </strong>\n    : Provides data to the host.\n   </li>\n<li>\n<strong>\n     OUT endpoint\n    </strong>\n    : Receives data from the host.\n   </li>\n<li>\n    For control transfers,\n    <strong>\n     Endpoint 0\n    </strong>\n    supports both IN and OUT transfers, so it is actually a pair of IN and OUT endpoint addresses with the same number.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n<strong>\n  Endpoint Limits\n </strong>\n :\n</p>\n<ul>\n<li>\n  A device can have multiple endpoints, but only\n  <strong>\n   Endpoint 0\n  </strong>\n  is required.\n </li>\n<li>\n  Full- or high-speed devices can have up to 30 additional endpoint addresses (from 1 to 15) which support both IN and OUT transfers.\n </li>\n<li>\n  Low-speed devices are limited to ju\n </li>\n</ul>\n"}, "Page 61": {"response": "<h3>\n Types of USB Transactions: IN, OUT, and Setup\n</h3>\n<p>\n In USB communication, transactions are the basic units of data transfer, and each transaction begins with a packet. This packet contains an\n <strong>\n  endpoint number\n </strong>\n , a\n <strong>\n  direction code\n </strong>\n , and indicates whether the transaction is initiating a control transfer. The three primary types of transactions are\n <strong>\n  IN\n </strong>\n ,\n <strong>\n  OUT\n </strong>\n , and\n <strong>\n  Setup\n </strong>\n . The naming of these transaction types is from the host's perspective.\n</p>\n<h4>\n IN Transaction:\n</h4>\n<ul>\n<li>\n<strong>\n   Direction\n  </strong>\n  : From the device to the host.\n </li>\n<li>\n<strong>\n   Purpose\n  </strong>\n  : Used in all types of transfers when data or status information is sent from the device to the host.\n </li>\n<li>\n<strong>\n   Action\n  </strong>\n  : When a device receives an IN packet, it checks if it has data ready to send. If data is available, it sends it from the specified endpoint to the bus, triggering an interrupt in the device\u2019s hardware to initiate further action.\n </li>\n</ul>\n<h4>\n OUT Transaction:\n</h4>\n<ul>\n<li>\n<strong>\n   Direction\n  </strong>\n  : From the host to the device.\n </li>\n<li>\n<strong>\n   Purpose\n  </strong>\n  : Used in all transfer types for sending data or status information from the host to the device.\n </li>\n<li>\n<strong>\n   Action\n  </strong>\n  : When a device receives an OUT packet, it stores the data that follows the packet in the designated endpoint, triggering an interrupt in the device\u2019s hardware to process the data.\n </li>\n</ul>\n<h4>\n Setup Transaction:\n</h4>\n<ul>\n<li>\n<strong>\n   Direction\n  </strong>\n  : From the host to the device (like an OUT transaction).\n </li>\n<li>\n<strong>\n   Purpose\n  </strong>\n  : Specifically used in\n  <strong>\n   control transfers\n  </strong>\n  , which are used for requests such as device configuration or status checks.\n </li>\n<li>\n<strong>\n   Action\n  </strong>\n  : The Setup transaction begins a control transfer. The device must always accept and process Setup transactions, as they contain specific requests from the host.\n </li>\n</ul>\n<h4>\n Summary of Transaction Types:\n</h4>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Transaction Type\n    </strong>\n</th>\n<th>\n<strong>\n     Source of Data\n    </strong>\n</th>\n<th>\n<strong>\n     Used By Transfer Types\n    </strong>\n</th>\n<th>\n<strong>\n     Contents\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     IN\n    </strong>\n</td>\n<td>\n    Device\n   </td>\n<td>\n    All transfer types\n   </td>\n<td>\n    Data or status information\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     OUT\n    </strong>\n</td>\n<td>\n    Host\n   </td>\n<td>\n    All transfer types\n   </td>\n<td>\n    Data or status information\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Setup\n    </strong>\n</td>\n<td>\n    Host\n   </td>\n<td>\n    Control\n   </td>\n<td>\n</td>\n</tr>\n</tbody>\n</table>\n"}, "Page 62": {"response": "<h3>\n USB Pipes and Types of Transfers\n</h3>\n<h4>\n Pipes: Connecting Endpoints to the Host\n</h4>\n<p>\n Before a USB transfer can take place, a connection, called a\n <strong>\n  pipe\n </strong>\n , must be established between the device\u2019s endpoint and the host controller\u2019s software. Pipes are essential for communication between the device and the host. Here\u2019s how they work:\n</p>\n<ul>\n<li>\n<strong>\n   Establishment of Pipes\n  </strong>\n  : During the\n  <strong>\n   enumeration\n  </strong>\n  process, the host establishes pipes to communicate with the device\u2019s endpoints. If the device is disconnected, the host removes the associated pipes.\n </li>\n<li>\n<strong>\n   Types of Pipes\n  </strong>\n  : There is a\n  <strong>\n   Default Control Pipe\n  </strong>\n  for each device, which uses\n  <strong>\n   Endpoint 0\n  </strong>\n  . If the host needs different configurations or interfaces, it can request new pipes or remove unused ones.\n </li>\n<li>\n<strong>\n   Endpoint Descriptors\n  </strong>\n  : Each endpoint the device wants to use is described by an\n  <strong>\n   endpoint descriptor\n  </strong>\n  . This descriptor contains vital information that tells the host about the endpoint, including:\n  <ul>\n<li>\n<strong>\n     Endpoint address\n    </strong>\n</li>\n<li>\n<strong>\n     Transfer type\n    </strong>\n    (which determines how data is transferred)\n   </li>\n<li>\n<strong>\n     Maximum packet size\n    </strong>\n</li>\n<li>\n<strong>\n     Transfer interval\n    </strong>\n    (for certain types of transfers)\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Types of Transfers\n</h4>\n<p>\n USB supports four main types of data transfers, each designed to meet the different requirements of devices, such as transfer speed, response time, and error correction. A device can support multiple transfer types depending on what it needs to accomplish. Below is a summary of each transfer type:\n</p>\n<ul>\n<li>\n<strong>\n   Control Transfers\n  </strong>\n  :\n  <ul>\n<li>\n<strong>\n     Purpose\n    </strong>\n    : These are used for management and setup functions, like reading device information, setting addresses, and selecting configurations.\n   </li>\n<li>\n<strong>\n     Support\n    </strong>\n    : All USB devices must support control transfers. These transfers may also include\n    <strong>\n     vendor-specific requests\n    </strong>\n    that send or receive data for custom functions.\n   </li>\n<li>\n<strong>\n     Standard Functions\n    </strong>\n    : These transfers are used for essential communication and configuration tasks.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n Table 2-1, not provided here, further elaborates on the features and uses of each transfer type. Each type serves different needs, ensuring USB can efficiently hand\n</p>\n"}, "Page 63": {"response": "<h3>\n Bulk, Interrupt, and Isochronous Transfers\n</h3>\n<p>\n USB provides four types of transfers to meet the different needs of devices. Here\u2019s an overview of\n <strong>\n  Bulk\n </strong>\n ,\n <strong>\n  Interrupt\n </strong>\n , and\n <strong>\n  Isochronous transfers\n </strong>\n :\n</p>\n<h4>\n Bulk Transfers\n</h4>\n<ul>\n<li>\n<strong>\n   Purpose\n  </strong>\n  : Bulk transfers are for non-time-sensitive data, like sending a file to a printer or receiving data from a scanner. These transfers don\u2019t require an immediate rate of transfer, meaning that while faster is better, data can be delayed if necessary.\n </li>\n<li>\n<strong>\n   Characteristics\n  </strong>\n  :\n  <ul>\n<li>\n<strong>\n     Delay\n    </strong>\n    : If the bus is busy, bulk transfers can be delayed. However, if the bus is idle, these transfers happen quickly.\n   </li>\n<li>\n<strong>\n     Speed\n    </strong>\n    : When the bus is available, bulk transfers are very fast, but they don\u2019t guarantee speed under high traffic conditions.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Interrupt Transfers\n</h4>\n<ul>\n<li>\n<strong>\n   Purpose\n  </strong>\n  : These are used for devices like mice and keyboards that require fast responses at predictable intervals, though not as frequently as isochronous transfers.\n </li>\n<li>\n<strong>\n   Characteristics\n  </strong>\n  :\n  <ul>\n<li>\n<strong>\n     Timing\n    </strong>\n    : Interrupt transfers must happen at regular intervals, though the exact data size is not as important.\n   </li>\n<li>\n<strong>\n     Guaranteed Latency\n    </strong>\n    : Interrupt transfers have a guaranteed latency, meaning there\u2019s a maximum time between transfers.\n   </li>\n<li>\n<strong>\n     Use Cases\n    </strong>\n    : Mice, keyboards, and other small input devices that need fast but non-continuous communication.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Isochronous Transfers\n</h4>\n<ul>\n<li>\n<strong>\n   Purpose\n  </strong>\n  : Isochronous transfers are used for applications that require continuous data flow, such as streaming audio or video.\n </li>\n<li>\n<strong>\n   Characteristics\n  </strong>\n  :\n  <ul>\n<li>\n<strong>\n     Real-Time Delivery\n    </strong>\n    : These transfers guarantee that data will arrive at the right time (with guaranteed latency). However, they do not guarantee the speed or amount of data in case of congestion on the bus.\n   </li>\n<li>\n<strong>\n     Stream Data\n    </strong>\n    : Isochronous transfers are ideal for stream data like audio or video where the data\u2019s timing is more important than ensuring every byte is delivered.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Comparison Summary (Table 2-1)\n</h4>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Transfer Type\n    </strong>\n</th>\n<th>\n<strong>\n     Typical Use\n    </strong>\n</th>\n<th>\n<strong>\n     Low Speed Allowed?\n    </strong>\n</th>\n<th>\n<strong>\n     Max Data Rate (High Speed)\n    </strong>\n</th>\n<th>\n<strong>\n     Direction of Data Flow\n    </strong>\n</th>\n<th>\n<strong>\n     Error Correction?\n    </strong>\n</th>\n<th>\n<strong>\n     Guaranteed Delivery?\n    </strong>\n</th>\n<th>\n<strong>\n     Guaranteed Latency?\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     Control\n    </strong>\n</td>\n<td>\n    Device identification, configuration\n   </td>\n<td>\n    Yes\n   </td>\n<td>\n    15,872 bytes/millisecond\n   </td>\n<td>\n    IN and OUT\n   </td>\n<td>\n    Yes\n   </td>\n<td>\n    No\n   </td>\n<td>\n    No\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Bulk\n    </strong>\n</td>\n<td>\n    Printers, scanners, drives\n   </td>\n<td>\n    No\n   </td>\n<td>\n    53,248 bytes/millisecond\n   </td>\n<td>\n    IN or OUT\n   </td>\n<td>\n    Yes\n   </td>\n<td>\n    No\n   </td>\n<td>\n    No\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Interrupt\n    </strong>\n</td>\n<td>\n    Mouse, keyboard\n   </td>\n<td>\n    Yes\n   </td>\n<td>\n    24,576 bytes/millisecond\n   </td>\n<td>\n    IN or OUT\n   </td>\n<td>\n    Yes\n   </td>\n<td>\n    Yes\n   </td>\n<td>\n    Yes\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Isochronous\n    </strong>\n</td>\n<td>\n    Audio, video streaming\n   </td>\n<td>\n    No\n   </td>\n<td>\n    24,576 bytes/millisecond\n   </td>\n<td>\n    IN or OUT\n   </td>\n<td>\n    No\n   </td>\n<td>\n    Yes\n   </td>\n<td>\n    Yes\n   </td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<strong>\n   Control Transfers\n  </strong>\n  : Required for all devices, used for device setup and configuration.\n </li>\n<li>\n<strong>\n   Bulk Transfers\n  </strong>\n  : Non-urgent data transfers, not requiring immediate delivery but can handle large volumes.\n </li>\n<li>\n<strong>\n   Interrupt Transfers\n  </strong>\n  : Used for devices needing fast responses at predictable intervals, like input devices.\n </li>\n<li>\n<strong>\n   Isochronous Transfers\n  </strong>\n  : Critical for applications needing real-tim\n </li>\n</ul>\n"}, "Page 64": {"response": "<h3>\n Interrupt, Isochronous Transfers, and Stream vs. Message Pipes\n</h3>\n<h4>\n Interrupt Transfers\n</h4>\n<ul>\n<li>\n<strong>\n   Purpose\n  </strong>\n  : Interrupt transfers are used by devices that need periodic attention from the host, like keyboards or mice. These devices send data like keypresses or mouse movements at regular intervals.\n </li>\n<li>\n<strong>\n   Speed\n  </strong>\n  : Interrupt transfers can use any speed (low, full, or high), but low-speed devices must use interrupt transfers for data transfer.\n </li>\n<li>\n<strong>\n   Support\n  </strong>\n  : While not required for all devices, certain device classes might require interrupt transfers. For example, a device class like HID (Human Interface Device) will commonly require interrupt transfers for things like keyboards and mice.\n </li>\n</ul>\n<h4>\n Isochronous Transfers\n</h4>\n<ul>\n<li>\n<strong>\n   Purpose\n  </strong>\n  : Isochronous transfers are used for data that needs to be delivered on time, without delays. This is ideal for real-time applications like audio or video streaming.\n </li>\n<li>\n<strong>\n   Key Feature\n  </strong>\n  : These transfers ensure that data arrives on time but do not automatically correct errors. This means that occasional data errors can occur, and those errors must be acceptable for the transfer to succeed.\n </li>\n<li>\n<strong>\n   Speed Requirements\n  </strong>\n  : Only full-speed and high-speed devices can perform isochronous transfers. These types of transfers are not mandatory for all devices but may be required for specific device classes, such as audio or video streaming devices.\n </li>\n</ul>\n<h4>\n Stream vs. Message Pipes\n</h4>\n<p>\n USB defines\n <strong>\n  pipes\n </strong>\n as channels through which data flows between devices and the host. The pipes can be classified as\n <strong>\n  stream\n </strong>\n or\n <strong>\n  message\n </strong>\n pipes, depending on the data directionality and transfer type.\n</p>\n<ul>\n<li>\n<strong>\n   Message Pipes\n  </strong>\n  : Used by control transfers, these pipes support bidirectional communication. A control transfer always starts with a\n  <strong>\n   Setup\n  </strong>\n  transaction, where the host sends a request to the device. The device may then respond with data or just status information.\n  <ul>\n<li>\n<strong>\n     Bidirectional\n    </strong>\n    : A message pipe allows communication in both directions.\n   </li>\n<li>\n<strong>\n     Example\n    </strong>\n    : A control transfer may involve the host requesting a device\u2019s descriptor, with the device sending back information in response.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Stream Pipes\n  </strong>\n  : Used by all transfer types except control transfers, stream pipes allow data to travel in one direction only. These are unidirectional pipes and are used for data flows like sending file data to a printer or receiving sensor data from a device.\n  <ul>\n<li>\n<strong>\n     Unidirectional\n    </strong>\n    : Stream pipes support only one-way data transfer, either from the device to the host (IN) or from the host to the device (OUT).\n   </li>\n</ul>\n</li>\n</ul>\n<h3>\n Summary of Key Concepts\n</h3>\n<ul>\n<li>\n<strong>\n   Interrupt Transfers\n  </strong>\n  : Periodic attention for low-speed devices, not required but essential for certain classes like keyboards and mice.\n </li>\n<li>\n<strong>\n   Isochronous Transfers\n  </strong>\n  : Real-time data delivery with no error correction, used for things like streaming audio/video, but only available for full and high-speed devices.\n </li>\n<li>\n<strong>\n   Stream vs. Message Pipes\n  </strong>\n  : Stream pipes are unidirectional (for all transfer types except control), while message pipes are bidirectional and us\n </li>\n</ul>\n"}, "Page 65": {"response": "<h3>\n Stream Pipes and Initiating a USB Transfer\n</h3>\n<h4>\n Stream Pipes for Data Transfer\n</h4>\n<ul>\n<li>\n<strong>\n   Unstructured Data\n  </strong>\n  : Stream pipes are used for transfers that do not follow a specific structure defined by the USB specification. The receiving device or host simply accepts the data as it arrives, and the software on either side processes the data based on the needs of the application.\n </li>\n<li>\n<strong>\n   Application-Specific Format\n  </strong>\n  : While the USB specification doesn't define a specific format for stream pipes, the sending and receiving devices must still agree on how to interpret the data. For example, a host might request data from a device, such as temperature readings, in a predefined format. In some cases, interrupt transfers might be preferable to stream transfers, particularly when guaranteed bandwidth is needed.\n </li>\n</ul>\n<h4>\n Initiating a Transfer\n</h4>\n<ul>\n<li>\n<strong>\n   Transfer Definition\n  </strong>\n  : In USB communication, a transfer refers to the process of making and carrying out a communication request. Transfers can range from very small (sending just a byte of data) to very large (transmitting an entire file).\n </li>\n<li>\n<strong>\n   Driver Interaction\n  </strong>\n  : When a device driver on the host wants to communicate with a device, it initiates the transfer. For example, a Windows application may use standard API functions to interact with a device driver. The application may request specific actions, such as sending a file to the device or retrieving data from the device.\n </li>\n<li>\n<strong>\n   API Functions\n  </strong>\n  : To start a transfer, an application uses a handle (a reference to the device) and calls an appropriate API function. For instance, the application might request the device to send the contents of a file or retrieve data from the device. This request is passed to the device\u2019s driver, which then sends it through the necessary system drivers and finally to the host controller, initiating the actual transfer on the bus.\n </li>\n</ul>\n<h4>\n Example in Practice\n</h4>\n<ul>\n<li>\n<strong>\n   File System API\n  </strong>\n  : In cases where devices are part of standard classes (like storage devices), programming languages offer built-in APIs to simplify communication. For example, in the .NET Framework, the\n  <code>\n   Directory\n  </code>\n  and\n  <code>\n   File\n  </code>\n  classes can be used to interact with devices like drives.\n </li>\n<li>\n<strong>\n   Vendor-Specific Drivers\n  </strong>\n  : For devices not using standard classes, the vendor may provide a custom driver with its own API. For example, FTDI Chip offers the D2XX driver for devices using their controllers, providing its own set of functions to facilitate device communication.\n </li>\n</ul>\n<h3>\n Summary\n</h3>\n<ul>\n<li>\n<strong>\n   Stream Pipes\n  </strong>\n  : These are used for data that doesn\u2019t follow a strict format, allowing flexible communication. The device and host must agree on a data format for successful communication.\n </li>\n<li>\n<strong>\n   Initiating Transfers\n  </strong>\n  : Transfers begin with a request from the host\u2019s driver, which can come from an application using system-level API functions. The driver then coordinates the transfer with the host control\n </li>\n</ul>\n"}, "Page 66": {"response": "<h3>\n Transactions: The Building Blocks of a USB Transfer\n</h3>\n<h4>\n Overview of Transactions and Transfers\n</h4>\n<p>\n A USB transfer is made up of several transactions, which are the fundamental units that carry out the actual data transfer. To understand how data is communicated, it\u2019s essential to distinguish between different components like\n <strong>\n  transfers\n </strong>\n ,\n <strong>\n  transactions\n </strong>\n ,\n <strong>\n  stages\n </strong>\n ,\n <strong>\n  phases\n </strong>\n ,\n <strong>\n  data transactions\n </strong>\n ,\n <strong>\n  packets\n </strong>\n ,\n <strong>\n  Status stages\n </strong>\n , and\n <strong>\n  handshakes\n </strong>\n .\n</p>\n<ul>\n<li>\n<strong>\n   Transfers\n  </strong>\n  : These represent the overall communication process. They are the highest level of data exchange, initiated by either the host or the device.\n </li>\n<li>\n<strong>\n   Transactions\n  </strong>\n  : These are the smaller steps within a transfer. A transfer is composed of multiple transactions, each responsible for different pieces of data or control.\n </li>\n<li>\n<strong>\n   Stages and Phases\n  </strong>\n  : In the context of transfers, the term \"stages\" refers to distinct portions of the process (such as setting up or sending data), while \"phases\" are more specific steps within the stages (such as the exchange of status or data).\n </li>\n<li>\n<strong>\n   Data Transactions and Packets\n  </strong>\n  : Transactions typically involve data packets, which are the actual units of data being transferred. Each packet contains a Packet Identifier (PID), error-checking bits, and sometimes additional information.\n </li>\n</ul>\n<h4>\n The Structure of a Transfer\n</h4>\n<p>\n A typical USB transfer consists of multiple\n <strong>\n  transactions\n </strong>\n , and each of those transactions contains several\n <strong>\n  packets\n </strong>\n . These packets hold the essential elements such as the\n <strong>\n  PID\n </strong>\n and other associated data for the transfer to be completed successfully.\n</p>\n<p>\n Understanding the relationship between these components is crucial for designing and trou\n</p>\n"}, "Page 67": {"response": "<h3>\n Transaction Phases in USB Transfers\n</h3>\n<h4>\n Overview of Transaction Phases\n</h4>\n<p>\n Each USB transaction occurs in three distinct phases, which are executed sequentially:\n</p>\n<ol>\n<li>\n<strong>\n   Token Phase\n  </strong>\n  : This is the first phase where identifying information, like the device address and endpoint number, is provided. It ensures that the data is being sent to the correct destination.\n </li>\n<li>\n<strong>\n   Data Phase\n  </strong>\n  : The actual data transfer happens during this phase, where the host or device exchanges the intended information.\n </li>\n<li>\n<strong>\n   Handshake Phase\n  </strong>\n  : In the final phase, a handshake occurs to confirm the successful reception of data, error-checking, or to signal the end of a transfer.\n </li>\n</ol>\n<p>\n These phases happen in a specific order and are designed to ensure that the communication is error-free and the data reaches its destination accurately.\n</p>\n<h4>\n The Role of Packets and PIDs\n</h4>\n<p>\n Each of these phases consists of one or two packets. A\n <strong>\n  packet\n </strong>\n is a block of information that follows a specific format. Every packet begins with a\n <strong>\n  Packet Identifier (PID)\n </strong>\n , which helps identify the packet's purpose and content. The PID contains information such as the transaction type, direction, and error-checking data.\n</p>\n<ul>\n<li>\n<strong>\n   Token Phase\n  </strong>\n  : The packet contains addressing information, like the device address and endpoint number, which tells where the data should go.\n </li>\n<li>\n<strong>\n   Data Phase\n  </strong>\n  : This phase involves the actual exchange of data between the host and the device.\n </li>\n<li>\n<strong>\n   Handshake Phase\n  </strong>\n  : A confirmation packet is sent to verify the successful data transfer, ensuring that no errors occurred.\n </li>\n</ul>\n<h4>\n Transaction Flow\n</h4>\n<p>\n In any USB transfer, the flow of data happens in these phases. Depending on the transfer type, one or multiple transactions are needed to complete the entire process. For smaller amounts of data, a single transaction might suffice, while larger transfers could span multiple transactions, each carrying a portion of the data.\n</p>\n<h3>\n Summary of Transaction Types and Phases\n</h3>\n<ul>\n<li>\n<strong>\n   Setup Transactions\n  </strong>\n  : Used to send control requests to a device (Initiate control transfer).\n </li>\n<li>\n<strong>\n   OUT Transactions\n  </strong>\n  : Transfer data or status information from the host to the device.\n </li>\n<li>\n<strong>\n   IN Transactions\n  </strong>\n  : Transfer data or status information from the device to the host.\n </li>\n</ul>\n<p>\n The transaction and its three phases\u2014token, data, and handshake\u2014must occur in sequence, and each packet involved includes the appropriate PID fo\n</p>\n"}, "Page 68": {"response": "<h3>\n Phases of USB Transactions\n</h3>\n<p>\n In USB transfers, each transaction goes through several distinct phases, each serving a specific purpose to ensure data is correctly transmitted and received.\n</p>\n<h4>\n Phases of a Transaction\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Token Phase\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This phase starts when the host sends a token packet to initiate communication.\n   </li>\n<li>\n    The\n    <strong>\n     Packet ID (PID)\n    </strong>\n    in this token packet specifies the type of transaction, such as Setup, IN, OUT, or Start-of-Frame.\n   </li>\n<li>\n    The token also carries the destination endpoint address, which directs the communication to the correct device endpoint.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Data Phase\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    During this phase, either the host or the device sends or receives data in the form of a data packet.\n   </li>\n<li>\n    The PID in the data packet contains a\n    <strong>\n     data-toggle\n    </strong>\n    or\n    <strong>\n     data-sequencing\n    </strong>\n    value. This helps in managing data integrity by preventing loss or duplication when multiple data packets are involved in a transfer.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Handshake Phase\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    In this final phase, a handshake packet is sent to confirm that the data has been successfully received.\n   </li>\n<li>\n    If the data was received correctly, the device or host responds with an acknowledgment. If there was an error, a negative acknowledgment (NAK) may be sent.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Types of Transfers and Their Phases\n</h4>\n<p>\n The structure of the transactions and phases varies depending on the type of transfer. The table below summarizes how each transfer type is structured:\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Transfer Type\n    </strong>\n</th>\n<th>\n<strong>\n     Transactions\n    </strong>\n</th>\n<th>\n<strong>\n     Phases\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     Control\n    </strong>\n</td>\n<td>\n    1 or more transactions\n   </td>\n<td>\n<strong>\n     Setup Stage\n    </strong>\n    (Token, Data, Handshake),\n    <br/>\n<strong>\n     Data Stage\n    </strong>\n    (Token, Data, Handshake),\n    <br/>\n<strong>\n     Status Stage\n    </strong>\n    (Token, Data, Handshake)\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Bulk\n    </strong>\n</td>\n<td>\n    1 or more transactions\n   </td>\n<td>\n<strong>\n     Token, Data, Handshake\n    </strong>\n</td>\n</tr>\n<tr>\n<td>\n<strong>\n     Interrupt\n    </strong>\n</td>\n<td>\n    1 or more transactions\n   </td>\n<td>\n<strong>\n     Token, Data, Handshake\n    </strong>\n</td>\n</tr>\n<tr>\n<td>\n<strong>\n     Isochronous\n    </strong>\n</td>\n<td>\n    1 or more transactions\n   </td>\n<td>\n<strong>\n     Token, Data\n    </strong>\n    (No handshake phase)\n   </td>\n</tr>\n</tbody>\n</table>\n<p>\n For\n <strong>\n  Control Transfers\n </strong>\n , there are additional stages like the Setup, Data, and Status stages that involve one or more transactions. Each of these stages is crucial for the transfer to proceed correctly, especially for initiating communication or handling specific device requests. On the other hand,\n <strong>\n  Bulk\n </strong>\n and\n <strong>\n  Interrupt\n </strong>\n transfers typically follow the standard sequence of token, data, and handshake phases, while\n <strong>\n  Isochronous Transfers\n </strong>\n may not have a handshake phase but still follow token and data phases.\n</p>\n<h4>\n Special Considerations for Low-Speed Transfers\n</h4>\n<ul>\n<li>\n  In low-speed transfers, the transaction is also preceded by a\n  <strong>\n   PRE packet\n  </strong>\n  . This additional step ensures the correct synchronization and handling of data within the constraints of low-speed communication.\n </li>\n</ul>\n<p>\n This structure ensures that USB transfers are reliable, and each phase serve\n</p>\n"}, "Page 69": {"response": "<h3>\n Understanding the Packet Identifier (PID) in USB Transactions\n</h3>\n<p>\n The\n <strong>\n  Packet Identifier (PID)\n </strong>\n is an important part of USB transactions, as it helps to identify the type of packet being sent and indicates the nature of the transaction. Each PID provides key information for proper communication between the host and device. Below is an overview of the various PIDs used in USB transfers, their values, and their significance:\n</p>\n<h4>\n Token Packets (Identifying Transaction Types)\n</h4>\n<p>\n Token packets define the transaction type and are sent by the host to initiate communication with the device.\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     PID Name\n    </strong>\n</th>\n<th>\n<strong>\n     PID Value\n    </strong>\n</th>\n<th>\n<strong>\n     Transfer Types Used\n    </strong>\n</th>\n<th>\n<strong>\n     Source\n    </strong>\n</th>\n<th>\n<strong>\n     Bus Speed\n    </strong>\n</th>\n<th>\n<strong>\n     Description\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     OUT\n    </strong>\n</td>\n<td>\n    0001\n   </td>\n<td>\n    All\n   </td>\n<td>\n    Host\n   </td>\n<td>\n    All\n   </td>\n<td>\n    Specifies the device and endpoint address for an OUT (host-to-device) transaction.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     IN\n    </strong>\n</td>\n<td>\n    1001\n   </td>\n<td>\n    All\n   </td>\n<td>\n    Host\n   </td>\n<td>\n    All\n   </td>\n<td>\n    Specifies the device and endpoint address for an IN (device-to-host) transaction.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     SOF\n    </strong>\n</td>\n<td>\n    0101\n   </td>\n<td>\n    Start-of-Frame\n   </td>\n<td>\n    Host\n   </td>\n<td>\n    All\n   </td>\n<td>\n    Marks the beginning of a frame and includes the frame number.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     SETUP\n    </strong>\n</td>\n<td>\n    1101\n   </td>\n<td>\n    Control\n   </td>\n<td>\n    Host\n   </td>\n<td>\n    All\n   </td>\n<td>\n    Specifies the device and endpoint address for a Setup transaction, which is used to initiate control transfers.\n   </td>\n</tr>\n</tbody>\n</table>\n<h4>\n Data Packets (Carrying Data or Status Code)\n</h4>\n<p>\n Data packets contain the actual data or status information and are used to send or receive information between the host and device.\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     PID Name\n    </strong>\n</th>\n<th>\n<strong>\n     PID Value\n    </strong>\n</th>\n<th>\n<strong>\n     Transfer Types Used\n    </strong>\n</th>\n<th>\n<strong>\n     Source\n    </strong>\n</th>\n<th>\n<strong>\n     Bus Speed\n    </strong>\n</th>\n<th>\n<strong>\n     Description\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     DATA0\n    </strong>\n</td>\n<td>\n    0011\n   </td>\n<td>\n    All\n   </td>\n<td>\n    Host, Device\n   </td>\n<td>\n    All\n   </td>\n<td>\n    Carries data with a data-toggle and PID sequencing.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     DATA1\n    </strong>\n</td>\n<td>\n    1011\n   </td>\n<td>\n    All\n   </td>\n<td>\n    Host, Device\n   </td>\n<td>\n    All\n   </td>\n<td>\n    Similar to DATA0 but used for toggling between data packets.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     DATA2\n    </strong>\n</td>\n<td>\n    0111\n   </td>\n<td>\n    Isochronous\n   </td>\n<td>\n    Host, Device\n   </td>\n<td>\n    High\n   </td>\n<td>\n    Data packet used for isochronous transfers with PID sequencing.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     MDATA\n    </strong>\n</td>\n<td>\n    1111\n   </td>\n<td>\n    Isochronous, Split Transactions\n   </td>\n<td>\n    Host, Device\n   </td>\n<td>\n    High\n   </td>\n<td>\n    Data packet used in isochronous transfers or split transactions with PID sequencing.\n   </td>\n</tr>\n</tbody>\n</table>\n<h4>\n Handshake Packets (Carrying Status Code)\n</h4>\n<p>\n Handshake packets provide status information regarding the reception of data or the readiness of the device or host to continue.\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     PID Name\n    </strong>\n</th>\n<th>\n<strong>\n     PID Value\n    </strong>\n</th>\n<th>\n<strong>\n     Transfer Types Used\n    </strong>\n</th>\n<th>\n<strong>\n     Source\n    </strong>\n</th>\n<th>\n<strong>\n     Bus Speed\n    </strong>\n</th>\n<th>\n<strong>\n     Description\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     ACK\n    </strong>\n</td>\n<td>\n    0010\n   </td>\n<td>\n    All\n   </td>\n<td>\n    Host, Device\n   </td>\n<td>\n    All\n   </td>\n<td>\n    Indicates that the receiver accepts the error-free data packet.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     NAK\n    </strong>\n</td>\n<td>\n    1010\n   </td>\n<td>\n    Control, Bulk, Interrupt\n   </td>\n<td>\n    Device\n   </td>\n<td>\n    All\n   </td>\n<td>\n    Indicates that the receiver cannot accept data, or the sender has no data to send.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     STALL\n    </strong>\n</td>\n<td>\n    1110\n   </td>\n<td>\n    Control, Bulk, Interrupt\n   </td>\n<td>\n    Device\n   </td>\n<td>\n    All\n   </td>\n<td>\n    Indicates that the control request is not supported or the endpoint is halted.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     NYET\n    </strong>\n</td>\n<td>\n    0110\n   </td>\n<td>\n    Control, Write, Bulk OUT, Split Transactions\n   </td>\n<td>\n    Device\n   </td>\n<td>\n    High\n   </td>\n<td>\n    Indicates that the device accepts the error-free data packet but is not yet ready for another transfer, or that a hub has not yet received all the split transaction data.\n   </td>\n</tr>\n</tbody>\n</table>\n<h4>\n Summary\n</h4>\n<p>\n The\n <strong>\n  PID\n </strong>\n values in USB transactions are crucial for managing data flow and controlling how data is transmitted between devices and the host. They define the type of transaction (such as IN, OUT, Setup), carry the data in a structured format, and include status updates through handshakes (such as ACK, NAK, and STALL). Understanding these PIDs helps in debugging, optimizing, and en\n</p>\n"}, "Page 70": {"response": "<h3>\n Handshake and Token Phases in USB Transactions\n</h3>\n<p>\n In USB communication, a transaction involves several phases, each with its own purpose and specific role in ensuring successful data transfer. Two important phases are the\n <strong>\n  Handshake Phase\n </strong>\n and the\n <strong>\n  Token Phase\n </strong>\n .\n</p>\n<h4>\n Handshake Phase: Status Information\n</h4>\n<p>\n The\n <strong>\n  Handshake Phase\n </strong>\n provides status information about the data transfer and ensures that the data was received successfully. It consists of a\n <strong>\n  handshake packet\n </strong>\n , which is sent either by the host or the device. The\n <strong>\n  Packet Identifier (PID)\n </strong>\n in this packet contains a status code that indicates the result of the transfer. The status codes include:\n</p>\n<ul>\n<li>\n<strong>\n   ACK\n  </strong>\n  : The receiver has successfully received the data.\n </li>\n<li>\n<strong>\n   NAK\n  </strong>\n  : The receiver is unable to accept data, or the sender has no data to transmit.\n </li>\n<li>\n<strong>\n   STALL\n  </strong>\n  : The receiver cannot process the request, or the endpoint is halted.\n </li>\n<li>\n<strong>\n   NYET\n  </strong>\n  : The receiver is not ready to accept more data but has successfully received the last packet.\n </li>\n</ul>\n<p>\n This phase is sometimes referred to as the\n <strong>\n  status phase\n </strong>\n or\n <strong>\n  status packet\n </strong>\n , which further emphasizes its role in providing feedback about the transaction.\n</p>\n<h4>\n Token Phase: Start-of-Frame (SOF) and Timing\n</h4>\n<p>\n The\n <strong>\n  Token Phase\n </strong>\n is initiated by the host and serves to identify the type of transaction being requested (such as IN, OUT, or Setup). Additionally, a\n <strong>\n  Start-of-Frame (SOF)\n </strong>\n marker may be included in the token packet. This marker plays a critical role in timing and synchronization:\n</p>\n<ul>\n<li>\n<strong>\n   SOF Timing\n  </strong>\n  : At\n  <strong>\n   full speed\n  </strong>\n  , the host sends an SOF packet once every millisecond. At\n  <strong>\n   high speed\n  </strong>\n  , the interval is much shorter, occurring every 125 microseconds.\n </li>\n<li>\n<strong>\n   Frame Number\n  </strong>\n  : The SOF packet also includes a\n  <strong>\n   frame number\n  </strong>\n  that increments with each frame. This helps synchronize the data across the system, as all microframes within a given frame share the same frame number.\n </li>\n<li>\n<strong>\n   Device Synchronization\n  </strong>\n  : Devices may use the frame number or synchronize to the SOF marker for timing purposes, ensuring accurate coordination during transfers.\n </li>\n<li>\n<strong>\n   Preventing Low-Power Mode\n  </strong>\n  : The SOF marker also prevents devices from entering a low-power\n  <strong>\n   Suspend state\n  </strong>\n  during periods of no data traffic, ensuring they remain ready to respond.\n </li>\n</ul>\n<h4>\n Low-Speed Devices and End-of-Packet (EOP)\n</h4>\n<p>\n Unlike\n <strong>\n  full-speed\n </strong>\n and\n <strong>\n  high-speed\n </strong>\n devices,\n <strong>\n  low-speed devices\n </strong>\n do not process the SOF packet. Instead, the\n <strong>\n  hub\n </strong>\n that the low-speed device is connected to sends a simpler signal called the\n <strong>\n  End-of-Packet (EOP)\n </strong>\n or\n <strong>\n  low-speed keep-alive signal\n </strong>\n . This signal is sent once per frame, providing a basic timing reference for low-speed devices. The EOP serves to keep the device active without requiring the full SOF mechanism.\n</p>\n<h4>\n Additional Token Packet Types\n</h4>\n<p>\n Beyond the standard IN, OUT, and Setup tokens, there are special token packet types used in specific scenarios:\n</p>\n<ul>\n<li>\n<strong>\n   PRE (Preamble)\n  </strong>\n  : Sent by the host to indicate that the next packet will be low speed. This is only relevant for low-speed transactions and is issued before the low-speed packet.\n </li>\n<li>\n<strong>\n   ERR\n  </strong>\n  : Returned by a hub to report a low-speed or full-speed error in a split transaction. This is used for error reporting.\n </li>\n<li>\n<strong>\n   SPLIT\n  </strong>\n  : Sent by the host to indicate the beginning of a split transaction, which is used for high-speed data transfers that are broken into multiple parts.\n </li>\n<li>\n<strong>\n   PING\n  </strong>\n  : Used by the host to check if a device is ready to accept data during bulk OUT or control write transactions. It\u2019s sent after a NYET response to verify the device's readiness for the next transfer.\n </li>\n</ul>\n<h4>\n Summary\n</h4>\n<p>\n The\n <strong>\n  Handshake Phase\n </strong>\n ensures the successful transfer of data by sending status feedback (ACK, NAK, STALL, NYET). The\n <strong>\n  Token Phase\n </strong>\n , which may include a\n <strong>\n  Start-of-Frame (SOF)\n </strong>\n marker, provides synchronization and timing reference for the communication, especially important in high-speed transfers. For low-speed devices, an\n <strong>\n  End-of-Packet (EOP)\n </strong>\n signal replaces the SOF, keeping the device active. Additionally, there are several specialized token packet types (PRE, ERR, SPLIT,\n</p>\n"}, "Page 71": {"response": "<h3>\n Special PIDs and Packet Sequences in USB Transfers\n</h3>\n<p>\n In USB communication, there are specific\n <strong>\n  Packet Identifiers (PIDs)\n </strong>\n that serve special purposes based on the speed of the device and the nature of the transfer. These special PIDs help manage the communication process between the host, hubs, and devices.\n</p>\n<h4>\n Special PIDs for Different USB Speeds\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    PRE PID\n   </strong>\n   : This PID is used only for\n   <strong>\n    low-speed devices\n   </strong>\n   . It contains a preamble that informs the hub that the following packet is a low-speed packet. When a hub receives the\n   <strong>\n    PRE PID\n   </strong>\n   , it prepares to handle communications with any attached low-speed devices. This PID precedes all token, data, and handshake packets directed at low-speed devices. However, high-speed buses encode this\n   <strong>\n    PRE PID\n   </strong>\n   in the\n   <strong>\n    SPLIT PID\n   </strong>\n   instead of sending it separately. Low-speed devices themselves do not require the\n   <strong>\n    PRE PID\n   </strong>\n   in their responses.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    PING PID\n   </strong>\n   : The\n   <strong>\n    PING PID\n   </strong>\n   is used only in\n   <strong>\n    high-speed\n   </strong>\n   devices. In bulk or control transfers that involve multiple data packets, before sending subsequent data packets, the host sends a\n   <strong>\n    PING PID\n   </strong>\n   to check if the endpoint is ready to accept more data. The device then responds with a status code. This ensures that the host doesn't overwhelm the device with too much data if it's not ready to handle it.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    SPLIT PID\n   </strong>\n   : The\n   <strong>\n    SPLIT PID\n   </strong>\n   marks the beginning of a\n   <strong>\n    split transaction\n   </strong>\n   , a method used when a large transaction is divided into multiple parts due to bus constraints. This PID helps in identifying and managing the different segments of the split transaction.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    ERR PID\n   </strong>\n   : The\n   <strong>\n    ERR PID\n   </strong>\n   is used in\n   <strong>\n    split transactions\n   </strong>\n   . It is returned by a\n   <strong>\n    USB 2.0 hub\n   </strong>\n   to report any errors that occurred during a low-speed or full-speed transaction. Though the\n   <strong>\n    ERR PID\n   </strong>\n   and\n   <strong>\n    PRE PID\n   </strong>\n   share the same value, they serve distinct purposes and will never be confused because a hub will never send a\n   <strong>\n    PRE PID\n   </strong>\n   to the host or an\n   <strong>\n    ERR PID\n   </strong>\n   to a device. The\n   <strong>\n    ERR PID\n   </strong>\n   is specific to high-speed segments, while the\n   <strong>\n    PRE PID\n   </strong>\n   is never used in high-speed segments.\n  </p>\n</li>\n</ol>\n<h4>\n Packet Sequences in USB Transactions\n</h4>\n<p>\n Every USB transaction consists of at least one\n <strong>\n  token packet\n </strong>\n . This packet, always sent by the host, is critical because it sets up the transaction by specifying several key pieces of information:\n</p>\n<ul>\n<li>\n<strong>\n   Transaction Type\n  </strong>\n  : The PID of the token packet indicates whether the transaction is a Setup, IN, OUT, or other types.\n </li>\n<li>\n<strong>\n   Device and Endpoint\n  </strong>\n  : The token packet identifies the target device and endpoint.\n </li>\n<li>\n<strong>\n   Data Direction\n  </strong>\n  : The token packet also specifies the direction of data transfer (host-to-device or device-to-host).\n </li>\n</ul>\n<p>\n For transactions involving low-speed devices on a full-speed bus, the\n <strong>\n  PRE packet\n </strong>\n precedes the token packet. In\n <strong>\n  split transactions\n </strong>\n , the\n <strong>\n  SPLIT packet\n </strong>\n precedes the token packet. After the token packet, a\n <strong>\n  data packet\n </strong>\n may follow, depending on the transfer type and whether the host or device has data to send.\n</p>\n<p>\n In summary, the\n <strong>\n  PRE PID\n </strong>\n is used to signal low-speed transactions, the\n <strong>\n  PING PID\n </strong>\n checks if a device is ready for more data during high-speed transfers, and the\n <strong>\n  SPLIT PID\n </strong>\n helps manage split transactions. The\n <strong>\n  ERR PID\n </strong>\n reports errors in split transactions. These PIDs are vital in ensuring the proper sequence and error-free communication in USB transfers, with the host setting up each transaction through the token\n</p>\n"}, "Page 72": {"response": "<h3>\n Timing Constraints, Data Transfer, and Split Transactions in USB\n</h3>\n<p>\n USB transfers have strict timing constraints to ensure the efficiency and reliability of data communication. These constraints govern the timing between token, data, and handshake packets to allow for minimal delays. Additionally, transactions and the way data is transferred can involve multiple phases, and in some cases, split transactions are used to manage devices operating at different speeds.\n</p>\n<h4>\n Timing Constraints for Transactions\n</h4>\n<p>\n The timing between the various stages of a USB transaction is very tight. The delays between token, data, and handshake packets are kept minimal, allowing just enough time for cable delays, switching times, and to give the hardware time to prepare a response. This response might be the sending of a status code in a handshake packet, indicating whether the transaction was successful or failed.\n</p>\n<p>\n A key consideration when writing firmware for USB devices is ensuring that data is prepared for transmission before the host requests it. A common mistake is waiting for an interrupt before the device firmware provides the data. Instead, the device must prepare the data in the endpoint buffer and configure the endpoint to send the data when an\n <strong>\n  IN token packet\n </strong>\n is received. The interrupt should happen after the transaction is complete, signaling that the endpoint\u2019s buffer is available for the next set of data. Waiting for an interrupt before preparing the data results in no data being transferred because the interrupt never occurs.\n</p>\n<h4>\n Data Transfer and Packet Sizes\n</h4>\n<p>\n Each transaction can transfer up to the maximum packet size specified for the endpoint. If a transaction carries less data than the maximum size, it\u2019s considered a\n <strong>\n  short packet\n </strong>\n . For example, in a full-speed\n <strong>\n  bulk transfer\n </strong>\n of 512 bytes, each transaction can carry a maximum of 64 bytes. Therefore, to transfer 512 bytes, the data will be divided into at least 8 transactions. These transactions may span multiple frames or microframes. Frames and microframes are time slots during which data is transmitted, and they don\u2019t necessarily have to be contiguous.\n</p>\n<h4>\n Split Transactions for Speed Conversion\n</h4>\n<p>\n USB 2.0 hubs and hosts typically communicate at high speeds. However, when a low-speed or full-speed device is attached to a 2.0 hub, the hub handles the speed conversion to ensure proper communication between devices with different speeds. The\n <strong>\n  split transaction\n </strong>\n mechanism is crucial in this process.\n</p>\n<p>\n When a low-speed or full-speed device is connected to a\n <strong>\n  USB 2.0 hub\n </strong>\n , the hub ensures that the device communicates at the correct speed. If there is a\n <strong>\n  1.x hub\n </strong>\n between the device and the host, it might introduce additional complexities in speed conversion. The hub essentially manages the conversion from one speed to another, enabling the host and device to communicate effectively despite their differing capabilities.\n</p>\n<p>\n In summary, USB transactions are designed to be fast and efficient, with tight timing between packet exchanges. The device firmware must be proactive in preparing data to avoid delays. Additionally, large data transfers may span multiple transactions, and hubs play a critical role in managing communication between devices operating at different speeds. Split transactions are used to handle these c\n</p>\n"}, "Page 73": {"response": "<h3>\n Split Transactions and Ensuring Successful Transfers in USB\n</h3>\n<p>\n USB 2.0 introduces\n <strong>\n  split transactions\n </strong>\n as a method for efficiently handling communication between devices operating at different speeds. This system ensures that faster devices, like those operating at high speed, don't have to wait for slower devices to transfer data. Additionally, USB uses handshaking and error-checking mechanisms to ensure that transfers are successful and data reaches its destination without errors.\n</p>\n<h4>\n Split Transactions for Speed Management\n</h4>\n<p>\n In a USB 2.0 system,\n <strong>\n  high-speed\n </strong>\n communication is significantly faster\u201440 times faster than\n <strong>\n  full-speed\n </strong>\n and 320 times faster than\n <strong>\n  low-speed\n </strong>\n . Given these significant differences, it would be inefficient for the entire bus to wait for data exchanges with low- or full-speed devices. To address this,\n <strong>\n  split transactions\n </strong>\n are employed.\n</p>\n<p>\n When a\n <strong>\n  high-speed host\n </strong>\n communicates with a\n <strong>\n  low-speed or full-speed device\n </strong>\n , the usual single transaction is split into two main phases:\n</p>\n<ol>\n<li>\n<strong>\n   Start-split transactions\n  </strong>\n  : These are used to send data to the device.\n </li>\n<li>\n<strong>\n   Complete-split transactions\n  </strong>\n  : These are used to receive data from the device.\n </li>\n</ol>\n<p>\n One notable exception to this is\n <strong>\n  isochronous OUT transactions\n </strong>\n , which do not require complete-split transactions because these devices have no data to send.\n</p>\n<p>\n Although split transactions increase the number of individual transactions, they make better use of the bus time by allowing high-speed devices to continue transferring data while waiting for low- or full-speed devices to complete their transfers. This way, the bus doesn\u2019t sit idle, and high-speed devices can operate efficiently.\n</p>\n<p>\n The\n <strong>\n  host controller\n </strong>\n and the\n <strong>\n  hub\n </strong>\n are responsible for managing split transactions. The\n <strong>\n  device\n </strong>\n itself doesn't need to know whether split transactions are being used. This abstraction means that the firmware and device drivers don\u2019t need to worry about split transactions, as they are handled at a lower system level. For users and application software, the process remains seamless.\n</p>\n<h4>\n Handshaking to Ensure Successful Transfers\n</h4>\n<p>\n USB transfers utilize a\n <strong>\n  handshaking\n </strong>\n mechanism to ensure data flows correctly and without errors. In the context of data communication,\n <strong>\n  handshaking\n </strong>\n involves sending status or control signals between devices to manage the flow of data.\n</p>\n<p>\n In\n <strong>\n  hardware handshaking\n </strong>\n , dedicated lines are used to carry the handshaking information. This method is similar to other communication systems that rely on control signals to manage data flow. For example, in hardware protocols, lines like\n <strong>\n  RTS (Request to Send)\n </strong>\n and\n <strong>\n  CTS (Clear to Send)\n </strong>\n are used to indicate whether devices are ready to send or receive data.\n</p>\n<p>\n USB handshaking operates in a similar way, where both the host and device exchange handshake packets to confirm whether data was received correctly or if there were issues. These handshake signals help ensure that data is transmitted and received successfully, without errors or data loss, enhancing the reliability of USB communication.\n</p>\n<p>\n In summary,\n <strong>\n  split transactions\n </strong>\n are a critical feature in USB 2.0 for handling devices that operate at different speeds. While they increase the number of transactions, they help optimize the use of the bus. Additionally,\n <strong>\n  handshaking\n </strong>\n and error-checking protocols are essential for ensuring that USB transf\n</p>\n"}, "Page 74": {"response": "<h3>\n USB Handshaking and Status Codes\n</h3>\n<p>\n In USB communication, handshaking is managed through software, where the same lines that carry data also carry handshaking signals. A status code is used to indicate whether transactions were successful, except for isochronous transfers. During control transfers, the Status stage allows devices to report the success or failure of the entire transfer.\n</p>\n<h4>\n Handshaking Signals\n</h4>\n<p>\n Handshaking signals are transmitted in the handshake or data packet, and they help determine the next action to take. The primary status codes used are:\n</p>\n<ul>\n<li>\n<strong>\n   ACK (Acknowledge)\n  </strong>\n</li>\n<li>\n<strong>\n   NAK (Negative Acknowledge)\n  </strong>\n</li>\n<li>\n<strong>\n   STALL\n  </strong>\n</li>\n<li>\n<strong>\n   NYET\n  </strong>\n</li>\n<li>\n<strong>\n   ERR\n  </strong>\n</li>\n</ul>\n<p>\n If a handshake code is expected but not received, it typically signals a more serious error. The receiver uses these codes to decide how to proceed with the communication.\n</p>\n<p>\n Table 2-4 shows the status codes and the transaction types where they are used.\n</p>\n<h4>\n ACK (Acknowledge)\n</h4>\n<ul>\n<li>\n<strong>\n   Meaning\n  </strong>\n  : Data has been received correctly without errors.\n </li>\n<li>\n<strong>\n   Usage\n  </strong>\n  :\n  <ul>\n<li>\n    Devices return ACK in Setup transactions if both the token and data packets were received correctly.\n   </li>\n<li>\n    Devices may also return ACK in OUT transactions' handshake packets.\n   </li>\n<li>\n    The host returns ACK in IN transactions' handshake packets.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n NAK (Negative Acknowledge)\n</h4>\n<ul>\n<li>\n<strong>\n   Meaning\n  </strong>\n  : The device is either too busy or has no data to return.\n </li>\n<li>\n<strong>\n   Usage\n  </strong>\n  :\n  <ul>\n<li>\n    When the device is too busy to accept data from the host, it returns NAK in the handshake packet.\n   </li>\n<li>\n    When the host requests data from the device and the device has no data to send, it returns NAK in the data packet.\n   </li>\n<li>\n    NAK indicates a temporary issue, prompting the host to retry later.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n<strong>\n  Note\n </strong>\n : Hosts never send NAK. Isochronous transfers don't use NAK because there is no handshake packet for it. If an isochronous transfer fails, the data is lost.\n</p>\n"}, "Page 75": {"response": "<h3>\n USB Transfer Handshake: STALL and Its Meanings\n</h3>\n<p>\n The\n <strong>\n  STALL\n </strong>\n handshake signal in USB transfers can have three distinct meanings, depending on the situation:\n</p>\n<ol>\n<li>\n<strong>\n   Unsupported Control Request\n  </strong>\n  :\n  <ul>\n<li>\n    If a device receives a control transfer request that it does not support, it responds with STALL.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Control Request Failed\n  </strong>\n  :\n  <ul>\n<li>\n<p>\n     If the device supports the request but cannot fulfill it for some reason (e.g., invalid configuration request), it returns a STALL. For instance, if a host sends a\n     <strong>\n      Set_Configuration\n     </strong>\n     request for a configuration that the device cannot support (e.g., requesting configuration 2 when the device only supports configuration 1), the device responds with STALL.\n    </p>\n</li>\n<li>\n<p>\n     To resolve this, the host can simply send another\n     <strong>\n      Setup\n     </strong>\n     packet to initiate a new control transfer, which is known as a\n     <strong>\n      protocol stall\n     </strong>\n     .\n    </p>\n</li>\n</ul>\n</li>\n<li>\n<strong>\n   Endpoint Failed\n  </strong>\n  :\n  <ul>\n<li>\n    A STALL is also used when the endpoint\u2019s\n    <strong>\n     Halt feature\n    </strong>\n    is active, meaning the endpoint cannot send or receive data. This is referred to as a\n    <strong>\n     functional stall\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Transaction Type and Handshake Locations\n</h4>\n<p>\n The source and content of handshake signals depend on the type of transaction. The following table summarizes the source, content, and location of data and handshake signals for each transaction type:\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Transaction Type or PING Query\n    </strong>\n</th>\n<th>\n<strong>\n     Data Packet Source\n    </strong>\n</th>\n<th>\n<strong>\n     Data Packet Contents\n    </strong>\n</th>\n<th>\n<strong>\n     Handshake Packet Source\n    </strong>\n</th>\n<th>\n<strong>\n     Handshake Packet Contents\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     Setup\n    </strong>\n</td>\n<td>\n    Host\n   </td>\n<td>\n    Data\n   </td>\n<td>\n    Device\n   </td>\n<td>\n    ACK\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     OUT\n    </strong>\n</td>\n<td>\n    Host\n   </td>\n<td>\n    Data\n   </td>\n<td>\n    Device\n   </td>\n<td>\n    ACK, NAK, STALL, NYET (high-speed only), ERR (from hub in complete split)\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     IN\n    </strong>\n</td>\n<td>\n    Device\n   </td>\n<td>\n    Data, NAK, STALL, ERR (from hub in complete split)\n   </td>\n<td>\n    Host\n   </td>\n<td>\n    ACK\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     PING (high-speed only)\n    </strong>\n</td>\n<td>\n    None\n   </td>\n<td>\n    None\n   </td>\n<td>\n    Device\n   </td>\n<td>\n    ACK, NAK, STALL\n   </td>\n</tr>\n</tbody>\n</table>\n"}, "Page 76": {"response": "<h3>\n Functional Stall and NYET in USB Transfers\n</h3>\n<h4>\n Functional Stall\n</h4>\n<p>\n<strong>\n  Bulk\n </strong>\n and\n <strong>\n  interrupt\n </strong>\n endpoints must support the\n <strong>\n  functional stall\n </strong>\n , which prevents the endpoint from sending or receiving data. While\n <strong>\n  control endpoints\n </strong>\n can also support functional stalls, it's not recommended. This is because control endpoints in a functional stall must still handle requests related to controlling and monitoring the stall condition. If an endpoint can respond to such requests, it should not be stalled, as it indicates the endpoint can still communicate.\n</p>\n<p>\n<strong>\n  Isochronous transactions\n </strong>\n don\u2019t use the\n <strong>\n  STALL\n </strong>\n handshake because they lack a handshake packet to return STALL signals. When a device enters a functional stall, the host drops all pending requests to the device and will not resume communication until the host sends a successful request to clear the\n <strong>\n  Halt feature\n </strong>\n of the device. Notably, hosts do not send STALL signals.\n</p>\n<h4>\n NYET (Not Yet)\n</h4>\n<p>\n<strong>\n  NYET\n </strong>\n is used only by\n <strong>\n  high-speed\n </strong>\n devices and stands for \"not yet.\" In high-speed bulk and control transfers, the host can check if a device is ready to receive data before sending it, improving efficiency compared to lower speeds. At\n <strong>\n  full\n </strong>\n and\n <strong>\n  low speeds\n </strong>\n , when the host wants to send data in a transfer (control, bulk, or interrupt), the process involves sending token and data packets and waiting for a handshake reply. If the device isn\u2019t ready, the host receives a\n <strong>\n  NAK\n </strong>\n and retries later. This can waste bus time, especially if data packets are large and the device is often not ready.\n</p>\n<p>\n High-speed bulk and control transfers handle this differently. After receiving a data packet, a device can send a\n <strong>\n  NYET\n </strong>\n handshake, which indicates that the device accepted the data but isn't ready for the next data packet yet. To check readiness, the host can send a\n <strong>\n  PING\n </strong>\n token packet. In response, the device can return:\n</p>\n<ul>\n<li>\n<strong>\n   ACK\n  </strong>\n  : The device is ready for the next data packet.\n </li>\n<li>\n<strong>\n   NAK\n  </strong>\n  or\n  <strong>\n   STALL\n  </strong>\n  : The device isn't ready.\n </li>\n</ul>\n<p>\n Using\n <strong>\n  PING\n </strong>\n is more efficient than sending an entire data packet, only to find out that the device isn't ready and then having to resend it. Even after receiving an\n <strong>\n  ACK\n </strong>\n from the device, the endpoint may still return\n <strong>\n  NAK\n </strong>\n if it\u2019s not ready for the next data packet, though this should be rare. The host may try again by sending another\n <strong>\n  PING\n </strong>\n . The use of\n <strong>\n  PING\n </strong>\n by the host is optional.\n</p>\n"}, "Page 77": {"response": "<h3>\n NYET, ERR, and No Response in USB Transfers\n</h3>\n<h4>\n NYET in Hub and Split Transactions\n</h4>\n<p>\n A\n <strong>\n  2.0 hub\n </strong>\n may also use\n <strong>\n  NYET\n </strong>\n in complete-split transactions. This is specific to high-speed hubs and indicates that the device has accepted a data packet but is not yet ready for another.\n <strong>\n  Hosts\n </strong>\n and\n <strong>\n  low-\n </strong>\n and\n <strong>\n  full-speed devices\n </strong>\n do not send\n <strong>\n  NYET\n </strong>\n .\n</p>\n<h4>\n ERR in High-Speed Hubs\n</h4>\n<p>\n The\n <strong>\n  ERR\n </strong>\n handshake is used only by\n <strong>\n  high-speed hubs\n </strong>\n during\n <strong>\n  complete-split transactions\n </strong>\n . It signals that the device did not return the expected handshake in the transaction the hub is completing with the host.\n</p>\n<h4>\n No Response\n</h4>\n<p>\n If a handshake is expected but no response is received, it could indicate an error, such as a failed error-checking calculation. In this case, the sender knows to try again. If multiple attempts fail, the sender may take further action. If the receiver acknowledges the data but doesn't use it, the problem is likely with the\n <strong>\n  data-toggle\n </strong>\n value.\n</p>\n<hr/>\n<h3>\n Reporting Control Transfer Status\n</h3>\n<p>\n In USB control transfers, the same status codes (\n <strong>\n  ACK\n </strong>\n ,\n <strong>\n  NAK\n </strong>\n , and\n <strong>\n  STALL\n </strong>\n ) indicate the success or failure of the entire transfer. Additionally, a\n <strong>\n  zero-length data packet (ZLP)\n </strong>\n is used to report the successful completion of a control transfer.\n</p>\n<p>\n A\n <strong>\n  ZLP\n </strong>\n occurs when the\n <strong>\n  Data phase\n </strong>\n of a transfer consists only of a\n <strong>\n  Data PID\n </strong>\n and error-checking bits, with no actual data being transferred.\n</p>\n<h4>\n Control Write Transfers\n</h4>\n<p>\n For\n <strong>\n  control write transfers\n </strong>\n (where the device receives data in the\n <strong>\n  Data\n </strong>\n stage), the device reports the status of the transfer in the\n <strong>\n  Status\n </strong>\n stage's\n <strong>\n  data packet\n </strong>\n . The possible status codes are:\n</p>\n<ul>\n<li>\n<strong>\n   ZLP\n  </strong>\n  : Successful transfer completion.\n </li>\n<li>\n<strong>\n   STALL\n  </strong>\n  : The device cannot complete the transfer.\n </li>\n<li>\n<strong>\n   NAK\n  </strong>\n  : The device is not ready to complete the transfer.\n </li>\n</ul>\n<p>\n The\n <strong>\n  host\n </strong>\n returns an\n <strong>\n  ACK\n </strong>\n in the\n <strong>\n  Status stage's handshake packet\n </strong>\n to confirm that it received the response.\n</p>\n<h4>\n Control Read Transfers\n</h4>\n<p>\n For\n <strong>\n  control read transfers\n </strong>\n (where the host receives data in the\n <strong>\n  Data\n </strong>\n stage), the\n <strong>\n  device\n </strong>\n returns the status of the transfer in the\n <strong>\n  handshake packet\n </strong>\n of the\n <strong>\n  Status\n </strong>\n stage.\n</p>\n"}, "Page 78": {"response": "<h3>\n USB Control Transfer Status and Error Checking\n</h3>\n<h4>\n Status Stage in Control Transfers\n</h4>\n<p>\n In\n <strong>\n  control read transfers\n </strong>\n , the\n <strong>\n  host\n </strong>\n waits to receive all data packets in the\n <strong>\n  Data\n </strong>\n stage before sending a\n <strong>\n  zero-length data packet\n </strong>\n in the\n <strong>\n  Status\n </strong>\n stage. The device then responds with one of the following status codes:\n</p>\n<ul>\n<li>\n<strong>\n   ACK\n  </strong>\n  : Successful transfer\n </li>\n<li>\n<strong>\n   NAK\n  </strong>\n  : Device is busy\n </li>\n<li>\n<strong>\n   STALL\n  </strong>\n  : Transfer failed\n </li>\n</ul>\n<p>\n If the host initiates the\n <strong>\n  Status\n </strong>\n stage before all requested data packets are sent, the device must abandon the\n <strong>\n  Data\n </strong>\n stage and return a status code instead.\n</p>\n<hr/>\n<h3>\n Error Checking in USB\n</h3>\n<p>\n While the\n <strong>\n  USB specification\n </strong>\n ensures that errors due to line noise are rare, there is still a chance that noise glitches or disconnected cables could corrupt transmissions. To mitigate this risk, USB packets include\n <strong>\n  error-checking bits\n </strong>\n that allow the receiver to detect discrepancies between the transmitted and received data. Additionally, for transfers that involve multiple transactions, a\n <strong>\n  data-toggle\n </strong>\n value ensures that the transmitter and receiver remain synchronized and no transactions are missed.\n</p>\n<h4>\n Error-Checking Bits\n</h4>\n<p>\n All\n <strong>\n  token\n </strong>\n ,\n <strong>\n  data\n </strong>\n , and\n <strong>\n  Start-of-Frame\n </strong>\n packets include error-checking bits. These bits are generated using a mathematical algorithm called\n <strong>\n  cyclic redundancy check (CRC)\n </strong>\n , which helps identify any errors in transmission.\n</p>\n<hr/>\n<h3>\n Control Transfer Status Codes\n</h3>\n<p>\n The\n <strong>\n  Status stage\n </strong>\n of a control transfer reports success or failure depending on the transfer's direction:\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Transfer Type and Direction\n    </strong>\n</th>\n<th>\n<strong>\n     Status Stage Direction\n    </strong>\n</th>\n<th>\n<strong>\n     Status Stage\u2019s Data Packet\n    </strong>\n</th>\n<th>\n<strong>\n     Status Stage\u2019s Handshake Packet\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     Control Write (Host to Device)\n    </strong>\n</td>\n<td>\n<strong>\n     IN\n    </strong>\n</td>\n<td>\n    Device sends status:\n    <strong>\n     ZLP\n    </strong>\n    (success),\n    <strong>\n     NAK\n    </strong>\n    (busy), or\n    <strong>\n     STALL\n    </strong>\n    (failed)\n   </td>\n<td>\n    Host returns\n    <strong>\n     ACK\n    </strong>\n</td>\n</tr>\n<tr>\n<td>\n<strong>\n     Control Read (Device to Host)\n    </strong>\n</td>\n<td>\n<strong>\n     OUT\n    </strong>\n</td>\n<td>\n    Host sends\n    <strong>\n     ZLP\n    </strong>\n</td>\n<td>\n    Device sends status:\n    <strong>\n     ACK\n    </strong>\n    (success),\n    <strong>\n     NAK\n    </strong>\n    (busy), or\n    <strong>\n     STALL\n    </strong>\n    (failed)\n   </td>\n</tr>\n</tbody>\n</table>\n"}, "Page 79": {"response": "<h3>\n Error Checking with CRC and Data Toggle in USB Transfers\n</h3>\n<h4>\n CRC Error Checking\n</h4>\n<p>\n USB uses\n <strong>\n  Cyclic Redundancy Check (CRC)\n </strong>\n for error detection. The transmitting device performs a CRC calculation on the data and sends the result along with the data. The receiving device performs the same CRC calculation on the received data. If the results match, the data is considered error-free, and the receiving device returns an\n <strong>\n  ACK\n </strong>\n (acknowledgement). If the results don\u2019t match, no handshake is returned, signaling to the sender that a retry is needed.\n</p>\n<p>\n Typically, the host retries up to three times, but the USB specification allows flexibility in the number of retries. If retries fail, the host notifies the driver about the error.\n</p>\n<h4>\n Token Packet PID Error Checking\n</h4>\n<p>\n In\n <strong>\n  token packets\n </strong>\n , a simpler error check is applied to the\n <strong>\n  PID\n </strong>\n (Packet Identifier) field. The PID's lower four bits represent the PID, while the upper four bits are the complement of the PID. The receiver checks the integrity by complementing the upper four bits and ensuring they match the PID. If they don't match, the packet is considered corrupted and ignored.\n</p>\n<h4>\n Data Toggle in Multiple-Transaction Transfers\n</h4>\n<p>\n For transfers requiring multiple transactions, the\n <strong>\n  data-toggle\n </strong>\n value ensures synchronization between the sender and receiver. The\n <strong>\n  data-toggle\n </strong>\n value is included in the\n <strong>\n  PID field\n </strong>\n of the\n <strong>\n  IN\n </strong>\n and\n <strong>\n  OUT\n </strong>\n token packets. There are two toggle values:\n</p>\n<ul>\n<li>\n<strong>\n   DATA0\n  </strong>\n  : Represented by code 0011\n </li>\n<li>\n<strong>\n   DATA1\n  </strong>\n  : Represented by code 1011\n </li>\n</ul>\n<p>\n The\n <strong>\n  data-toggle bit\n </strong>\n is often stored in a register bit of the controller chip. Each endpoint maintains its own data toggle. Both the sender and receiver track the data toggle, ensuring the correct sequence.\n</p>\n<p>\n In Windows, the host automatically handles the data toggles, requiring no user intervention. Some device controller chips also manage data toggles automatically, while others may need some firmware assistance. If a device transmits the correct data but the receiver discards it, it is likely due to an incorrect data toggle.\n</p>\n"}, "Page 80": {"response": "<h3>\n Data Toggle Behavior in USB Transfers\n</h3>\n<h4>\n Data Toggle Initialization and Alternation\n</h4>\n<p>\n When a device is configured upon power-up or attachment, both the host and device set their\n <strong>\n  data toggles\n </strong>\n to\n <strong>\n  DATA0\n </strong>\n , except for some\n <strong>\n  high-speed isochronous endpoints\n </strong>\n . Upon receiving a data packet, both the host and device compare the state of their data toggle with the received data toggle:\n</p>\n<ul>\n<li>\n  If the toggles match, the receiver switches its data toggle value and sends an\n  <strong>\n   ACK\n  </strong>\n  (acknowledgement) handshake to the sender.\n </li>\n<li>\n  The\n  <strong>\n   ACK\n  </strong>\n  causes the sender to toggle its value for the next transaction.\n </li>\n</ul>\n<p>\n This alternating process continues until the transfer completes, with the data toggle alternating between\n <strong>\n  DATA0\n </strong>\n and\n <strong>\n  DATA1\n </strong>\n . However,\n <strong>\n  control transfers\n </strong>\n always use\n <strong>\n  DATA1\n </strong>\n in the\n <strong>\n  Status stage\n </strong>\n .\n</p>\n<h4>\n Handling NAKs and No Response\n</h4>\n<p>\n If the receiver is busy, it may return a\n <strong>\n  NAK\n </strong>\n (negative acknowledge), or if data corruption is detected, it may not respond. In these cases:\n</p>\n<ul>\n<li>\n  The sender does not toggle the data bit and retries the transaction using the same data and data toggle.\n </li>\n<li>\n  If the receiver returns an\n  <strong>\n   ACK\n  </strong>\n  but the sender doesn\u2019t detect it, the sender will assume the receiver didn\u2019t get the data and retry with the same data and data toggle.\n </li>\n<li>\n  In these situations, the receiver will ignore the repeated data but will still return an\n  <strong>\n   ACK\n  </strong>\n  , which re-synchronizes the data toggles.\n </li>\n</ul>\n<p>\n Similarly, if the sender mistakenly sends the same data toggle twice, the receiver will ignore the repeated data but return an\n <strong>\n  ACK\n </strong>\n , ensuring synchronization.\n</p>\n<h4>\n Control Transfers and Data Toggle\n</h4>\n<p>\n In\n <strong>\n  control transfers\n </strong>\n , the\n <strong>\n  Setup stage\n </strong>\n uses\n <strong>\n  DATA0\n </strong>\n , the first transaction of the\n <strong>\n  Data\n </strong>\n stage uses\n <strong>\n  DATA1\n </strong>\n , and the data toggle alternates for subsequent transactions in the\n <strong>\n  Data\n </strong>\n stage. The\n <strong>\n  Status stage\n </strong>\n always uses\n <strong>\n  DATA1\n </strong>\n .\n</p>\n<h4>\n Bulk and Interrupt Endpoints\n</h4>\n<ul>\n<li>\n<strong>\n   Bulk endpoints\n  </strong>\n  toggle the data toggle bit in every transaction, resetting it only after a\n  <strong>\n   Set_Configuration\n  </strong>\n  ,\n  <strong>\n   Set_Interface\n  </strong>\n  , or\n  <strong>\n   Clear_Feature (ENDPOINT HALT)\n  </strong>\n  request.\n </li>\n<li>\n<strong>\n   Interrupt endpoints\n  </strong>\n  can either behave like\n  <strong>\n   bulk endpoints\n  </strong>\n  (toggling the data toggle in each transaction) or toggle the data bit in every transaction without checking for the host's\n  <strong>\n   ACK\n  </strong>\n  , which risks losing some data.\n </li>\n</ul>\n<h4>\n Isochronous Transfers and Data Toggle\n</h4>\n<ul>\n<li>\n<strong>\n   Full-speed isochronous transfers\n  </strong>\n  always use\n  <strong>\n   DATA0\n  </strong>\n  because there is no handshake packet for returning\n  <strong>\n   ACK\n  </strong>\n  or\n  <strong>\n   NAK\n  </strong>\n  , making error correction through data toggle impossible.\n </li>\n<li>\n<strong>\n   High-speed isochronous transfers\n  </strong>\n  may use\n  <strong>\n   DATA0\n  </strong>\n  ,\n  <strong>\n   DATA1\n  </strong>\n  , and additional\n  <strong>\n   PIDs\n  </strong>\n  (Packet Identifiers) like\n  <strong>\n   DATA2\n  </strong>\n  and\n  <strong>\n   MDATA\n  </strong>\n  for more efficient data handling.\n </li>\n</ul>\n"}, "Page 81": {"response": "<h3>\n Data PID Sequencing in High-Speed Isochronous Transfers\n</h3>\n<p>\n In high-speed isochronous transfers, particularly for\n <strong>\n  OUT transfers\n </strong>\n that require multiple transactions per microframe,\n <strong>\n  DATA0\n </strong>\n ,\n <strong>\n  DATA1\n </strong>\n , and\n <strong>\n  MDATA\n </strong>\n (Modified Data) encoding are used to indicate the order of transactions within a microframe. This method is known as\n <strong>\n  data PID sequencing\n </strong>\n . The same encoding applies to\n <strong>\n  IN transfers\n </strong>\n as well, with each transaction in a microframe receiving a distinct\n <strong>\n  Data PID\n </strong>\n to track its position.\n</p>\n<h4>\n IN Transactions per Microframe\n</h4>\n<p>\n For\n <strong>\n  IN transactions\n </strong>\n , the\n <strong>\n  Data PIDs\n </strong>\n are assigned as follows based on the number of transactions per microframe:\n</p>\n<ul>\n<li>\n<strong>\n   1 transaction\n  </strong>\n  :\n  <strong>\n   DATA0\n  </strong>\n  (First Transaction)\n </li>\n<li>\n<strong>\n   2 transactions\n  </strong>\n  :\n  <strong>\n   DATA1\n  </strong>\n  (First Transaction),\n  <strong>\n   DATA0\n  </strong>\n  (Second Transaction)\n </li>\n<li>\n<strong>\n   3 transactions\n  </strong>\n  :\n  <strong>\n   DATA2\n  </strong>\n  (First Transaction),\n  <strong>\n   DATA1\n  </strong>\n  (Second Transaction),\n  <strong>\n   DATA0\n  </strong>\n  (Third Transaction)\n </li>\n</ul>\n<h4>\n OUT Transactions per Microframe\n</h4>\n<p>\n For\n <strong>\n  OUT transactions\n </strong>\n , the\n <strong>\n  Data PIDs\n </strong>\n are assigned differently based on the number of transactions:\n</p>\n<ul>\n<li>\n<strong>\n   1 transaction\n  </strong>\n  :\n  <strong>\n   DATA0\n  </strong>\n  (First Transaction)\n </li>\n<li>\n<strong>\n   2 transactions\n  </strong>\n  :\n  <strong>\n   MDATA\n  </strong>\n  (First Transaction),\n  <strong>\n   DATA1\n  </strong>\n  (Second Transaction)\n </li>\n<li>\n<strong>\n   3 transactions\n  </strong>\n  :\n  <strong>\n   MDATA\n  </strong>\n  (First Transaction),\n  <strong>\n   MDATA\n  </strong>\n  (Second Transaction),\n  <strong>\n   DATA2\n  </strong>\n  (Third Transaction)\n </li>\n</ul>\n<p>\n In high-speed isochronous transfers, this data PID sequencing helps maintain synchronization and indicates whether more data will follow within the microframe, ensuring that all data is correctly processed and handled.\n</p>\n"}, "Page 82": {"response": "<p>\n It seems the content for Chapter 2 is missing. Could you please provide the specific text or section you would like me to restate and explain?\n</p>\n"}, "Page 83": {"response": "<h3>\n USB Transfer Types: Overview and Purposes\n</h3>\n<p>\n This chapter focuses on the four primary\n <strong>\n  USB transfer types\n </strong>\n :\n <strong>\n  control\n </strong>\n ,\n <strong>\n  bulk\n </strong>\n ,\n <strong>\n  interrupt\n </strong>\n , and\n <strong>\n  isochronous\n </strong>\n . Each transfer type is designed for specific purposes and has distinct capabilities and limitations that make it suitable for particular tasks. A table (not shown) compares the amount of data each transfer type can handle across the three USB speeds.\n</p>\n<h4>\n Control Transfers\n</h4>\n<p>\n<strong>\n  Control transfers\n </strong>\n serve two main functions:\n</p>\n<ol>\n<li>\n<strong>\n   USB Specification Requests\n  </strong>\n  : They carry requests from the host to configure and obtain information about devices, in line with the USB specification.\n </li>\n<li>\n<strong>\n   Class or Vendor-Specific Requests\n  </strong>\n  : Control transfers also support requests defined by device classes or vendors for various purposes beyond the basic USB specification.\n </li>\n</ol>\n<p>\n These transfers are used for configuration, device setup, and communication of device-specific commands.\n</p>\n"}, "Page 84": {"response": "<h3>\n Control Transfers: Structure and Availability\n</h3>\n<h4>\n Availability of Control Transfers\n</h4>\n<p>\n Every USB device is required to support\n <strong>\n  control transfers\n </strong>\n over the default pipe at\n <strong>\n  Endpoint 0\n </strong>\n . While a device may have additional pipes for control transfers, typically only one is needed. The host allocates bandwidth for control transfers based on the number and size of the requests, not the number of control endpoints. Therefore, adding more control endpoints does not provide any advantages.\n</p>\n<h4>\n Structure of Control Transfers\n</h4>\n<p>\n Control transfers, which are fundamental for USB communication, consist of the following stages:\n</p>\n<ol>\n<li>\n<strong>\n   Setup Stage\n  </strong>\n  : Every control transfer must begin with this stage, which sets up the transfer.\n </li>\n<li>\n<strong>\n   Data Stage\n  </strong>\n  (optional): This stage may be required depending on the specific request. In\n  <strong>\n   Control Write transfers\n  </strong>\n  , data flows from the\n  <strong>\n   host\n  </strong>\n  to the\n  <strong>\n   device\n  </strong>\n  in the Data stage. If no data is involved, the transfer is still classified as a\n  <strong>\n   Control Write\n  </strong>\n  transfer.\n </li>\n<li>\n<strong>\n   Status Stage\n  </strong>\n  : This final stage concludes the transfer and ensures proper completion.\n </li>\n</ol>\n<p>\n Each control transfer involves\n <strong>\n  bidirectional communication\n </strong>\n , using both\n <strong>\n  IN\n </strong>\n and\n <strong>\n  OUT\n </strong>\n endpoint addresses, as data is transmitted in both directions.\n</p>\n<h4>\n Control Read vs. Control Write Transfers\n</h4>\n<ul>\n<li>\n<strong>\n   Control Write Transfer\n  </strong>\n  : In this transfer type, the\n  <strong>\n   Data Stage\n  </strong>\n  sends data from the host to the device.\n </li>\n<li>\n<strong>\n   Control Read Transfer\n  </strong>\n  : Here, the\n  <strong>\n   Data Stage\n  </strong>\n  carries data from the device to the host.\n </li>\n</ul>\n<p>\n The\n <strong>\n  Data Stage\n </strong>\n is optional, but the\n <strong>\n  Setup\n </strong>\n and\n <strong>\n  Status\n </strong>\n stages are mandatory for all control transfers. The actual flow of data varies depending on whether the transfer is a Read or Write operation. Figures 3-1 and 3-2 (not shown) illustrate these stages for low and full-speed buses, with variations described later in the chapter.\n</p>\n<h4>\n Data Transfer Rates by Transfer Type and Speed\n</h4>\n<p>\n Table 3-1 (not shown) provides a comparison of maximum data transfer rates per endpoint across different transfer types and USB speeds. The maximum rates are as follows:\n</p>\n<ul>\n<li>\n<strong>\n   Control Transfers\n  </strong>\n  :\n  <ul>\n<li>\n    Low Speed: 24 KB/sec\n   </li>\n<li>\n    Full Speed: 832 KB/sec\n   </li>\n<li>\n    High Speed: 15,872 KB/sec\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n Other transfer types (Interrupt, Bulk, and Isochronous) have varying rates depending on the speed, with Bulk and Isochronous transfers reaching much higher rates at Full and High speeds.\n</p>\n"}, "Page 85": {"response": "<h3>\n Control Write Transfer: Structure and Transactions\n</h3>\n<p>\n A\n <strong>\n  Control Write transfer\n </strong>\n consists of three main transactions:\n</p>\n<ol>\n<li>\n<strong>\n   Setup Transaction\n  </strong>\n  : This initiates the transfer by setting up the necessary conditions for the transfer.\n </li>\n<li>\n<strong>\n   Data Transactions\n  </strong>\n  : These are optional and can be zero or more, depending on the data being sent.\n </li>\n<li>\n<strong>\n   Status Transaction\n  </strong>\n  : This final transaction confirms the completion of the transfer.\n </li>\n</ol>\n<p>\n In some high-speed transfers with multiple data packets, the\n <strong>\n  PING protocol\n </strong>\n is used (not shown in the figure). Additionally,\n <strong>\n  split transactions\n </strong>\n are used when low- and full-speed devices are on a high-speed bus, but this detail is also not shown in the diagram.\n</p>\n<p>\n The Control Write transfer structure ensures that data flows from the host to the device with appropriate setup and status confirmation.\n</p>\n"}, "Page 86": {"response": "<h3>\n Control Read Transfer: Structure and Transactions\n</h3>\n<p>\n A\n <strong>\n  Control Read transfer\n </strong>\n follows a similar structure to the Control Write transfer, with three primary transactions:\n</p>\n<ol>\n<li>\n<strong>\n   Setup Transaction\n  </strong>\n  : Initiates the transfer and sets up the conditions for data exchange.\n </li>\n<li>\n<strong>\n   Data Transactions\n  </strong>\n  : These are one or more transactions where data flows from the device to the host.\n </li>\n<li>\n<strong>\n   Status Transaction\n  </strong>\n  : Confirms the completion of the transfer and ensures proper data transfer.\n </li>\n</ol>\n<p>\n Just like with Control Write transfers,\n <strong>\n  split transactions\n </strong>\n are used for low- and full-speed devices operating on a high-speed bus, though this detail is not shown in the figure.\n</p>\n<p>\n The key difference between Control Read and Control Write transfers is the direction of data flow. In Control Read, data moves from the device to the host.\n</p>\n"}, "Page 87": {"response": "<h3>\n Control Transfers: Detailed Structure and Stages\n</h3>\n<h4>\n Setup Stage\n</h4>\n<p>\n The\n <strong>\n  Setup stage\n </strong>\n begins with the host sending a\n <strong>\n  Setup transaction\n </strong>\n . This transaction includes:\n</p>\n<ul>\n<li>\n  A\n  <strong>\n   token packet\n  </strong>\n  with a PID identifying the transfer as a control transfer.\n </li>\n<li>\n  A\n  <strong>\n   data packet\n  </strong>\n  containing details of the request, such as the request number, whether the transfer requires a\n  <strong>\n   Data stage\n  </strong>\n  , and the direction of data transfer (IN or OUT).\n </li>\n</ul>\n<p>\n The\n <strong>\n  USB 2.0 specification\n </strong>\n defines 11 standard requests. Some requests, like setting a device\u2019s address, require specific responses for successful enumeration. Other requests may return a code indicating that they are not supported. Devices can also respond to\n <strong>\n  class-specific requests\n </strong>\n or\n <strong>\n  vendor-specific requests\n </strong>\n that are defined by the device manufacturer.\n</p>\n<h4>\n Data Stage\n</h4>\n<p>\n The\n <strong>\n  Data stage\n </strong>\n may consist of multiple\n <strong>\n  Data transactions\n </strong>\n , which can either be\n <strong>\n  IN\n </strong>\n (device to host) or\n <strong>\n  OUT\n </strong>\n (host to device). Depending on the request, either the host or the device acts as the source of data, but the direction of all data packets in this stage remains consistent.\n</p>\n<p>\n In\n <strong>\n  high-speed control Write transfers\n </strong>\n , if there are multiple data packets, and the device returns a\n <strong>\n  NYET\n </strong>\n handshake after receiving a packet, the host may use the\n <strong>\n  PING protocol\n </strong>\n before sending additional data packets. This helps optimize data transfer by confirming the device's readiness.\n</p>\n<h4>\n Status Stage\n</h4>\n<p>\n The\n <strong>\n  Status stage\n </strong>\n follows the Data stage and consists of one\n <strong>\n  IN or OUT transaction\n </strong>\n , called the\n <strong>\n  status transaction\n </strong>\n . The device reports the success or failure of the previous stages in this transaction. The source of the\n <strong>\n  Status stage\u2019s data packet\n </strong>\n is the device that received the data in the Data stage. If there is no Data stage, the device sends the Status stage\u2019s data packet directly.\n</p>\n<p>\n The\n <strong>\n  data or handshake packet\n </strong>\n sent by the device in the Status stage will contain a code indicating whether the request was successful or failed.\n</p>\n<h4>\n Split Transactions for Low- or Full-Speed Devices\n</h4>\n<p>\n When performing a control transfer with a\n <strong>\n  low- or full-speed device\n </strong>\n on a\n <strong>\n  high-speed bus\n </strong>\n , the host uses\n <strong>\n  split transactions\n </strong>\n as described in Chapter 2. These transactions, although part of a high-speed bus, appear to the device as if they are on a 1.x speed host. The device\u2019s\n <strong>\n  hub\n </strong>\n handles the transaction and reports back to the host when requested.\n</p>\n"}, "Page 88": {"response": "<h3>\n Control Transfer Data Size and Speed\n</h3>\n<h4>\n Data Size\n</h4>\n<p>\n The size of data packets in the\n <strong>\n  Data stage\n </strong>\n of control transfers depends on the device\u2019s speed:\n</p>\n<ul>\n<li>\n<strong>\n   Low-speed devices\n  </strong>\n  : Maximum packet size is\n  <strong>\n   8 bytes\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Full-speed devices\n  </strong>\n  : Maximum packet size can be\n  <strong>\n   8, 16, 32, or 64 bytes\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   High-speed devices\n  </strong>\n  : Maximum packet size is\n  <strong>\n   64 bytes\n  </strong>\n  .\n </li>\n</ul>\n<p>\n This size refers to the\n <strong>\n  data\n </strong>\n in the packet and does not include the\n <strong>\n  PID\n </strong>\n (Packet Identifier) and\n <strong>\n  CRC\n </strong>\n (Cyclic Redundancy Check) bits.\n</p>\n<ul>\n<li>\n  All data packets in the\n  <strong>\n   Data stage\n  </strong>\n  , except the last, must be sent at the\n  <strong>\n   maximum packet size\n  </strong>\n  for the endpoint.\n </li>\n<li>\n  The\n  <strong>\n   maximum packet size\n  </strong>\n  for the\n  <strong>\n   Default Control Pipe\n  </strong>\n  is specified in the\n  <strong>\n   device descriptor\n  </strong>\n  during enumeration, while for other control endpoints, the size is listed in the\n  <strong>\n   endpoint descriptor\n  </strong>\n  .\n </li>\n<li>\n  If a transfer requires more data than can fit in one transaction, the host will send or receive the data across\n  <strong>\n   multiple transactions\n  </strong>\n  .\n </li>\n</ul>\n<p>\n In some\n <strong>\n  control Read transfers\n </strong>\n , if the amount of data returned is less than requested and is an even multiple of the endpoint\u2019s maximum packet size, the device should signal the end of the data by sending a\n <strong>\n  zero-length data packet\n </strong>\n in response to the next\n <strong>\n  IN token packet\n </strong>\n .\n</p>\n<h4>\n Speed\n</h4>\n<p>\n The host works to ensure that control transfers happen as quickly as possible by allocating a portion of the bus bandwidth specifically for them:\n</p>\n<ul>\n<li>\n<strong>\n   Low- and full-speed buses\n  </strong>\n  :\n  <strong>\n   10 percent\n  </strong>\n  of the available bandwidth is reserved for control transfers.\n </li>\n<li>\n<strong>\n   High-speed buses\n  </strong>\n  :\n  <strong>\n   20 percent\n  </strong>\n  of the available bandwidth is reserved for control transfers.\n </li>\n</ul>\n<p>\n If control transfers do not require the full reserved bandwidth, the remaining space can be used for\n <strong>\n  bulk transfers\n </strong>\n . If there is still unused bandwidth, control transfers may use more than the reserved amount.\n</p>\n<p>\n The host tries to allocate bus time as fairly as possible, and for each transfer, it may include multiple transactions in a single\n <strong>\n  frame\n </strong>\n or\n <strong>\n  microframe\n </strong>\n , or distribute the transactions across different\n <strong>\n  (micro)frames\n </strong>\n .\n</p>\n<p>\n While control transfers are typically used for\n <strong>\n  enumeration\n </strong>\n and\n <strong>\n  configuration\n </strong>\n data, some debate exists about whether they are suitable for transferring other types of data.\n</p>\n"}, "Page 89": {"response": "<h3>\n Control Transfers: Use, Efficiency, and Timing\n</h3>\n<h4>\n Use of Control Transfers\n</h4>\n<p>\n Control transfers are primarily reserved for handling\n <strong>\n  standard USB requests\n </strong>\n and infrequent\n <strong>\n  configuration tasks\n </strong>\n . This ensures that the bandwidth allocated for these transfers remains as open as possible, allowing them to complete quickly. Some argue that the specification should restrict control transfers to these tasks to optimize bandwidth usage. However, the\n <strong>\n  USB specification\n </strong>\n doesn't prevent other uses of control transfers, and some believe devices should have the flexibility to use control transfers for any purpose.\n</p>\n<p>\n For\n <strong>\n  low-speed devices\n </strong>\n , control transfers are the only option, as they cannot use other transfer types like bulk or isochronous. However, low-speed devices can end up wasting bandwidth, especially when data is transferred infrequently, as they rely on\n <strong>\n  periodic interrupt transfers\n </strong>\n .\n</p>\n<h4>\n Efficiency of Control Transfers\n</h4>\n<p>\n Control transfers, while essential, aren't the most efficient way to transfer data. In addition to the data being transferred, each transfer involves overhead due to\n <strong>\n  token packets\n </strong>\n ,\n <strong>\n  handshake packets\n </strong>\n , and the packet's own\n <strong>\n  PID\n </strong>\n and\n <strong>\n  CRC\n </strong>\n bits. This overhead increases with the speed of the device:\n</p>\n<ul>\n<li>\n<strong>\n   Low-speed devices\n  </strong>\n  : 63 bytes of overhead.\n </li>\n<li>\n<strong>\n   Full-speed devices\n  </strong>\n  : 45 bytes of overhead.\n </li>\n<li>\n<strong>\n   High-speed devices\n  </strong>\n  : 173 bytes of overhead.\n </li>\n</ul>\n<p>\n Transfers with larger data packets become more efficient because the overhead remains constant while the data size increases. For example, a\n <strong>\n  single low-speed control transfer\n </strong>\n with just\n <strong>\n  8 bytes of data\n </strong>\n can consume\n <strong>\n  29%\n </strong>\n of a frame's available bandwidth, though the individual transactions may span multiple frames.\n</p>\n<p>\n In the case of control transfers involving multiple data packets, the data might travel across the same or different frames, depending on the bus's load.\n</p>\n<ul>\n<li>\n<strong>\n   Low-speed\n  </strong>\n  : One 8-byte transfer requires\n  <strong>\n   3 frames\n  </strong>\n  of reserved bandwidth.\n </li>\n<li>\n<strong>\n   Full-speed\n  </strong>\n  : A 64-byte transfer requires\n  <strong>\n   1 frame\n  </strong>\n  of reserved bandwidth.\n </li>\n<li>\n<strong>\n   High-speed\n  </strong>\n  : A\n  <strong>\n   512-byte transfer\n  </strong>\n  fits within the reserved portion of\n  <strong>\n   1 frame\n  </strong>\n  .\n </li>\n</ul>\n<h4>\n Timing Limits and Response Delays\n</h4>\n<p>\n Devices are not required to respond immediately to\n <strong>\n  control-transfer requests\n </strong>\n . While\n <strong>\n  timing limits\n </strong>\n are specified for most requests in the USB specification, certain\n <strong>\n  device classes\n </strong>\n may impose stricter timing rules for standard or class-specific requests.\n</p>\n<p>\n In cases where there is no strict timing limit, if the host requests data from a device, the device may take up to\n <strong>\n  500 milliseconds\n </strong>\n before providing the data. The process works as follows:\n</p>\n<ol>\n<li>\n  The\n  <strong>\n   host sends a token packet\n  </strong>\n  requesting data.\n </li>\n<li>\n  If the data is ready, the device sends it immediately in that transaction\u2019s\n  <strong>\n   data packet\n  </strong>\n  .\n </li>\n<li>\n  If the data is not ready, the device responds with a\n  <strong>\n   NAK\n  </strong>\n  (Negative Acknowledgment), telling the host to retry later.\n </li>\n<li>\n  The host will keep retrying at intervals for up to\n  <strong>\n   500 milliseconds\n  </strong>\n  .\n </li>\n</ol>\n<p>\n In a case where the\n <strong>\n  host sends data to the device\n </strong>\n , similar timing constraints apply.\n</p>\n"}, "Page 90": {"response": "<h3>\n Handling Delays and Errors in Control Transfers\n</h3>\n<h4>\n Response Delays\n</h4>\n<p>\n When the\n <strong>\n  host sends data\n </strong>\n to the\n <strong>\n  device\n </strong>\n in a control transfer, the device can\n <strong>\n  delay for up to 5 seconds\n </strong>\n before accepting all data and completing the\n <strong>\n  Status stage\n </strong>\n . This delay does not account for any additional delays the host may introduce between packets. However, the\n <strong>\n  Status stage\n </strong>\n must always complete within\n <strong>\n  50 milliseconds\n </strong>\n . In control transfers that do not have a Data stage, the device must complete the request and Status stage within\n <strong>\n  50 milliseconds\n </strong>\n . Importantly, the host and its drivers are not required to enforce these timing limits strictly.\n</p>\n<h4>\n Error Detection and Handling\n</h4>\n<p>\n If a device fails to return an expected\n <strong>\n  handshake packet\n </strong>\n during a control transfer, the host will retry the operation\n <strong>\n  two more times\n </strong>\n , for a total of three attempts. If after three tries no response is received, the host will notify the requesting software about the failure and stop communication with that endpoint until the issue is resolved. However, if the failure is due to a\n <strong>\n  NAK\n </strong>\n (Negative Acknowledgment), this is not considered an error, and the retries do not apply.\n</p>\n<p>\n To prevent data loss,\n <strong>\n  data toggles\n </strong>\n are used during control transfers. In a\n <strong>\n  Control Read transfer\n </strong>\n , the host typically sends an\n <strong>\n  ACK\n </strong>\n after receiving data from the device and then sends an\n <strong>\n  OUT token packet\n </strong>\n to begin the Status stage. If the device does not see the\n <strong>\n  ACK\n </strong>\n , it should interpret the received\n <strong>\n  OUT token packet\n </strong>\n as an indication that the handshake has been successfully received, allowing the Status stage to start.\n</p>\n<p>\n A device must always accept\n <strong>\n  Setup packets\n </strong>\n . If a new Setup packet is received before the current transfer is completed, the device is required to\n <strong>\n  abandon the current transfer\n </strong>\n and begin the new one.\n</p>\n<h3>\n Bulk Transfers: Characteristics and Uses\n</h3>\n<p>\n Bulk transfers are ideal for\n <strong>\n  non-time-critical\n </strong>\n data transmissions. These transfers can handle large amounts of data without causing congestion on the bus, as they defer to other, higher-priority transfer types and wait until bandwidth is available.\n</p>\n<p>\n Common uses for\n <strong>\n  bulk transfers\n </strong>\n include:\n</p>\n<ul>\n<li>\n  Sending data from the\n  <strong>\n   host\n  </strong>\n  to a\n  <strong>\n   printer\n  </strong>\n  .\n </li>\n<li>\n  Transmitting data from a\n  <strong>\n   scanner\n  </strong>\n  to the host.\n </li>\n<li>\n  Reading and writing data to a\n  <strong>\n   disk\n  </strong>\n  .\n </li>\n</ul>\n<p>\n When the bus is idle,\n <strong>\n  bulk transfers\n </strong>\n are the fastest transfer type.\n</p>\n"}, "Page 91": {"response": "<h3>\n Bulk Transfers: Structure, Availability, and Data Size\n</h3>\n<h4>\n Availability and Device Support\n</h4>\n<p>\n Only\n <strong>\n  full-speed\n </strong>\n and\n <strong>\n  high-speed devices\n </strong>\n are capable of performing\n <strong>\n  bulk transfers\n </strong>\n . While devices are not required to support bulk transfers, certain device classes might mandate them. For instance, a device in the\n <strong>\n  mass-storage class\n </strong>\n is required to support a\n <strong>\n  bulk endpoint\n </strong>\n in both directions (IN and OUT).\n</p>\n<h4>\n Structure of Bulk Transfers\n</h4>\n<p>\n A\n <strong>\n  bulk transfer\n </strong>\n consists of one or more\n <strong>\n  IN\n </strong>\n or\n <strong>\n  OUT\n </strong>\n transactions, but the transfer is always one-directional, meaning all transactions in a transfer must be either\n <strong>\n  IN\n </strong>\n (data from the device to the host) or\n <strong>\n  OUT\n </strong>\n (data from the host to the device). If data needs to be transferred in both directions, separate pipes and transfers must be used for each direction.\n</p>\n<p>\n The transfer ends in two scenarios:\n</p>\n<ol>\n<li>\n  The expected amount of data is transferred.\n </li>\n<li>\n  A transaction contains\n  <strong>\n   zero data bytes\n  </strong>\n  or a number of bytes less than the endpoint\u2019s maximum packet size.\n </li>\n</ol>\n<p>\n Unlike other transfer types,\n <strong>\n  bulk transfers\n </strong>\n do not have a specific protocol to indicate the exact amount of data to be transferred. However, the\n <strong>\n  device\n </strong>\n and\n <strong>\n  host\n </strong>\n can use a\n <strong>\n  class-specific\n </strong>\n or\n <strong>\n  vendor-specific protocol\n </strong>\n to communicate this information. For example:\n</p>\n<ul>\n<li>\n  The transfer might begin with a\n  <strong>\n   header\n  </strong>\n  indicating the amount of data to be transferred.\n </li>\n<li>\n  The device or host can request a specific quantity of data through a protocol.\n </li>\n</ul>\n<p>\n To optimize bus time, the host may use the\n <strong>\n  PING protocol\n </strong>\n in\n <strong>\n  high-speed bulk transfers\n </strong>\n . If a\n <strong>\n  bulk OUT transfer\n </strong>\n involves multiple data packets and the device responds with\n <strong>\n  NYET\n </strong>\n (Not Yet), the host can use\n <strong>\n  PING\n </strong>\n to determine when it's okay to start the next transaction. If the device is on a\n <strong>\n  low-speed\n </strong>\n or\n <strong>\n  full-speed\n </strong>\n bus but the transfer occurs on a\n <strong>\n  high-speed bus\n </strong>\n , the host uses\n <strong>\n  split transactions\n </strong>\n for all the transfer\u2019s transactions.\n</p>\n<h4>\n Data Size and Transfer Limits\n</h4>\n<p>\n The maximum packet size for\n <strong>\n  bulk transfers\n </strong>\n varies by speed:\n</p>\n<ul>\n<li>\n<strong>\n   Full-speed\n  </strong>\n  devices can have a maximum packet size of\n  <strong>\n   8, 16, 32, or 64 bytes\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   High-speed\n  </strong>\n  devices must have a maximum packet size of\n  <strong>\n   512 bytes\n  </strong>\n  .\n </li>\n</ul>\n<p>\n During\n <strong>\n  enumeration\n </strong>\n , the\n <strong>\n  host\n </strong>\n reads the maximum packet size for each bulk endpoint from the\n <strong>\n  device's descriptors\n </strong>\n . The amount of data in a bulk transfer may be\n <strong>\n  less than\n </strong>\n ,\n <strong>\n  equal to\n </strong>\n , or\n <strong>\n  greater than\n </strong>\n the maximum packet size.\n</p>\n"}, "Page 92": {"response": "<h3>\n Bulk and Interrupt Transfers: Structure and Scheduling\n</h3>\n<p>\n Bulk and\n <strong>\n  interrupt transfers\n </strong>\n share the same structure, utilizing\n <strong>\n  IN\n </strong>\n and\n <strong>\n  OUT\n </strong>\n transactions. The key difference between them lies in how the host schedules these transfers, not in their structure.\n</p>\n<ul>\n<li>\n<strong>\n   IN transactions\n  </strong>\n  involve data being transferred from the device to the host.\n </li>\n<li>\n<strong>\n   OUT transactions\n  </strong>\n  involve data being sent from the host to the device.\n </li>\n</ul>\n<p>\n Both transfer types follow the same pattern of transactions, but the host schedules them differently based on their requirements (e.g., bulk transfers are deferred while interrupt transfers are time-sensitive).\n</p>\n<p>\n Note that the\n <strong>\n  PING protocol\n </strong>\n may be used in\n <strong>\n  high-speed bulk OUT transfers\n </strong>\n when multiple data packets are involved, and\n <strong>\n  split transactions\n </strong>\n are used when\n <strong>\n  low-speed\n </strong>\n or\n <strong>\n  full-speed\n </strong>\n devices are connected to a\n <strong>\n  high-speed bus\n </strong>\n . These protocols help ensure efficient data transfer while preventing bus congestion.\n</p>\n"}, "Page 93": {"response": "<h3>\n Bulk Transfers: Speed, Data Handling, and Error Detection\n</h3>\n<p>\n<strong>\n  Speed and Bandwidth Usage:\n </strong>\n</p>\n<ul>\n<li>\n<strong>\n   Bulk transfers\n  </strong>\n  don\u2019t have reserved bandwidth, meaning their speed depends on the bus traffic.\n </li>\n<li>\n<strong>\n   Control transfers\n  </strong>\n  are guaranteed 10% of the bandwidth at low and full speeds and 20% at high speed, while bulk transfers must wait for available bandwidth.\n </li>\n<li>\n  When the bus is idle, bulk transfers can use the full available bandwidth, making them very fast with minimal overhead. However, if the bus is busy, bulk transfers may experience significant delays.\n </li>\n</ul>\n<p>\n At\n <strong>\n  full speed\n </strong>\n :\n</p>\n<ul>\n<li>\n  A bulk transfer can send\n  <strong>\n   19 packets of 64 bytes\n  </strong>\n  , totaling\n  <strong>\n   1216 bytes per frame\n  </strong>\n  , achieving\n  <strong>\n   1.216 MB/sec\n  </strong>\n  . This leaves\n  <strong>\n   18% of the bandwidth\n  </strong>\n  for other transfer types.\n </li>\n</ul>\n<p>\n At\n <strong>\n  high speed\n </strong>\n :\n</p>\n<ul>\n<li>\n  A bulk transfer can send\n  <strong>\n   13 packets of 512 bytes\n  </strong>\n  , totaling\n  <strong>\n   6656 bytes per microframe\n  </strong>\n  , for a data rate of\n  <strong>\n   53.248 MB/sec\n  </strong>\n  , using\n  <strong>\n   98% of the bandwidth\n  </strong>\n  .\n </li>\n</ul>\n<p>\n The\n <strong>\n  protocol overhead\n </strong>\n for a bulk transfer is 13 bytes at full speed and 55 bytes at high speed. The actual performance may vary due to factors like\n <strong>\n  host-controller hardware\n </strong>\n ,\n <strong>\n  drivers\n </strong>\n , and\n <strong>\n  system memory latency\n </strong>\n . High-speed hosts can achieve around\n <strong>\n  35 MB/sec\n </strong>\n for a single transfer.\n</p>\n<p>\n<strong>\n  Data Handling:\n </strong>\n</p>\n<ul>\n<li>\n  If the amount of data exceeds the endpoint's packet size, the host will split the data across multiple transactions.\n </li>\n<li>\n  It\u2019s optimal to set the maximum allowed packet size for bulk endpoints, as this improves transfer efficiency.\n </li>\n</ul>\n<p>\n<strong>\n  Error Detection:\n </strong>\n</p>\n<ul>\n<li>\n  Bulk transfers include error detection. If the expected\n  <strong>\n   handshake packet\n  </strong>\n  isn't received, the host will retry the transfer\n  <strong>\n   twice\n  </strong>\n  . It will also retry in case of receiving a\n  <strong>\n   NAK handshake\n  </strong>\n  .\n </li>\n</ul>\n"}, "Page 94": {"response": "<h3>\n Interrupt Transfers: Timeliness and Structure\n</h3>\n<p>\n<strong>\n  Purpose and Applications:\n </strong>\n</p>\n<ul>\n<li>\n<strong>\n   Interrupt transfers\n  </strong>\n  are designed for data that needs to be transferred within a specific time frame. Common applications include\n  <strong>\n   keyboards\n  </strong>\n  ,\n  <strong>\n   pointing devices\n  </strong>\n  (like mice),\n  <strong>\n   game controllers\n  </strong>\n  , and\n  <strong>\n   hub status reports\n  </strong>\n  .\n </li>\n<li>\n  These devices require\n  <strong>\n   minimal delay\n  </strong>\n  between actions (e.g., pressing a key or moving the mouse) and the result on screen.\n </li>\n<li>\n<strong>\n   Hub status\n  </strong>\n  updates, such as device attachment or removal, also need to be transferred quickly.\n </li>\n<li>\n<strong>\n   Low-speed devices\n  </strong>\n  , which only support\n  <strong>\n   control\n  </strong>\n  and\n  <strong>\n   interrupt transfers\n  </strong>\n  , typically use interrupt transfers for general data.\n </li>\n</ul>\n<p>\n<strong>\n  Bandwidth and Speed:\n </strong>\n</p>\n<ul>\n<li>\n  At\n  <strong>\n   low\n  </strong>\n  and\n  <strong>\n   full speed\n  </strong>\n  , the available bandwidth for\n  <strong>\n   interrupt transfers\n  </strong>\n  is limited.\n </li>\n<li>\n  However, at\n  <strong>\n   high speed\n  </strong>\n  , the limits are significantly relaxed, allowing\n  <strong>\n   interrupt transfers\n  </strong>\n  to handle\n  <strong>\n   up to 400 times more data\n  </strong>\n  than at full speed within the same period.\n </li>\n</ul>\n<p>\n<strong>\n  Interrupt Transfers vs. Hardware Interrupts:\n </strong>\n</p>\n<ul>\n<li>\n  Despite the name \"interrupt transfer,\" these transfers\n  <strong>\n   don\u2019t occur spontaneously\n  </strong>\n  like hardware interrupts. Instead, they are initiated when the\n  <strong>\n   host polls\n  </strong>\n  the device.\n </li>\n<li>\n  They are \"interrupt-like\" because they\n  <strong>\n   minimize delays\n  </strong>\n  in sending or receiving data between the host and device.\n </li>\n</ul>\n<p>\n<strong>\n  Availability:\n </strong>\n</p>\n<ul>\n<li>\n<strong>\n   All USB speeds\n  </strong>\n  (low, full, high) support interrupt transfers.\n </li>\n<li>\n  Devices are\n  <strong>\n   not required\n  </strong>\n  to support interrupt transfers, but certain device classes, like the\n  <strong>\n   Human Interface Device (HID)\n  </strong>\n  class,\n  <strong>\n   must\n  </strong>\n  support interrupt\n  <strong>\n   IN\n  </strong>\n  transfers (for sending data to the host).\n </li>\n</ul>\n<p>\n<strong>\n  Structure:\n </strong>\n</p>\n<ul>\n<li>\n  An interrupt transfer consists of\n  <strong>\n   one or more IN transactions\n  </strong>\n  or\n  <strong>\n   one or more OUT transactions\n  </strong>\n  .\n </li>\n<li>\n  On the USB bus,\n  <strong>\n   interrupt transactions\n  </strong>\n  are structurally the same as\n  <strong>\n   bulk transactions\n  </strong>\n  (refer to Figure 3-3).\n </li>\n<li>\n  The key difference between interrupt and bulk transfers lies in their\n  <strong>\n   scheduling\n  </strong>\n  . An interrupt transfer is one-way, meaning it uses either\n  <strong>\n   all IN transactions\n  </strong>\n  or\n  <strong>\n   all OUT transactions\n  </strong>\n  .\n </li>\n</ul>\n"}, "Page 95": {"response": "<h3>\n Interrupt Transfers: Data Flow and Speed\n</h3>\n<p>\n<strong>\n  Data Flow:\n </strong>\n</p>\n<ul>\n<li>\n<p>\n   An\n   <strong>\n    interrupt transfer\n   </strong>\n   is one-way, meaning it consists of\n   <strong>\n    either IN or OUT transactions\n   </strong>\n   , but not both.\n  </p>\n</li>\n<li>\n<p>\n   If data needs to be transferred in both directions,\n   <strong>\n    separate transfers and pipes\n   </strong>\n   are used for each direction.\n  </p>\n</li>\n<li>\n<p>\n   The transfer concludes when:\n  </p>\n<ol>\n<li>\n    The expected data has been successfully transferred.\n   </li>\n<li>\n    A transaction contains\n    <strong>\n     zero data bytes\n    </strong>\n    or fewer bytes than the endpoint's maximum packet size.\n   </li>\n</ol>\n</li>\n<li>\n<p>\n   The\n   <strong>\n    USB specification\n   </strong>\n   doesn't dictate how the amount of data in an interrupt transfer is communicated. However,\n   <strong>\n    class-specific or vendor-specific protocols\n   </strong>\n   may be used to manage this, such as including a header indicating the byte count to be transferred or using a protocol to request a specific quantity of data.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Split transactions\n   </strong>\n   are used in\n   <strong>\n    high-speed interrupt transfers\n   </strong>\n   when interacting with\n   <strong>\n    low- or full-speed devices\n   </strong>\n   on a high-speed bus. However, unlike\n   <strong>\n    bulk OUT transfers\n   </strong>\n   ,\n   <strong>\n    interrupt OUT transfers\n   </strong>\n   at high-speed cannot use the\n   <strong>\n    PING protocol\n   </strong>\n   for managing multiple transactions.\n  </p>\n</li>\n</ul>\n<p>\n<strong>\n  Data Size:\n </strong>\n</p>\n<ul>\n<li>\n<p>\n   The\n   <strong>\n    maximum packet size\n   </strong>\n   varies based on the device's speed:\n  </p>\n<ul>\n<li>\n<strong>\n     Low-speed devices\n    </strong>\n    : Packet size ranges from\n    <strong>\n     1 to 8 bytes\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     Full-speed devices\n    </strong>\n    : Packet size ranges from\n    <strong>\n     1 to 64 bytes\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     High-speed devices\n    </strong>\n    : Packet size ranges from\n    <strong>\n     1 to 1024 bytes\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n   In the device's\n   <strong>\n    default interface\n   </strong>\n   ,\n   <strong>\n    interrupt endpoints\n   </strong>\n   must support a\n   <strong>\n    maximum packet size of 64 bytes\n   </strong>\n   or less. If the data size exceeds the maximum packet size, the\n   <strong>\n    host\n   </strong>\n   will split the transfer into multiple transactions to accommodate the data.\n  </p>\n</li>\n</ul>\n<p>\n<strong>\n  Speed and Latency:\n </strong>\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Interrupt transfers\n   </strong>\n   guarantee a maximum latency, meaning the time between transaction attempts is predictable. There\u2019s\n   <strong>\n    no guaranteed transfer rate\n   </strong>\n   , but it ensures the\n   <strong>\n    time delay\n   </strong>\n   between attempts will never exceed the specified maximum latency.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    High-speed interrupt transfers\n   </strong>\n   can be very efficient. A\n   <strong>\n    high-speed endpoint\n   </strong>\n   can request up to\n   <strong>\n    three 1024-byte packets\n   </strong>\n   in a\n   <strong>\n    125-microsecond microframe\n   </strong>\n   , resulting in a transfer rate of\n   <strong>\n    24.576 Megabytes/sec\n   </strong>\n   . If more data is requested, the speed can be adjusted according to the available bandwidth.\n  </p>\n</li>\n</ul>\n"}, "Page 96": {"response": "<h3>\n Interrupt Transfer Speed and Latency\n</h3>\n<p>\n<strong>\n  High-Bandwidth Interrupt Endpoints:\n </strong>\n</p>\n<ul>\n<li>\n  Interrupt transfers at high speeds can request\n  <strong>\n   up to 1024 bytes per microframe\n  </strong>\n  , which is categorized as a\n  <strong>\n   high-bandwidth endpoint\n  </strong>\n  .\n </li>\n<li>\n  However, older operating systems like\n  <strong>\n   Windows XP\n  </strong>\n  and earlier don\u2019t support high-bandwidth interrupt endpoints, limiting the achievable transfer rate to\n  <strong>\n   8.192 Megabytes/sec\n  </strong>\n  .\n </li>\n<li>\n  If the\n  <strong>\n   host driver\n  </strong>\n  doesn't support alternate interfaces, the maximum achievable rate is\n  <strong>\n   64 kilobytes/sec\n  </strong>\n  .\n </li>\n</ul>\n<p>\n<strong>\n  Speed and Data Rates:\n </strong>\n</p>\n<ul>\n<li>\n  A\n  <strong>\n   full-speed endpoint\n  </strong>\n  can transfer\n  <strong>\n   up to 64 bytes\n  </strong>\n  per\n  <strong>\n   1-millisecond frame\n  </strong>\n  , which amounts to\n  <strong>\n   64 kilobytes/sec\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Low-speed devices\n  </strong>\n  can request\n  <strong>\n   up to 8 bytes\n  </strong>\n  every\n  <strong>\n   10 milliseconds\n  </strong>\n  , resulting in\n  <strong>\n   800 bytes/sec\n  </strong>\n  .\n </li>\n</ul>\n<p>\n<strong>\n  Maximum Latency:\n </strong>\n</p>\n<ul>\n<li>\n  The\n  <strong>\n   endpoint descriptor\n  </strong>\n  in the device specifies the\n  <strong>\n   maximum latency\n  </strong>\n  period, which determines the time between transaction attempts. This varies with the device\u2019s speed:\n  <ul>\n<li>\n<strong>\n     Low-speed\n    </strong>\n    devices: latency can range from\n    <strong>\n     10 to 255 milliseconds\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     Full-speed\n    </strong>\n    devices: latency can range from\n    <strong>\n     1 to 255 milliseconds\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     High-speed\n    </strong>\n    devices: latency can range from\n    <strong>\n     125 microseconds to 4 seconds\n    </strong>\n    , in increments of\n    <strong>\n     125 microseconds\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n  For\n  <strong>\n   high-speed interrupt endpoints\n  </strong>\n  with a latency of\n  <strong>\n   125 microseconds\n  </strong>\n  , the endpoint can request\n  <strong>\n   1, 2, or 3 transactions\n  </strong>\n  per interval. The\n  <strong>\n   host controller\n  </strong>\n  ensures transactions occur within the specified time.\n </li>\n</ul>\n<p>\n<strong>\n  Transaction Timing and Host Controller Behavior:\n </strong>\n</p>\n<ul>\n<li>\n  The host may initiate each transaction\n  <strong>\n   at any time up to the specified maximum latency\n  </strong>\n  from the previous transaction. For example:\n  <ul>\n<li>\n    With a\n    <strong>\n     10-millisecond maximum latency at full speed\n    </strong>\n    ,\n    <strong>\n     five transfers\n    </strong>\n    could take between\n    <strong>\n     5 to 50 milliseconds\n    </strong>\n    .\n   </li>\n<li>\n    In\n    <strong>\n     OHCI\n    </strong>\n    (Open Host Controller Interface) host controllers, latency values correspond to powers of\n    <strong>\n     2\n    </strong>\n    , with a maximum latency of\n    <strong>\n     32 milliseconds\n    </strong>\n    . This means if a device requests a\n    <strong>\n     maximum latency between 8 to 15 milliseconds\n    </strong>\n    , the host will start a transfer every\n    <strong>\n     8 milliseconds\n    </strong>\n    , while a\n    <strong>\n     latency between 32 to 255 milliseconds\n    </strong>\n    will result in a transfer every\n    <strong>\n     32 milliseconds\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n<strong>\n  Rate of Delivery:\n </strong>\n</p>\n<ul>\n<li>\n  While the host is free to transfer data\n  <strong>\n   faster\n  </strong>\n  than the requested rate,\n  <strong>\n   interrupt transfers don\u2019t guarantee an exact delivery rate\n  </strong>\n  unless the maximum latency corresponds to the\n  <strong>\n   fastest possible rate\n  </strong>\n  .\n </li>\n<li>\n  For example, with\n  <strong>\n   full-speed interrupt transfers on a 1.x host\n  </strong>\n  , if configured for\n  <strong>\n   1 transaction per millisecond\n  </strong>\n  , the host will ensure\n  <strong>\n   one transaction\n  </strong>\n  is reserved for every frame.\n </li>\n</ul>\n<p>\n<strong>\n  Key Takeaways:\n </strong>\n</p>\n<ul>\n<li>\n<strong>\n   Interrupt transfers\n  </strong>\n  are designed for time-sensitive data but don\u2019t guarantee a precise rate, as the host has flexibility in when to initiate the transactions, as long as the\n  <strong>\n   maximum latency\n  </strong>\n  is respected.\n </li>\n</ul>\n"}, "Page 97": {"response": "<h3>\n Interrupt Transfer Bandwidth and Error Handling\n</h3>\n<p>\n<strong>\n  Low-Speed Interrupt Transfers:\n </strong>\n</p>\n<ul>\n<li>\n  On an\n  <strong>\n   idle bus\n  </strong>\n  , up to\n  <strong>\n   six low-speed, 8-byte transactions\n  </strong>\n  can fit into each frame.\n </li>\n<li>\n  However, a\n  <strong>\n   low-speed interrupt endpoint\n  </strong>\n  can request only\n  <strong>\n   8 bytes every 10 milliseconds\n  </strong>\n  , and each\n  <strong>\n   low-speed device\n  </strong>\n  can have\n  <strong>\n   no more than two interrupt endpoints\n  </strong>\n  .\n </li>\n<li>\n  Devices needing\n  <strong>\n   more than 800 bytes/sec\n  </strong>\n  in each direction should use\n  <strong>\n   full-speed\n  </strong>\n  or\n  <strong>\n   high-speed\n  </strong>\n  . This is because low-speed traffic consumes more bandwidth relative to the data being transferred at higher speeds.\n </li>\n</ul>\n<p>\n<strong>\n  Full-Speed Interrupt Transfers:\n </strong>\n</p>\n<ul>\n<li>\n  At\n  <strong>\n   full speed\n  </strong>\n  , up to\n  <strong>\n   nineteen 64-byte transactions\n  </strong>\n  can fit in a single frame. However, since there is a minimum time of\n  <strong>\n   one millisecond\n  </strong>\n  between each transfer, the\n  <strong>\n   practical maximum\n  </strong>\n  number of interrupt transactions per frame is likely lower due to the host\u2019s scheduling capabilities.\n </li>\n</ul>\n<p>\n<strong>\n  High-Speed Interrupt Transfers:\n </strong>\n</p>\n<ul>\n<li>\n  At\n  <strong>\n   high speed\n  </strong>\n  , the limit is\n  <strong>\n   two transfers per microframe\n  </strong>\n  , each consisting of\n  <strong>\n   three 1024-byte transactions\n  </strong>\n  .\n </li>\n</ul>\n<p>\n<strong>\n  Protocol Overhead:\n </strong>\n</p>\n<ul>\n<li>\n  The overhead associated with each transfer depends on the speed:\n  <ul>\n<li>\n<strong>\n     Low-speed\n    </strong>\n    : 19 bytes\n   </li>\n<li>\n<strong>\n     Full-speed\n    </strong>\n    : 13 bytes\n   </li>\n<li>\n<strong>\n     High-speed\n    </strong>\n    : 55 bytes\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n<strong>\n  Microframe Usage:\n </strong>\n</p>\n<ul>\n<li>\n<strong>\n   High-speed interrupt and isochronous transfers\n  </strong>\n  together cannot exceed\n  <strong>\n   80%\n  </strong>\n  of a microframe's bandwidth.\n </li>\n<li>\n<strong>\n   Full-speed isochronous\n  </strong>\n  and\n  <strong>\n   low- and full-speed interrupt transfers\n  </strong>\n  combined cannot use more than\n  <strong>\n   90%\n  </strong>\n  of a frame.\n </li>\n</ul>\n<p>\n<strong>\n  Error Detection and Handling:\n </strong>\n</p>\n<ul>\n<li>\n  If a\n  <strong>\n   device fails to return an expected handshake packet\n  </strong>\n  ,\n  <strong>\n   host controllers in PCs\n  </strong>\n  will try to send the request up to\n  <strong>\n   two more times\n  </strong>\n  .\n </li>\n<li>\n  For\n  <strong>\n   NAK responses\n  </strong>\n  , the host typically retries the transaction\n  <strong>\n   without a limit\n  </strong>\n  . This is common in devices like\n  <strong>\n   keyboards\n  </strong>\n  , where the device may be idle for extended periods before a key press occurs.\n </li>\n</ul>\n<p>\n<strong>\n  Key Takeaways:\n </strong>\n</p>\n<ul>\n<li>\n<strong>\n   Low-speed interrupt transfers\n  </strong>\n  are very limited in bandwidth, so devices requiring higher rates should use higher speeds.\n </li>\n<li>\n<strong>\n   Full-speed and high-speed\n  </strong>\n  transfers can handle much more data but still have limits on how many transactions fit in a frame or microframe.\n </li>\n<li>\n  The protocol overhead is higher at higher speeds, but still manageable when considering the data being transferred.\n </li>\n<li>\n<strong>\n   Error handling\n  </strong>\n  ensures that if a handshake or data transfer doesn\u2019t complete, retries are attempted before the transfer is abandoned.\n </li>\n</ul>\n"}, "Page 98": {"response": "<h3>\n Isochronous Transfers: Real-Time, Constant-Rate Data Transfer\n</h3>\n<p>\n<strong>\n  Purpose and Use:\n </strong>\n Isochronous transfers are specifically designed for situations where data must be delivered at a constant rate, or within a specific timeframe, and where occasional errors are acceptable. These transfers are typically used for\n <strong>\n  streaming real-time data\n </strong>\n such as\n <strong>\n  encoded voice\n </strong>\n or\n <strong>\n  music\n </strong>\n . For example, music played in real-time or voice data in a live conversation.\n</p>\n<ul>\n<li>\n<strong>\n   Real-time Data\n  </strong>\n  : Isochronous transfers ensure timely delivery of data, which is critical in scenarios where the data must be processed in real-time (e.g., audio or video streaming).\n </li>\n<li>\n<strong>\n   Error Tolerance\n  </strong>\n  : These transfers can tolerate occasional data errors, unlike other transfer types like bulk transfers that prioritize accuracy over timing.\n </li>\n</ul>\n<p>\n<strong>\n  Comparing Isochronous to Other Transfers:\n </strong>\n</p>\n<ul>\n<li>\n  At\n  <strong>\n   full speed\n  </strong>\n  , isochronous transfers can transfer more data per frame than\n  <strong>\n   interrupt transfers\n  </strong>\n  but do not provide a mechanism for retransmitting data if it\u2019s received with errors.\n </li>\n<li>\n  While\n  <strong>\n   bulk transfers\n  </strong>\n  can send large data (such as a music file) to a device,\n  <strong>\n   isochronous transfers\n  </strong>\n  guarantee timely delivery but do not always require data to be consumed at a constant rate. For example, music file transfers can be done with bulk transfers, but\n  <strong>\n   real-time playback\n  </strong>\n  needs isochronous transfers to ensure data is delivered consistently over time.\n </li>\n</ul>\n<p>\n<strong>\n  Guaranteed Delivery at a Constant Rate:\n </strong>\n</p>\n<ul>\n<li>\n<strong>\n   Isochronous transfers\n  </strong>\n  ensure that once a transfer starts, the necessary bandwidth and time will be available to complete the transfer at a consistent rate. This makes it possible to predict the transfer\u2019s completion time, unlike bulk transfers that may face delays depending on bus activity.\n </li>\n</ul>\n<p>\n<strong>\n  Availability and Requirements:\n </strong>\n</p>\n<ul>\n<li>\n<strong>\n   Full-speed\n  </strong>\n  and\n  <strong>\n   high-speed\n  </strong>\n  devices support isochronous transfers, but these are not mandatory for every device. However, certain device classes like\n  <strong>\n   audio\n  </strong>\n  and\n  <strong>\n   video devices\n  </strong>\n  may require isochronous endpoints to ensure data is delivered correctly and in real-time.\n </li>\n</ul>\n<p>\n<strong>\n  Structure of Isochronous Transfers:\n </strong>\n</p>\n<ul>\n<li>\n  Isochronous transfers have a fixed\n  <strong>\n   data transfer rate\n  </strong>\n  , meaning a specific number of bytes are transferred in each\n  <strong>\n   frame\n  </strong>\n  or\n  <strong>\n   microframe\n  </strong>\n  . This fixed rate ensures that the timing and delivery of the data remain consistent.\n </li>\n</ul>\n<p>\n<strong>\n  Conclusion:\n </strong>\n</p>\n<ul>\n<li>\n<strong>\n   Isochronous transfers\n  </strong>\n  are critical for real-time data applications that need to arrive at a steady rate, like audio or video streaming. They guarantee timely data delivery but do not handle retransmissions for errors, which makes them suitable for situations where occasional errors are acceptable but timely delivery is crucial.\n </li>\n</ul>\n"}, "Page 99": {"response": "<h3>\n Isochronous Transfers: Structured Data Delivery for Real-Time Needs\n</h3>\n<p>\n<strong>\n  Data Rate and Structure:\n </strong>\n Isochronous transfers have a fixed data transfer rate, with a specific number of bytes moving in each frame (or microframe). This guarantees that data is delivered at a consistent rate, making it suitable for real-time data like audio and video streaming.\n</p>\n<ul>\n<li>\n<strong>\n   Full-Speed Isochronous Transfers\n  </strong>\n  : At full speed, each isochronous transfer consists of one\n  <strong>\n   IN\n  </strong>\n  or\n  <strong>\n   OUT\n  </strong>\n  transaction per frame. Multiple frames may be used at regular intervals to deliver the data.\n </li>\n<li>\n<strong>\n   High-Speed Isochronous Transfers\n  </strong>\n  : High-speed devices have more flexibility, allowing them to request as many as three transactions per\n  <strong>\n   microframe\n  </strong>\n  or as few as one transaction every\n  <strong>\n   32,768 microframes\n  </strong>\n  .\n </li>\n</ul>\n<p>\n<strong>\n  One-Way Transfers:\n </strong>\n Isochronous transfers are\n <strong>\n  one-way\n </strong>\n . All transactions in a transfer must either be\n <strong>\n  IN\n </strong>\n transactions (sending data to the host) or\n <strong>\n  OUT\n </strong>\n transactions (sending data to the device). If data needs to flow in both directions, separate pipes and transfers are required for each direction.\n</p>\n<p>\n<strong>\n  Data Amount and Protocols:\n </strong>\n The USB specification doesn\u2019t define a fixed protocol for specifying the exact amount of data in an isochronous transfer. To manage this, the device and host can use a\n <strong>\n  class-specific\n </strong>\n or\n <strong>\n  vendor-specific\n </strong>\n protocol to communicate the amount of data being transferred. For instance, they could include a header to indicate the data quantity or use another method for data request clarification.\n</p>\n<p>\n<strong>\n  No Handshakes:\n </strong>\n Unlike other transfer types, isochronous transfers\n <strong>\n  don\u2019t include handshake packets\n </strong>\n . This means that occasional errors are expected and must be tolerated. Therefore, isochronous transfers are designed for scenarios where timely data delivery is crucial, and minor data errors can be accepted.\n</p>\n<p>\n<strong>\n  Summary:\n </strong>\n</p>\n<ul>\n<li>\n<strong>\n   Isochronous transfers\n  </strong>\n  ensure data flows at a constant rate, ideal for real-time applications such as streaming.\n </li>\n<li>\n  They can be structured with different flexibilities depending on the speed: full-speed transfers are more rigid with one transaction per frame, while high-speed transfers allow more varied transaction requests.\n </li>\n<li>\n  Errors are expected in isochronous transfers, and no retries or handshakes occur during these transactions.\n </li>\n</ul>\n"}, "Page 100": {"response": "<h3>\n Isochronous Transfer Bandwidth and Synchronization\n</h3>\n<p>\n<strong>\n  Bandwidth Reservation and Availability:\n </strong>\n Before starting an isochronous transfer, the host controller checks if the necessary bandwidth is available. This involves comparing the\n <strong>\n  unreserved bandwidth\n </strong>\n with the\n <strong>\n  maximum packet size\n </strong>\n and\n <strong>\n  transfer rate\n </strong>\n of the device's isochronous endpoints.\n</p>\n<ul>\n<li>\n  For example, a\n  <strong>\n   full-speed transfer\n  </strong>\n  using the maximum\n  <strong>\n   1023 bytes per frame\n  </strong>\n  would use up\n  <strong>\n   69%\n  </strong>\n  of the bus's bandwidth. If two devices require the same amount of bandwidth, the host will only configure the first device, as the remaining bandwidth won't be sufficient to accommodate the second device.\n </li>\n<li>\n  To avoid this, every USB 2.0 device with isochronous endpoints must have at least one\n  <strong>\n   interface\n  </strong>\n  that requests\n  <strong>\n   no isochronous bandwidth\n  </strong>\n  , enabling the host to configure the device even when there isn't enough bandwidth available.\n </li>\n</ul>\n<p>\n<strong>\n  Alternate Configurations:\n </strong>\n</p>\n<ul>\n<li>\n  Devices can have alternate interfaces that request lower isochronous data rates, either by using smaller data packets or requesting fewer packets per microframe.\n </li>\n<li>\n  If necessary, the device driver can request a lower-rate interface or retry later when more bandwidth is available.\n </li>\n<li>\n  Once the host configures the device, the transfers are guaranteed to have the necessary bandwidth for completion.\n </li>\n</ul>\n<p>\n<strong>\n  Data Transfer Rate and Overhead:\n </strong>\n</p>\n<ul>\n<li>\n<strong>\n   Isochronous transfers\n  </strong>\n  send a fixed amount of data per frame, but the actual\n  <strong>\n   data transfer rate\n  </strong>\n  may fluctuate due to\n  <strong>\n   overhead\n  </strong>\n  and the need to share bus time with other devices. Thus, the transfer might burst at rates like\n  <strong>\n   12 Megabits/sec\n  </strong>\n  or\n  <strong>\n   480 Megabits/sec\n  </strong>\n  at any point within the frame or microframe.\n </li>\n<li>\n  To maintain a constant data rate (e.g., sending audio data to a speaker), the receiving device must convert the received data into signals that can be processed at a steady pace.\n </li>\n</ul>\n<p>\n<strong>\n  Synchronization in Isochronous Transfers:\n </strong>\n Isochronous transfers can be synchronized to other data sources or devices, or to the USB bus\u2019s\n <strong>\n  Start-of-Frame\n </strong>\n signals. For example, the data from a\n <strong>\n  microphone\n </strong>\n can be synchronized with the\n <strong>\n  audio output of speakers\n </strong>\n . The USB specification includes methods for synchronizing transfers with internal or external clocks, ensuring data is transferred and consumed at precise times.\n</p>\n<p>\n In summary:\n</p>\n<ul>\n<li>\n<strong>\n   Bandwidth checks\n  </strong>\n  are performed before isochronous transfers to ensure availability.\n </li>\n<li>\n  Devices may offer\n  <strong>\n   alternate interfaces\n  </strong>\n  with different bandwidth requirements.\n </li>\n<li>\n  Data is transferred in\n  <strong>\n   bursts\n  </strong>\n  rather than a constant rate, and synchronization is used to manage the timing of data consumption.\n </li>\n</ul>\n"}, "Page 101": {"response": "<h3>\n Isochronous Transfers: Data Size, Speed, and Transaction Details\n</h3>\n<p>\n<strong>\n  Data Size and Packet Limits:\n </strong>\n</p>\n<ul>\n<li>\n<strong>\n   Full-speed endpoints\n  </strong>\n  can transfer up to\n  <strong>\n   1023 bytes\n  </strong>\n  per packet, while\n  <strong>\n   high-speed endpoints\n  </strong>\n  can handle\n  <strong>\n   up to 1024 bytes\n  </strong>\n  .\n </li>\n<li>\n  If the data doesn't fit into a single packet, the host will continue the transfer in multiple transactions.\n </li>\n</ul>\n<p>\n<strong>\n  Data Distribution Across Frames:\n </strong>\n</p>\n<ul>\n<li>\n  Within an isochronous transfer, the\n  <strong>\n   amount of data per frame\n  </strong>\n  doesn\u2019t need to be the same for every frame. For instance, in an audio transfer at 44,100 samples per second, the data could be spread across\n  <strong>\n   9 frames with 44 samples each\n  </strong>\n  , followed by\n  <strong>\n   1 frame containing 45 samples\n  </strong>\n  . This ensures that data can be transferred in a manner that adapts to the device's needs.\n </li>\n</ul>\n<p>\n<strong>\n  Transfer Speed and Bandwidth:\n </strong>\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Full-speed isochronous transfers\n   </strong>\n   can achieve a maximum transfer rate of\n   <strong>\n    1.023 Megabytes/sec\n   </strong>\n   , using up to\n   <strong>\n    1023 bytes per frame\n   </strong>\n   , leaving\n   <strong>\n    31%\n   </strong>\n   of the bus bandwidth free for other uses. The protocol overhead for a single data packet transfer is\n   <strong>\n    9 bytes\n   </strong>\n   , which is less than\n   <strong>\n    1%\n   </strong>\n   of the total transfer for a\n   <strong>\n    1023-byte transaction\n   </strong>\n   . The minimum bandwidth for a full-speed transfer is\n   <strong>\n    1 kilobyte per second\n   </strong>\n   (1 byte per frame).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    High-speed isochronous transfers\n   </strong>\n   can transfer up to\n   <strong>\n    1024 bytes\n   </strong>\n   per transaction. For high-bandwidth endpoints that require more than\n   <strong>\n    1024 bytes\n   </strong>\n   per microframe, the host can request\n   <strong>\n    2 or 3 transactions per microframe\n   </strong>\n   , leading to a maximum transfer rate of\n   <strong>\n    24.576 Megabytes/sec\n   </strong>\n   . The protocol overhead for a single transfer is\n   <strong>\n    38 bytes\n   </strong>\n   for one data packet.\n  </p>\n</li>\n</ul>\n<p>\n In summary:\n</p>\n<ul>\n<li>\n<strong>\n   Full-speed\n  </strong>\n  and\n  <strong>\n   high-speed\n  </strong>\n  isochronous transfers have different\n  <strong>\n   data size limits\n  </strong>\n  , with high-speed allowing slightly larger packet sizes.\n </li>\n<li>\n  Data can be distributed unevenly across frames, allowing flexibility in transfers like audio streaming.\n </li>\n<li>\n<strong>\n   Full-speed\n  </strong>\n  transfers are slower, leaving more bandwidth for other devices, while\n  <strong>\n   high-speed\n  </strong>\n  transfers support faster rates, especially with high-bandwidth endpoints.\n </li>\n</ul>\n"}, "Page 102": {"response": "<h3>\n High-Speed Isochronous Transfers: Bandwidth, Error Handling, and Timing\n</h3>\n<p>\n<strong>\n  Bandwidth Flexibility:\n </strong>\n</p>\n<ul>\n<li>\n<strong>\n   High-speed isochronous transfers\n  </strong>\n  have the advantage of not needing a transaction in every frame or microframe, allowing them to request less bandwidth than\n  <strong>\n   full-speed transfers\n  </strong>\n  . The minimum bandwidth request can be as low as\n  <strong>\n   one byte every 32,678 microframes\n  </strong>\n  , which translates to\n  <strong>\n   one byte every 4.096 seconds\n  </strong>\n  . This flexibility allows endpoints to transfer less data than their maximum reserved bandwidth by either skipping available transactions or sending less data per transaction.\n </li>\n</ul>\n<p>\n<strong>\n  Bandwidth Usage Limits:\n </strong>\n</p>\n<ul>\n<li>\n  On a\n  <strong>\n   high-speed bus\n  </strong>\n  ,\n  <strong>\n   interrupt\n  </strong>\n  and\n  <strong>\n   isochronous transfers\n  </strong>\n  together can use up to\n  <strong>\n   80%\n  </strong>\n  of a microframe. On a\n  <strong>\n   full-speed bus\n  </strong>\n  ,\n  <strong>\n   isochronous transfers\n  </strong>\n  and\n  <strong>\n   low- and full-speed interrupt transfers\n  </strong>\n  combined can utilize\n  <strong>\n   up to 90%\n  </strong>\n  of a frame. When the bus is idle, a\n  <strong>\n   high-speed bus\n  </strong>\n  can carry\n  <strong>\n   two isochronous transfers\n  </strong>\n  at their maximum rate.\n </li>\n</ul>\n<p>\n<strong>\n  Error Handling in Isochronous Transfers:\n </strong>\n</p>\n<ul>\n<li>\n<strong>\n   Isochronous transfers\n  </strong>\n  don\u2019t include error correction as they are designed for real-time data delivery, where occasional errors are tolerable. This is particularly true for applications like streaming music or voice, where small dropouts may go unnoticed by users. If an error occurs, the receiver cannot request a retransmission, as this would disrupt the timing of the transfer. Although a receiver could ask for a complete resend, this is not efficient and often not practical.\n </li>\n</ul>\n<p>\n<strong>\n  Time-Critical Transfer Limitations:\n </strong>\n</p>\n<ul>\n<li>\n  Achieving the desired data transfer rate can be influenced by several factors, even if the endpoint supports high transfer speeds. Factors like\n  <strong>\n   bus bandwidth\n  </strong>\n  , the device\u2019s capabilities, and the host\u2019s performance can limit the actual data transfer rate. This means that while an endpoint may be capable of transferring data at high speeds, external conditions can affect whether that rate is realized in practice.\n </li>\n</ul>\n<p>\n In summary:\n</p>\n<ul>\n<li>\n<strong>\n   High-speed isochronous transfers\n  </strong>\n  offer bandwidth flexibility, allowing transfers to request less bandwidth and skip transactions when necessary.\n </li>\n<li>\n<strong>\n   Error correction\n  </strong>\n  is not supported in isochronous transfers due to their time-critical nature, making them suitable for applications where occasional errors are acceptable.\n </li>\n<li>\n  Achieving the maximum transfer rate depends on several factors, including\n  <strong>\n   bus bandwidth\n  </strong>\n  , device limitations, and host performance, which can all impact the actual transfer speed.\n </li>\n</ul>\n"}, "Page 103": {"response": "<h3>\n Bus Bandwidth and Device Capabilities in USB Transfers\n</h3>\n<p>\n<strong>\n  Bus Bandwidth\n </strong>\n<br/>\n When a device requests more bandwidth for interrupt or isochronous transfers than the bus can provide, the host will reject the device configuration. Low- and full-speed interrupt transfers consume minimal bandwidth, making them unlikely to cause issues. However, high-speed interrupt transfers can use up to 40% of the bus bandwidth, particularly if a high-speed endpoint requests three 1024-byte packets per microframe. To avoid configuration issues, the default interface must specify interrupt endpoints with a maximum packet size of 64 bytes. After the device is configured, the driver may request more bandwidth if needed by using alternate settings or configurations.\n</p>\n<p>\n Isochronous endpoints may also cause bandwidth issues, especially when devices request more bandwidth than the bus can support. On 1.x devices, this can result in the device being unconfigured without clear feedback. For USB 2.0 compliance, the default interface must not request isochronous bandwidth. This is usually achieved by omitting isochronous endpoints in the default interface. Post-enumeration, the device driver can request alternate interfaces or configurations to obtain isochronous bandwidth.\n</p>\n<p>\n<strong>\n  Device Capabilities\n </strong>\n<br/>\n Even if the host promises sufficient bandwidth, there is no guarantee that the device will be ready to send or receive data when required. This emphasizes the importance of both the device's capabilities and its driver in ensuring successful data transfer.\n</p>\n"}, "Page 104": {"response": "<h3>\n Effective Use of Interrupt and Isochronous Transfers\n</h3>\n<p>\n<strong>\n  Device and Transfer Readiness\n </strong>\n<br/>\n For interrupt and isochronous transfers to function smoothly, both the sending and receiving devices need to be able to manage data at the required rates. The sending device must load data into the endpoint\u2019s transmit buffer on time, ensuring the controller can send the data when the IN token packet is received. On the receiving end, the device must read the previous data from the buffer before new data arrives. If it doesn\u2019t, the new data may overwrite the old data, or the device may return a NAK (negative acknowledgment) or drop the data entirely.\n</p>\n<p>\n To help prevent data loss or overwriting, using\n <strong>\n  double or quadruple buffering\n </strong>\n (discussed in Chapter 6) can be effective. Multiple buffers allow more time for the firmware to prepare the next set of data for transfer or to retrieve newly received data.\n</p>\n<p>\n<strong>\n  Host Capabilities\n </strong>\n<br/>\n The ability of the host, particularly the device driver and application software, plays a crucial role in ensuring timely and successful data transfers.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Device Driver\n   </strong>\n   : The driver initiates a transfer by submitting an I/O Request Packet (IRP) to a lower-level driver. For interrupt and isochronous transfers, if the host controller does not have an outstanding IRP for an endpoint at its scheduled time, the transfer attempt will be skipped. To avoid missed transfers, drivers typically submit a new IRP immediately after the previous one completes.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Application Software\n   </strong>\n   : The software that consumes the data must also be capable of keeping pace with the data transfer. For example, in the case of HID-class devices, the driver places received report data into a buffer. If the buffer is full when a new report arrives, the driver will discard the oldest report to make room for the new one, potentially causing data loss. This can be mitigated by increasing the buffer size or allowing the software to read multiple reports at once.\n  </p>\n</li>\n</ul>\n<p>\n To ensure minimal delays, it's also beneficial to place the code that interacts with the device driver in an optimized location within the application, ensuring smoother and more efficient data handling.\n</p>\n"}, "Page 105": {"response": "<h3>\n Managing Latency and Transfer Efficiency\n</h3>\n<p>\n<strong>\n  Optimizing Application Performance\n </strong>\n<br/>\n To improve communication efficiency, it's beneficial for the application that interacts with the device to run its own dedicated program thread. This thread should focus solely on managing the USB communications, minimizing the potential for delays caused by multitasking responsibilities.\n</p>\n<p>\n Additionally, performing fewer, larger transfers is generally more efficient than multiple smaller ones. The application can typically send or request large chunks of data faster than many smaller ones. For transfers with multiple transactions, the lower-level drivers manage the scheduling, which can help optimize transfer efficiency.\n</p>\n<p>\n<strong>\n  Host Latencies and Their Impact\n </strong>\n<br/>\n Latency in the system, especially due to how Windows handles multi-tasking, can significantly affect the performance of time-critical USB transfers. Windows was not designed as a real-time operating system, meaning it cannot guarantee precise timing for data transfer, such as one transfer per millisecond.\n</p>\n<p>\n In Windows, multiple threads run concurrently, and the operating system allocates CPU time to each thread. However, threads cannot be guaranteed CPU time at exact intervals, leading to latency issues. Although most latencies are short (usually under 1 millisecond), in some situations, threads can be delayed for over 100 milliseconds. Newer versions of Windows tend to have improved handling of latencies compared to older versions.\n</p>\n<p>\n<strong>\n  Dealing with Latency\n </strong>\n<br/>\n USB devices and their software have no control over what other tasks the host CPU is executing, making it difficult to manage latency when timing is crucial. To minimize the impact of these latencies, it's best to offload real-time processing to the device itself, making the host communication as non-critical as possible.\n</p>\n<p>\n For example, consider a full-speed device reading a sensor every millisecond. If the device tries to send each reading through a separate interrupt transfer, missing one transfer would mean the system cannot catch up. A more efficient approach is for the device to gather multiple readings and transfer them in fewer, larger chunks. This way, the timing of the transfers becomes less sensitive to small delays in the host system.\n</p>\n"}, "Page 106": {"response": "<h3>\n Reducing Transfer Sensitivity with Data Compression\n</h3>\n<p>\n To reduce the impact of timing issues, the frequency of data transfers can be decreased by sending larger chunks at a time instead of many small transfers. This approach makes the timing of bus transfers less critical. Additionally, using data compression can be an effective strategy to reduce the amount of data that needs to be transferred, further minimizing the load on the system and improvin\n</p>\n"}, "Page 107": {"response": "<h3>\n Enumeration: How the Host Learns About Devices\n</h3>\n<p>\n Before applications can interact with a USB device, the host must first gather information about it and assign a suitable driver. This process is known as\n <em>\n  enumeration\n </em>\n . Enumeration involves several key steps: assigning a unique address to the device, reading its descriptors, assigning and loading the appropriate device driver, and selecting a configuration that details the device's power needs, endpoints, and other capabilities. Once this is complete, the device is ready to begin transferring data through its defined endpoints.\n</p>\n<p>\n This chapter explains the enumeration process and the role of descriptors, which the host uses to gather the necessary information. While not every detail of enumeration is required for designing a USB peripheral, understanding the general process is crucial.\n</p>\n"}, "Page 108": {"response": "<h3>\n The Enumeration Process\n</h3>\n<p>\n Enumeration is the process by which the host system identifies and configures USB devices. The first task is detecting when devices are attached or removed. This is managed by the hub, which uses an interrupt IN endpoint to report these events to the host. During system startup, the host polls its root hub to check for attached devices, including any additional hubs and devices connected to them. After boot-up, the host continues to poll periodically to detect any newly connected or removed devices.\n</p>\n<p>\n When a new device is detected, the host sends a series of requests to the device\u2019s hub to establish a communication path. Following this, the host begins the enumeration process by sending control transfers with standard USB requests to the device\u2019s Endpoint 0. Every USB device must support these control transfers, standard requests, and Endpoint 0. The device must respond by providing the requested information and performing the necessary actions to successfully complete the enumeration.\n</p>\n<p>\n From the user\u2019s perspective, enumeration is generally invisible and automatic. However, the user might be prompted to select or locate a driver when the device is used for the first time. Once enumeration is complete, the device appears in the Device Manager on Windows. If the device is removed from the bus, Windows will also remove it from the Device Manager.\n</p>\n<p>\n Most devices store the information required for enumeration in their firmware, and a combination of hardware and firmware manages the decoding and response to these requests. Some devices can handle the entire enumeration process in hardware, without requiring firmware support. On the host side, the enumeration process is also supported by the operating system.\n</p>\n"}, "Page 109": {"response": "<h3>\n Enumeration Steps: How the Host Detects and Configures Devices\n</h3>\n<p>\n The USB enumeration process follows a series of steps, with the device transitioning through various states to become fully configured for use. The USB specification defines six device states, but during enumeration, a device passes through only four: Powered, Default, Address, and Configured. Each state comes with specific behaviors and capabilities. The device must be prepared to respond to any request or event at any point during this process, as the sequence of requests may not always follow a fixed order.\n</p>\n<h4>\n 1. Device Attachment or Power-Up\n</h4>\n<p>\n The process begins when a user connects a device to a USB port, or when the system powers up with a device already connected. The device is in the\n <strong>\n  Powered\n </strong>\n state at this stage. The port on the host (either on the root hub or a downstream hub) supplies power to the device, but the device is not yet actively communicating with the host.\n</p>\n<h4>\n 2. Hub Detects the Device\n</h4>\n<p>\n The hub detects the attached device by monitoring the voltage levels on the signal lines (D+ and D-). Each hub port has a pull-down resistor (14.25 to 24.8 k\u03a9) on both signal lines. The device itself includes a pull-up resistor (900 to 1575 ohms) on either D+ (for full-speed devices) or D- (for low-speed devices). For high-speed devices, the attachment occurs at full speed. When the device is plugged into the port, its pull-up resistor brings the corresponding signal line high, alerting the hub that a device is present. At this stage, the hub continues to power the device but does not yet transmit USB traffic to it.\n</p>\n<h4>\n 3. Host Learns About the Device\n</h4>\n<p>\n After detecting the new device, the hub uses its interrupt endpoint to report the event to the host. The report tells the host that a device is attached and indicates which port the device is connected to. Upon receiving this information, the host sends a\n <strong>\n  Get_Port_Status\n </strong>\n request to the hub to gather more details about the device. This request, along with other standard requests, forms part of the USB enumeration process.\n</p>\n<p>\n By handling these steps, the host gradually learns about the device, preparing it for further configuration and eventual data transfers.\n</p>\n"}, "Page 110": {"response": "<h3>\n Enumeration Process Continued: Steps 4 to 7\n</h3>\n<p>\n After the hub has detected the device, the enumeration continues with a series of checks and resets to prepare the device for communication with the host.\n</p>\n<h4>\n 4. Hub Determines Device Speed\n</h4>\n<p>\n Before resetting the device, the hub checks whether the device is low-speed or full-speed. This is done by monitoring the voltages on the signal lines (D+ and D-). The hub identifies the device's speed based on which line has the higher voltage when idle. The speed information is then sent to the host in response to the next\n <strong>\n  Get_Port_Status\n </strong>\n request. If the hub is a USB 1.x model, speed detection may happen after a bus reset. However, USB 2.0 requires the speed detection to occur before the reset so the hub can determine whether the device supports high-speed communication.\n</p>\n<h4>\n 5. Hub Resets the Device\n</h4>\n<p>\n After learning about the new device, the host controller instructs the hub to reset the device\u2019s port using a\n <strong>\n  Set_Port_Feature\n </strong>\n request. During the reset, the hub places the device\u2019s USB data lines (D+ and D-) into a \"Reset\" condition for at least 10 milliseconds. In the reset state, both D+ and D- are held low, a special condition distinct from the normal state where the lines are in opposite logic states. This reset is specific to the new device, and other devices or hubs on the bus are unaffected.\n</p>\n<h4>\n 6. Host Determines if Full-Speed Device Supports High Speed\n</h4>\n<p>\n To determine whether a full-speed device can support high-speed communication, the device and hub use two special signal states known as Chirp J and Chirp K. In the Chirp J state, only the D+ line is driven, and in the Chirp K state, only the D- line is driven. During reset, a high-speed device sends a\n <strong>\n  Chirp K\n </strong>\n signal. If the device supports high speed, the high-speed-capable hub detects this chirp and responds with alternating\n <strong>\n  Chirp K\n </strong>\n and\n <strong>\n  Chirp J\n </strong>\n signals. If the hub receives the pattern\n <strong>\n  KJKJKJ\n </strong>\n , the device switches from full-speed to high-speed communication by removing the full-speed pull-up resistor. If the hub doesn\u2019t respond with the expected chirps, the device remains at full speed. Importantly, all high-speed devices must be capable of responding to enumeration requests at full speed.\n</p>\n<h4>\n 7. Hub Establishes Communication Path\n</h4>\n<p>\n Once the reset is complete, the host checks whether the device has exited the reset state by sending a\n <strong>\n  Get_Port_Status\n </strong>\n request. The response to thi\n</p>\n"}, "Page 111": {"response": "<h3>\n Enumeration Process Continued: Steps 8 to 10\n</h3>\n<p>\n Once the hub has successfully detected and reset the device, the enumeration process moves forward with several more steps to finalize the device\u2019s configuration and ensure the host can communicate with it effectively.\n</p>\n<h4>\n 8. Host Requests Device Descriptor and Maximum Packet Size\n</h4>\n<p>\n After the device exits the reset state, it enters the\n <strong>\n  Default\n </strong>\n state. In this state, the device is ready to respond to control transfers at Endpoint 0, using the default address of 00h, and can draw up to 100 milliamperes of power from the bus.\n</p>\n<p>\n The host now sends a\n <strong>\n  Get_Descriptor\n </strong>\n request to learn the maximum packet size of the device\u2019s default endpoint. This request is directed to device address 0, Endpoint 0. Since only one device responds to address 0, the host communicates with the correct device, even if multiple devices are connected. The eighth byte of the\n <strong>\n  device descriptor\n </strong>\n indicates the maximum packet size for Endpoint 0. Typically, the host requests 64 bytes. After receiving the data (whether it's the full 64 bytes or not), the host proceeds to the\n <strong>\n  Status stage\n </strong>\n of the transfer. Once the Status stage is complete, the host sends a reset request to the hub to ensure the device is in a known state, even though the reset is not required by the USB specification.\n</p>\n<h4>\n 9. Host Assigns a Unique Device Address\n</h4>\n<p>\n The next step in the enumeration process is assigning a unique address to the device. The host does this by sending a\n <strong>\n  Set_Address\n </strong>\n request. The device acknowledges this request and completes the Status stage using the default address of 00h. Afterward, the device implements the newly assigned address and enters the\n <strong>\n  Address\n </strong>\n state. From this point, all communication with the device will use its new address. The address remains valid until the device is detached, the port is reset, or the system reboots. On subsequent enumerations, the host may assign a different address to the device.\n</p>\n<h4>\n 10. Host Retrieves Full Device Descriptor\n</h4>\n<p>\n Finally, the host retrieves the full\n <strong>\n  device descriptor\n </strong>\n by sending a\n <strong>\n  Get_Descriptor\n </strong>\n request to the newly assigned address. This descriptor contains detailed information about the device, including the maximum packet size for Endpoint 0, the number of configurations supported, and other basic device details. The host uses this information for subsequent interactions with the device, helping to configure the device appropriately for data\n</p>\n"}, "Page 112": {"response": "<h3>\n Host Learns About Device and Loads Drivers: Steps 11-12\n</h3>\n<p>\n After the host has retrieved the basic device descriptor, it continues gathering more detailed information from the device, including configuration and interface data. The next steps involve selecting a suitable device driver and finalizing the device configuration.\n</p>\n<h4>\n 11. Host Assigns and Loads a Device Driver\n</h4>\n<p>\n Once the host has acquired enough information about the device through its descriptors, it searches for the appropriate driver to manage communications. Windows starts by matching the\n <strong>\n  Vendor ID\n </strong>\n ,\n <strong>\n  Product ID\n </strong>\n , and optional\n <strong>\n  release number\n </strong>\n from the device to the data in the PC\u2019s INF files. If no exact match is found, it looks for a match based on the\n <strong>\n  class\n </strong>\n ,\n <strong>\n  subclass\n </strong>\n , and\n <strong>\n  protocol\n </strong>\n values retrieved from the device.\n</p>\n<p>\n If the device has been connected before, Windows may use previously stored information from the system registry to avoid searching the INF files again. Once a suitable driver is identified, it is loaded to manage the device. Sometimes, after the driver is loaded, it may request the device to resend its descriptors or provide additional class-specific descriptors for further configuration.\n</p>\n<p>\n An exception to this process applies to\n <strong>\n  composite devices\n </strong>\n , which can have multiple interfaces. These devices may require different drivers for different interfaces, and these drivers are assigned after the interfaces are enabled. The device must first be configured before the interfaces can be activated.\n</p>\n<h4>\n 12. Device Driver Requests a Configuration\n</h4>\n<p>\n Once the driver is assigned, the host\u2019s device driver proceeds by selecting a configuration for the device. The device driver requests the appropriate\n <strong>\n  configuration descriptor\n </strong>\n . This descriptor includes details about the device's power requirements, endpoints, and other configuration-specific information. After this, the device can begin functioning with the selected configuration, and its endpoints can\n</p>\n"}, "Page 113": {"response": "<h3>\n Final Enumeration Steps and Device States\n</h3>\n<p>\n After the host has successfully gathered all necessary descriptors and assigned a device driver, it proceeds to finalize the device\u2019s configuration and put it into the appropriate operational state. The host also manages other device states, like\n <strong>\n  Attached\n </strong>\n and\n <strong>\n  Suspend\n </strong>\n , to ensure the device is ready for use or powered down when needed.\n</p>\n<h4>\n 13. Host Sends Set_Configuration Request\n</h4>\n<p>\n The final step in enumeration involves the host sending a\n <strong>\n  Set_Configuration\n </strong>\n request to the device. This request specifies which configuration should be applied. Some devices have only one configuration, while others offer multiple configurations. If a device supports multiple configurations, the driver decides which one to use. The driver can either choose based on how the device will be used, request user input, or simply select the first configuration.\n</p>\n<p>\n Once the device receives the request, it enables the specified configuration, entering the\n <strong>\n  Configured\n </strong>\n state. If the device is a\n <strong>\n  composite device\n </strong>\n , the host assigns appropriate drivers to each active interface at this point. The device is now fully configured and ready for use.\n</p>\n<h4>\n 14. The Attached and Suspend States\n</h4>\n<p>\n In addition to the\n <strong>\n  Configured\n </strong>\n state, two other states\u2014\n <strong>\n  Attached\n </strong>\n and\n <strong>\n  Suspend\n </strong>\n \u2014are also part of the USB device lifecycle:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Attached State\n   </strong>\n   : If the hub is not supplying power to the device\u2019s VBUS line (due to an over-current condition or a host request), the device enters the\n   <strong>\n    Attached\n   </strong>\n   state. In this state, there is no power on the VBUS, and the host cannot communicate with the device, treating it as if the device is not attached at all.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Suspend State\n   </strong>\n   : The device enters the\n   <strong>\n    Suspend\n   </strong>\n   state when there is no bus activity (such as Start-of-Frame markers) for at least 3 milliseconds. While in this state, the device must limit its use of bus power. Both configured and unconfigured devices must support this state.\n  </p>\n</li>\n</ul>\n<h4>\n Enumerating a Hub\n</h4>\n<p>\n Since hubs are also USB devices, the host enumerates newly attached hubs in the same way as any other device. After the host enumerates a hub, it then enumerates any devices attached to that hub, following the same\n</p>\n"}, "Page 114": {"response": "<h3>\n Device Removal and Tips for Successful Enumeration\n</h3>\n<p>\n Proper device removal and enumeration are crucial to ensuring the smooth communication between the device and the host. When a device is removed or a new one is added, the system must handle the changes correctly to maintain functionality. Additionally, the process of enumeration must be conducted in a flexible and error-free manner, as many factors can influence how it progresses.\n</p>\n<h4>\n Device Removal Process\n</h4>\n<p>\n When a user removes a device from the USB bus, the corresponding hub disables the device's port. The host becomes aware of this removal by polling the hub. Upon detecting an event, the host sends a\n <strong>\n  Get_Port_Status\n </strong>\n request to the hub to confirm the removal. Once the host learns that a device has been removed, Windows removes the device from the\n <strong>\n  Device Manager\n </strong>\n , and the device's address is freed up for any new device that might be attached.\n</p>\n<h4>\n Tips for Successful Enumeration\n</h4>\n<p>\n For successful enumeration, the device must respond promptly to various requests and events during the process. The following tips will help prevent common enumeration issues:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Don\u2019t Assume Event or Request Order\n   </strong>\n   : The USB specification does not define a fixed order for how the host will send control requests during enumeration. The device must be prepared to handle requests in any order and respond accordingly. Additionally, the host may reset the bus at any point, and the device must detect and handle these resets properly.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Be Ready to Abandon a Transfer or End It Early\n   </strong>\n   : When a device receives a new\n   <strong>\n    Setup packet\n   </strong>\n   , it must abandon any ongoing transfer and begin the new one. Similarly, upon receiving an\n   <strong>\n    OUT token\n   </strong>\n   packet, the device must assume that the host is ending the Data stage and transitioning to the\n   <strong>\n    Status\n   </strong>\n   stage, even if all requested data has not been transferred.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Don\u2019t Send More Data Than Requested\n   </strong>\n   : In the\n   <strong>\n    Data stage\n   </strong>\n   of a\n   <strong>\n    Control Read\n   </strong>\n   transfer, the device should not send more data than the host has requested. Sending too much data can cause issues, as the host is only expecting a specif\n  </p>\n</li>\n</ul>\n"}, "Page 115": {"response": "<h3>\n Tips for Successful Enumeration and Descriptors\n</h3>\n<p>\n To ensure smooth enumeration and successful interaction between a USB device and host, it is essential for the device to handle requests properly, respond appropriately to events, and follow best practices. This section also discusses the role of descriptors in enabling the host to understand the device's capabilities.\n</p>\n<h4>\n Additional Tips for Successful Enumeration:\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Limit Data to Host\u2019s Request\n   </strong>\n   : When the host requests a specific amount of data, such as nine bytes, the device should send only that exact amount. Sending more data than requested can cause issues with the enumeration process.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Send Zero-Length Data Packets When Necessary\n   </strong>\n   : If the device has less data to return than the host requested, and the requested data is an exact multiple of the endpoint\u2019s maximum packet size, the device must send a zero-length data packet. This tells the host that no more data is available.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Return a Stall for Unsupported Requests\n   </strong>\n   : The device should not assume it can handle every potential request the host may make. If the device encounters an unsupported request, it should respond with a\n   <strong>\n    STALL\n   </strong>\n   condition.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Wait to Set the Address\n   </strong>\n   : When the device receives a\n   <strong>\n    Set_Address\n   </strong>\n   request, it should only apply the new address after completing the\n   <strong>\n    Status\n   </strong>\n   stage of the request.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Prepare for Bus Suspension\n   </strong>\n   : The host may suspend the bus while the device is in any powered state, including before it has been fully configured. If the bus is suspended, the device should reduce its use of bus power as required by the USB specification.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Test Across Different Host Controllers\n   </strong>\n   : Host controllers may handle control transfers differently. Some may schedule multiple stages of a transfer within the same frame, while others do not. The device should be capable of handling both cases.\n  </p>\n</li>\n</ul>\n<h4>\n USB Descriptors:\n</h4>\n<p>\n Descriptors are crucial for a USB device\u2019s communication with the host. They are formatted blocks of information that provide details about the device\u2019s capabilities and features. All USB devices must be able to respond to standard\n <strong>\n  USB descriptor\n </strong>\n requests from the host. These descriptors store information about the device itself or specific elements within the device.\n</p>\n<p>\n Every USB device must respond correctly to requests for standard descriptors, which allows the host to gather the necessary details for enumeration and further communication. The descriptors act as a bridge between the device and the host, enabling the host to understand the device's func\n</p>\n"}, "Page 116": {"response": "<h3>\n Types of Descriptors\n</h3>\n<p>\n During the enumeration process, the host requests a variety of descriptors from the device. These descriptors provide progressively more detailed information about the device, starting with its overall characteristics and moving toward more specific elements such as configurations, interfaces, and endpoints. Below is an explanation of the key types of descriptors and their roles.\n</p>\n<h4>\n Overview of Descriptor Types\n</h4>\n<ul>\n<li>\n<strong>\n   Device Descriptor\n  </strong>\n  : Every USB device has exactly one device descriptor, which provides basic information about the entire device. This includes the number of configurations the device supports and other essential details.\n </li>\n<li>\n<strong>\n   Configuration Descriptor\n  </strong>\n  : Each device also has one or more configuration descriptors that specify the device\u2019s power requirements and the number of interfaces supported by the configuration.\n </li>\n<li>\n<strong>\n   Interface Descriptor\n  </strong>\n  : For each configuration, there are one or more interface descriptors. These describe the functionality of each interface and may include references to one or more endpoint descriptors.\n </li>\n<li>\n<strong>\n   Endpoint Descriptor\n  </strong>\n  : Each endpoint in an interface is described by an endpoint descriptor, which provides the details required to transfer data with the endpoint. If an interface has no endpoint descriptors, it must use the control endpoint for communication.\n </li>\n</ul>\n<p>\n When the host requests a configuration descriptor, the device responds by returning the configuration descriptor along with any related descriptors for interfaces, endpoints, and other subordinate descriptors, up to the specified byte limit.\n</p>\n<h4>\n Special Descriptors for Speed Support\n</h4>\n<ul>\n<li>\n<strong>\n   Device Qualifier Descriptor\n  </strong>\n  : Devices that support both full and high speeds may also include a\n  <strong>\n   device_qualifier\n  </strong>\n  descriptor. This descriptor provides information about the device\u2019s behavior when operating at the speed that is not currently selected.\n </li>\n<li>\n<strong>\n   Other-Speed Configuration Descriptor\n  </strong>\n  : Devices that support both full and high speeds may also include an\n  <strong>\n   other_speed_configuration\n  </strong>\n  descriptor. It provides details about the device's configuration when operating at the speed not currently selected.\n </li>\n</ul>\n<h4>\n String Descriptors\n</h4>\n<ul>\n<li>\n<strong>\n   String Descriptor\n  </strong>\n  : A string descriptor contains text information, such as the device\u2019s name or the vendor's name. Other descriptors can include index values that point to specific string descriptors, which the host can access using\n  <strong>\n   Get_Descriptor\n  </strong>\n  requests.\n </li>\n</ul>\n<h4>\n Class- or Vendor-Specific Descriptors\n</h4>\n<ul>\n<li>\n<strong>\n   Class or Vendor-Specific Descriptors\n  </strong>\n  : In addition to the standard descriptors, USB devices may also have class- or vendor-specific descriptors. These allow the device to provide more detailed information about its features or functionality in a structured format. For example, an interface descriptor might contain additional descriptors that offer more specialized details depending on the device\u2019s class or vendor.\n </li>\n</ul>\n<p>\n In summary, descriptors are critical for the host to gather detailed information about a device's structure, power usage, capabilities, and communication endpoints. The host uses these descriptors to configure the device and enable communication based on the specific de\n</p>\n"}, "Page 117": {"response": "<h3>\n Descriptor Types and Their Identification\n</h3>\n<p>\n Descriptors are key data structures used during the enumeration process, and they allow the host to understand various aspects of a USB device. Each descriptor contains a value that identifies its type. The type helps the host process and interpret the data contained within that descriptor. Below is an explanation of the various descriptor types and how they are identified.\n</p>\n<h4>\n Descriptor Type Identification\n</h4>\n<ul>\n<li>\n<p>\n   Each descriptor includes a\n   <strong>\n    bDescriptorType\n   </strong>\n   value that identifies the type of descriptor. The descriptor type can be divided into three categories:\n  </p>\n<ul>\n<li>\n<strong>\n     Standard descriptors\n    </strong>\n    (value 00h)\n   </li>\n<li>\n<strong>\n     Class-specific descriptors\n    </strong>\n    (value 01h)\n   </li>\n<li>\n<strong>\n     Vendor-specific descriptors\n    </strong>\n    (value 02h)\n   </li>\n<li>\n<strong>\n     Reserved descriptors\n    </strong>\n    (value 03h)\n   </li>\n</ul>\n</li>\n<li>\n<p>\n   Additionally, the\n   <strong>\n    bDescriptorType\n   </strong>\n   field has bitwise structures that help in identifying its specific kind:\n  </p>\n<ul>\n<li>\n<strong>\n     Bit 7\n    </strong>\n    is always set to 0.\n   </li>\n<li>\n<strong>\n     Bits 6 and 5\n    </strong>\n    determine whether the descriptor is standard, class-specific, vendor-specific, or reserved.\n   </li>\n<li>\n<strong>\n     Bits 4 through 0\n    </strong>\n    further specify the descriptor.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Common Descriptor Types\n</h4>\n<p>\n Here are some of the common descriptor types and their functions:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    01h \u2013 Device Descriptor\n   </strong>\n   : This is a required descriptor for all devices. It provides general information about the device as a whole.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    02h \u2013 Configuration Descriptor\n   </strong>\n   : Another required descriptor, it details the device\u2019s configuration, such as power usage and the number of interfaces supported.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    03h \u2013 String Descriptor\n   </strong>\n   : Optional. It holds descriptive text, such as the device name or vendor name. The device may support multiple string descriptors.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    04h \u2013 Interface Descriptor\n   </strong>\n   : Required for every configuration. It describes a specific function of the device, detailing the type of interface used.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    05h \u2013 Endpoint Descriptor\n   </strong>\n   : Optional unless the device uses only Endpoint 0. This descriptor contains details about how data is transferred between the device and the host.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    06h \u2013 Device Qualifier Descriptor\n   </strong>\n   : Required for devices that support both full and high speeds. This descriptor is not used for devices that only support one speed.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    07h \u2013 Other-Speed Configuration Descriptor\n   </strong>\n   : Like the device qualifier, this is only used for devices that support both full and high speeds.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    08h \u2013 Interface Power Descriptor\n   </strong>\n   : This descriptor is used for devices that support interface-level power management.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    09h \u2013 OTG (On-The-Go) Descriptor\n   </strong>\n   : Used for On-The-Go (OTG) devices, which support both host and device roles.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    0Ah \u2013 Debug Descriptor\n   </strong>\n   : This optional descriptor provides debugging capabilities for the device.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    0Bh \u2013 Interface Association Descriptor\n   </strong>\n   : This is used for\n   <strong>\n    composite devices\n   </strong>\n   , which have multiple interfaces that may need to be handled by separate drivers.\n  </p>\n</li>\n</ul>\n<h4>\n Class-Specific Descriptors\n</h4>\n<p>\n Some devices, especially those belonging to certain device classes, may also include additional descriptors specific to that class. For instance:\n</p>\n<ul>\n<li>\n<strong>\n   29h\n  </strong>\n  : A\n  <strong>\n   hub descriptor\n  </strong>\n  used for devices acting as hubs.\n </li>\n<li>\n<strong>\n   21h\n  </strong>\n  : A\n  <strong>\n   HID (Human Interface Device) descriptor\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   22h\n  </strong>\n  : A\n  <strong>\n   report descriptor\n  </strong>\n  in the HID class.\n </li>\n<li>\n<strong>\n   23h\n  </strong>\n  : A\n  <strong>\n   physical descriptor\n  </strong>\n  in the HID class.\n </li>\n</ul>\n<h4>\n Descriptor Fields\n</h4>\n<p>\n Each descriptor contains a set of fields that define various pieces of data. Many of these field names use prefixes to clarify their content or format:\n</p>\n<ul>\n<li>\n<strong>\n   b\n  </strong>\n  : byte (8 bits)\n </li>\n<li>\n<strong>\n   w\n  </strong>\n  : word (16 bits)\n </li>\n<li>\n<strong>\n   bm\n  </strong>\n  : bit map\n </li>\n<li>\n<strong>\n   bcd\n  </strong>\n  : binary-coded decimal\n </li>\n<li>\n<strong>\n   i\n  </strong>\n  : index\n </li>\n<li>\n<strong>\n   id\n  </strong>\n  : identifier\n </li>\n</ul>\n<p>\n In conclusion, descriptors play a critical role in enabling the host to understand and communicate with the USB device. Each descriptor provides structured information about the device's capabilities, power usage, interfaces, and more. By recognizing the\n <strong>\n  bDescriptorType\n </strong>\n field and understanding the different types of descriptors, the host can accurately configure the device for use.\n</p>\n"}, "Page 118": {"response": "<h3>\n Device Descriptor: Essential Information About the Device\n</h3>\n<p>\n The\n <strong>\n  device descriptor\n </strong>\n provides fundamental information about a USB device. It is the first piece of data the host reads when a device is connected. This descriptor allows the host to gather necessary details to request further information from the device. A host retrieves the device descriptor by sending a\n <strong>\n  Get_Descriptor\n </strong>\n request with the high byte of the Setup transaction\u2019s\n <strong>\n  wValue\n </strong>\n field set to 1.\n</p>\n<p>\n The device descriptor contains 14 fields, and these fields are grouped based on their purpose. Table 4-2 outlines the fields in the order they appear. This section explains the fields and their corresponding functions in more detail.\n</p>\n<h4>\n Descriptor Information\n</h4>\n<ul>\n<li>\n<strong>\n   bLength\n  </strong>\n  : The length, in bytes, of the descriptor.\n </li>\n<li>\n<strong>\n   bDescriptorType\n  </strong>\n  : This field is constant and holds the value\n  <strong>\n   DEVICE\n  </strong>\n  (01h), identifying it as a device descriptor.\n </li>\n</ul>\n<h4>\n Device Information\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    bcdUSB\n   </strong>\n   : This field indicates the version of the USB specification that the device and its descriptors comply with, in\n   <strong>\n    BCD (binary-coded decimal)\n   </strong>\n   format. The upper byte represents the major version number, while the next four bits represent tenths, and the final four bits represent hundredths. For example:\n  </p>\n<ul>\n<li>\n    USB 1.0: 0100h\n   </li>\n<li>\n    USB 1.1: 0110h\n   </li>\n<li>\n    USB 2.0: 0200h\nA USB 2.0 device does not need to be high-speed; it could be low-speed or full-speed, but the device should comply with the USB 2.0 specification for all devices.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    idVendor\n   </strong>\n   : This field contains a unique\n   <strong>\n    Vendor ID\n   </strong>\n   , assigned to members of the\n   <strong>\n    USB Implementers Forum (USB-IF)\n   </strong>\n   or other entities who have paid an administrative fee. The\n   <strong>\n    Vendor ID\n   </strong>\n   allows the host to identify the manufacturer of the device. If the host has an\n   <strong>\n    INF file\n   </strong>\n   that includes the Vendor ID, it helps the host choose an appropriate device driver for the device. It is crucial for every device descriptor (except those for internal use) to have a valid Vendor ID to avoid conflicts.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    idProduct\n   </strong>\n   : This field contains the\n   <strong>\n    Product ID\n   </strong>\n   , which is assigned by the vendor to uniquely identify a particular product. This value, found both in the device descriptor and the INF file on the host, helps the operating system select the correct driver for the device. The host uses the\n   <strong>\n    Vendor ID\n   </strong>\n   and\n   <strong>\n    Product ID\n   </strong>\n   to pair the device with the appropriate driver.\n  </p>\n</li>\n</ul>\n<p>\n By using the device descriptor, the host can identify the USB version, the device manufacturer, and the specific product, which helps in driver selection and further enumeration steps. This process is essential for successful communication between th\n</p>\n"}, "Page 119": {"response": "<h3>\n Device Descriptor: Key Fields and Their Functions\n</h3>\n<p>\n The\n <strong>\n  device descriptor\n </strong>\n is essential for identifying a USB device and facilitating proper communication with the host. It contains critical information about the device, which helps the host determine the correct driver and other device details. Below are the descriptions of the fields in the device descriptor, along with their purpose and usage.\n</p>\n<h4>\n Key Fields in the Device Descriptor\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    bLength\n   </strong>\n   : The size of the descriptor in bytes. It indicates the length of the device descriptor itself.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bDescriptorType\n   </strong>\n   : Always set to\n   <strong>\n    DEVICE\n   </strong>\n   (01h), this field indicates that the descriptor is a device descriptor.\n  </p>\n</li>\n</ul>\n<h4>\n Device Identification\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    bcdUSB\n   </strong>\n   : The USB specification version the device conforms to, stored in\n   <strong>\n    BCD (binary-coded decimal)\n   </strong>\n   format. For example:\n  </p>\n<ul>\n<li>\n    USB 1.0: 0100h\n   </li>\n<li>\n    USB 1.1: 0110h\n   </li>\n<li>\n    USB 2.0: 0200h\nThis version helps ensure the device works with the correct version of the USB specification.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    idVendor\n   </strong>\n   : The\n   <strong>\n    Vendor ID\n   </strong>\n   assigned to the manufacturer. This value helps identify the manufacturer of the device. The Vendor ID is unique, and the host can use it to find the right driver, particularly in\n   <strong>\n    INF files\n   </strong>\n   that contain vendor details.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    idProduct\n   </strong>\n   : The\n   <strong>\n    Product ID\n   </strong>\n   assigned by the vendor to distinguish different products. This ID works in conjunction with the Vendor ID to ensure that the host loads the correct driver for the device.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bcdDevice\n   </strong>\n   : This field contains the\n   <strong>\n    device release number\n   </strong>\n   , provided by the vendor in\n   <strong>\n    BCD format\n   </strong>\n   . This helps the host determine which version of the device it is dealing with and could play a role in selecting the appropriate driver.\n  </p>\n</li>\n</ul>\n<h4>\n String Descriptors\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    iManufacturer\n   </strong>\n   : This is an\n   <strong>\n    index\n   </strong>\n   that points to a string descriptor describing the manufacturer of the device. If no manufacturer string is available, this field is set to zero.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    iProduct\n   </strong>\n   : This is an\n   <strong>\n    index\n   </strong>\n   that points to a string descriptor describing the product name. If the product name is unavailable, this field is set to zero.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    iSerialNumber\n   </strong>\n   : This index points to a string descriptor containing the\n   <strong>\n    device\u2019s serial number\n   </strong>\n   . If there is no serial number, this field is set to zero. Some devices, like mass storage devices, require a serial number, especially when multiple identical devices are connected to the host. Serial numbers help the host differentiate between these devices, even after rebooting.\n  </p>\n</li>\n</ul>\n<h4>\n Configuration Information\n</h4>\n<ul>\n<li>\n<strong>\n   bNumConfigurations\n  </strong>\n  : This field indicates the number of possible configurations the device can have. The host uses this value to understand how many configurations it can request from the device.\n </li>\n</ul>\n<h3>\n Summary of the Device Descriptor Fields\n</h3>\n<p>\n The\n <strong>\n  device descriptor\n </strong>\n provides essential details about the device, including its manufacturer, product information, and capabilities. These fields allow the host to identify the device, load the appropriate driver, and ensure communication is set up correctly.\n</p>\n<p>\n Here's a quick overview of the device descriptor fields, shown in Table 4-2:\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Field\n    </strong>\n</th>\n<th>\n<strong>\n     Size (bytes)\n    </strong>\n</th>\n<th>\n<strong>\n     Description\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     bLength\n    </strong>\n</td>\n<td>\n    1\n   </td>\n<td>\n    Descriptor size in bytes\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     bDescriptorType\n    </strong>\n</td>\n<td>\n    1\n   </td>\n<td>\n    Always set to\n    <strong>\n     DEVICE\n    </strong>\n    (01h)\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     bcdUSB\n    </strong>\n</td>\n<td>\n    2\n   </td>\n<td>\n    USB specification version (BCD format)\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     bDeviceClass\n    </strong>\n</td>\n<td>\n    1\n   </td>\n<td>\n    Class code\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     bDeviceSubclass\n    </strong>\n</td>\n<td>\n    1\n   </td>\n<td>\n    Subclass code\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     bDeviceProtocol\n    </strong>\n</td>\n<td>\n    1\n   </td>\n<td>\n    Protocol code\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     bMaxPacketSize0\n    </strong>\n</td>\n<td>\n    1\n   </td>\n<td>\n    Max packet size for Endpoint 0\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     idVendor\n    </strong>\n</td>\n<td>\n    2\n   </td>\n<td>\n    Vendor ID\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     idProduct\n    </strong>\n</td>\n<td>\n    2\n   </td>\n<td>\n    Product ID\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     bcdDevice\n    </strong>\n</td>\n<td>\n    2\n   </td>\n<td>\n    Device release number (BCD format)\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     iManufacturer\n    </strong>\n</td>\n<td>\n    1\n   </td>\n<td>\n    Index to string descriptor for manufacturer\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     iProduct\n    </strong>\n</td>\n<td>\n    1\n   </td>\n<td>\n    Index to string descriptor for product\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     iSerialNumber\n    </strong>\n</td>\n<td>\n    1\n   </td>\n<td>\n    Index to string descriptor for serial number\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     bNumConfigurations\n    </strong>\n</td>\n<td>\n    1\n   </td>\n<td>\n    Number of possible configurations\n   </td>\n</tr>\n</tbody>\n</table>\n<p>\n This detailed information allows the host to interact effective\n</p>\n"}, "Page 120": {"response": "<h3>\n Configuration and Class Information in the Device Descriptor\n</h3>\n<p>\n The\n <strong>\n  device descriptor\n </strong>\n contains important details about the configuration and class of the device. These fields help the host determine the capabilities and features of the device, and they are essential for proper communication and driver selection. Below is a breakdown of these fields.\n</p>\n<h4>\n Configuration Information\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    bNumConfigurations\n   </strong>\n   : This field indicates how many configurations the device can support. A configuration describes the device's capabilities and how it operates in a given setup.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bMaxPacketSize0\n   </strong>\n   : The maximum packet size for\n   <strong>\n    Endpoint 0\n   </strong>\n   , which is essential for communication between the device and host. This value tells the host how much data can be sent at once over Endpoint 0. The packet size varies depending on the device's speed:\n  </p>\n<ul>\n<li>\n    For\n    <strong>\n     low-speed devices\n    </strong>\n    , the maximum is 8 bytes.\n   </li>\n<li>\n    For\n    <strong>\n     full-speed devices\n    </strong>\n    , the maximum can be 8, 16, 32, or 64 bytes.\n   </li>\n<li>\n    For\n    <strong>\n     high-speed devices\n    </strong>\n    , the maximum is 64 bytes.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Device Class Information\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    bDeviceClass\n   </strong>\n   : This field identifies the device's class at the device level. USB defines a range of standard class codes (1 to FEh). These predefined classes are listed in\n   <strong>\n    Table 4-3\n   </strong>\n   . If the device does not conform to a standard class, it can be marked with the value\n   <strong>\n    FFh\n   </strong>\n   , indicating that the class is vendor-specific. For many devices, their function is specified at the\n   <strong>\n    interface level\n   </strong>\n   rather than the device level, in which case this field is set to\n   <strong>\n    00h\n   </strong>\n   or\n   <strong>\n    EFh\n   </strong>\n   (for devices that use an interface association descriptor).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bDeviceSubclass\n   </strong>\n   : This field indicates a subclass within the specified device class. If the device class is\n   <strong>\n    0\n   </strong>\n   (or unspecified), this field must also be set to\n   <strong>\n    0\n   </strong>\n   . If a valid class code is provided, the subclass code must adhere to a specification for that class. A value of\n   <strong>\n    FFh\n   </strong>\n   means that the subclass is vendor-specific. Subclasses allow for additional features that may be shared by a group of devices within the same class.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bDeviceProtocol\n   </strong>\n   : This field specifies the protocol used by the device, based on its class or subclass. For example, a\n   <strong>\n    2.0 hub\n   </strong>\n   uses this field to indicate whether it is operating at high speed and whether it supports one or more transaction translators. If the device class is between\n   <strong>\n    01h\n   </strong>\n   and\n   <strong>\n    FEh\n   </strong>\n   , the protocol must match a code defined in the relevant USB class specification.\n  </p>\n</li>\n</ul>\n<h3>\n Summary of Key Fields\n</h3>\n<p>\n These configuration and class fields enable the host to understand the device's functionality and how it should interact with it. They provide critical information for selecting the correct configuration, determining the communication protocol, and ensuring compatibility between the host and device.\n</p>\n<ul>\n<li>\n<strong>\n   bNumConfigurations\n  </strong>\n  : The number of configurations supported by the device.\n </li>\n<li>\n<strong>\n   bMaxPacketSize0\n  </strong>\n  : The maximum packet size for Endpoint 0, specific to the device's speed.\n </li>\n<li>\n<strong>\n   bDeviceClass\n  </strong>\n  : Defines the device's class, helping the host understand the device's function.\n </li>\n<li>\n<strong>\n   bDeviceSubclass\n  </strong>\n  : Specifies a subclass within the device's class, if applicable.\n </li>\n<li>\n<strong>\n   bDeviceProtocol\n  </strong>\n  : Identifies the protocol used within the\n </li>\n</ul>\n"}, "Page 121": {"response": "<h3>\n Device_Qualifier Descriptor for Dual-Speed Devices\n</h3>\n<p>\n Devices that are capable of both\n <strong>\n  full-speed\n </strong>\n and\n <strong>\n  high-speed\n </strong>\n USB operations must include a\n <strong>\n  device_qualifier descriptor\n </strong>\n . This descriptor is necessary because certain fields in the\n <strong>\n  device descriptor\n </strong>\n change depending on the speed the device is currently using. The\n <strong>\n  device_qualifier descriptor\n </strong>\n holds the values of these fields for the speed that is not in use at the moment. In simple terms, when the device switches speeds, the contents of the\n <strong>\n  device descriptor\n </strong>\n and the\n <strong>\n  device_qualifier descriptor\n </strong>\n swap, depending on whether the device is operating at\n <strong>\n  full speed\n </strong>\n or\n <strong>\n  high speed\n </strong>\n .\n</p>\n<h4>\n Retrieving the Device_Qualifier Descriptor\n</h4>\n<p>\n The host can retrieve the\n <strong>\n  device_qualifier descriptor\n </strong>\n by sending a\n <strong>\n  Get_Descriptor\n </strong>\n request where the high byte of the\n <strong>\n  wValue\n </strong>\n field is set to\n <strong>\n  6\n </strong>\n . This will return the descriptor containing details about the device\u2019s capabilities at the speed not currently in use.\n</p>\n<h4>\n Fields in the Device_Qualifier Descriptor\n</h4>\n<p>\n The\n <strong>\n  device_qualifier descriptor\n </strong>\n contains nine fields, but some fields from the device descriptor\u2014like the\n <strong>\n  Vendor ID\n </strong>\n ,\n <strong>\n  Product ID\n </strong>\n ,\n <strong>\n  device release number\n </strong>\n , and string descriptors for the\n <strong>\n  manufacturer\n </strong>\n ,\n <strong>\n  product\n </strong>\n , and\n <strong>\n  serial number\n </strong>\n \u2014are not included in the\n <strong>\n  device_qualifier descriptor\n </strong>\n because they do not change when the device switches speeds. This makes the\n <strong>\n  device_qualifier descriptor\n </strong>\n more focused on the device's behavior and configurations for the speed that is not being actively used.\n</p>\n<p>\n The\n <strong>\n  device_qualifier descriptor\n </strong>\n provides the host with the necessary information to manage and configure the device depending on which USB speed is in use.\n</p>\n<h3>\n Device Class Information (bDeviceClass)\n</h3>\n<p>\n In the\n <strong>\n  device descriptor\n </strong>\n , the\n <strong>\n  bDeviceClass\n </strong>\n field indicates the class to which the device belongs. The possible values for this field include a variety of predefined class codes, and the device may use specific class codes to define its functionality at either the\n <strong>\n  device\n </strong>\n or\n <strong>\n  interface\n </strong>\n level. Here\u2019s an overview of the\n <strong>\n  bDeviceClass\n </strong>\n field values:\n</p>\n<ul>\n<li>\n<strong>\n   00h\n  </strong>\n  : The class is specified in the\n  <strong>\n   interface descriptor\n  </strong>\n  (use\n  <strong>\n   EFh\n  </strong>\n  if the device includes an\n  <strong>\n   interface association descriptor\n  </strong>\n  ).\n </li>\n<li>\n<strong>\n   02h\n  </strong>\n  : Communications.\n </li>\n<li>\n<strong>\n   09h\n  </strong>\n  : Hub.\n </li>\n<li>\n<strong>\n   DCh\n  </strong>\n  : Diagnostic Device (also can be defined at the interface level).\n </li>\n<li>\n<strong>\n   E0h\n  </strong>\n  : Wireless Controller (can also be defined at the interface level).\n </li>\n<li>\n<strong>\n   EFh\n  </strong>\n  : Miscellaneous Device (often associated with a\n  <strong>\n   common class\n  </strong>\n  or specific protocol).\n </li>\n<li>\n<strong>\n   FFh\n  </strong>\n  : Vendor-specific device.\n </li>\n</ul>\n<p>\n This class information is crucial for the host to understand how the device operates and ho\n</p>\n"}, "Page 122": {"response": "<h3>\n Device_Qualifier Descriptor Details\n</h3>\n<p>\n The\n <strong>\n  device_qualifier descriptor\n </strong>\n provides important information for devices that support both\n <strong>\n  full-speed\n </strong>\n and\n <strong>\n  high-speed\n </strong>\n USB operations. It essentially describes how the device behaves when using the USB speed not currently in use. This descriptor is crucial for the host to understand the device's capabilities across different speeds.\n</p>\n<h4>\n Fields in the Device_Qualifier Descriptor\n</h4>\n<p>\n The\n <strong>\n  device_qualifier descriptor\n </strong>\n consists of nine fields, as outlined in the table below:\n</p>\n<ol>\n<li>\n<strong>\n   bLength (1 byte)\n  </strong>\n  : Specifies the length of the descriptor in bytes.\n </li>\n<li>\n<strong>\n   bDescriptorType (1 byte)\n  </strong>\n  : Always set to\n  <strong>\n   06h\n  </strong>\n  , which indicates that this is a\n  <strong>\n   device_qualifier descriptor\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   bcdUSB (2 bytes)\n  </strong>\n  : Defines the USB specification version that the device and its descriptors comply with. It must be at least\n  <strong>\n   0200h\n  </strong>\n  for USB 2.0 compatibility.\n </li>\n<li>\n<strong>\n   bDeviceClass (1 byte)\n  </strong>\n  : Identifies the class the device belongs to. This field is used when the device belongs to a class and is applicable in both the device descriptor and the device_qualifier descriptor.\n </li>\n<li>\n<strong>\n   bDeviceSubclass (1 byte)\n  </strong>\n  : If the device belongs to a class, this field specifies the subclass within that class.\n </li>\n<li>\n<strong>\n   bDeviceProtocol (1 byte)\n  </strong>\n  : Defines the protocol within the selected class or subclass. For example, for a USB hub, this could indicate whether the device supports both\n  <strong>\n   low-speed\n  </strong>\n  ,\n  <strong>\n   full-speed\n  </strong>\n  , and\n  <strong>\n   high-speed\n  </strong>\n  protocols.\n </li>\n<li>\n<strong>\n   bMaxPacketSize0 (1 byte)\n  </strong>\n  : Indicates the maximum packet size for\n  <strong>\n   Endpoint 0\n  </strong>\n  , which is crucial for the host to know when interacting with the device.\n </li>\n<li>\n<strong>\n   bNumConfigurations (1 byte)\n  </strong>\n  : Specifies the number of configurations the device supports. This is important for the host to configure the device appropriately.\n </li>\n<li>\n<strong>\n   Reserved (1 byte)\n  </strong>\n  : Reserved for future use and must be set to 0.\n </li>\n</ol>\n<h4>\n Summary of Key Points\n</h4>\n<ul>\n<li>\n  The\n  <strong>\n   device_qualifier descriptor\n  </strong>\n  is specifically for devices that operate at both full-speed and high-speed and helps the host adjust based on the speed currently being used.\n </li>\n<li>\n  The fields in the\n  <strong>\n   device_qualifier descriptor\n  </strong>\n  are similar to those in the\n  <strong>\n   device descriptor\n  </strong>\n  , but the\n  <strong>\n   device_qualifier descriptor\n  </strong>\n  focuses on the device's characteristics at the non-active speed.\n </li>\n<li>\n  The\n  <strong>\n   bcdUSB\n  </strong>\n  field ensures that the device is compliant with USB 2.0 or later, as i\n </li>\n</ul>\n"}, "Page 123": {"response": "<h3>\n Configuration Descriptor Details\n</h3>\n<p>\n The\n <strong>\n  configuration descriptor\n </strong>\n is an essential part of the enumeration process. After the host retrieves the\n <strong>\n  device descriptor\n </strong>\n , it can then retrieve the configuration descriptor, along with other related descriptors such as interface and endpoint descriptors. This descriptor provides the host with crucial information about the device's power usage and its supported interfaces.\n</p>\n<h4>\n Fields in the Configuration Descriptor\n</h4>\n<p>\n The\n <strong>\n  configuration descriptor\n </strong>\n consists of eight key fields, which are as follows:\n</p>\n<ol>\n<li>\n<strong>\n   bLength (1 byte)\n  </strong>\n  : This field specifies the size of the descriptor in bytes.\n </li>\n<li>\n<strong>\n   bDescriptorType (1 byte)\n  </strong>\n  : Always set to\n  <strong>\n   02h\n  </strong>\n  , indicating that this is a\n  <strong>\n   configuration descriptor\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   wTotalLength (2 bytes)\n  </strong>\n  : This field contains the total number of bytes in the configuration descriptor, including all of its subordinate descriptors. This helps the host know how much data to expect when retrieving the descriptor.\n </li>\n<li>\n<strong>\n   bNumInterfaces (1 byte)\n  </strong>\n  : Specifies the number of interfaces that this configuration supports. A device can support multiple interfaces, each of which may perform a different function.\n </li>\n<li>\n<strong>\n   bConfigurationValue (1 byte)\n  </strong>\n  : This is the value the host uses when selecting this configuration with the\n  <strong>\n   Set_Configuration\n  </strong>\n  request. This value identifies the current configuration.\n </li>\n<li>\n<strong>\n   iConfiguration (1 byte)\n  </strong>\n  : This field is an index that points to a string descriptor describing the configuration. If there is no string descriptor, this field is set to zero.\n </li>\n<li>\n<strong>\n   bmAttributes (1 byte)\n  </strong>\n  : This field describes the configuration's attributes, such as whether the configuration requires external power or can operate in a suspended state. For example, it can indicate whether the configuration is self-powered or bus-powered.\n </li>\n<li>\n<strong>\n   bMaxPower (1 byte)\n  </strong>\n  : Specifies the maximum power consumption of the device in this configuration, expressed in 2mA units. For instance, a value of\n  <strong>\n   50h\n  </strong>\n  (80) means the device can consume up to 160mA.\n </li>\n</ol>\n<h4>\n Summary of Key Points\n</h4>\n<ul>\n<li>\n  The\n  <strong>\n   configuration descriptor\n  </strong>\n  gives the host detailed information about the device's power requirements, the number of interfaces supported, and how the device operates in different configurations.\n </li>\n<li>\n  Each configuration descriptor may include one or more\n  <strong>\n   interface descriptors\n  </strong>\n  and\n  <strong>\n   endpoint descriptors\n  </strong>\n  , providing further details about how the device communicates and operates.\n </li>\n<li>\n  The\n  <strong>\n   Set_Configuration\n  </strong>\n  request allows the host to select the current active configuration based\n </li>\n</ul>\n"}, "Page 124": {"response": "<h3>\n Configuration Descriptor and Power Use\n</h3>\n<p>\n The\n <strong>\n  configuration descriptor\n </strong>\n plays a crucial role in defining how the device operates within a specific configuration. This descriptor provides key details about the configuration, its interfaces, and the device's power requirements.\n</p>\n<h4>\n Key Fields in the Configuration Descriptor\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    bConfigurationValue (1 byte)\n   </strong>\n   : This value identifies a specific configuration when the host sends\n   <strong>\n    Get_Configuration\n   </strong>\n   or\n   <strong>\n    Set_Configuration\n   </strong>\n   requests. It must be\n   <strong>\n    1 or higher\n   </strong>\n   , and if the host sends a\n   <strong>\n    Set_Configuration\n   </strong>\n   request with a value of\n   <strong>\n    0\n   </strong>\n   , the device will enter the\n   <strong>\n    Not Configured\n   </strong>\n   state.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    iConfiguration (1 byte)\n   </strong>\n   : This is an index pointing to a string descriptor that describes the configuration. If no string descriptor exists, the value will be zero.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bNumInterfaces (1 byte)\n   </strong>\n   : Indicates the number of interfaces supported by the current configuration. The minimum value is\n   <strong>\n    1\n   </strong>\n   . Interfaces are used to define the specific functions of the device.\n  </p>\n</li>\n</ol>\n<h4>\n Power Usage and Attributes\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    bmAttributes (1 byte)\n   </strong>\n   : This field describes the power and capabilities of the configuration:\n  </p>\n<ul>\n<li>\n<strong>\n     Bit 6\n    </strong>\n    : Set to\n    <strong>\n     1\n    </strong>\n    if the device is\n    <strong>\n     self-powered\n    </strong>\n    (powered by its own source) or\n    <strong>\n     0\n    </strong>\n    if the device is\n    <strong>\n     bus-powered\n    </strong>\n    (powered by the USB host).\n   </li>\n<li>\n<strong>\n     Bit 5\n    </strong>\n    : Set to\n    <strong>\n     1\n    </strong>\n    if the device supports\n    <strong>\n     remote wakeup\n    </strong>\n    . This allows the device, when in the\n    <strong>\n     Suspend\n    </strong>\n    state, to signal the host to resume communication. If no bus activity occurs for 3 milliseconds, the device enters the Suspend state. Devices with remote wakeup capability can use this feature to notify the host of important events.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    bMaxPower (1 byte)\n   </strong>\n   : Specifies the maximum power consumption for the configuration, expressed as the number of\n   <strong>\n    milliampere/2\n   </strong>\n   . For instance, a value of\n   <strong>\n    50h\n   </strong>\n   (80) means the device may consume up to\n   <strong>\n    160mA\n   </strong>\n   .\n  </p>\n</li>\n</ol>\n<h4>\n Summary of Configuration Descriptor Fields\n</h4>\n<p>\n The\n <strong>\n  configuration descriptor\n </strong>\n provides:\n</p>\n<ul>\n<li>\n<strong>\n   bConfigurationValue\n  </strong>\n  to identify the current configuration.\n </li>\n<li>\n<strong>\n   iConfiguration\n  </strong>\n  for a string descriptor that describes the configuration (if available).\n </li>\n<li>\n<strong>\n   bNumInterfaces\n  </strong>\n  to specify how many interfaces are present in the configuration.\n </li>\n<li>\n<strong>\n   bmAttributes\n  </strong>\n  to indicate the device's power source and support for remote wakeup.\n </li>\n<li>\n<strong>\n   bMaxPower\n  </strong>\n  to define the power consumption in milliamps, providing the host with essential power-related information.\n </li>\n</ul>\n<h3>\n Table of Configuration Descriptor Fields\n</h3>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Offset (decimal)\n    </strong>\n</th>\n<th>\n<strong>\n     Field\n    </strong>\n</th>\n<th>\n<strong>\n     Size (bytes)\n    </strong>\n</th>\n<th>\n<strong>\n     Description\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n    0\n   </td>\n<td>\n    bLength\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Descriptor size in bytes\n   </td>\n</tr>\n<tr>\n<td>\n    1\n   </td>\n<td>\n    bDescriptorType\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Always set to\n    <strong>\n     02h\n    </strong>\n    (Configuration descriptor)\n   </td>\n</tr>\n<tr>\n<td>\n    2\n   </td>\n<td>\n    wTotalLength\n   </td>\n<td>\n    2\n   </td>\n<td>\n    Total length of the configuration descriptor and its subordinates\n   </td>\n</tr>\n<tr>\n<td>\n    4\n   </td>\n<td>\n    bNumInterfaces\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Number of interfaces in this configuration\n   </td>\n</tr>\n<tr>\n<td>\n    5\n   </td>\n<td>\n    bConfigurationValue\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Identifies the configuration for\n    <strong>\n     Set_Configuration\n    </strong>\n    and\n    <strong>\n     Get_Configuration\n    </strong>\n</td>\n</tr>\n<tr>\n<td>\n    6\n   </td>\n<td>\n    iConfiguration\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Index of string descriptor for the configuration\n   </td>\n</tr>\n<tr>\n<td>\n    7\n   </td>\n<td>\n    bmAttributes\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Describes power attributes: self/bus-powered and remote wakeup\n   </td>\n</tr>\n<tr>\n<td>\n    8\n   </td>\n<td>\n    bMaxPower\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Maximum bus po\n   </td>\n</tr>\n</tbody>\n</table>\n"}, "Page 125": {"response": "<h3>\n Configuration and Power Usage Details\n</h3>\n<p>\n The\n <strong>\n  configuration descriptor\n </strong>\n includes crucial details about the device's power requirements and configuration capabilities.\n</p>\n<h4>\n Power Use\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    bmAttributes (1 byte)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Bits 0 through 4\n    </strong>\n    must be set to\n    <strong>\n     0\n    </strong>\n    (unused).\n   </li>\n<li>\n<strong>\n     Bit 7\n    </strong>\n    must always be set to\n    <strong>\n     1\n    </strong>\n    to indicate that the configuration is valid.\n   </li>\n<li>\n<strong>\n     Bit 6\n    </strong>\n    : Set to\n    <strong>\n     1\n    </strong>\n    if the device is\n    <strong>\n     self-powered\n    </strong>\n    or\n    <strong>\n     0\n    </strong>\n    if it is\n    <strong>\n     bus-powered\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     Bit 5\n    </strong>\n    : Set to\n    <strong>\n     1\n    </strong>\n    if the device supports\n    <strong>\n     remote wakeup\n    </strong>\n    , allowing it to signal the host to resume communication after being suspended.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    bMaxPower (1 byte)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This field specifies the maximum amount of bus current the device needs.\n   </li>\n<li>\n    The value is\n    <strong>\n     half\n    </strong>\n    the required current in milliamps (mA). For example, if the device needs\n    <strong>\n     200mA\n    </strong>\n    ,\n    <strong>\n     bMaxPower\n    </strong>\n    would be\n    <strong>\n     100\n    </strong>\n    (since 200mA \u00f7 2 = 100).\n   </li>\n<li>\n    The\n    <strong>\n     maximum allowed current\n    </strong>\n    is\n    <strong>\n     500mA\n    </strong>\n    , which is represented as\n    <strong>\n     250\n    </strong>\n    in\n    <strong>\n     bMaxPower\n    </strong>\n    .\n   </li>\n<li>\n    If the required current isn't available, the host may reject the device, and a driver could request an alternate configuration.\n   </li>\n</ul>\n</li>\n</ol>\n<hr/>\n<h3>\n Other-Speed Configuration Descriptor\n</h3>\n<p>\n For devices supporting both full-speed and high-speed, the\n <strong>\n  other-speed_configuration descriptor\n </strong>\n is used. This descriptor describes the device's configuration when operating at the speed\n <strong>\n  not currently in use\n </strong>\n .\n</p>\n<ul>\n<li>\n  The\n  <strong>\n   other-speed_configuration descriptor\n  </strong>\n  has the same structure as the regular configuration descriptor, but it is used to represent the configuration at the non-active speed.\n </li>\n<li>\n  The descriptor also includes subordinate descriptors, similar to the configuration descriptor.\n </li>\n<li>\n  To retrieve this descriptor, the host sends a\n  <strong>\n   Get_Descriptor\n  </strong>\n  request with the high byte of the\n  <strong>\n   wValue\n  </strong>\n  field set to\n  <strong>\n   7\n  </strong>\n  .\n </li>\n</ul>\n<h4>\n Table 4-6: Fields of the Other-Speed Configuration Descriptor\n</h4>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Offset (decimal)\n    </strong>\n</th>\n<th>\n<strong>\n     Field\n    </strong>\n</th>\n<th>\n<strong>\n     Size (bytes)\n    </strong>\n</th>\n<th>\n<strong>\n     Description\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n    0\n   </td>\n<td>\n    bLength\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Descriptor size in bytes\n   </td>\n</tr>\n<tr>\n<td>\n    1\n   </td>\n<td>\n    bDescriptorType\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Constant\n    <strong>\n     Other Speed Configuration (07h)\n    </strong>\n</td>\n</tr>\n<tr>\n<td>\n    2\n   </td>\n<td>\n    wTotalLength\n   </td>\n<td>\n    2\n   </td>\n<td>\n    Total length of the descriptor and its subordinates\n   </td>\n</tr>\n<tr>\n<td>\n    4\n   </td>\n<td>\n    bNumInterfaces\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Number of interfaces in this configuration\n   </td>\n</tr>\n<tr>\n<td>\n    5\n   </td>\n<td>\n    bConfigurationValue\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Identifier for\n    <strong>\n     Set_Configuration\n    </strong>\n    and\n    <strong>\n     Get_Configuration\n    </strong>\n</td>\n</tr>\n<tr>\n<td>\n    6\n   </td>\n<td>\n    iConfiguration\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Index of string descriptor for this configuration\n   </td>\n</tr>\n<tr>\n<td>\n    7\n   </td>\n<td>\n    bmAttributes\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Power attributes: self/bus-powered and remote wakeup\n   </td>\n</tr>\n<tr>\n<td>\n    8\n   </td>\n<td>\n    bMaxPower\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Maximum bus power required, in milliamps/2\n   </td>\n</tr>\n</tbody>\n</table>\n<hr/>\n<h3>\n Interface Association Descriptor (IAD)\n</h3>\n<p>\n The\n <strong>\n  Interface Association Descriptor (IAD)\n </strong>\n is used to identify multiple interfaces associated with a particular function in a device.\n</p>\n<ul>\n<li>\n  A\n  <strong>\n   device interface\n  </strong>\n  is essentially a feature or function that a device implements.\n </li>\n<li>\n  Most\n  <strong>\n   device classes\n  </strong>\n  specify functions at the\n  <strong>\n   interface level\n  </strong>\n  rather than the device level, which allows a single configuration to support multiple interfaces and functions.\n </li>\n<li>\n  The IAD groups related interfaces together under one function, making it easier\n </li>\n</ul>\n"}, "Page 126": {"response": "<h3>\n Interface Association Descriptor (IAD) and Composite Devices\n</h3>\n<p>\n The\n <strong>\n  Interface Association Descriptor (IAD)\n </strong>\n is used when a device has multiple interfaces that are related to a single function. This descriptor allows the host to understand which interfaces should be grouped together, even though they may perform different tasks. For example, a video camera may use one interface for camera controls and another for transmitting video data.\n</p>\n<p>\n In a\n <strong>\n  composite device\n </strong>\n \u2014one that has multiple interfaces that can be active at the same time\u2014each interface will have its own interface descriptor and endpoint descriptors. The host loads a driver for each of these interfaces. When interfaces are associated with the same function, the IAD helps the host identify which interfaces belong to the same functional group.\n</p>\n<ul>\n<li>\n<strong>\n   Example\n  </strong>\n  : A video device might use:\n  <ul>\n<li>\n    One interface for camera control\n   </li>\n<li>\n    Another interface to carry video data\nThe IAD helps the host understand that these interfaces are part of a single device function.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n The\n <strong>\n  Interface Association Descriptor\n </strong>\n is mandatory for devices that use multiple interfaces to manage a single function, such as in the\n <strong>\n  video-class specification\n </strong>\n . However, older class specifications that were developed before the introduction of this descriptor do not require it.\n <strong>\n  Hosts\n </strong>\n that do not support the descriptor simply ignore it.\n <strong>\n  Windows XP SP2\n </strong>\n and later versions support this descriptor.\n</p>\n<p>\n To help the host identify devices using the IAD, the\n <strong>\n  device descriptor\n </strong>\n should include the following values:\n</p>\n<ul>\n<li>\n<strong>\n   bDeviceClass = EFh\n  </strong>\n  (miscellaneous device class)\n </li>\n<li>\n<strong>\n   bDeviceSubClass = 02h\n  </strong>\n  (for interface association descriptors)\n </li>\n</ul>\n<hr/>\n<h3>\n Other-Speed Configuration Descriptor\n</h3>\n<p>\n Devices that support both\n <strong>\n  full-speed\n </strong>\n and\n <strong>\n  high-speed\n </strong>\n operations have an\n <strong>\n  other-speed_configuration descriptor\n </strong>\n , which provides details about the configuration when the device is operating at the speed that is\n <strong>\n  not currently active\n </strong>\n . This allows the host to understand how the device will behave when switching between these two speeds.\n</p>\n<p>\n The structure of the\n <strong>\n  other-speed_configuration descriptor\n </strong>\n is identical to the regular\n <strong>\n  configuration descriptor\n </strong>\n , but it describes the device\u2019s configuration when it's not using the active speed.\n</p>\n<ul>\n<li>\n<strong>\n   Subordinate descriptors\n  </strong>\n  for interfaces and endpoints are included, just as they are in the regular configuration descriptor.\n </li>\n<li>\n  The host retrieves this descriptor using a\n  <strong>\n   Get_Descriptor\n  </strong>\n  request with the high byte of the\n  <strong>\n   wValue\n  </strong>\n  field set to\n  <strong>\n   7\n  </strong>\n  .\n </li>\n</ul>\n<h4>\n Table 4-6: Fields of the Other-Speed Configuration Descriptor\n</h4>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Offset (decimal)\n    </strong>\n</th>\n<th>\n<strong>\n     Field\n    </strong>\n</th>\n<th>\n<strong>\n     Size (bytes)\n    </strong>\n</th>\n<th>\n<strong>\n     Description\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n    0\n   </td>\n<td>\n    bLength\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Descriptor size in bytes\n   </td>\n</tr>\n<tr>\n<td>\n    1\n   </td>\n<td>\n    bDescriptorType\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Constant\n    <strong>\n     OTHER_SPEED_CONFIGURATION (07h)\n    </strong>\n</td>\n</tr>\n<tr>\n<td>\n    2\n   </td>\n<td>\n    wTotalLength\n   </td>\n<td>\n    2\n   </td>\n<td>\n    Total length of the descriptor and its subordinates\n   </td>\n</tr>\n<tr>\n<td>\n    4\n   </td>\n<td>\n    bNumInterfaces\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Number of interfaces in the configuration\n   </td>\n</tr>\n<tr>\n<td>\n    5\n   </td>\n<td>\n    bConfigurationValue\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Identifier for\n    <strong>\n     Set_Configuration\n    </strong>\n    and\n    <strong>\n     Get_Configuration\n    </strong>\n</td>\n</tr>\n<tr>\n<td>\n    6\n   </td>\n<td>\n    iConfiguration\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Index of string descriptor for the configuration\n   </td>\n</tr>\n<tr>\n<td>\n    7\n   </td>\n<td>\n    bmAttributes\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Power attributes: self/bus-powered and remote wakeup\n   </td>\n</tr>\n<tr>\n<td>\n    8\n   </td>\n<td>\n    bMaxPower\n   </td>\n<td>\n    1\n   </td>\n<td>\n    M\n   </td>\n</tr>\n</tbody>\n</table>\n"}, "Page 127": {"response": "<h3>\n Interface Association Descriptor (IAD) for Multi-Interface Devices\n</h3>\n<p>\n The\n <strong>\n  Interface Association Descriptor (IAD)\n </strong>\n is used in devices that have multiple interfaces associated with a single function. These interfaces are typically used for different tasks but work together to provide the complete functionality of the device. For example, a device might have one interface for device control and another for transferring data.\n</p>\n<p>\n When a host interacts with a device that has multiple interfaces associated with one function, the IAD helps it understand which interfaces belong together.\n</p>\n<h3>\n Multi-Interface Function Device Class Codes\n</h3>\n<p>\n To identify devices that use IADs, the\n <strong>\n  device descriptor\n </strong>\n should include the following specific codes:\n</p>\n<ul>\n<li>\n<strong>\n   bDeviceClass = EFh\n  </strong>\n  (miscellaneous device class)\n </li>\n<li>\n<strong>\n   bDeviceSubClass = 02h\n  </strong>\n  (for the interface association descriptor)\n </li>\n<li>\n<strong>\n   bDeviceProtocol = 01h\n  </strong>\n  (indicating it's an interface association descriptor)\n </li>\n</ul>\n<p>\n These three codes are collectively referred to as the\n <strong>\n  Multi-interface Function Device Class Codes\n </strong>\n .\n</p>\n<h3>\n Retrieving the Interface Association Descriptor\n</h3>\n<p>\n A host retrieves the\n <strong>\n  Interface Association Descriptor\n </strong>\n by requesting the configuration descriptor for the configuration that the IAD belongs to.\n</p>\n<h4>\n Table 4-8: Fields in the Interface Association Descriptor\n</h4>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Offset (decimal)\n    </strong>\n</th>\n<th>\n<strong>\n     Field\n    </strong>\n</th>\n<th>\n<strong>\n     Size (bytes)\n    </strong>\n</th>\n<th>\n<strong>\n     Description\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n    0\n   </td>\n<td>\n    bLength\n   </td>\n<td>\n    1\n   </td>\n<td>\n    The size of the descriptor\n   </td>\n</tr>\n<tr>\n<td>\n    1\n   </td>\n<td>\n    bDescriptorType\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Constant\n    <strong>\n     INTERFACE ASSOCIATION (0Bh)\n    </strong>\n</td>\n</tr>\n<tr>\n<td>\n    2\n   </td>\n<td>\n    bFirstInterface\n   </td>\n<td>\n    1\n   </td>\n<td>\n    The interface number of the first interface in the group\n   </td>\n</tr>\n<tr>\n<td>\n    3\n   </td>\n<td>\n    bInterfaceCount\n   </td>\n<td>\n    1\n   </td>\n<td>\n    The number of interfaces in the group\n   </td>\n</tr>\n<tr>\n<td>\n    4\n   </td>\n<td>\n    bFunctionClass\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Class code for the function shared by the interfaces\n   </td>\n</tr>\n<tr>\n<td>\n    5\n   </td>\n<td>\n    bFunctionSubClass\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Subclass code for the function shared by the interfaces\n   </td>\n</tr>\n<tr>\n<td>\n    6\n   </td>\n<td>\n    bFunctionProtocol\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Protocol code for the function shared by the interfaces\n   </td>\n</tr>\n<tr>\n<td>\n    7\n   </td>\n<td>\n    iFunction\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Index of string descriptor for the function\n   </td>\n</tr>\n</tbody>\n</table>\n<h3>\n Detailed Descriptions of Fields\n</h3>\n<ul>\n<li>\n<p>\n<strong>\n    bFirstInterface\n   </strong>\n   : This field identifies the interface number of the first interface in a group of associated interfaces. The interface number corresponds to the\n   <strong>\n    bInterfaceNumber\n   </strong>\n   in the interface descriptor. The interface numbers of all associated interfaces must be contiguous.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bInterfaceCount\n   </strong>\n   : This field specifies how many contiguous interfaces are grouped together as part of the same function.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bFunctionClass\n   </strong>\n   : This field contains the class code for the function that all the associated interfaces share. If no specific value is provided by the class, the default value is the\n   <strong>\n    bInterfaceClass\n   </strong>\n   from the first associated interface descriptor. Values\n   <strong>\n    01h to FEh\n   </strong>\n   are reserved for USB-defined classes, while\n   <strong>\n    FFh\n   </strong>\n   indicates a vendor-defined class. A value of\n   <strong>\n    00h\n   </strong>\n   is not allowed.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bFunctionSubClass\n   </strong>\n   : This field specifies a subclass code for the function shared by the associated interfaces. If the class does not provide a subclass value, the\n   <strong>\n    bInterfaceSubClass\n   </strong>\n   value from the first interface descriptor is used.\n  </p>\n</li>\n</ul>\n"}, "Page 128": {"response": "<h3>\n Interface Association Descriptor (IAD) Continued\n</h3>\n<p>\n The\n <strong>\n  Interface Association Descriptor (IAD)\n </strong>\n continues to provide details about how multiple interfaces within a configuration are grouped and associated with a single function.\n</p>\n<h4>\n Additional Fields in the Interface Association Descriptor\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    bInterfaceProtocol\n   </strong>\n   : This field indicates the protocol code that applies to the function shared by all associated interfaces. If the class doesn\u2019t specify a protocol, the preferred value is the\n   <strong>\n    bInterfaceProtocol\n   </strong>\n   value from the descriptor of the first associated interface.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    iInterface\n   </strong>\n   : This field points to a string descriptor that describes the function of the associated interfaces. If there is no such string descriptor, the value is set to zero.\n  </p>\n</li>\n</ul>\n<hr/>\n<h3>\n Interface Descriptor: Details of a Device's Functions\n</h3>\n<p>\n The\n <strong>\n  Interface Descriptor\n </strong>\n provides essential information about a specific function or feature of a device, detailing the class, subclass, and protocol it uses, as well as the number of endpoints that the interface operates with.\n</p>\n<p>\n A device configuration can include multiple interfaces, and these interfaces might be:\n</p>\n<ol>\n<li>\n<strong>\n   Active simultaneously\n  </strong>\n  , either working together for a common function or operating independently.\n </li>\n<li>\n<strong>\n   Alternate interfaces\n  </strong>\n  , which provide mutually exclusive functions within the same configuration. For example, a device might have an interface for data transfer and another for controlling settings. The host can switch between these alternate interfaces using a\n  <strong>\n   Set_Interface\n  </strong>\n  request.\n </li>\n<li>\n<strong>\n   Isochronous interfaces\n  </strong>\n  , which need alternate interfaces to manage bandwidth allocation properly. The default interface typically does not request any isochronous bandwidth, so using alternate interfaces makes handling bandwidth easier.\n </li>\n</ol>\n<p>\n Each interface has its own interface descriptor and possibly subordinate descriptors, depending on the interface's complexity and features.\n</p>\n<h4>\n Table 4-7: The Interface Association Descriptor Structure\n</h4>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Offset (decimal)\n    </strong>\n</th>\n<th>\n<strong>\n     Field\n    </strong>\n</th>\n<th>\n<strong>\n     Size (bytes)\n    </strong>\n</th>\n<th>\n<strong>\n     Description\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n    0\n   </td>\n<td>\n    bLength\n   </td>\n<td>\n    1\n   </td>\n<td>\n    The size of the descriptor\n   </td>\n</tr>\n<tr>\n<td>\n    1\n   </td>\n<td>\n    bDescriptorType\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Constant\n    <strong>\n     Interface Association (0Bh)\n    </strong>\n</td>\n</tr>\n<tr>\n<td>\n    2\n   </td>\n<td>\n    bFirstInterface\n   </td>\n<td>\n    1\n   </td>\n<td>\n    The interface number of the first associated interface\n   </td>\n</tr>\n<tr>\n<td>\n    3\n   </td>\n<td>\n    bInterfaceCount\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Number of contiguous interfaces in the group\n   </td>\n</tr>\n<tr>\n<td>\n    4\n   </td>\n<td>\n    bFunctionClass\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Class code for the function shared by the interfaces\n   </td>\n</tr>\n<tr>\n<td>\n    5\n   </td>\n<td>\n    bFunctionSubClass\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Subclass code for the function shared by the interfaces\n   </td>\n</tr>\n<tr>\n<td>\n    6\n   </td>\n<td>\n    bFunctionProtocol\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Protocol code for the function shared by the interfaces\n   </td>\n</tr>\n<tr>\n<td>\n    7\n   </td>\n<td>\n    iFunction\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Index of string descriptor describing the function\n   </td>\n</tr>\n</tbody>\n</table>\n<hr/>\n<h3>\n Key Functionality of the Interface Descriptor\n</h3>\n<p>\n The\n <strong>\n  Interface Descriptor\n </strong>\n contains information that allows the host to:\n</p>\n<ul>\n<li>\n  Identify and handle different interfaces that may be active simultaneously.\n </li>\n<li>\n  Switch between alternate interfaces, providing flexibility in how the device is used.\n </li>\n<li>\n  Manage isochronous\n </li>\n</ul>\n"}, "Page 129": {"response": "<h3>\n Interface Descriptor\n</h3>\n<p>\n The\n <strong>\n  Interface Descriptor\n </strong>\n provides detailed information about a specific interface of a device, describing its functionality and features, including the class, subclass, protocol, and the endpoints it uses. Each interface descriptor is unique to its function and helps the host understand how to interact with the interface.\n</p>\n<h4>\n Fields of the Interface Descriptor\n</h4>\n<p>\n An interface descriptor consists of nine fields. Here is a breakdown of each field and its role:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    bLength\n   </strong>\n   : This field represents the size of the descriptor in bytes.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bDescriptorType\n   </strong>\n   : This field is set to the constant\n   <strong>\n    INTERFACE (04h)\n   </strong>\n   , which identifies the descriptor type.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    iInterface\n   </strong>\n   : This field points to a string descriptor that describes the interface. If no string descriptor is available, the value is zero.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bInterfaceNumber\n   </strong>\n   : This field identifies the interface within a configuration. A configuration can have multiple interfaces active at once, and each interface must have a unique number. The default value is zero.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bAlternateSetting\n   </strong>\n   : If the configuration supports multiple mutually exclusive interfaces, each interface shares the same\n   <strong>\n    bInterfaceNumber\n   </strong>\n   but has a unique\n   <strong>\n    bAlternateSetting\n   </strong>\n   value. This allows the host to select the active setting using the\n   <strong>\n    Set_Interface\n   </strong>\n   request, while the\n   <strong>\n    Get_Interface\n   </strong>\n   request retrieves the current setting. The default value is zero.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bNumEndpoints\n   </strong>\n   : This field specifies the number of endpoints, excluding Endpoint 0, that the interface uses. If the device only uses Endpoint 0, this field will be zero.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bInterfaceClass\n   </strong>\n   : This is similar to the\n   <strong>\n    bDeviceClass\n   </strong>\n   field in the device descriptor but applies to devices where the interface has its own class. The field provides the class code for the interface. The USB specification reserves values from 01h to FEh for standard classes, while FFh indicates a vendor-defined class. The value zero is reserved.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bInterfaceSubClass\n   </strong>\n   : Similar to the\n   <strong>\n    bDeviceSubClass\n   </strong>\n   field in the device descriptor, this field specifies the subclass code for the interface. For interfaces that do not specify a subclass, this field may not be used.\n  </p>\n</li>\n</ul>\n<h4>\n Retrieving Interface Descriptors\n</h4>\n<p>\n To access the interface descriptors, the host sends a\n <strong>\n  Get_Descriptor\n </strong>\n request for the configuration descriptor that includes the interface. This allows the host to obtain all relevant interface details, such as the number of endpoints and the specific class, subclass, and protocol used.\n</p>\n<hr/>\n<h3>\n Summary of Interface Descriptor Structure\n</h3>\n<p>\n The interface descriptor is essential for the host to understand how to interact with each interface of a device. It provides a unique identifier for each interface, details on the number of endpoints, and information about the class and subclass of the interface. The host uses this descriptor to configure and manage multiple interfaces, alternate settings, and han\n</p>\n"}, "Page 130": {"response": "<h3>\n Interface Descriptor Details\n</h3>\n<p>\n The\n <strong>\n  Interface Descriptor\n </strong>\n provides specific information about each interface in a device, including the interface's identity, the number of endpoints it uses, and its class, subclass, and protocol details. Each interface within a device may have its own descriptor, and the host uses these descriptors to configure and manage the device's functions.\n</p>\n<h4>\n Key Fields in the Interface Descriptor\n</h4>\n<p>\n An interface descriptor has nine fields that detail the interface's structure and functionality:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    bLength\n   </strong>\n   : The size of the descriptor in bytes.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bDescriptorType\n   </strong>\n   : Always set to\n   <strong>\n    INTERFACE (04h)\n   </strong>\n   , indicating that this is an interface descriptor.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bInterfaceNumber\n   </strong>\n   : The identifier for the interface. Each interface within a device must have a unique number. The default value is zero.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bAlternateSetting\n   </strong>\n   : In cases where the configuration supports multiple, mutually exclusive interfaces, this field allows the selection of different interface settings. Each interface will have the same\n   <strong>\n    bInterfaceNumber\n   </strong>\n   but a unique\n   <strong>\n    bAlternateSetting\n   </strong>\n   value. By default, this is zero.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bNumEndpoints\n   </strong>\n   : The number of endpoints the interface supports, excluding Endpoint 0. If the device only uses Endpoint 0, this value will be zero.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bInterfaceClass\n   </strong>\n   : This is the class code associated with the interface, similar to\n   <strong>\n    bDeviceClass\n   </strong>\n   in the device descriptor but specific to interfaces. USB-defined class codes range from 01h to FEh, and FFh indicates a vendor-defined class. A value of zero is reserved.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bInterfaceSubclass\n   </strong>\n   : If the interface belongs to a class, this field specifies its subclass. If\n   <strong>\n    bInterfaceClass\n   </strong>\n   is zero,\n   <strong>\n    bInterfaceSubclass\n   </strong>\n   must also be zero. If\n   <strong>\n    bInterfaceClass\n   </strong>\n   is a defined USB class (01h to FEh), this field can either be zero or a subclass code defined by the USB specification. FFh indicates a subclass that is vendor-specific.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bInterfaceProtocol\n   </strong>\n   : This field specifies the protocol used by the interface, similar to\n   <strong>\n    bDeviceProtocol\n   </strong>\n   in the device descriptor. It can either be zero or a protocol code defined by the USB specification, depending on the\n   <strong>\n    bInterfaceClass\n   </strong>\n   and\n   <strong>\n    bInterfaceSubclass\n   </strong>\n   values.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    iInterface\n   </strong>\n   : This field points to a string descriptor that describes the interface. If no string descriptor is provided, this field is set to zero.\n  </p>\n</li>\n</ul>\n<hr/>\n<h3>\n Endpoint Descriptor\n</h3>\n<p>\n Each interface that uses endpoints (except for Endpoint 0) will have associated\n <strong>\n  Endpoint Descriptors\n </strong>\n . The\n <strong>\n  Endpoint 0\n </strong>\n is a special case because it is always present and described in the device descriptor, so it does not have its own endpoint descriptor.\n</p>\n<p>\n The host can retrieve endpoint descriptors by sending a\n <strong>\n  Get_Descriptor\n </strong>\n request for the configuration that the endpoints belong to. Each endpoint descriptor contains information about how data is transferred through that endpoint.\n</p>\n<hr/>\n<h3>\n Summary\n</h3>\n<p>\n The\n <strong>\n  Interface Descriptor\n </strong>\n is crucial for the host to identify and configure the various interfaces on a device. Each interface can have different settings, class codes, protocols, and endpoints. The interface descriptor ensures that the host knows how to manage the device's multiple functions and endpoints effectively. It allows for flexibility in device configurations, supporting b\n</p>\n"}, "Page 131": {"response": "<h3>\n Endpoint Descriptor Details\n</h3>\n<p>\n The\n <strong>\n  Endpoint Descriptor\n </strong>\n provides essential information about each endpoint used by an interface in a USB device. These descriptors are retrieved by the host to understand the details of each endpoint, such as the type of transfer, direction, and maximum packet size.\n <strong>\n  Endpoint 0\n </strong>\n does not have its own descriptor, as it is predefined in the device descriptor. The host retrieves the endpoint descriptors by issuing a\n <strong>\n  Get_Descriptor\n </strong>\n request for the configuration the endpoint belongs to.\n</p>\n<h4>\n Key Fields in the Endpoint Descriptor\n</h4>\n<p>\n An endpoint descriptor consists of six fields, listed below in the order they appear:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    bLength\n   </strong>\n   : The length of the descriptor in bytes.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bDescriptorType\n   </strong>\n   : Always set to\n   <strong>\n    ENDPOINT (05h)\n   </strong>\n   , which indicates that this is an endpoint descriptor.\n  </p>\n</li>\n</ul>\n<hr/>\n<h3>\n bInterfaceClass Field in the Interface Descriptor\n</h3>\n<p>\n The\n <strong>\n  bInterfaceClass\n </strong>\n field in the interface descriptor specifies the class to which the interface belongs. Different classes define the type of functionality the interface supports. The values for\n <strong>\n  bInterfaceClass\n </strong>\n are standardized and each class corresponds to a specific set of device types.\n</p>\n<p>\n Here are some of the class codes from the\n <strong>\n  bInterfaceClass\n </strong>\n field, which are used to categorize USB device functions:\n</p>\n<table>\n<thead>\n<tr>\n<th>\n    Class Code (Hex)\n   </th>\n<th>\n    Description\n   </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     01h\n    </strong>\n</td>\n<td>\n    Audio\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     02h\n    </strong>\n</td>\n<td>\n    Communication Device Class (Communication Interface)\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     03h\n    </strong>\n</td>\n<td>\n    Human Interface Device (HID)\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     05h\n    </strong>\n</td>\n<td>\n    Physical\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     06h\n    </strong>\n</td>\n<td>\n    Image\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     07h\n    </strong>\n</td>\n<td>\n    Printer\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     08h\n    </strong>\n</td>\n<td>\n    Mass Storage\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     09h\n    </strong>\n</td>\n<td>\n    Hub\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     0Ah\n    </strong>\n</td>\n<td>\n    Communication Device Class (Data Interface)\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     0Bh\n    </strong>\n</td>\n<td>\n    Smart Card\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     0Dh\n    </strong>\n</td>\n<td>\n    Content Security\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     0Eh\n    </strong>\n</td>\n<td>\n    Video\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     DCh\n    </strong>\n</td>\n<td>\n    Diagnostic Device (can also be declared at device level)\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     E0h\n    </strong>\n</td>\n<td>\n    Wireless Controller (can also be declared at device level)\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     FEh\n    </strong>\n</td>\n<td>\n    Application-Specific\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     FFh\n    </strong>\n</td>\n<td>\n    Vendor-Specific (can also be declared at the device level)\n   </td>\n</tr>\n</tbody>\n</table>\n<h4>\n Additional Information for Specific Classes\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    bInterfaceSubClass\n   </strong>\n   and\n   <strong>\n    bInterfaceProtocol\n   </strong>\n   fields are used to further specify the subclass and protocol for the interface within a class, depending on the device's needs.\n  </p>\n</li>\n<li>\n<p>\n   For instance, for\n   <strong>\n    Wireless Controllers\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     bInterfaceSubClass = 1\n    </strong>\n    for RF Controllers\n   </li>\n<li>\n<strong>\n     bInterfaceProtocol = 1\n    </strong>\n    for Bluetooth Programming Interface\n   </li>\n</ul>\n</li>\n<li>\n<p>\n   For\n   <strong>\n    Diagnostic Devices\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     bInterfaceSubClass = 1\n    </strong>\n    for Reprogrammable Diagnostic Devices\n   </li>\n<li>\n<strong>\n     bInterfaceProtocol = 1\n    </strong>\n    for USB2 Compliance Devices\n   </li>\n</ul>\n</li>\n<li>\n<p>\n   The\n   <strong>\n    Application-Specific\n   </strong>\n   class (FEh) supports additional subclasses, such as:\n  </p>\n<ul>\n<li>\n<strong>\n     bInterfaceSubClass = 1\n    </strong>\n    for Device Firmware Update\n   </li>\n<li>\n<strong>\n     bInterfaceSubClass = 2\n    </strong>\n    for IrDA Bridge\n   </li>\n<li>\n<strong>\n     bInterfaceSubClass = 3\n    </strong>\n    for Test and Measurement\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n These class and subclass codes help identify the specific function and behavior of an interface within a USB device, mak\n</p>\n"}, "Page 132": {"response": "<h3>\n Endpoint Descriptor Details\n</h3>\n<p>\n The\n <strong>\n  Endpoint Descriptor\n </strong>\n provides critical information about each endpoint within a USB device, such as the endpoint number, transfer type, maximum packet size, and latency or polling interval. This descriptor helps the host understand the characteristics of each endpoint so it can properly communicate with the device. The endpoint descriptor consists of six fields, which are explained below.\n</p>\n<h4>\n Key Fields in the Endpoint Descriptor\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    bLength\n   </strong>\n   : This field specifies the size of the descriptor in bytes.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bDescriptorType\n   </strong>\n   : Set to\n   <strong>\n    Endpoint (05h)\n   </strong>\n   , indicating that this is an endpoint descriptor.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bEndpointAddress\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Contains the endpoint number and direction of the endpoint.\n   </li>\n<li>\n    Bits 0-3 indicate the endpoint number (ranging from 0 to 15, depending on device speed).\n   </li>\n<li>\n    For low-speed devices, there can be a maximum of 3 endpoints, typically numbered 0 through 2.\n   </li>\n<li>\n    Bits 7 indicates direction:\n    <ul>\n<li>\n<strong>\n       0\n      </strong>\n      = Out (from device to host)\n     </li>\n<li>\n<strong>\n       1\n      </strong>\n      = In (from host to device)\n     </li>\n<li>\n<strong>\n       Ignored\n      </strong>\n      for control transfers (Bidirectional).\n     </li>\n</ul>\n</li>\n<li>\n    Bits 4-6 are reserved and must be set to zero.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    bmAttributes\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This field defines the type of transfer the endpoint supports.\n   </li>\n<li>\n    Bits 0 and 1 define the transfer type:\n    <ul>\n<li>\n<strong>\n       00\n      </strong>\n      = Control\n     </li>\n<li>\n<strong>\n       01\n      </strong>\n      = Isochronous\n     </li>\n<li>\n<strong>\n       10\n      </strong>\n      = Bulk\n     </li>\n<li>\n<strong>\n       11\n      </strong>\n      = Interrupt\n     </li>\n</ul>\n</li>\n<li>\n    For\n    <strong>\n     Endpoint 0\n    </strong>\n    , control transfer is assumed.\n   </li>\n<li>\n    In USB 2.0, bits 2-5 define additional attributes for isochronous endpoints:\n    <ul>\n<li>\n<strong>\n       Bits 2-3\n      </strong>\n      : Synchronization type:\n      <ul>\n<li>\n<strong>\n         00\n        </strong>\n        = No synchronization\n       </li>\n<li>\n<strong>\n         01\n        </strong>\n        = Asynchronous\n       </li>\n<li>\n<strong>\n         10\n        </strong>\n        = Adaptive\n       </li>\n<li>\n<strong>\n         11\n        </strong>\n        = Synchronous\n       </li>\n</ul>\n</li>\n<li>\n<strong>\n       Bits 4-5\n      </strong>\n      : Usage type:\n      <ul>\n<li>\n<strong>\n         00\n        </strong>\n        = Data endpoint\n       </li>\n<li>\n<strong>\n         01\n        </strong>\n        = Feedback endpoint\n       </li>\n<li>\n<strong>\n         10\n        </strong>\n        = Implicit feedback data endpoint\n       </li>\n<li>\n<strong>\n         11\n        </strong>\n        = Reserved\n       </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n    For non-isochronous endpoints, bits 2-5 must be zero, and bits 6-7 must also be zero.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    wMaxPacketSize\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Specifies the maximum packet size the endpoint can transfer in a transaction.\n   </li>\n<li>\n    The value is dependent on the device's speed and transfer type.\n   </li>\n<li>\n    The maximum packet size can range from 0 to 1024 bytes in USB 2.0.\n   </li>\n<li>\n    Bits 12-11 in USB 2.0 indicate additional transactions per microframe supported by high-speed isochronous endpoints:\n    <ul>\n<li>\n<strong>\n       00\n      </strong>\n      = No additional transactions\n     </li>\n<li>\n<strong>\n       01\n      </strong>\n      = 1 additional transaction\n     </li>\n<li>\n<strong>\n       10\n      </strong>\n      = 2 additional transactions\n     </li>\n<li>\n<strong>\n       11\n      </strong>\n      = Reserved\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    bInterval\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Defines the polling interval or NAK rate for the endpoint.\n   </li>\n<li>\n    For\n    <strong>\n     interrupt endpoints\n    </strong>\n    , this field specifies how often the host should poll the device for data.\n   </li>\n<li>\n    For\n    <strong>\n     isochronous endpoints\n    </strong>\n    , it specifies the maximum latency or polling interval.\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n These fields provide essential details for configuring endpoints and understanding how data transfers will be han\n</p>\n"}, "Page 133": {"response": "<h3>\n bInterval and Its Role in USB Endpoints\n</h3>\n<p>\n The\n <strong>\n  bInterval\n </strong>\n field in an endpoint descriptor plays a significant role in defining how frequently the host should poll an endpoint or handle latency in data transfers, depending on the endpoint type. The value of\n <strong>\n  bInterval\n </strong>\n varies depending on device speed, transfer type, and compliance with USB 2.0 standards.\n</p>\n<h4>\n Key Points about bInterval:\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    For Interrupt Endpoints:\n   </strong>\n</p>\n<ul>\n<li>\n<strong>\n     Low-Speed Devices\n    </strong>\n    : The value in\n    <strong>\n     bInterval\n    </strong>\n    specifies the maximum polling latency in\n    <strong>\n     milliseconds\n    </strong>\n    . The value can range from 10 to 255.\n   </li>\n<li>\n<strong>\n     Full-Speed Devices\n    </strong>\n    : For both interrupt and isochronous endpoints,\n    <strong>\n     bInterval\n    </strong>\n    also defines the polling interval in milliseconds. For interrupt endpoints, it ranges from 1 to 255, while for isochronous endpoints, it is limited to 1.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    For Isochronous Endpoints:\n   </strong>\n</p>\n<ul>\n<li>\n    In\n    <strong>\n     USB 1.x\n    </strong>\n    , full-speed isochronous endpoints are restricted to an interval of 1 millisecond.\n   </li>\n<li>\n    In\n    <strong>\n     USB 2.0\n    </strong>\n    , full-speed isochronous endpoints have a range from 1 to 16, with the interval calculated as\n    2\n    b\n    I\n    n\n    t\n    e\n    r\n    v\n    a\n    l\n    \u2212\n    1\n    2^{bInterval} - 1\n    2\n    b\n    I\n    n\n    t\n    er\n    v\n    a\n    l\n    \u2212\n    1\n    . This gives an interval range from\n    <strong>\n     1 millisecond\n    </strong>\n    to\n    <strong>\n     32.768 seconds\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    For Bulk and Control Transfers:\n   </strong>\n</p>\n<ul>\n<li>\n    In\n    <strong>\n     full-speed\n    </strong>\n    and\n    <strong>\n     high-speed devices\n    </strong>\n    , the\n    <strong>\n     bInterval\n    </strong>\n    value for bulk and control endpoints is ignored.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    For High-Speed Devices:\n   </strong>\n</p>\n<ul>\n<li>\n    The\n    <strong>\n     bInterval\n    </strong>\n    for interrupt and isochronous endpoints is measured in\n    <strong>\n     microframe units (125 microseconds)\n    </strong>\n    , with a range from 1 to 16, calculated as\n    2\n    b\n    I\n    n\n    t\n    e\n    r\n    v\n    a\n    l\n    \u2212\n    1\n    2^{bInterval} - 1\n    2\n    b\n    I\n    n\n    t\n    er\n    v\n    a\n    l\n    \u2212\n    1\n    . This gives a range from\n    <strong>\n     125 microseconds\n    </strong>\n    to\n    <strong>\n     4.096 seconds\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     For High-Speed Bulk OUT and Control Endpoints\n    </strong>\n    ,\n    <strong>\n     bInterval\n    </strong>\n    determines the maximum\n    <strong>\n     NAK (Negative Acknowledgment)\n    </strong>\n    rate. If the device is unable to accept incoming data, it returns\n    <strong>\n     NAK\n    </strong>\n    to signal the host to try again. The\n    <strong>\n     bInterval\n    </strong>\n    specifies how frequently the device can return a\n    <strong>\n     NAK\n    </strong>\n    during a period. The value can range from 0 to 255 microframes.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Practical Usage:\n</h4>\n<ul>\n<li>\n  The\n  <strong>\n   bInterval\n  </strong>\n  value defines the timing between transactions, such as how frequently the host should poll the endpoint or the maximum delay before retrying a failed transaction.\n </li>\n<li>\n  For interrupt endpoints,\n  <strong>\n   bInterval\n  </strong>\n  controls the maximum polling interval, while for bulk and control endpoints, it defin\n </li>\n</ul>\n"}, "Page 134": {"response": "<h3>\n String Descriptor in USB Devices\n</h3>\n<p>\n A\n <strong>\n  String Descriptor\n </strong>\n in USB is used to store text that provides descriptive information about the device, such as manufacturer, product name, serial number, configuration, or interface details. It may also include class-specific or vendor-specific string descriptors. While the support for string descriptors is optional, some USB classes may require their use. A host retrieves string descriptors using a\n <strong>\n  Get_Descriptor\n </strong>\n request.\n</p>\n<h4>\n Key Fields of a String Descriptor:\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    bLength\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Specifies the number of bytes in the descriptor.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    bDescriptorType\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    A constant value of\n    <strong>\n     STRING (03h)\n    </strong>\n    that indicates the descriptor type.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n The String in the Descriptor:\n</h4>\n<ul>\n<li>\n<p>\n   When a host requests a string descriptor, it uses an\n   <strong>\n    index value\n   </strong>\n   in the\n   <strong>\n    wValue\n   </strong>\n   field. This index determines which string to retrieve. The special index value of\n   <strong>\n    zero\n   </strong>\n   is used to request\n   <strong>\n    language IDs\n   </strong>\n   , while other indices refer to specific string descriptors containing text.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    wLANGID[0...n]\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This field is only present in\n    <strong>\n     String Descriptor 0\n    </strong>\n    , which contains one or more\n    <strong>\n     16-bit language ID codes\n    </strong>\n    . These codes specify the languages in which the strings are available. For instance:\n    <ul>\n<li>\n<strong>\n       0009h\n      </strong>\n      refers to English.\n     </li>\n<li>\n<strong>\n       0004h\n      </strong>\n      is the subcode for U.S. English.\n     </li>\n</ul>\n</li>\n<li>\n    These language ID codes indicate the languages supported by the device. The device must return a valid language ID before any other string descriptors can be returned. If a device doesn't provide string descriptors, it must not return any language ID array.\n   </li>\n<li>\n    A list of all defined USB language IDs can be found on the USB-IF's official website.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    bString\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    For string descriptors with index values\n    <strong>\n     1 or higher\n    </strong>\n    , the\n    <strong>\n     bString\n    </strong>\n    field contains the actual text represented in\n    <strong>\n     Unicode\n    </strong>\n    .\n   </li>\n<li>\n    Unicode uses\n    <strong>\n     16-bit characters\n    </strong>\n    , which ensures that the text can be displayed correctly across different platforms and languages.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Purpose and Use:\n</h4>\n<ul>\n<li>\n  String descriptors are helpful for providing human-readable descriptions of the device's properties, allowing the user or the host to understand information such as device name, manufacturer, serial number, and more.\n </li>\n<li>\n  The device uses the\n  <strong>\n   wValue\n  </strong>\n  field's index to request a particular string, either\n </li>\n</ul>\n"}, "Page 135": {"response": "<h3>\n Other Standard Descriptors in USB\n</h3>\n<p>\n The USB 2.0 specification also defines three additional types of descriptors beyond the commonly used ones:\n <strong>\n  interface_power\n </strong>\n ,\n <strong>\n  OTG\n </strong>\n , and\n <strong>\n  debug\n </strong>\n descriptors. These are less frequently used but serve specific purposes in certain USB device configurations.\n</p>\n<h4>\n 1.\n <strong>\n  interface_power Descriptor\n </strong>\n :\n</h4>\n<ul>\n<li>\n<strong>\n   Purpose\n  </strong>\n  : This descriptor was proposed as part of the\n  <strong>\n   Interface Power Management\n  </strong>\n  specification to allow interfaces in USB devices to manage their own power consumption individually.\n </li>\n<li>\n<strong>\n   Background\n  </strong>\n  : Originally proposed by Microsoft in 1998, the interface_power descriptor has not been officially approved or widely implemented.\n </li>\n<li>\n<strong>\n   Details\n  </strong>\n  : The descriptor structure and use were outlined in the\n  <strong>\n   USB Feature Specification: Interface Power Management\n  </strong>\n  document, but its adoption has been limited.\n </li>\n</ul>\n<h4>\n 2.\n <strong>\n  OTG (On-The-Go) Descriptor\n </strong>\n :\n</h4>\n<ul>\n<li>\n<strong>\n   Purpose\n  </strong>\n  : The OTG descriptor is crucial for devices that support\n  <strong>\n   USB On-The-Go (OTG)\n  </strong>\n  , particularly for devices using the\n  <strong>\n   Host Negotiation Protocol (HNP)\n  </strong>\n  or the\n  <strong>\n   Session Request Protocol (SRP)\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Functionality\n  </strong>\n  : The OTG descriptor indicates which specific protocols (HNP or SRP) the device supports.\n </li>\n<li>\n<strong>\n   More Information\n  </strong>\n  : Detailed information about the OTG descriptor can be found in\n  <strong>\n   Chapter 20\n  </strong>\n  of the USB specification, which delves into On-The-Go devices and protocols.\n </li>\n</ul>\n<h4>\n 3.\n <strong>\n  Debug Descriptor\n </strong>\n :\n</h4>\n<ul>\n<li>\n<strong>\n   Purpose\n  </strong>\n  : This descriptor is used for\n  <strong>\n   USB2 Debug Devices\n  </strong>\n  . These devices connect to a\n  <strong>\n   debug port\n  </strong>\n  defined in the\n  <strong>\n   EHCI (Enhanced Host Controller Interface)\n  </strong>\n  specification for high-speed host controllers.\n </li>\n<li>\n<strong>\n   Functionality\n  </strong>\n  : The debug descriptor and corresponding debug port are intended to replace the traditional\n  <strong>\n   RS-232\n  </strong>\n  serial port, which has been used for debugging in PCs for many years.\n </li>\n</ul>\n<h3>\n String Descriptor Details\n</h3>\n<p>\n A\n <strong>\n  String Descriptor\n </strong>\n in USB provides descriptive text and is structured as follows:\n</p>\n<ul>\n<li>\n<strong>\n   bLength\n  </strong>\n  : Specifies the size of the descriptor in bytes.\n </li>\n<li>\n<strong>\n   bDescriptorType\n  </strong>\n  : A constant value\n  <strong>\n   STRING (03h)\n  </strong>\n  .\n </li>\n</ul>\n<p>\n For\n <strong>\n  String Descriptor 0\n </strong>\n , the\n <strong>\n  wLANGID\n </strong>\n field contains an array of\n <strong>\n  Language Identifier codes\n </strong>\n . These codes indicate the languages in which the strings are available. For other string descriptors,\n <strong>\n  bString\n </strong>\n contains the actual\n <strong>\n  Unicode\n </strong>\n string.\n</p>\n<ul>\n<li>\n<strong>\n   bString\n  </strong>\n  : For all descriptors with an index of\n  <strong>\n   1 or higher\n  </strong>\n  , this field contains the Unicode string text. Each character is represented by a\n  <strong>\n   16-bit value\n  </strong>\n  (Unicode). For instance, the word \"Gizmo\" would be encoded in Unicode as:\n  <ul>\n<li>\n    0047 0069 007A 006D 006F (for G, i, z, m, o).\n   </li>\n</ul>\n</li>\n</ul>\n<h3>\n Unicode Representation:\n</h3>\n<ul>\n<li>\n<strong>\n   ANSI codes (00h to 7Fh)\n  </strong>\n  map directly to\n  <strong>\n   Unicode (0000h to 007Fh)\n  </strong>\n  . This means simple characters in the ASCII range are compatible between the two formats.\n </li>\n<li>\n  The strings are\n  <strong>\n   not null-terminated\n  </strong>\n  in USB descriptors.\n </li>\n</ul>\n<p>\n These descriptors enable USB devices to communicate textual information, such as product names, serial numbers, and configuration details, in a language-in\n</p>\n"}, "Page 136": {"response": "<h3>\n Microsoft OS Descriptor\n</h3>\n<p>\n The\n <strong>\n  Microsoft OS descriptor\n </strong>\n is a special descriptor developed by Microsoft for use with devices in\n <strong>\n  vendor-defined classes\n </strong>\n . This descriptor helps provide\n <strong>\n  Windows-specific\n </strong>\n information, such as icons and registry settings, which are often required for Windows devices.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Structure\n   </strong>\n   : The descriptor consists of:\n  </p>\n<ul>\n<li>\n    A\n    <strong>\n     String descriptor\n    </strong>\n    with an index of\n    <strong>\n     EEh\n    </strong>\n    that contains an embedded signature. This signature helps identify the descriptor for Windows.\n   </li>\n<li>\n    One or more\n    <strong>\n     Microsoft OS feature descriptors\n    </strong>\n    , which are used to store specific information for Windows compatibility.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Usage\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Windows XP SP1 and later\n    </strong>\n    request this string descriptor when a device is first attached. If the device does not support this descriptor, it should return a\n    <strong>\n     STALL\n    </strong>\n    response.\n   </li>\n<li>\n    If a device contains the Microsoft OS String descriptor,\n    <strong>\n     Windows\n    </strong>\n    will subsequently request additional\n    <strong>\n     Microsoft-specific descriptors\n    </strong>\n    .\n   </li>\n</ul>\n<p>\n   For future details,\n   <strong>\n    Windows DDK\n   </strong>\n   (Device Driver Kit) updates will provide further documentation about these descriptors.\n  </p>\n</li>\n</ul>\n<h3>\n Descriptors in 2.0-Compliant Devices\n</h3>\n<p>\n When upgrading a device from\n <strong>\n  USB 1.x\n </strong>\n to\n <strong>\n  USB 2.0\n </strong>\n , certain descriptor changes might be necessary. Here's what needs to be done to ensure compliance with the USB 2.0 specification.\n</p>\n<h4>\n Making 1.x Descriptors 2.0-Compliant\n</h4>\n<p>\n For most devices, the\n <strong>\n  only required change\n </strong>\n to make a\n <strong>\n  1.x-compliant device\n </strong>\n USB 2.0 compliant is updating the\n <strong>\n  bcdUSB field\n </strong>\n in the\n <strong>\n  device descriptor\n </strong>\n . It should be set to\n <strong>\n  0200h\n </strong>\n to indicate USB 2.0 support.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Isochronous Endpoints\n   </strong>\n   : If the device uses isochronous transfers, the upgrade is more involved. USB 2.0 specifies that a device's default interface must not request isochronous bandwidth. Since the default interface does not transfer isochronous data, the device must support at least one\n   <strong>\n    alternate interface\n   </strong>\n   for isochronous data transfer. This alternate interface will include at least one\n   <strong>\n    subordinate endpoint descriptor\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Dual-speed Devices\n   </strong>\n   : In a\n   <strong>\n    dual-speed device\n   </strong>\n   , it is not possible to detect whether the device is operating at\n   <strong>\n    full speed\n   </strong>\n   or\n   <strong>\n    high speed\n   </strong>\n   directly from the descriptors alone. Other methods must be used to determine the actual operating speed of the device.\n  </p>\n</li>\n</ul>\n<p>\n These changes ensure that older USB 1.x devices meet the requirements of USB 2.0, especially for handling faster d\n</p>\n"}, "Page 137": {"response": "<h3>\n USB 2.0 Compliance for 1.x Devices\n</h3>\n<p>\n The USB 2.0 specification introduces new descriptors and updates existing ones, but most of the changes are only needed for\n <strong>\n  dual-speed devices\n </strong>\n . For the majority of devices, the USB 2.0 changes are\n <strong>\n  backwards compatible\n </strong>\n with USB 1.x, with only a few updates needed to support new functionalities.\n</p>\n<h4>\n Key Changes for Full-Speed Isochronous Endpoints\n</h4>\n<p>\n For\n <strong>\n  full-speed isochronous endpoints\n </strong>\n , the\n <strong>\n  endpoint descriptor\n </strong>\n introduces new optional features:\n</p>\n<ul>\n<li>\n<strong>\n   bmAttributes field\n  </strong>\n  : This field can now specify\n  <strong>\n   synchronization\n  </strong>\n  and\n  <strong>\n   usage types\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   bInterval field\n  </strong>\n  : The interval can be set to greater than 1 millisecond, unlike USB 1.x, where the default was 1 millisecond.\n </li>\n</ul>\n<p>\n In USB 1.x descriptors:\n</p>\n<ul>\n<li>\n<strong>\n   Synchronization\n  </strong>\n  was defaulted to\n  <strong>\n   no synchronization\n  </strong>\n  (0).\n </li>\n<li>\n<strong>\n   Interval\n  </strong>\n  was set to\n  <strong>\n   1 millisecond\n  </strong>\n  .\n </li>\n</ul>\n<p>\n For\n <strong>\n  interrupt\n </strong>\n and\n <strong>\n  isochronous endpoints\n </strong>\n , the\n <strong>\n  bInterval\n </strong>\n value will result in different interval lengths depending on the\n <strong>\n  transfer type\n </strong>\n and\n <strong>\n  speed\n </strong>\n :\n</p>\n<ul>\n<li>\n  For\n  <strong>\n   low- and full-speed interrupt endpoints\n  </strong>\n  , the interval equals the value of\n  <strong>\n   bInterval\n  </strong>\n  in milliseconds.\n </li>\n<li>\n  For\n  <strong>\n   full-speed isochronous endpoints\n  </strong>\n  , the interval is calculated as\n  <strong>\n   2 * bInterval - 1\n  </strong>\n  in milliseconds.\n </li>\n<li>\n  For\n  <strong>\n   high-speed interrupt and isochronous endpoints\n  </strong>\n  , the interval is calculated as\n  <strong>\n   2 * bInterval - 1\n  </strong>\n  in\n  <strong>\n   125 microsecond\n  </strong>\n  units.\n </li>\n</ul>\n<p>\n In\n <strong>\n  USB 1.x\n </strong>\n , the\n <strong>\n  bInterval = 1\n </strong>\n for isochronous endpoints gives a 1 millisecond interval, which doesn't require any changes for compliance with USB 2.0.\n</p>\n<h4>\n Upgrading a Full-Speed Device to High-Speed\n</h4>\n<p>\n When upgrading a\n <strong>\n  full-speed device\n </strong>\n to support\n <strong>\n  high-speed\n </strong>\n transfers, the device must include additional descriptors:\n</p>\n<ul>\n<li>\n<strong>\n   device_qualifier descriptor\n  </strong>\n</li>\n<li>\n<strong>\n   other_speed_configuration descriptor\n  </strong>\n</li>\n<li>\n<strong>\n   High-speed configuration descriptors\n  </strong>\n</li>\n</ul>\n<p>\n Additionally, for\n <strong>\n  interrupt endpoints\n </strong>\n in the\n <strong>\n  default interface\n </strong>\n , the\n <strong>\n  maximum packet size\n </strong>\n should be\n <strong>\n  64 bytes\n </strong>\n or less.\n</p>\n<p>\n A USB 2.0 device that supports only\n <strong>\n  low speed\n </strong>\n or\n <strong>\n  full speed\n </strong>\n will return a\n <strong>\n  STALL\n </strong>\n response if asked for the\n <strong>\n  device_qualifier\n </strong>\n or\n <strong>\n  other_speed_configuration\n </strong>\n descriptors.\n</p>\n<h4>\n Summary of Required Changes for USB 2.0 Compliance\n</h4>\n<p>\n For most\n <strong>\n  1.x devices\n </strong>\n upgrading to USB 2.0, only minor changes are necessary:\n</p>\n<ul>\n<li>\n<strong>\n   Device Descriptor\n  </strong>\n  : The\n  <strong>\n   bcdUSB field\n  </strong>\n  must be set to\n  <strong>\n   0200h\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Endpoint Descriptor (Isochronous)\n  </strong>\n  : For the default configuration,\n  <strong>\n   wMaxPacketSize\n  </strong>\n  must be set to\n </li>\n</ul>\n"}, "Page 138": {"response": "<h3>\n Detecting the Speed of a Dual-Speed Device\n</h3>\n<p>\n A\n <strong>\n  dual-speed device\n </strong>\n (one capable of both full-speed and high-speed operation) initially responds to enumeration requests at\n <strong>\n  full speed\n </strong>\n . However, if the device is connected to a high-speed host or if it directly supports high-speed operation, it may also function at high speed. Generally,\n <strong>\n  applications\n </strong>\n and\n <strong>\n  device drivers\n </strong>\n do not need to determine the speed of a device, as the system handles this automatically at a lower level. Windows does not offer a straightforward way for applications to detect the device's speed, but there are a few methods to check the\n <strong>\n  bus speed\n </strong>\n of many devices.\n</p>\n<h4>\n Methods to Detect Device Speed\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Bulk Endpoint Method\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    If the device has a\n    <strong>\n     bulk endpoint\n    </strong>\n    , you can check the\n    <strong>\n     wMaxPacketSize\n    </strong>\n    field in the endpoint descriptor.\n    <ul>\n<li>\n      In a\n      <strong>\n       high-speed\n      </strong>\n      device, the\n      <strong>\n       wMaxPacketSize\n      </strong>\n      must be\n      <strong>\n       512 bytes\n      </strong>\n      .\n     </li>\n<li>\n      In a\n      <strong>\n       full-speed\n      </strong>\n      device, the\n      <strong>\n       wMaxPacketSize\n      </strong>\n      cannot be 512 bytes.\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Interrupt or Isochronous Endpoint Method\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    If the device does not have a bulk endpoint, you can inspect the\n    <strong>\n     wMaxPacketSize\n    </strong>\n    of an\n    <strong>\n     interrupt\n    </strong>\n    or\n    <strong>\n     isochronous endpoint\n    </strong>\n    :\n    <ul>\n<li>\n      For\n      <strong>\n       interrupt endpoints\n      </strong>\n      , if the\n      <strong>\n       wMaxPacketSize\n      </strong>\n      is\n      <strong>\n       greater than 64 bytes\n      </strong>\n      , the device is likely operating at\n      <strong>\n       high speed\n      </strong>\n      .\n     </li>\n<li>\n      If the\n      <strong>\n       wMaxPacketSize\n      </strong>\n      is\n      <strong>\n       64 bytes or less\n      </strong>\n      , the device could be operating at either\n      <strong>\n       full-speed\n      </strong>\n      or\n      <strong>\n       high-speed\n      </strong>\n      .\n     </li>\n<li>\n      For\n      <strong>\n       isochronous endpoints\n      </strong>\n      , if the\n      <strong>\n       wMaxPacketSize\n      </strong>\n      is\n      <strong>\n       1024 bytes\n      </strong>\n      , it indicates\n      <strong>\n       high speed\n      </strong>\n      . If it's\n      <strong>\n       1023 bytes or less\n      </strong>\n      , the device might be using\n      <strong>\n       full-speed\n      </strong>\n      or\n      <strong>\n       high-speed\n      </strong>\n      .\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Providing Speed Information in Firmware\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    If you are writing\n    <strong>\n     device firmware\n    </strong>\n    , you can include speed information in\n    <strong>\n     string descriptors\n    </strong>\n    . These descriptors can be indexed by the\n    <strong>\n     configuration\n    </strong>\n    and\n    <strong>\n     other_speed_configuration\n    </strong>\n    descriptors.\n    <ul>\n<li>\n      For instance, a string indexed by the\n      <strong>\n       configuration descriptor\n      </strong>\n      could contain the text \"\n      <strong>\n       high speed\n      </strong>\n      ,\" and a string indexed by the\n      <strong>\n       other_speed_configuration descriptor\n      </strong>\n      could state \"\n      <strong>\n       full speed\n      </strong>\n      .\"\n     </li>\n<li>\n      Applications can then read these string descriptors to learn the device's speed.\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Using USBView Application\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     USBView\n    </strong>\n    tool in the\n    <strong>\n     Windows DDK\n    </strong>\n    demonstrates how applications can read the device descriptors to determine the speed.\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n In summary, determining whether a device is operating at\n <strong>\n  high speed\n </strong>\n or\n <strong>\n  full speed\n </strong>\n can be done by examining specific descriptors like\n <strong>\n  wMaxPacketSize\n </strong>\n , using custom firmware string descriptors, or utilizing tools like\n <strong>\n  USBView\n </strong>\n .\n</p>\n"}, "Page 139": {"response": "<h3>\n Control Transfers: Structured Requests for Critical Data\n</h3>\n<p>\n Control transfers are one of the four transfer types in USB, but they stand out because they have the most intricate structure and are the only transfer type with functions clearly defined by the USB specification. This chapter explores the details of control transfers and the types of requests that are part of this transfer method.\n</p>\n<h4>\n Elements of a Control Transfer\n</h4>\n<p>\n Control transfers play a vital role in enabling communication between the host and the device, allowing them to exchange important information about the device\u2019s capabilities. Additionally, control transfers are used for transferring class-specific or vendor-specific information.\n</p>\n<p>\n A control transfer follows a specific format, which includes the following stages:\n</p>\n<ol>\n<li>\n<strong>\n   Setup Stage\n  </strong>\n  : The initial stage where the host sends a request to the device, typically to request information or to perform a command.\n </li>\n<li>\n<strong>\n   Data Stage\n  </strong>\n  (optional): This stage occurs if data needs to be exchanged between the host and the device. The Data stage is optional for cert\n </li>\n</ol>\n"}, "Page 140": {"response": "<h3>\n Control Transfers: Structured Requests for Critical Data\n</h3>\n<p>\n Control transfers are essential for enabling communication between the host and the device, and they follow a structured process consisting of multiple stages and transactions. These transfers include key stages like Setup, Data, and Status, and each stage involves a series of packets to facilitate data exchange.\n</p>\n<h4>\n Stages of a Control Transfer\n</h4>\n<p>\n A control transfer is structured into three main stages:\n</p>\n<ol>\n<li>\n<strong>\n   Setup Stage\n  </strong>\n  : This is the first stage, where the host sends a request to the device, identifying the transfer as a control transfer and providing the necessary information for the device to process the request.\n </li>\n<li>\n<strong>\n   Data Stage\n  </strong>\n  (optional): This stage involves data transfer between the host and the device, but it is not always required for every control transfer.\n </li>\n<li>\n<strong>\n   Status Stage\n  </strong>\n  : The final stage in the transfer, used to finalize the process and confirm that the device has processed the request.\n </li>\n</ol>\n<p>\n Each of these stages contains one or more transactions, and each transaction has three phases:\n</p>\n<ul>\n<li>\n<strong>\n   Token Phase\n  </strong>\n  : Identifies the type of transaction.\n </li>\n<li>\n<strong>\n   Data Phase\n  </strong>\n  : Transfers the actual data.\n </li>\n<li>\n<strong>\n   Handshake Phase\n  </strong>\n  : Confirms the successful transfer of the data.\n </li>\n</ul>\n<p>\n Additionally, certain transfers, like low-speed and high-speed, utilize specific protocols (PRE, PING, or split transactions), but these protocols are handled automatically by the hardware, so developers don\u2019t need to manage them directly.\n</p>\n<h4>\n Setup Stage Breakdown\n</h4>\n<p>\n The Setup stage, in particular, involves a specific\n <strong>\n  Setup transaction\n </strong>\n designed to both:\n</p>\n<ol>\n<li>\n  Identify the transfer as a control transfer.\n </li>\n<li>\n  Send the necessary request and related information for the device to fulfill it.\n </li>\n</ol>\n<p>\n<strong>\n  Key Components of the Setup Stage Transaction:\n </strong>\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Token Packet\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Purpose: This packet identifies the receiver and marks the transaction as a Setup transaction.\n   </li>\n<li>\n    Sent by: The host.\n   </li>\n<li>\n    Packet Identifier (PID): SETUP.\n   </li>\n<li>\n    Additional Contents: Includes the device and endpoint addresses.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Data Packet\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Purpose: This packet carries the request and any additional information required for the transaction.\n   </li>\n<li>\n    Sent by: The host.\n   </li>\n</ul>\n</li>\n</ol>\n"}, "Page 141": {"response": "<h3>\n Control Transfers: Structured Requests for Critical Data (Continued)\n</h3>\n<p>\n The Setup stage of a control transfer includes a\n <strong>\n  Data Packet\n </strong>\n that contains critical information. This packet's contents are structured into five fields, which are essential for defining the transfer\u2019s behavior.\n</p>\n<h4>\n Breakdown of the Data Packet Fields\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    bmRequestType\n   </strong>\n   (1 byte):\n  </p>\n<ul>\n<li>\n    This byte specifies several key aspects of the request:\n    <ul>\n<li>\n<strong>\n       Direction bit (Bit 7)\n      </strong>\n      :\n      <ul>\n<li>\n        Defines the direction of data flow for the Data stage.\n       </li>\n<li>\n        0 = Host to device (OUT) or no Data stage.\n       </li>\n<li>\n        1 = Device to host (IN).\n       </li>\n</ul>\n</li>\n<li>\n<strong>\n       Request Type bits (Bits 6-5)\n      </strong>\n      :\n      <ul>\n<li>\n        00 = Standard request (defined by USB).\n       </li>\n<li>\n        01 = Class-specific request (defined by a USB class).\n       </li>\n<li>\n        10 = Vendor-specific request (defined by a vendor for specific products).\n       </li>\n</ul>\n</li>\n<li>\n<strong>\n       Recipient bits (Bits 4-0)\n      </strong>\n      :\n      <ul>\n<li>\n        Defines the recipient of the request:\n        <ul>\n<li>\n          00000 = Device.\n         </li>\n<li>\n          00001 = Interface.\n         </li>\n<li>\n          00010 = Endpoint.\n         </li>\n<li>\n          00011 = Other element in the device.\n         </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    bRequest\n   </strong>\n   (1 byte):\n  </p>\n<ul>\n<li>\n    This byte specifies the request itself. Each request is uniquely identified by a\n    <strong>\n     bRequest\n    </strong>\n    value:\n    <ul>\n<li>\n      If the\n      <strong>\n       Request Type\n      </strong>\n      bits in\n      <strong>\n       bmRequestType\n      </strong>\n      = 00, then\n      <strong>\n       bRequest\n      </strong>\n      corresponds to a standard USB request.\n     </li>\n<li>\n      If the\n      <strong>\n       Request Type\n      </strong>\n      bits = 01, then\n      <strong>\n       bRequest\n      </strong>\n      is for a class-specific request.\n     </li>\n<li>\n      If the\n      <strong>\n       Request Type\n      </strong>\n      bits = 10, then\n      <strong>\n       bRequest\n      </strong>\n      is for a vendor-specific request.\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    wValue\n   </strong>\n   (2 bytes):\n  </p>\n<ul>\n<li>\n    These two bytes allow the host to pass information to the device.\n   </li>\n<li>\n    The meaning of these bytes is request-dependent. For instance:\n    <ul>\n<li>\n      In a\n      <strong>\n       Set_Address\n      </strong>\n      request,\n      <strong>\n       wValue\n      </strong>\n      contains the device address.\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    wIndex\n   </strong>\n   (2 bytes):\n  </p>\n<ul>\n<li>\n    This field passes additional information, typically used for indexing or offset purposes.\n   </li>\n<li>\n    For example:\n    <ul>\n<li>\n      If it's an\n      <strong>\n       endpoint index\n      </strong>\n      , bits 0-3 indicate the endpoint number, and bit 7 specifies the endpoint direction (0 = OUT/Control, 1 = IN).\n     </li>\n<li>\n      If it's an\n      <strong>\n       interface index\n      </strong>\n      , bits 0-7 represent the interface number, with unused bits set to zero.\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    wLength\n   </strong>\n   (2 bytes):\n  </p>\n<ul>\n<li>\n    This field specifies the number of data bytes expected in the Data stage (if present).\n   </li>\n<li>\n    For host-to-device transfers,\n    <strong>\n     wLength\n    </strong>\n    ind\n   </li>\n</ul>\n</li>\n</ol>\n"}, "Page 142": {"response": "<h3>\n Control Transfers: Data Stage and Handshake\n</h3>\n<h4>\n Handshake Packet\n</h4>\n<p>\n The\n <strong>\n  Handshake Packet\n </strong>\n is crucial for completing the Setup stage of a control transfer. It serves as an acknowledgment from the device to indicate that the Setup transaction was successfully received.\n</p>\n<ul>\n<li>\n<strong>\n   Purpose\n  </strong>\n  : To confirm the device's receipt of the Setup or Data packet.\n </li>\n<li>\n<strong>\n   Sent by\n  </strong>\n  : The device.\n </li>\n<li>\n<strong>\n   PID\n  </strong>\n  :\n  <strong>\n   ACK\n  </strong>\n  (Acknowledgment).\n </li>\n<li>\n<strong>\n   Additional Contents\n  </strong>\n  : None\u2014this packet consists solely of the PID.\n </li>\n<li>\n<strong>\n   Device Behavior\n  </strong>\n  : If the device detects an error in the received Setup or Data packet, it does not send a handshake (ACK). The device\u2019s hardware generally handles error checking and sending the ACK automatically, so no additional programming is required.\n </li>\n</ul>\n<h4>\n Data Stage\n</h4>\n<p>\n When a\n <strong>\n  Data Stage\n </strong>\n is included in the control transfer, it can consist of one or more\n <strong>\n  IN\n </strong>\n (device to host) or\n <strong>\n  OUT\n </strong>\n (host to device) transactions. The\n <strong>\n  wLength\n </strong>\n field in the Setup transaction indicates how much data needs to be transferred.\n</p>\n<ul>\n<li>\n<strong>\n   IN transactions\n  </strong>\n  : The device sends data to the host. For example, the\n  <strong>\n   Get_Descriptor\n  </strong>\n  request involves the device sending the requested descriptor to the host.\n </li>\n<li>\n<strong>\n   OUT transactions\n  </strong>\n  : The host sends data to the device. An example of this is the\n  <strong>\n   Set_Report\n  </strong>\n  request, where the host sends a report to the device.\n </li>\n</ul>\n<p>\n If the\n <strong>\n  wLength\n </strong>\n field in the Setup transaction is zero, no Data stage is required. For instance, in the\n <strong>\n  Set_Configuration\n </strong>\n request, the host sends a configuration value to the device, and no data transfer is needed.\n</p>\n<p>\n If the Data stage involves more data than can fit in one packet, multiple transactions are used. The number of transactions required to transfer all the data is calculated by dividing the\n <strong>\n  wLength\n </strong>\n value in the Setup transaction by the\n <strong>\n  wMaxPacketSize\n </strong>\n in the endpoint\u2019s descriptor, rounding up to ensure all data is sent.\n</p>\n<p>\n This structured exchange ensures that data is transferred correctly and\n</p>\n"}, "Page 143": {"response": "<h3>\n Control Transfers: Data Stage Details\n</h3>\n<h4>\n Data Stage Transactions\n</h4>\n<p>\n In the\n <strong>\n  Data Stage\n </strong>\n of a control transfer, data is transferred either from the device to the host or from the host to the device. The\n <strong>\n  wLength\n </strong>\n field from the Setup stage defines the amount of data being transferred, and the\n <strong>\n  wMaxPacketSize\n </strong>\n from the endpoint descriptor determines the maximum packet size allowed per transaction.\n</p>\n<ul>\n<li>\n  If the\n  <strong>\n   wLength\n  </strong>\n  field indicates that more data needs to be transferred than can fit in a single packet, multiple transactions are used.\n </li>\n<li>\n  For example, if the\n  <strong>\n   wLength\n  </strong>\n  is 18 bytes and the\n  <strong>\n   wMaxPacketSize\n  </strong>\n  is 8 bytes, the transfer would require 3 Data transactions.\n </li>\n<li>\n  The direction of the data transfer (whether from the device or host) remains the same throughout the Data stage. If no data is transferred, a zero-length data packet (just the PID) is used.\n </li>\n</ul>\n<p>\n When transferring data in a low or full-speed device, split transactions may occur if the device is connected through an upstream hub to a high-speed bus. If the device is high-speed and more than one data transaction is required, the\n <strong>\n  PING protocol\n </strong>\n may be used for\n <strong>\n  OUT transactions\n </strong>\n .\n</p>\n<p>\n Each transaction in the Data stage consists of three types of packets:\n <strong>\n  Token\n </strong>\n ,\n <strong>\n  Data\n </strong>\n , and\n <strong>\n  Handshake\n </strong>\n .\n</p>\n<h4>\n Token Packet\n</h4>\n<ul>\n<li>\n<strong>\n   Purpose\n  </strong>\n  : Identifies the transaction's direction (IN or OUT) and specifies the receiver.\n </li>\n<li>\n<strong>\n   Sent by\n  </strong>\n  : The host.\n </li>\n<li>\n<strong>\n   PID\n  </strong>\n  : If the data is being sent to the host, the PID is\n  <strong>\n   IN\n  </strong>\n  . If the data is being sent to the device, the PID is\n  <strong>\n   OUT\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Additional Contents\n  </strong>\n  : The device and endpoint addresses.\n </li>\n</ul>\n<h4>\n Data Packet\n</h4>\n<ul>\n<li>\n<strong>\n   Purpose\n  </strong>\n  : Transfers part or all of the data specified in the\n  <strong>\n   wLength\n  </strong>\n  field from the Setup transaction.\n </li>\n<li>\n<strong>\n   Sent by\n  </strong>\n  : If the\n  <strong>\n   PID\n  </strong>\n  in the token packet is\n  <strong>\n   IN\n  </strong>\n  , the device sends the Data packet; if the\n  <strong>\n   PID\n  </strong>\n  is\n  <strong>\n   OUT\n  </strong>\n  , the host sends the Data packet.\n </li>\n<li>\n<strong>\n   PID\n  </strong>\n  : The first packet in the Data stage uses\n  <strong>\n   DATA1\n  </strong>\n  . All additional packets alternate between\n  <strong>\n   DATA0\n  </strong>\n  and\n  <strong>\n   DATA1\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Additional Contents\n  </strong>\n  : This packet contains the actual data being transferred or, if no data is being sent, a zero-length data packet.\n </li>\n</ul>\n<p>\n These elements ensure that the\n <strong>\n  Data Stage\n </strong>\n correctly facilitates the transfer of data between the host and the device, using multiple packets if\n</p>\n"}, "Page 144": {"response": "<h3>\n Chapter 5: USB Handshake and Status Stage\n</h3>\n<h4>\n Handshake Packet\n</h4>\n<p>\n<strong>\n  Purpose\n </strong>\n : The receiver sends a handshake packet to return status information about the received data.\n <br/>\n<strong>\n  Sender\n </strong>\n :\n</p>\n<ul>\n<li>\n  If the token packet's PID is IN, the host sends the handshake packet.\n </li>\n<li>\n  If the token packet's PID is OUT, the device sends the handshake packet.\n </li>\n</ul>\n<p>\n<strong>\n  PID\n </strong>\n :\n</p>\n<ul>\n<li>\n  ACK: Data was received successfully.\n </li>\n<li>\n  NAK: The endpoint is busy.\n </li>\n<li>\n  STALL: The request is not supported or the endpoint is halted.\n </li>\n<li>\n  NYET (for high-speed devices): The current data was accepted, but the endpoint isn't ready for another packet yet.\n </li>\n<li>\n  The host can only return ACK.\n </li>\n</ul>\n<p>\n<strong>\n  Content\n </strong>\n : The handshake packet contains only the PID with no additional data.\n <br/>\n<strong>\n  Note\n </strong>\n : If the receiver detects an error in the token or data packet, no handshake packet is sent.\n</p>\n<h4>\n Status Stage\n</h4>\n<p>\n<strong>\n  Purpose\n </strong>\n : The Status stage indicates whether the entire transfer was successful or failed, similar to the handshake packet but for the whole transfer. It may sometimes use the handshake packet in the Status stage to communicate this.\n</p>\n<ul>\n<li>\n  In some cases (e.g., receiving the first packet of a device descriptor during enumeration), the host may start the Status stage before the Data stage is complete. In such cases, the device must detect the token packet of the Status stage, abandon the Data stage, and complete the Status stage.\n </li>\n</ul>\n<p>\n<strong>\n  Token Packet\n </strong>\n :\n <br/>\n<strong>\n  Purpose\n </strong>\n : Identifies the receiver and indicates the direction of the data packet in the Status stage.\n</p>\n"}, "Page 145": {"response": "<h3>\n Control Transfers: Structured Requests for Critical Data\n</h3>\n<h4>\n Status Stage\n</h4>\n<p>\n<strong>\n  Sender\n </strong>\n : The host sends the status stage.\n <br/>\n<strong>\n  PID\n </strong>\n : The PID of the status stage is opposite to the previous transaction\u2019s data packet:\n</p>\n<ul>\n<li>\n  If the Data stage's PID was OUT or there was no Data stage, the Status stage\u2019s PID is IN.\n </li>\n<li>\n  If the Data stage's PID was IN, the Status stage\u2019s PID is OUT.\n  <br/>\n<strong>\n   Additional Contents\n  </strong>\n  : Contains the device and endpoint addresses.\n </li>\n</ul>\n<h4>\n Data Packet\n</h4>\n<p>\n<strong>\n  Purpose\n </strong>\n : The data packet indicates the status of the transfer, depending on the outcome of the Data stage.\n <br/>\n<strong>\n  Sender\n </strong>\n :\n</p>\n<ul>\n<li>\n  If the Status stage\u2019s token packet\u2019s PID is IN, the device sends the data packet.\n </li>\n<li>\n  If the Status stage\u2019s token packet\u2019s PID is OUT, the host sends the data packet.\n  <br/>\n<strong>\n   PID Type\n  </strong>\n  : DATA1\n  <br/>\n<strong>\n   Additional Contents\n  </strong>\n  :\n </li>\n<li>\n  The host sends a zero-length data packet.\n </li>\n<li>\n  The device may send a zero-length data packet (indicating success), NAK (if the endpoint is busy), or STALL (if the endpoint is halted).\n  <br/>\n<strong>\n   Comments\n  </strong>\n  : For most requests, a zero-length data packet from the device signals that the requested action, if any, has been completed. An exception is the Set_Address command, which the device executes only after the Status stage.\n </li>\n</ul>\n<h4>\n Handshake Packet\n</h4>\n<p>\n<strong>\n  Purpose\n </strong>\n : The handshake packet communicates the status of the transfer from the sender of the Data stage.\n <br/>\n<strong>\n  Sender\n </strong>\n : The receiver of the Status stage\u2019s data packet:\n</p>\n<ul>\n<li>\n  If the Status stage\u2019s token packet\u2019s PID is IN, the host sends the handshake packet.\n </li>\n<li>\n  If the Status stage\u2019s token packet\u2019s PID is OUT, the device sends the handshake packet.\n  <br/>\n<strong>\n   PID Type\n  </strong>\n  : The possible responses are:\n </li>\n<li>\n  ACK (success)\n </li>\n<li>\n  NAK (busy)\n </li>\n<li>\n  STALL (request unsupported or endpoint halted)\n  <br/>\n  The host always responds with ACK if the data packet is received without error.\n </li>\n</ul>\n"}, "Page 146": {"response": "<h3>\n Chapter 5: Final Steps in Control Transfers and Error Handling\n</h3>\n<h4>\n Handshake Packet\n</h4>\n<p>\n<strong>\n  Additional Contents\n </strong>\n : The handshake packet consists only of the PID with no additional data.\n <br/>\n<strong>\n  Comments\n </strong>\n :\n</p>\n<ul>\n<li>\n  The handshake packet in the Status stage is the final transmission of the transfer.\n </li>\n<li>\n  If the receiver detects an error in the token or data packet, no handshake packet is returned.\n </li>\n<li>\n  For requests that take a long time to complete (e.g., multiple milliseconds), the protocol should offer an alternate method for determining when the request is finished. This prevents the host from waiting unnecessarily for an acknowledgment.\n  <ul>\n<li>\n    Example: The Set_Port_Feature(PORT_RESET) request sent to a hub. The reset signal lasts at least 10 milliseconds, but instead of waiting for the reset to complete, the hub acknowledges the request when it begins the reset and sets a bit when the reset is done. The host can later check this bit using a Get_Port_Status request.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Handling Errors\n</h4>\n<p>\n Devices may not always process every control-transfer request. Possible issues include:\n</p>\n<ul>\n<li>\n  The device\u2019s firmware doesn\u2019t support the request.\n </li>\n<li>\n  The device is unable to respond due to firmware crashes, a Halt condition at the endpoint, or being disconnected from the bus.\n </li>\n<li>\n  The host may decide to end the transfer prematurely.\n </li>\n</ul>\n<p>\n<strong>\n  Examples of Errors\n </strong>\n :\n</p>\n<ul>\n<li>\n  An unsupported request could occur if the request code is unfamiliar to the device\u2019s firmware, or if the device supports the request but the Setup stage has mismatched or unsupported information.\n </li>\n<li>\n  In such cases, a\n  <strong>\n   Request Error\n  </strong>\n  condition occurs, and the device notifies the host by sending a\n  <strong>\n   STALL\n  </strong>\n  code in a handshake packet.\n </li>\n<li>\n  The device must send an\n  <strong>\n   ACK\n  </strong>\n  in response to the Setup transaction, so the\n  <strong>\n   STALL\n  </strong>\n  response is included in the handshake packet during the Data or Status stage.\n </li>\n</ul>\n<p>\n<strong>\n  Host Actions on Error\n </strong>\n :\n</p>\n<ul>\n<li>\n  If the host doesn't receive the expected response, or detects an error in received data or a Halt condition, it abandons the transfer.\n </li>\n</ul>\n"}, "Page 147": {"response": "<h3>\n Control Transfers: Managing Data Requests and Device Firmware\n</h3>\n<h4>\n Host Handling of Errors and Transfer Abandonment\n</h4>\n<p>\n When a device fails to respond correctly to a transfer, the host attempts to re-establish communication by sending a new token packet for a fresh Setup transaction.\n</p>\n<ul>\n<li>\n  If the device receives a Setup token packet before finishing the current control transfer, it must abandon the ongoing transfer and start the new one.\n </li>\n<li>\n  If the transfer is using the Default Control Pipe and the new token packet doesn't resolve the issue, the host may request the device's hub to reset the device's port.\n </li>\n<li>\n  The host can also end a transfer early by initiating the Status stage before the Data stage has finished. In this case, the device must disregard the remaining data and treat the transfer as though all the data had been successfully received.\n </li>\n</ul>\n<h4>\n Device Firmware for Control Transfers\n</h4>\n<p>\n For a device to properly support control transfers, its firmware must handle several tasks when processing requests. Below is an overview of the steps the device firmware must perform for a Control Write request, where the host sends data to the device:\n</p>\n<p>\n<strong>\n  1. Setup Packet Detection\n </strong>\n :\n</p>\n<ul>\n<li>\n  The device's hardware detects the Setup packet, stores the data packet contents, returns an ACK, and triggers an interrupt.\n </li>\n</ul>\n<p>\n<strong>\n  2. Interrupt-Service Routine\n </strong>\n :\n</p>\n<ul>\n<li>\n  The interrupt-service routine decodes the request and configures Endpoint 0 to accept data from the host following an OUT token packet.\n </li>\n<li>\n  Endpoint 0 must also be capable of handling a new Setup packet, in case the host decides to abandon the transfer early.\n </li>\n</ul>\n<p>\n<strong>\n  3. Data Stage Processing\n </strong>\n :\n</p>\n<ul>\n<li>\n  When an OUT token packet arrives at Endpoint 0, it indicates that the host is sending data. The endpoint must return an ACK in the handshake packet, and the hardware triggers an interrupt.\n </li>\n</ul>\n<p>\n<strong>\n  4. Storing or Using Data\n </strong>\n :\n</p>\n<ul>\n<li>\n  The interrupt-service routine stores or processes the received data as necessary.\n </li>\n</ul>\n"}, "Page 148": {"response": "<h3>\n Control Transfers: Handling Data Stages and Control Requests\n</h3>\n<h4>\n Control Write Requests with Data Stage\n</h4>\n<p>\n For Control Write requests with a Data stage, the device must follow these steps:\n <br/>\n<strong>\n  5. More Data Packets\n </strong>\n :\n</p>\n<ul>\n<li>\n  If more data packets are expected in the Data stage, steps 3 and 4 repeat for each additional OUT transaction, until the amount of data specified by the wLength value in the Setup transaction is received.\n </li>\n</ul>\n<p>\n<strong>\n  6. Completing the Transfer\n </strong>\n :\n</p>\n<ul>\n<li>\n  Once all data has been received, the firmware configures Endpoint 0 to send a zero-length data packet in response to an IN token packet. The host then returns ACK to complete the transfer.\n </li>\n</ul>\n<h4>\n Control Write Requests with No Data Stage\n</h4>\n<p>\n For Control Write requests without a Data stage, the device follows a simplified process:\n <br/>\n<strong>\n  1. Setup Packet Detection\n </strong>\n :\n</p>\n<ul>\n<li>\n  The device detects the Setup packet, stores the data packet contents, returns an ACK, and triggers an interrupt.\n </li>\n</ul>\n<p>\n<strong>\n  2. Interrupt-Service Routine\n </strong>\n :\n</p>\n<ul>\n<li>\n  The interrupt-service routine decodes the request, performs the necessary action, and configures Endpoint 0 to respond to an IN token packet. It should also be prepared to handle a new Setup packet in case the host abandons the transfer early.\n </li>\n</ul>\n<p>\n<strong>\n  3. Status Stage\n </strong>\n :\n</p>\n<ul>\n<li>\n  Upon receiving the IN token packet, the device begins the Status stage by sending a zero-length data packet. The host returns ACK to complete the transfer.\n </li>\n</ul>\n<h4>\n Control Read Requests\n</h4>\n<p>\n For Control Read requests, where the host requests data from the device, the device follows these steps:\n <br/>\n<strong>\n  1. Setup Packet Detection\n </strong>\n :\n</p>\n<ul>\n<li>\n  The device detects the Setup packet, stores the data packet contents, returns an ACK, and triggers an interrupt.\n </li>\n</ul>\n<p>\n<strong>\n  2. Interrupt-Service Routine\n </strong>\n :\n</p>\n<ul>\n<li>\n  The interrupt-service routine decodes the request and configures Endpoint 0 to send data when an IN token packet is received. The endpoint should also be ready for a new Setup or OUT packet in case the host decides to abandon the transfer or start the Status stage early.\n </li>\n</ul>\n<p>\n<strong>\n  3. Data Stage\n </strong>\n :\n</p>\n<ul>\n<li>\n  The device returns to normal operation. The arrival of an IN token packet at Endpoint 0 signals that the host is requesting data in the Data stage.\n </li>\n</ul>\n"}, "Page 149": {"response": "<h3>\n Control Transfers: Completing Data Transfers and Standard Requests\n</h3>\n<h4>\n Control Read Requests (Continued)\n</h4>\n<p>\n For Control Read requests where the host asks for data, the device continues with the following steps:\n <br/>\n<strong>\n  4. Sending More Data\n </strong>\n :\n</p>\n<ul>\n<li>\n  If more data needs to be sent, the interrupt service routine configures the endpoint to send data when it receives another IN token packet. Steps 3 and 4 are repeated for each additional packet of data.\n </li>\n</ul>\n<p>\n<strong>\n  5. Completing the Transfer\n </strong>\n :\n</p>\n<ul>\n<li>\n  Once an OUT token packet is received, followed by a zero-length data packet, the endpoint sends an ACK to finalize the transfer.\n </li>\n</ul>\n<h4>\n Standard USB Requests\n</h4>\n<p>\n Table 5-1 summarizes the eleven standard USB requests, which all devices must respond to. Some requests may simply return a\n <strong>\n  STALL\n </strong>\n response if not supported. These requests are numbered from 00 to 0Ch, with a few values being unused.\n</p>\n<ul>\n<li>\n  Most requests come in pairs, where each\n  <strong>\n   Set\n  </strong>\n  request has a corresponding\n  <strong>\n   Get\n  </strong>\n  or\n  <strong>\n   Clear\n  </strong>\n  request.\n </li>\n<li>\n  Exceptions to this pattern include\n  <strong>\n   Set_Address\n  </strong>\n  ,\n  <strong>\n   Synch_Frame\n  </strong>\n  , and\n  <strong>\n   Get_Status\n  </strong>\n  .\n </li>\n</ul>\n"}, "Page 150": {"response": "<h3>\n USB Standard Control Requests\n</h3>\n<h4>\n Table 5-1: Summary of USB Standard Requests\n</h4>\n<p>\n The USB specification defines eleven standard requests for control transfers, each serving specific purposes. The table below summarizes these requests:\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Request Number\n    </strong>\n</th>\n<th>\n<strong>\n     Request\n    </strong>\n</th>\n<th>\n<strong>\n     Data Source (Data Stage)\n    </strong>\n</th>\n<th>\n<strong>\n     Recipient\n    </strong>\n</th>\n<th>\n<strong>\n     wValue\n    </strong>\n</th>\n<th>\n<strong>\n     wIndex\n    </strong>\n</th>\n<th>\n<strong>\n     Data Length (bytes) in Data Stage (wLength)\n    </strong>\n</th>\n<th>\n<strong>\n     Data in Data Stage\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n    00h\n   </td>\n<td>\n<strong>\n     Get_Status\n    </strong>\n</td>\n<td>\n    device\n   </td>\n<td>\n    device, interface, endpoint\n   </td>\n<td>\n    0\n   </td>\n<td>\n    device, interface, or endpoint\n   </td>\n<td>\n    2\n   </td>\n<td>\n    status\n   </td>\n</tr>\n<tr>\n<td>\n    01h\n   </td>\n<td>\n<strong>\n     Clear_Feature\n    </strong>\n</td>\n<td>\n    no Data stage\n   </td>\n<td>\n    device, interface, endpoint\n   </td>\n<td>\n    feature\n   </td>\n<td>\n    device, interface, or endpoint\n   </td>\n<td>\n    \u2013\n   </td>\n<td>\n    \u2013\n   </td>\n</tr>\n<tr>\n<td>\n    03h\n   </td>\n<td>\n<strong>\n     Set_Feature\n    </strong>\n</td>\n<td>\n    no Data stage\n   </td>\n<td>\n    device, interface, endpoint\n   </td>\n<td>\n    feature\n   </td>\n<td>\n    device, interface, or endpoint\n   </td>\n<td>\n    \u2013\n   </td>\n<td>\n    \u2013\n   </td>\n</tr>\n<tr>\n<td>\n    05h\n   </td>\n<td>\n<strong>\n     Set_Address\n    </strong>\n</td>\n<td>\n    no Data stage\n   </td>\n<td>\n    device\n   </td>\n<td>\n    device address\n   </td>\n<td>\n    \u2013\n   </td>\n<td>\n    0\n   </td>\n<td>\n    \u2013\n   </td>\n</tr>\n<tr>\n<td>\n    06h\n   </td>\n<td>\n<strong>\n     Get_Descriptor\n    </strong>\n</td>\n<td>\n    device\n   </td>\n<td>\n    device\n   </td>\n<td>\n    descriptor type and index\n   </td>\n<td>\n    device or language ID\n   </td>\n<td>\n    descriptor length\n   </td>\n<td>\n    descriptor\n   </td>\n</tr>\n<tr>\n<td>\n    07h\n   </td>\n<td>\n<strong>\n     Set_Descriptor\n    </strong>\n</td>\n<td>\n    host\n   </td>\n<td>\n    device\n   </td>\n<td>\n    descriptor type and index\n   </td>\n<td>\n    device or language ID\n   </td>\n<td>\n    descriptor length\n   </td>\n<td>\n    descriptor\n   </td>\n</tr>\n<tr>\n<td>\n    08h\n   </td>\n<td>\n<strong>\n     Get_Configuration\n    </strong>\n</td>\n<td>\n    device\n   </td>\n<td>\n    device\n   </td>\n<td>\n    0\n   </td>\n<td>\n    device\n   </td>\n<td>\n    1\n   </td>\n<td>\n    configuration\n   </td>\n</tr>\n<tr>\n<td>\n    09h\n   </td>\n<td>\n<strong>\n     Set_Configuration\n    </strong>\n</td>\n<td>\n    no Data stage\n   </td>\n<td>\n    device\n   </td>\n<td>\n    configuration\n   </td>\n<td>\n    \u2013\n   </td>\n<td>\n    \u2013\n   </td>\n<td>\n    \u2013\n   </td>\n</tr>\n<tr>\n<td>\n    0Ah\n   </td>\n<td>\n<strong>\n     Get_Interface\n    </strong>\n</td>\n<td>\n    device\n   </td>\n<td>\n    interface\n   </td>\n<td>\n    0\n   </td>\n<td>\n    interface\n   </td>\n<td>\n    1\n   </td>\n<td>\n    alternate setting\n   </td>\n</tr>\n<tr>\n<td>\n    0Bh\n   </td>\n<td>\n<strong>\n     Set_Interface\n    </strong>\n</td>\n<td>\n    no Data stage\n   </td>\n<td>\n    interface\n   </td>\n<td>\n    interface\n   </td>\n<td>\n    \u2013\n   </td>\n<td>\n    \u2013\n   </td>\n<td>\n    \u2013\n   </td>\n</tr>\n<tr>\n<td>\n    0Ch\n   </td>\n<td>\n<strong>\n     Synch_Frame\n    </strong>\n</td>\n<td>\n    device\n   </td>\n<td>\n    endpoint\n   </td>\n<td>\n    0\n   </td>\n<td>\n    endpoint\n   </td>\n<td>\n    2\n   </td>\n<td>\n    frame number\n   </td>\n</tr>\n</tbody>\n</table>\n<h4>\n Explanation of the Requests\n</h4>\n<ol>\n<li>\n<strong>\n   Get_Status (00h)\n  </strong>\n  : Retrieves the status of a device, interface, or endpoint. The data returned is 2 bytes: status information.\n </li>\n<li>\n<strong>\n   Clear_Feature (01h)\n  </strong>\n  : Clears a specific feature on a device, interface, or endpoint. No data is transferred.\n </li>\n<li>\n<strong>\n   Set_Feature (03h)\n  </strong>\n  : Sets a specific feature on a device, interface, or endpoint. No data is transferred.\n </li>\n<li>\n<strong>\n   Set_Address (05h)\n  </strong>\n  : Assigns a new address to the device. No data is transferred.\n </li>\n<li>\n<strong>\n   Get_Descriptor (06h)\n  </strong>\n  : Retrieves a descriptor from the device. This includes the descriptor type and index, with the data consisting of the descriptor itself.\n </li>\n<li>\n<strong>\n   Set_Descriptor (07h)\n  </strong>\n  : Sets a descriptor on the device. The data includes the descriptor type, index, and the descriptor itself.\n </li>\n<li>\n<strong>\n   Get_Configuration (08h)\n  </strong>\n  : Retrieves the current configuration of the device. The data is a single byte indicating the configuration.\n </li>\n<li>\n<strong>\n   Set_Configuration (09h)\n  </strong>\n  : Sets the device's configuration. No data is transferred.\n </li>\n<li>\n<strong>\n   Get_Interface (0Ah)\n  </strong>\n  : Retrieves the current alternate setting for a given interface. The data is a single byte indicating the setting.\n </li>\n<li>\n<strong>\n   Set_Interface (0Bh)\n  </strong>\n  : Sets the alternate setting for a given interface. No data is transferred.\n </li>\n<li>\n<strong>\n   Synch_Frame (0Ch)\n  </strong>\n  : Used by devices to synchronize with a specific frame. The data returned consists of a 2-byte frame number.\n </li>\n</ol>\n"}, "Page 151": {"response": "<h3>\n Get_Status Request\n</h3>\n<h4>\n Purpose\n</h4>\n<p>\n The\n <strong>\n  Get_Status\n </strong>\n request allows the host to retrieve the status of various features of a device, interface, or endpoint.\n</p>\n<h4>\n Request Details\n</h4>\n<ul>\n<li>\n<strong>\n   Request Number (bRequest)\n  </strong>\n  : 00h\n </li>\n<li>\n<strong>\n   Source of Data\n  </strong>\n  : Device\n </li>\n<li>\n<strong>\n   Data Length (wLength)\n  </strong>\n  : 2 bytes\n </li>\n</ul>\n<h4>\n Parameters\n</h4>\n<ul>\n<li>\n<strong>\n   wValue field\n  </strong>\n  : Always 0\n </li>\n<li>\n<strong>\n   wIndex field\n  </strong>\n  :\n  <ul>\n<li>\n    For a\n    <strong>\n     device\n    </strong>\n    , the value is 0.\n   </li>\n<li>\n    For an\n    <strong>\n     interface\n    </strong>\n    , it is the interface number.\n   </li>\n<li>\n    For an\n    <strong>\n     endpoint\n    </strong>\n    , it is the endpoint number.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Data in Data Stage\n</h4>\n<p>\n The data packet in the Data stage contains the status of the device, interface, or endpoint, which can be interpreted as follows:\n</p>\n<h4>\n Supported States\n</h4>\n<ul>\n<li>\n<strong>\n   Default\n  </strong>\n  : Status is undefined.\n </li>\n<li>\n<strong>\n   Address\n  </strong>\n  : Status is valid for address 0, endpoint 0. Any other address returns a\n  <strong>\n   STALL\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Configured\n  </strong>\n  : Status is valid when the device is properly configured.\n </li>\n</ul>\n<h4>\n Error Behavior\n</h4>\n<ul>\n<li>\n  If the specified interface or endpoint does not exist, the device returns a\n  <strong>\n   STALL\n  </strong>\n  .\n </li>\n</ul>\n<h4>\n Comments\n</h4>\n<ul>\n<li>\n  For device-specific requests, there are two defined status bits:\n  <ul>\n<li>\n<strong>\n     Bit 0 (Self-Powered)\n    </strong>\n    :\n    <ul>\n<li>\n      0 = bus-powered\n     </li>\n<li>\n      1 = self-powered\n      <br/>\n      (The host cannot modify this value.)\n     </li>\n</ul>\n</li>\n<li>\n<strong>\n     Bit 1 (Remote Wakeup)\n    </strong>\n    :\n    <ul>\n<li>\n      Default value on reset is 0 (disabled).\n     </li>\n</ul>\n</li>\n<li>\n    All other bits are reserved.\n   </li>\n</ul>\n</li>\n<li>\n  For interface-specific requests, all bits are reserved (no defined status bits).\n </li>\n<li>\n  For endpoint-specific requests,\n  <strong>\n   Bit 0\n  </strong>\n  is defined:\n  <ul>\n<li>\n<strong>\n     Bit 0 = 1\n    </strong>\n    indicates a\n    <strong>\n     Halt condition\n    </strong>\n    at the endpoint.\n   </li>\n<li>\n    Further details on\n    <strong>\n     Remote Wakeup\n    </strong>\n    and\n    <strong>\n     Halt\n    </strong>\n    are covered in the\n    <strong>\n     Set_Feature\n    </strong>\n    and\n    <strong>\n     Clear_Feature\n    </strong>\n    requests.\n   </li>\n</ul>\n</li>\n</ul>\n"}, "Page 152": {"response": "<h3>\n Clear_Feature Request\n</h3>\n<h4>\n Purpose\n</h4>\n<p>\n The\n <strong>\n  Clear_Feature\n </strong>\n request allows the host to disable a specific feature on a device, interface, or endpoint.\n</p>\n<h4>\n Request Details\n</h4>\n<ul>\n<li>\n<strong>\n   Request Number (bRequest)\n  </strong>\n  : 01h\n </li>\n<li>\n<strong>\n   Source of Data\n  </strong>\n  : No data stage\n </li>\n<li>\n<strong>\n   Data Length (wLength)\n  </strong>\n  : None\n </li>\n</ul>\n<h4>\n Parameters\n</h4>\n<ul>\n<li>\n<strong>\n   wValue field\n  </strong>\n  : Specifies the feature to be disabled.\n </li>\n<li>\n<strong>\n   wIndex field\n  </strong>\n  :\n  <ul>\n<li>\n    For a\n    <strong>\n     device feature\n    </strong>\n    , the value is 0.\n   </li>\n<li>\n    For an\n    <strong>\n     interface feature\n    </strong>\n    , the value is the interface number.\n   </li>\n<li>\n    For an\n    <strong>\n     endpoint feature\n    </strong>\n    , the value is the endpoint number.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Data in Data Stage\n</h4>\n<p>\n There is no data transferred in the Data stage for this request.\n</p>\n<h4>\n Supported States\n</h4>\n<ul>\n<li>\n<strong>\n   Default\n  </strong>\n  : Status is undefined.\n </li>\n<li>\n<strong>\n   Address\n  </strong>\n  : Status is valid for address 0, endpoint 0. Any other address returns a\n  <strong>\n   STALL\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Configured\n  </strong>\n  : Status is valid when the device is configured.\n </li>\n</ul>\n<h4>\n Error Behavior\n</h4>\n<ul>\n<li>\n  If the specified feature, device, or endpoint does not exist, or if the feature cannot be disabled, the device returns a\n  <strong>\n   STALL\n  </strong>\n  .\n </li>\n<li>\n  If\n  <strong>\n   wLength\n  </strong>\n  is greater than 0, the behavior is undefined.\n </li>\n</ul>\n<h4>\n Comments\n</h4>\n<ul>\n<li>\n  The\n  <strong>\n   Clear_Feature\n  </strong>\n  request can disable certain features, including:\n  <ul>\n<li>\n<strong>\n     DEVICE_REMOTE_WAKEUP\n    </strong>\n</li>\n<li>\n<strong>\n     ENDPOINT_HALT\n    </strong>\n    (which resets the endpoint\u2019s data toggle to\n    <strong>\n     DATA0\n    </strong>\n    )\n   </li>\n<li>\n    It cannot disable the\n    <strong>\n     TEST_MODE\n    </strong>\n    feature.\n   </li>\n</ul>\n</li>\n<li>\n  For more details, refer to the\n  <strong>\n   Set_Feature\n  </strong>\n  and\n  <strong>\n   Get_Status\n  </strong>\n  requests.\n </li>\n</ul>\n"}, "Page 153": {"response": "<h3>\n Set_Feature Request\n</h3>\n<h4>\n Purpose\n</h4>\n<p>\n The\n <strong>\n  Set_Feature\n </strong>\n request allows the host to enable a specific feature on a device, interface, or endpoint.\n</p>\n<h4>\n Request Details\n</h4>\n<ul>\n<li>\n<strong>\n   Request Number (bRequest)\n  </strong>\n  : 03h\n </li>\n<li>\n<strong>\n   Source of Data\n  </strong>\n  : No data stage\n </li>\n<li>\n<strong>\n   Data Length (wLength)\n  </strong>\n  : None\n </li>\n</ul>\n<h4>\n Parameters\n</h4>\n<ul>\n<li>\n<strong>\n   wValue field\n  </strong>\n  : Specifies the feature to enable.\n </li>\n<li>\n<strong>\n   wIndex field\n  </strong>\n  :\n  <ul>\n<li>\n    For a\n    <strong>\n     device\n    </strong>\n    , the value is 0.\n   </li>\n<li>\n    For an\n    <strong>\n     interface\n    </strong>\n    , the value is the interface number.\n   </li>\n<li>\n    For an\n    <strong>\n     endpoint\n    </strong>\n    , the value is the endpoint number.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Data in Data Stage\n</h4>\n<p>\n No data is transferred during the Data stage for this request.\n</p>\n<h4>\n Supported States\n</h4>\n<ul>\n<li>\n<strong>\n   For all features except TEST_MODE\n  </strong>\n  :\n  <ul>\n<li>\n<strong>\n     Default\n    </strong>\n    : Status is undefined.\n   </li>\n<li>\n<strong>\n     Address\n    </strong>\n    : Valid for address 0, endpoint 0. Otherwise, the device returns a\n    <strong>\n     STALL\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     Configured\n    </strong>\n    : Status is valid when the device is configured.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   For the TEST_MODE feature\n  </strong>\n  : The feature must be supported when using high speed in the\n  <strong>\n   Default\n  </strong>\n  ,\n  <strong>\n   Address\n  </strong>\n  , and\n  <strong>\n   Configured\n  </strong>\n  states.\n </li>\n</ul>\n<h4>\n Error Behavior\n</h4>\n<ul>\n<li>\n  If the specified endpoint or interface does not exist, the device will return a\n  <strong>\n   STALL\n  </strong>\n  .\n </li>\n</ul>\n<h4>\n Comments\n</h4>\n<p>\n The USB 2.0 specification defines three key features that can be enabled using\n <strong>\n  Set_Feature\n </strong>\n :\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    ENDPOINT_HALT (value 0)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Applies to endpoints.\n   </li>\n<li>\n    Bulk and interrupt endpoints must support the Halt condition, which can be triggered by:\n    <ul>\n<li>\n      Communication problems (e.g., missing handshake packet or receiving unexpected data).\n     </li>\n<li>\n      The host sending a\n      <strong>\n       Set_Feature\n      </strong>\n      request to halt the endpoint.\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    DEVICE_REMOTE_WAKEUP (value 1)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Applies to devices.\n   </li>\n<li>\n    When enabled, a device in the\n    <strong>\n     Suspend\n    </strong>\n    state can request the host to resume communications.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    TEST_MODE (value 2)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Applies to devices.\n   </li>\n<li>\n    Enabling this feature puts the upstream-facing port into test mode. For more information on\n    <strong>\n     TEST_MODE\n    </strong>\n    , refer to Chapter 18 of the USB specification.\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n The\n <strong>\n  Get_Status\n </strong>\n request can be used to check which features are currently enabled. Also, refer to the\n <strong>\n  Clear_Feature\n </strong>\n request for more details on disabling features.\n</p>\n"}, "Page 154": {"response": "<h3>\n Set_Address Request\n</h3>\n<h4>\n Purpose\n</h4>\n<p>\n The\n <strong>\n  Set_Address\n </strong>\n request allows the host to assign a unique address to a device for future communications.\n</p>\n<h4>\n Request Details\n</h4>\n<ul>\n<li>\n<strong>\n   Request Number (bRequest)\n  </strong>\n  : 05h\n </li>\n<li>\n<strong>\n   Source of Data\n  </strong>\n  : No data stage\n </li>\n<li>\n<strong>\n   Data Length (wLength)\n  </strong>\n  : None\n </li>\n</ul>\n<h4>\n Parameters\n</h4>\n<ul>\n<li>\n<strong>\n   wValue field\n  </strong>\n  : Contains the new device address, which must be a value between 1 and 127. Each device on the bus, including the root hub, must have a unique address.\n </li>\n<li>\n<strong>\n   wIndex field\n  </strong>\n  : Always set to 0.\n </li>\n<li>\n<strong>\n   Data in Data Stage\n  </strong>\n  : No data is transferred in this request.\n </li>\n</ul>\n<h4>\n Supported States\n</h4>\n<ul>\n<li>\n<strong>\n   Default\n  </strong>\n  : The device is in the Default state with address 0.\n </li>\n<li>\n<strong>\n   Address\n  </strong>\n  : The device is in the Address state after the request is completed and a new address is assigned.\n </li>\n</ul>\n<h4>\n Error Behavior\n</h4>\n<p>\n The error behavior for this request is not explicitly defined.\n</p>\n<h4>\n Comments\n</h4>\n<ul>\n<li>\n  After a hub enables a port following power-up or device attachment, the device will initially use the default address (0) until the host sends a\n  <strong>\n   Set_Address\n  </strong>\n  request.\n </li>\n<li>\n  Unlike most requests, the device does not execute the\n  <strong>\n   Set_Address\n  </strong>\n  request immediately. The device only performs the address change after completing the Status stage of the request, which involves sending a zero-length data packet. The host sends the token packet for the Status stage to the default address (0), and the device must respond to this packet before it can change its address.\n </li>\n<li>\n  Once the\n  <strong>\n   Set_Address\n  </strong>\n  request is completed, all future communications with the device will use the newly assigned address.\n </li>\n<li>\n  After completing the request:\n  <ul>\n<li>\n    The device transitions from the Default state (address 0) to the Address state (using the new address).\n   </li>\n<li>\n    The device must send the handshake packet within 50 milliseconds after receiving the request.\n   </li>\n<li>\n    The device must complete the address change and implement the request within 2 milliseconds after finishing the Status stage.\n   </li>\n</ul>\n</li>\n</ul>\n"}, "Page 155": {"response": "<h3>\n Get_Descriptor Request\n</h3>\n<h4>\n Purpose\n</h4>\n<p>\n The\n <strong>\n  Get_Descriptor\n </strong>\n request allows the host to request a specific descriptor from a device.\n</p>\n<h4>\n Request Details\n</h4>\n<ul>\n<li>\n<strong>\n   Request Number (bRequest)\n  </strong>\n  : 06h\n </li>\n<li>\n<strong>\n   Source of Data\n  </strong>\n  : Device\n </li>\n<li>\n<strong>\n   Data Length (wLength)\n  </strong>\n  : Specifies the number of bytes the host expects to receive.\n  <ul>\n<li>\n    If the descriptor is longer than the specified\n    <strong>\n     wLength\n    </strong>\n    , the device will return up to\n    <strong>\n     wLength\n    </strong>\n    bytes.\n   </li>\n<li>\n    If the descriptor is shorter than\n    <strong>\n     wLength\n    </strong>\n    , the device returns the full descriptor.\n   </li>\n<li>\n    If the descriptor is shorter than\n    <strong>\n     wLength\n    </strong>\n    and is an even multiple of the endpoint\u2019s maximum packet size, the device follows the descriptor with a zero-length data packet.\n   </li>\n<li>\n    The host detects the end of the data transfer when it receives either the expected number of bytes or a data packet that is smaller than the maximum packet size (including zero bytes).\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Parameters\n</h4>\n<ul>\n<li>\n<strong>\n   wValue field\n  </strong>\n  :\n  <ul>\n<li>\n    The\n    <strong>\n     high byte\n    </strong>\n    specifies the descriptor type.\n   </li>\n<li>\n    The\n    <strong>\n     low byte\n    </strong>\n    specifies the descriptor index, used when multiple descriptors of the same type exist.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   wIndex field\n  </strong>\n  :\n  <ul>\n<li>\n    For\n    <strong>\n     String descriptors\n    </strong>\n    , it contains the\n    <strong>\n     Language ID\n    </strong>\n    .\n   </li>\n<li>\n    Otherwise, it is set to zero.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Data in Data Stage\n  </strong>\n  : The requested descriptor is returned.\n </li>\n</ul>\n<h4>\n Supported States\n</h4>\n<ul>\n<li>\n<strong>\n   Default\n  </strong>\n</li>\n<li>\n<strong>\n   Address\n  </strong>\n</li>\n<li>\n<strong>\n   Configured\n  </strong>\n</li>\n</ul>\n<h4>\n Error Behavior\n</h4>\n<p>\n If the device does not support the requested descriptor, it should return a\n <strong>\n  STALL\n </strong>\n .\n</p>\n<h4>\n Comments\n</h4>\n<p>\n The\n <strong>\n  Get_Descriptor\n </strong>\n request can be used to retrieve various descriptor types, including:\n</p>\n<ul>\n<li>\n<strong>\n   Device descriptor\n  </strong>\n</li>\n<li>\n<strong>\n   Device Qualifier descriptor\n  </strong>\n</li>\n<li>\n<strong>\n   Configuration descriptor\n  </strong>\n</li>\n<li>\n<strong>\n   Other-speed Configuration descriptor\n  </strong>\n</li>\n<li>\n<strong>\n   String descriptor\n  </strong>\n</li>\n</ul>\n<p>\n When a host requests a\n <strong>\n  configuration\n </strong>\n or\n <strong>\n  other-speed configuration\n </strong>\n descriptor, the device should return the requested descriptor, followed by any subordinate descriptors that belong to the configuration, up to the number of bytes requested by the host.\n</p>\n<p>\n In addition to the standard descriptors, class or vendor-specific descriptors (e.g., an HID-class report descriptor) can also be requested. For more information on setting descriptors, refer to the\n <strong>\n  Set_Descriptor\n </strong>\n request.\n</p>\n"}, "Page 156": {"response": "<h3>\n Set_Descriptor Request\n</h3>\n<h4>\n Purpose\n</h4>\n<p>\n The\n <strong>\n  Set_Descriptor\n </strong>\n request allows the host to add a new descriptor or update an existing descriptor on a device.\n</p>\n<h4>\n Request Details\n</h4>\n<ul>\n<li>\n<strong>\n   Request Number (bRequest)\n  </strong>\n  : 07h\n </li>\n<li>\n<strong>\n   Source of Data\n  </strong>\n  : Host\n </li>\n<li>\n<strong>\n   Data Length (wLength)\n  </strong>\n  : The number of bytes the host is transferring to the device.\n </li>\n<li>\n<strong>\n   wValue field\n  </strong>\n  :\n  <ul>\n<li>\n    The\n    <strong>\n     high byte\n    </strong>\n    specifies the descriptor type (refer to\n    <strong>\n     Get_Descriptor\n    </strong>\n    for descriptor types).\n   </li>\n<li>\n    The\n    <strong>\n     low byte\n    </strong>\n    specifies the descriptor index, which is used when there are multiple descriptors of the same type.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   wIndex field\n  </strong>\n  :\n  <ul>\n<li>\n    For\n    <strong>\n     String descriptors\n    </strong>\n    , the field contains the\n    <strong>\n     Language ID\n    </strong>\n    .\n   </li>\n<li>\n    Otherwise, it is set to zero.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Data in Data Stage\n  </strong>\n  : The descriptor data, which includes the descriptor length.\n </li>\n</ul>\n<h4>\n Supported States\n</h4>\n<ul>\n<li>\n<strong>\n   Address\n  </strong>\n</li>\n<li>\n<strong>\n   Configured\n  </strong>\n</li>\n</ul>\n<h4>\n Error Behavior\n</h4>\n<p>\n If the device does not support the request, it responds with a\n <strong>\n  STALL\n </strong>\n .\n</p>\n<h4>\n Comments\n</h4>\n<p>\n This request allows the host to add new descriptors or modify existing ones. However, many devices do not support this request due to the potential risks of incorrect descriptor information being written, especially by errant or malicious software. For more details on descriptor retrieval, see the\n <strong>\n  Get_Descriptor\n </strong>\n request.\n</p>\n"}, "Page 157": {"response": "<h3>\n Get_Configuration Request\n</h3>\n<h4>\n Purpose\n</h4>\n<p>\n The\n <strong>\n  Get_Configuration\n </strong>\n request is used by the host to retrieve the current configuration value of the device.\n</p>\n<h4>\n Request Details\n</h4>\n<ul>\n<li>\n<strong>\n   Request Number (bRequest)\n  </strong>\n  : 08h\n </li>\n<li>\n<strong>\n   Source of Data\n  </strong>\n  : Device\n </li>\n<li>\n<strong>\n   Data Length (wLength)\n  </strong>\n  : 1 byte\n </li>\n<li>\n<strong>\n   wValue field\n  </strong>\n  : Set to 0\n </li>\n<li>\n<strong>\n   wIndex field\n  </strong>\n  : Set to 0\n </li>\n<li>\n<strong>\n   Data in Data Stage\n  </strong>\n  : The device returns the current configuration value.\n </li>\n</ul>\n<h4>\n Supported States\n</h4>\n<ul>\n<li>\n<strong>\n   Address state\n  </strong>\n  : Returns 0 if the device is not configured.\n </li>\n<li>\n<strong>\n   Configured state\n  </strong>\n  : Returns the current configuration value.\n </li>\n</ul>\n<h4>\n Error Behavior\n</h4>\n<p>\n No specific behavior is defined for errors.\n</p>\n<h4>\n Comments\n</h4>\n<p>\n If the device is not configured, it will return 0. If configured, the device will return the active configuration value. This request is often used in conjunction with the\n <strong>\n  Set_Configuration\n </strong>\n request.\n</p>\n"}, "Page 158": {"response": "<h3>\n Set_Configuration Request\n</h3>\n<h4>\n Purpose\n</h4>\n<p>\n The\n <strong>\n  Set_Configuration\n </strong>\n request allows the host to set a specific configuration for the device.\n</p>\n<h4>\n Request Details\n</h4>\n<ul>\n<li>\n<strong>\n   Request Number (bRequest)\n  </strong>\n  : 09h\n </li>\n<li>\n<strong>\n   Source of Data\n  </strong>\n  : No Data stage\n </li>\n<li>\n<strong>\n   Data Length (wLength)\n  </strong>\n  : None\n </li>\n<li>\n<strong>\n   wValue field\n  </strong>\n  :\n  <ul>\n<li>\n    The lower byte specifies the configuration to be set.\n   </li>\n<li>\n    If the value matches a supported configuration, the device applies the requested configuration.\n   </li>\n<li>\n    A value of\n    <strong>\n     0\n    </strong>\n    means the device is not configured and will return to the Address state, requiring a new Set_Configuration request to be configured.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   wIndex field\n  </strong>\n  : 0\n </li>\n<li>\n<strong>\n   Data in Data Stage\n  </strong>\n  : None\n </li>\n</ul>\n<h4>\n Supported States\n</h4>\n<ul>\n<li>\n<strong>\n   Address state\n  </strong>\n  : Allows configuration to be set to 0 or a valid configuration value.\n </li>\n<li>\n<strong>\n   Configured state\n  </strong>\n  : Device can be set to a specific configuration.\n </li>\n</ul>\n<h4>\n Error Behavior\n</h4>\n<p>\n If the\n <strong>\n  wValue\n </strong>\n field is not\n <strong>\n  0\n </strong>\n or is not a supported configuration, the device responds with a\n <strong>\n  STALL\n </strong>\n .\n</p>\n<h4>\n Comments\n</h4>\n<ul>\n<li>\n  After a valid\n  <strong>\n   Set_Configuration\n  </strong>\n  request, the device enters the Configured state, which is required for many standard requests.\n </li>\n<li>\n  This request also resets the endpoint's data toggle to\n  <strong>\n   DATA0\n  </strong>\n  .\n </li>\n<li>\n  For more details, see the\n  <strong>\n   Get_Configuration\n  </strong>\n  request.\n </li>\n</ul>\n"}, "Page 159": {"response": "<h3>\n Get_Interface Request\n</h3>\n<h4>\n Purpose\n</h4>\n<p>\n The\n <strong>\n  Get_Interface\n </strong>\n request allows the host to retrieve the currently active setting for a device interface that supports multiple mutually exclusive settings.\n</p>\n<h4>\n Request Details\n</h4>\n<ul>\n<li>\n<strong>\n   Request Number (bRequest)\n  </strong>\n  : 0Ah\n </li>\n<li>\n<strong>\n   Source of Data\n  </strong>\n  : Device\n </li>\n<li>\n<strong>\n   Data Length (wLength)\n  </strong>\n  : 1 byte\n </li>\n<li>\n<strong>\n   wValue field\n  </strong>\n  : 0\n </li>\n<li>\n<strong>\n   wIndex field\n  </strong>\n  : Interface number (specifies which interface's setting is being queried)\n </li>\n<li>\n<strong>\n   Data in Data Stage\n  </strong>\n  : The current setting of the interface, corresponding to the\n  <strong>\n   bAlternateInterface\n  </strong>\n  field in the interface descriptor.\n </li>\n</ul>\n<h4>\n Supported States\n</h4>\n<ul>\n<li>\n<strong>\n   Configured\n  </strong>\n  : The request is only valid when the device is in the Configured state.\n </li>\n</ul>\n<h4>\n Error Behavior\n</h4>\n<p>\n If the specified interface does not exist, the device will return a\n <strong>\n  STALL\n </strong>\n .\n</p>\n<h4>\n Comments\n</h4>\n<ul>\n<li>\n  The\n  <strong>\n   wIndex\n  </strong>\n  field refers to the\n  <strong>\n   bInterface\n  </strong>\n  field in the interface descriptor, which identifies a specific interface on the device.\n </li>\n<li>\n  The\n  <strong>\n   Data field\n  </strong>\n  in this request indicates the current setting of the interface, corresponding to the\n  <strong>\n   bAlternateInterface\n  </strong>\n  field in the interface descriptor.\n </li>\n<li>\n  Each interface can have multiple mutually exclusive settings, each with its own descriptor and possibly associated endpoint descriptors. While many devices support only one setting per interface, some support alternate settings.\n </li>\n<li>\n  For more details, see the\n  <strong>\n   Set_Interface\n  </strong>\n  request.\n </li>\n</ul>\n"}, "Page 160": {"response": "<h3>\n Set_Interface Request\n</h3>\n<h4>\n Purpose\n</h4>\n<p>\n The\n <strong>\n  Set_Interface\n </strong>\n request allows the host to select a specific alternate setting for an interface that supports multiple mutually exclusive settings.\n</p>\n<h4>\n Request Details\n</h4>\n<ul>\n<li>\n<strong>\n   Request Number (bRequest)\n  </strong>\n  : 0Bh\n </li>\n<li>\n<strong>\n   Source of Data\n  </strong>\n  : No Data Stage\n </li>\n<li>\n<strong>\n   Data Length (wLength)\n  </strong>\n  : None\n </li>\n<li>\n<strong>\n   wValue field\n  </strong>\n  : The alternate setting to be selected.\n </li>\n<li>\n<strong>\n   wIndex field\n  </strong>\n  : The interface number, identifying the interface whose setting is being modified.\n </li>\n<li>\n<strong>\n   Data in Data Stage\n  </strong>\n  : None\n </li>\n</ul>\n<h4>\n Supported States\n</h4>\n<ul>\n<li>\n<strong>\n   Configured\n  </strong>\n  : This request is valid only when the device is in the Configured state.\n </li>\n</ul>\n<h4>\n Error Behavior\n</h4>\n<ul>\n<li>\n  If the device supports only the default interface, it may return a\n  <strong>\n   STALL\n  </strong>\n  .\n </li>\n<li>\n  If the requested interface or setting does not exist, the device will return a\n  <strong>\n   STALL\n  </strong>\n  .\n </li>\n</ul>\n<h4>\n Comments\n</h4>\n<ul>\n<li>\n  The\n  <strong>\n   Set_Interface\n  </strong>\n  request is used to switch between alternate settings for interfaces that support them.\n </li>\n<li>\n  This request also resets the endpoint\u2019s data toggle to\n  <strong>\n   DATA0\n  </strong>\n  .\n </li>\n<li>\n  For more information about querying the current interface setting, see the\n  <strong>\n   Get_Interface\n  </strong>\n  request.\n </li>\n</ul>\n"}, "Page 161": {"response": "<h3>\n Synch_Frame Request\n</h3>\n<h4>\n Purpose\n</h4>\n<p>\n The\n <strong>\n  Synch_Frame\n </strong>\n request allows the device to set and report the synchronization frame for an endpoint, mainly used in isochronous transfers.\n</p>\n<h4>\n Request Details\n</h4>\n<ul>\n<li>\n<strong>\n   Request Number (bRequest)\n  </strong>\n  : 0Ch\n </li>\n<li>\n<strong>\n   Source of Data\n  </strong>\n  : Host\n </li>\n<li>\n<strong>\n   Data Length (wLength)\n  </strong>\n  : 2\n </li>\n<li>\n<strong>\n   wValue field\n  </strong>\n  : 0\n </li>\n<li>\n<strong>\n   wIndex field\n  </strong>\n  : The endpoint number for which the synchronization frame is being requested.\n </li>\n<li>\n<strong>\n   Data in Data Stage\n  </strong>\n  : The frame number that precedes the start of the next sequence.\n </li>\n</ul>\n<h4>\n Supported States\n</h4>\n<ul>\n<li>\n<strong>\n   Default\n  </strong>\n  : Undefined behavior.\n </li>\n<li>\n<strong>\n   Address\n  </strong>\n  : The device returns a\n  <strong>\n   STALL\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Configured\n  </strong>\n  : Valid and accepted request.\n </li>\n</ul>\n<h4>\n Error Behavior\n</h4>\n<ul>\n<li>\n  If the endpoint does not support the\n  <strong>\n   Synch_Frame\n  </strong>\n  request, it should return a\n  <strong>\n   STALL\n  </strong>\n  .\n </li>\n</ul>\n<h4>\n Comments\n</h4>\n<ul>\n<li>\n  This request is mainly used for\n  <strong>\n   isochronous transfers\n  </strong>\n  , where an endpoint sends data packets in a sequence with varying sizes (e.g., repeating sequences of 8, 8, 8, 64 bytes).\n </li>\n<li>\n  The\n  <strong>\n   Synch_Frame\n  </strong>\n  request helps synchronize the host and endpoint by agreeing on which frame begins the sequence.\n </li>\n<li>\n  The request is infrequently used because there is generally little need for the synchronization information it provides.\n </li>\n</ul>\n"}, "Page 162": {"response": "<h3>\n Other Control Requests\n</h3>\n<p>\n In addition to the standard control requests defined by the USB 2.0 specification, USB devices may also support\n <strong>\n  class-specific\n </strong>\n and\n <strong>\n  vendor-specific\n </strong>\n control requests.\n</p>\n<h4>\n Class-Specific Requests\n</h4>\n<ul>\n<li>\n<strong>\n   Class-Specific Requests\n  </strong>\n  are defined for devices within a particular USB class. These requests can be either required or optional for devices in that class.\n </li>\n<li>\n  Some class-specific requests are entirely separate from the standard USB requests, while others extend standard requests by adding class-specific fields.\n </li>\n</ul>\n<p>\n<strong>\n  Examples of Class-Specific Requests:\n </strong>\n</p>\n<ul>\n<li>\n<strong>\n   Unrelated Requests\n  </strong>\n  : The\n  <strong>\n   Get_Max_LUN\n  </strong>\n  request, used by some mass-storage devices, allows the host to determine the number of logical units supported by the device.\n </li>\n<li>\n<strong>\n   Extended Standard Requests\n  </strong>\n  : The\n  <strong>\n   Get_Port_Status\n  </strong>\n  request, supported by hubs, is similar to the standard\n  <strong>\n   Get_Status\n  </strong>\n  request but with different values in specific fields. For instance, the\n  <strong>\n   bmRequestType\n  </strong>\n  field is set to\n  <code>\n   01\n  </code>\n  for class-specific requests, and the\n  <strong>\n   wIndex\n  </strong>\n  field holds the port number of the hub.\n </li>\n</ul>\n<h4>\n Vendor-Specific Requests\n</h4>\n<ul>\n<li>\n<strong>\n   Vendor-Specific Requests\n  </strong>\n  are custom control requests defined by a specific vendor for their devices. These requests are not part of the standard USB specification and are unique to the vendor\u2019s hardware.\n </li>\n</ul>\n<p>\n<strong>\n  Requirements for Vendor-Specific Requests:\n </strong>\n</p>\n<ul>\n<li>\n<strong>\n   Setup Stage\n  </strong>\n  : The\n  <strong>\n   Setup\n  </strong>\n  stage of the request will include vendor-defined fields, and the\n  <strong>\n   bmRequestType\n  </strong>\n  bits 6 and 5 are set to\n  <code>\n   10\n  </code>\n  , signaling that the request is vendor-specific.\n </li>\n<li>\n<strong>\n   Device Support\n  </strong>\n  : The device must include code to detect the vendor-specific request number in the\n  <strong>\n   Setup\n  </strong>\n  packet and respond accordingly.\n </li>\n<li>\n<strong>\n   Host Support\n  </strong>\n  : The host must have a\n  <strong>\n   vendor-specific device driver\n  </strong>\n  to initiate the request. Applications themselves cannot initiate these requests directly. Instead, they must call a function from the driver that knows how to handle the vendor-specific request.\n </li>\n</ul>\n<p>\n These additional request types allow for more flexibility and functionality in USB devices, especially when standardized control requests are not sufficient for a particular device\u2019s needs.\n</p>\n"}, "Page 163": {"response": "<h3>\n Chip Choices\n</h3>\n<p>\n Selecting the right USB controller for your project can be both exciting and daunting due to the vast number of options available. However, understanding the key factors that influence your decision can make the process easier.\n</p>\n<h4>\n Key Considerations for Selecting a USB Controller\n</h4>\n<p>\n When choosing a USB controller, several important factors need to be taken into account:\n</p>\n<ol>\n<li>\n<strong>\n   Functionality\n  </strong>\n  : What tasks and features must the controller perform for your specific project?\n </li>\n<li>\n<strong>\n   Cost\n  </strong>\n  : The budget available will heavily influence your choice of chip.\n </li>\n<li>\n<strong>\n   Availability\n  </strong>\n  : Is the chip readily available for purchase in the quantities you need?\n </li>\n<li>\n<strong>\n   Ease of Development\n  </strong>\n  : How easy is it to develop with the chip? This includes:\n  <ul>\n<li>\n    The quality and availability of\n    <strong>\n     development tools\n    </strong>\n    (such as IDEs and debugging tools).\n   </li>\n<li>\n    The availability of\n    <strong>\n     device-driver software\n    </strong>\n    for the host.\n   </li>\n<li>\n    Availability of\n    <strong>\n     sample code\n    </strong>\n    and application notes.\n   </li>\n<li>\n    Your\n    <strong>\n     experience\n    </strong>\n    with specific\n    <strong>\n     device architectures\n    </strong>\n    and\n    <strong>\n     compilers\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Types of Chips Available\n</h4>\n<p>\n There are a wide variety of USB chips to choose from, ranging from simple, low-cost chips to more advanced, high-end chips. The simple chips typically have basic USB support and simpler architectures, while the high-end ones offer more features and advanced capabilities.\n</p>\n<p>\n This chapter provides a guide to selecting a USB controller, giving an overview of the factors to consider and descriptions of different chips that span various performance levels and features. For those looking into USB On-The-Go (OTG) devices, additional information on controllers for these devices is provided in Chapter 20.\n</p>\n<p>\n By considering these factors carefully, you can make a well-informed decision that best suits your project\u2019s needs.\n</p>\n"}, "Page 164": {"response": "<h3>\n Components of a USB Device\n</h3>\n<p>\n A USB device must have the necessary components to implement the USB protocol effectively. This includes the ability to detect and respond to requests, manage communication on the bus, and handle both sending and receiving data. These functions are typically carried out by a\n <strong>\n  microcontroller\n </strong>\n or an\n <strong>\n  application-specific integrated circuit (ASIC)\n </strong>\n .\n</p>\n<h4>\n Types of USB Controllers\n</h4>\n<p>\n USB controllers vary in terms of the firmware support they require for USB communications:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Simple Controllers\n   </strong>\n   : Some USB controllers only require minimal intervention from device firmware. These controllers provide basic access to registers to send and receive USB data, handling the protocol with very little additional overhead.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Advanced Controllers\n   </strong>\n   : Other controllers are more complex and require the device firmware to manage additional aspects of the USB protocol, such as:\n  </p>\n<ul>\n<li>\n    Sending descriptors to the host\n   </li>\n<li>\n    Managing data-toggle values\n   </li>\n<li>\n    Ensuring the appropriate handshake packets are transmitted\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n These controllers might need more processing power from the device firmware to function correctly.\n</p>\n<h4>\n CPU Integration\n</h4>\n<p>\n USB controllers come with varying levels of processing power:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Controllers with Built-In CPUs\n   </strong>\n   : Some USB controllers integrate a general-purpose CPU on the chip itself. This can simplify the design by eliminating the need for external components.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Controllers Requiring External CPUs\n   </strong>\n   : Other controllers are designed to interface with an external CPU, which handles tasks that are not related to USB communication. These are known as\n   <strong>\n    USB interface chips\n   </strong>\n   , as they are designed to facilitate USB communication while relying on an external CPU for other functions.\n  </p>\n</li>\n</ol>\n<p>\n All USB controllers include a USB port, along with various buffers, registers, and I/O capabilities to perform their functions. If the controller has a CPU on chip, it will either have its own program and data memory or the ability to interface with external memory.\n</p>\n<h4>\n Custom ASICs for High-Volume Applications\n</h4>\n<p>\n For applications that require high-speed performance and are produced in large quantities, designing a\n <strong>\n  custom ASIC\n </strong>\n can be an option. Several companies provide synthesizable\n <strong>\n  VHDL\n </strong>\n and\n <strong>\n  Verilog\n </strong>\n source code, which can be used to create custom USB controllers for these specific needs.\n</p>\n<h4>\n Controller Features and Limitations\n</h4>\n<p>\n Not all USB controllers support all four transfer types, and some may support only a subset of\n <strong>\n  bus speeds\n </strong>\n . Many controllers also support fewer than the maximum number of\n <strong>\n  endpoint addresses\n </strong>\n \u2014usually one control endpoint and up to 30 additional endpoint addresses\u2014since most devices do not need to utilize the full range of endpoints available.\n</p>\n<p>\n Choosing the right controller involves understanding these features and determining which ones are necessary for your application.\n</p>\n"}, "Page 165": {"response": "<h3>\n The USB Controller\n</h3>\n<p>\n A typical USB controller is designed with several key components to handle the USB communication protocol effectively. These include the\n <strong>\n  USB transceiver\n </strong>\n , the\n <strong>\n  serial interface engine (SIE)\n </strong>\n ,\n <strong>\n  buffers\n </strong>\n , and\n <strong>\n  registers\n </strong>\n that store configuration, status, and control information related to USB operations.\n</p>\n<h4>\n The Transceiver\n</h4>\n<p>\n The\n <strong>\n  USB transceiver\n </strong>\n is the hardware interface between the USB connector on the device and the circuits that manage USB communications. It acts as the physical link between the device and the USB bus.\n</p>\n<ul>\n<li>\n  Typically, the transceiver is integrated\n  <strong>\n   on-chip\n  </strong>\n  within the controller. However, some controllers may allow for the connection of an\n  <strong>\n   external transceiver\n  </strong>\n  if needed for specialized purposes.\n </li>\n</ul>\n<h4>\n The Serial Interface Engine (SIE)\n</h4>\n<p>\n The\n <strong>\n  serial interface engine (SIE)\n </strong>\n handles the data transactions over the USB bus. It interfaces directly with the transceiver to manage sending and receiving packets. While the SIE doesn't interpret the data, it is responsible for transmitting the data that is made available and storing received data. The typical functions of the SIE include:\n</p>\n<ul>\n<li>\n<strong>\n   Detecting incoming packets\n  </strong>\n  : The SIE recognizes when packets are arriving from the USB bus.\n </li>\n<li>\n<strong>\n   Sending packets\n  </strong>\n  : It is responsible for transmitting data packets over the bus.\n </li>\n<li>\n<strong>\n   Generating and detecting signaling\n  </strong>\n  : The SIE handles essential signaling tasks such as:\n  <ul>\n<li>\n    Start-of-Packet (SOP)\n   </li>\n<li>\n    End-of-Packet (EOP)\n   </li>\n<li>\n    Reset and Resume signals\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Encoding and decoding data\n  </strong>\n  : The SIE encodes and decodes data using\n  <strong>\n   NRZI (Non-Return to Zero Inverted)\n  </strong>\n  with bit stuffing, which is the USB data transmission format.\n </li>\n<li>\n<strong>\n   CRC (Cyclic Redundancy Check)\n  </strong>\n  : It checks and generates CRC values for error detection.\n </li>\n<li>\n<strong>\n   Packet IDs (PID)\n  </strong>\n  : The SIE checks and generates Packet Identifiers (PIDs), which help manage different types of packets.\n </li>\n<li>\n<strong>\n   Data conversion\n  </strong>\n  : It converts USB serial data into parallel data, allowing it to be stored in registers or memory.\n </li>\n</ul>\n<p>\n Implementing these functions typically requires about\n <strong>\n  2500 gates\n </strong>\n in the design of the controller, showcasing the complexity involved in managing USB communication.\n</p>\n<h4>\n Buffers\n</h4>\n<p>\n<strong>\n  Buffers\n </strong>\n are used by USB controllers to temporarily store data that has either been recently received or is ready to be transmitted. These buffers are crucial for efficient data handling and to ensure smooth communication without delays.\n</p>\n<p>\n For example,\n <strong>\n  PLX Technology\n </strong>\n offers chips that incorporate such buffers, highlighting the importance of effective data management in USB controllers to prevent data loss or overflow during communication.\n</p>\n<p>\n Together, these components form the foundation of a USB controller, enabling it to interact with the USB bus, handle communication protocols, and manage data efficiently.\n</p>\n"}, "Page 166": {"response": "<h3>\n Buffers and Data Management in USB Controllers\n</h3>\n<p>\n USB controllers often use\n <strong>\n  buffers\n </strong>\n to temporarily store data during transmission and reception. These buffers help manage data flow and ensure efficient communication. The way buffers are managed can vary depending on the chip, but most follow similar principles for storing and accessing data.\n</p>\n<h4>\n FIFO Buffers\n</h4>\n<p>\n Many USB controllers use\n <strong>\n  FIFO (First In, First Out)\n </strong>\n buffers for both transmission and reception of data. Here's how these work:\n</p>\n<ul>\n<li>\n<strong>\n   Transmit FIFO\n  </strong>\n  : Data written to the transmit FIFO is stored in order, and the controller transmits it byte by byte in the same sequence. The first byte written will be transmitted first, and so on.\n </li>\n<li>\n<strong>\n   Receive FIFO\n  </strong>\n  : As data is received, it\u2019s stored in the FIFO, and each read of the buffer returns the byte that has been in the buffer the longest, starting from the first byte received.\n </li>\n</ul>\n<p>\n The FIFO buffer is typically managed with an\n <strong>\n  internal pointer\n </strong>\n that increments automatically as the firmware reads from or writes to the buffer. This ensures data is processed in the correct order without having to manually track where the next read or write should happen.\n</p>\n<h4>\n Non-FIFO Buffers\n</h4>\n<p>\n Some USB chips, like Cypress\u2019\n <strong>\n  enCoRe series\n </strong>\n , don't use FIFO buffers. Instead, these chips store data in\n <strong>\n  ordinary data memory\n </strong>\n . In this case, the firmware explicitly selects memory locations for reading and writing, rather than relying on an automatic pointer system. Though technically not FIFOs, these buffers are sometimes referred to as such, as they function similarly in practice by storing data in a sequential order.\n</p>\n<ul>\n<li>\n<strong>\n   Transmit buffer\n  </strong>\n  : Data is sent in order from the lowest to highest memory address.\n </li>\n<li>\n<strong>\n   Receive buffer\n  </strong>\n  : Data is stored in the order it arrives, from lowest to highest memory address.\n </li>\n</ul>\n<h4>\n Double and Quadruple Buffers\n</h4>\n<p>\n To improve data transfer speeds, some chips are designed with\n <strong>\n  double buffers\n </strong>\n . These buffers allow for two full sets of data to be stored in each direction (one for transmitting and one for receiving). Here's how they work:\n</p>\n<ul>\n<li>\n<strong>\n   Transmit Direction\n  </strong>\n  : While one buffer is actively transmitting, the firmware can write the next block of data into the second buffer. This allows the second block to be ready as soon as the first one finishes transmitting.\n </li>\n<li>\n<strong>\n   Receive Direction\n  </strong>\n  : The extra buffer enables new data to be stored while the firmware is still processing the previous data. This reduces delays and ensures a continuous data flow.\n </li>\n</ul>\n<p>\n Some\n <strong>\n  high-speed controllers\n </strong>\n , like Cypress\u2019\n <strong>\n  EZ-USB FX2 series\n </strong>\n , even support\n <strong>\n  quadruple buffers\n </strong>\n , which allows for even more simultaneous data handling.\n</p>\n<h4>\n Configuration, Status, and Control Information\n</h4>\n<p>\n USB controllers also include\n <strong>\n  registers\n </strong>\n that store important information about the device's operations, including:\n</p>\n<ul>\n<li>\n  Which\n  <strong>\n   endpoints\n  </strong>\n  are enabled.\n </li>\n<li>\n  The number of bytes\n  <strong>\n   received\n  </strong>\n  and\n  <strong>\n   ready to transmit\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Suspend-state status\n  </strong>\n  (indicating whether the device is in a low-power state).\n </li>\n<li>\n<strong>\n   Error-checking information\n  </strong>\n  .\n </li>\n<li>\n  Information about how the interface is used and the status of data transfers.\n </li>\n</ul>\n<p>\n These registers provide vital control and status information that allows the USB controller to manage its operations effectively. For instance, setting specific bits in a\n <strong>\n  configuration register\n </strong>\n can enable or disable certain endpoints or data transfer settings, ensuring that the device functions as required by the host.\n</p>\n<h3>\n Conclusion\n</h3>\n<p>\n Effective buffer management is key to ensuring smooth data transfer between the device and the USB host. FIFO buffers are the most common, but some controllers offer more advanced buffering techniques, like double or quadruple buffers, for higher-speed transfers. USB controllers also contain registers that track and manage important status and control information, allowing for more efficient and flexible USB communication.\n</p>\n"}, "Page 167": {"response": "<h3>\n Key Components of a USB Device\n</h3>\n<p>\n A USB device requires several key components to function properly, each contributing to the overall system's performance. These components include not only the USB interface but also the CPU, memory, and various other features that support the device's operations.\n</p>\n<h4>\n Configuration and Control Registers\n</h4>\n<p>\n USB controllers contain\n <strong>\n  configuration registers\n </strong>\n that store essential data for device management. These registers:\n</p>\n<ul>\n<li>\n<strong>\n   Enable/disable endpoints\n  </strong>\n  : For example, a configuration register can enable a specific endpoint, allowing communication over that channel.\n </li>\n<li>\n<strong>\n   Track communication settings\n  </strong>\n  : Registers hold data related to the status of communication, endpoints, and error-checking mechanisms.\n </li>\n</ul>\n<p>\n However, the specific number of registers, their contents, and how to access them depend on the particular chip or chip family being used. Therefore, the firmware required for USB communications will vary based on the controller used, making it important to tailor the low-level device firmware to the specific chip.\n</p>\n<h4>\n Clock Source\n</h4>\n<p>\n USB communications need a precise timing source, which is typically provided by a\n <strong>\n  crystal oscillator\n </strong>\n . In some cases, especially for low-speed devices, a cheaper\n <strong>\n  ceramic resonator\n </strong>\n may be used instead. Many USB controllers come with an\n <strong>\n  on-chip clock circuit\n </strong>\n , eliminating the need for an external timing source.\n</p>\n<h4>\n Other Device Components\n</h4>\n<p>\n Besides the USB interface, typical USB devices include several other components that manage the device's general operations, such as:\n</p>\n<ul>\n<li>\n<strong>\n   CPU\n  </strong>\n  : The CPU executes firmware instructions and controls the device\u2019s actions.\n </li>\n<li>\n<strong>\n   Program and Data Memory\n  </strong>\n  : Stores the code that the CPU executes, along with data for processing.\n </li>\n<li>\n<strong>\n   Other I/O Interfaces\n  </strong>\n  : These may be used for additional communication with peripherals or other devices.\n </li>\n<li>\n<strong>\n   Timers and Counters\n  </strong>\n  : Used for time-related operations within the device.\n </li>\n</ul>\n<p>\n These components may either be integrated within the controller chip or exist as separate modules, depending on the device design.\n</p>\n<h4>\n CPU in USB Devices\n</h4>\n<p>\n The\n <strong>\n  CPU\n </strong>\n is the brain of the USB device, controlling its operations by running firmware stored in memory. If the USB controller includes an on-chip CPU, it could be based on a general-purpose microcontroller like the\n <strong>\n  8051\n </strong>\n or\n <strong>\n  PICMicro\n </strong>\n , or it may use a custom CPU architecture designed specifically for USB applications.\n</p>\n<p>\n Alternatively, a\n <strong>\n  USB interface-only controller\n </strong>\n can communicate with any CPU that supports a compatible interface, allowing greater flexibility in the design.\n</p>\n<h4>\n Program Memory\n</h4>\n<p>\n The\n <strong>\n  program memory\n </strong>\n is where the CPU stores the firmware code it needs to run. This firmware not only manages USB communications but also handles any other functions the device is responsible for. This memory can be located in the microcontroller itself or in an external chip.\n</p>\n<p>\n There are several types of\n <strong>\n  program memory\n </strong>\n that can be used in USB devices:\n</p>\n<ul>\n<li>\n<strong>\n   ROM\n  </strong>\n  (Read-Only Memory)\n </li>\n<li>\n<strong>\n   EPROM\n  </strong>\n  (Erasable Programmable Read-Only Memory)\n </li>\n<li>\n<strong>\n   EEPROM\n  </strong>\n  (Electrically Erasable Programmable Read-Only Memory)\n </li>\n<li>\n<strong>\n   Flash memory\n  </strong>\n</li>\n<li>\n<strong>\n   RAM\n  </strong>\n  (Random Access Memory)\n </li>\n</ul>\n<p>\n All of these are\n <strong>\n  non-volatile\n </strong>\n except for RAM (unless it's battery-backed), meaning they retain data even when the device is powered off. The amount of program memory varies, with smaller devices typically having just a few kilobytes of storage.\n</p>\n<h3>\n Conclusion\n</h3>\n<p>\n In summary, USB devices consist of various essential components like configuration registers, clock sources, CPUs, and program memory. These elements, whether integrated within a controller chip or externally connected, work together to enable smooth USB communication. The controller\u2019s specific configuration, the type of memory used, and the presence of a dedicated CPU all depend on the device's requirements and the complexity of the intended application.\n</p>\n"}, "Page 168": {"response": "<h3>\n Program Memory in USB Devices\n</h3>\n<p>\n USB devices rely on program memory to store the firmware or code that controls the device\u2019s functions. This memory is essential for the device's operation, and the type and capacity of memory vary depending on the device's requirements.\n</p>\n<h4>\n Types of Program Memory\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    ROM (Read-Only Memory)\n   </strong>\n<br/>\n   ROM is typically used for storing firmware that is pre-programmed and cannot be modified. It is useful for mass production where the code remains fixed after being programmed at the factory. However, ROM is not ideal for products that require frequent updates. It is generally used only in high-volume manufacturing.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    EPROM (Erasable Programmable Read-Only Memory)\n   </strong>\n<br/>\n   EPROM is user-programmable, allowing developers to modify the code after initial programming. To erase the contents of an EPROM, it is exposed to ultraviolet light through a quartz window. After erasing, it can be reprogrammed multiple times, typically around 100 cycles. This type of memory is useful during development stages but is often less cost-effective for final production.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    OTP (One-Time Programmable) PROM\n   </strong>\n<br/>\n   OTP PROMs are similar to EPROMs but cannot be erased after programming. They are cost-effective for final product runs since they are cheaper than EPROMs but still offer the ability to program the firmware during development. Once programmed, the data cannot be changed, making them suitable for final production stages where the firmware no longer requires modification.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Flash Memory\n   </strong>\n<br/>\n   Flash memory is an electrically erasable memory technology that is widely used in USB devices. Unlike EPROM, flash memory does not require ultraviolet light or a special programming voltage, making it easier and more cost-effective to program. Flash memory is capable of enduring around 100,000 erase and reprogram cycles. Its reprogrammable nature makes it ideal for both development and final product programming, especially in low-volume projects.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    EEPROM (Electrically Erasable Programmable Read-Only Memory)\n   </strong>\n<br/>\n   EEPROM is similar to flash memory in that it does not require a window for erasure or special programming voltages. However, EEPROM tends to have longer access times compared to flash memory. EEPROM is used for smaller data storage needs where frequent updates are necessary, but it is slower than flash memory.\n  </p>\n</li>\n</ol>\n<h4>\n Memory Size and Access\n</h4>\n<p>\n Program memory can range from a few kilobytes to a megabyte or more, depending on the controller\u2019s needs and whether it supports off-chip memory. Devices that need more complex operations or store larger programs may use external memory, supporting greater capacity than what is available on-chip.\n</p>\n<h4>\n Firmware vs. Program Code\n</h4>\n<p>\n The term\n <strong>\n  firmware\n </strong>\n refers to the code stored in non-volatile memory, such as ROM, EPROM, Flash, or EEPROM. This firmware controls the device's behavior and interacts with the USB system. It is more permanent than regular program code, which is loaded into RAM for execution and can be edited and re-saved.\n</p>\n<p>\n In summary, the choice of memory type affects both the development process and the final product design, with trade-offs between cost, flexibility, and reusability. For development, more flexible and reprogrammable memory types like Flash and EEPROM are preferred, while for final product runs, non-reprogrammable options like OTP PROMs may be more economical.\n</p>\n"}, "Page 169": {"response": "<h3>\n Data and Memory Storage in USB Controllers\n</h3>\n<p>\n In USB devices, various types of memory and data storage are used to handle both program and data management. These types of memory allow for different data retention methods and access speeds, impacting device performance and development flexibility.\n</p>\n<h4>\n EEPROM (Electrically Erasable Programmable Read-Only Memory)\n</h4>\n<p>\n EEPROMs are commonly used in USB devices for storing configuration data and other small, infrequently changed information, such as Vendor ID and Product ID. EEPROMs are available with both parallel and serial interfaces, including Microwire, I2C, and SPI. For example, Cypress' EZ-USB controllers can load their firmware from an external serial EEPROM into RAM upon power-up.\n</p>\n<p>\n Current EEPROM technology allows for around 10 million erase/reprogram cycles, making them suitable for many applications. However, EEPROM is typically slower compared to other memory types like Flash, though it offers the advantage of not requiring special voltages or a quartz window for erasure.\n</p>\n<h4>\n RAM (Random Access Memory)\n</h4>\n<p>\n RAM is commonly used for temporary data storage during program execution. Unlike other memory types, RAM can be erased and rewritten indefinitely, but the stored data is lost when the device powers down. However, some devices use\n <strong>\n  battery-backed RAM\n </strong>\n , which retains data when power is lost, allowing the device to store information without needing a power cycle to reload it.\n</p>\n<p>\n For devices like Cypress Semiconductor\u2019s EZ-USB, RAM can also be used for program storage, with firmware loaded from a host PC at startup. This method has the advantage of no limit on erase/rewrite cycles, though the device needs to be powered up or attached to a host to reload the program each time.\n</p>\n<h4>\n Serial EEPROM for Storage\n</h4>\n<p>\n Serial EEPROMs are another type of memory used for small amounts of data storage, especially configuration data that changes infrequently. They are useful for low-level settings such as the device\u2019s Vendor ID and Product ID. These EEPROMs are connected via serial interfaces like Microwire, I2C, and SPI, making them more compact and versatile than their parallel counterparts.\n</p>\n<h4>\n Data Memory\n</h4>\n<p>\n Data memory is primarily used to store temporary data needed for the program's execution. This could include data that is received from or sent to the USB port, values for calculations, or other pieces of information the device needs to manage. The data memory is typically implemented in\n <strong>\n  RAM\n </strong>\n , and typical sizes range from 128 to 1024 bytes, depending on the device's requirements.\n</p>\n<h4>\n Other I/O Interfaces\n</h4>\n<p>\n In addition to the USB interface, USB controllers often feature various other interfaces for communication with external devices. These interfaces can include general-purpose\n <strong>\n  I/O pins\n </strong>\n for connecting to other circuits, or specialized\n <strong>\n  serial interfaces\n </strong>\n such as RS-232 for asynchronous communication, or synchronous interfaces for higher-speed data transfer. Some controllers, like FTDI Chip\u2019s products, even support\n <strong>\n  Bit Bang mode\n </strong>\n , enabling basic digital input and output functionality without requiring a full microcontroller.\n</p>\n<h3>\n Summary\n</h3>\n<p>\n Different types of memory and data storage are used in USB controllers, including EEPROM, RAM, and serial EEPROMs. Each of these memory types offers unique advantages, such as reprogrammability and speed. EEPROMs are ideal for storing configuration data, while RAM serves as temporary storage for dynamic data during execution. Other I/O interfaces and pins on USB controllers allow for flexible connections to external devices, enhancing the device's capabilities.\n</p>\n"}, "Page 170": {"response": "<h3>\n Simplifying Device Development: Key Considerations\n</h3>\n<p>\n When selecting a USB controller chip for a project, it's crucial to find one that aligns with both hardware and software requirements. In addition to the hardware features needed for the device, several factors can significantly simplify the development process. These factors include familiarity with the chip\u2019s architecture, well-organized documentation, and access to ready-made, reliable firmware and drivers.\n</p>\n<h4>\n Key Features for Streamlined Development:\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Familiar Chip Architecture and Programming Language:\n   </strong>\n   Choose a controller chip that uses an architecture and programming language you're already comfortable with. Familiarity with the tools and languages will save development time and reduce the learning curve.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Comprehensive Hardware Documentation:\n   </strong>\n   Well-documented hardware details are essential for successful project design and implementation. Clear documentation helps in understanding pinout, electrical characteristics, and other key parameters necessary for proper chip integration.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Reliable Example Firmware:\n   </strong>\n   Access to example firmware that is well-documented and bug-free can significantly speed up development. If the example code is similar to your application, it can be adapted quickly for your project, saving hours of development time.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Effective Development Tools:\n   </strong>\n   A development system that supports easy downloading and debugging of firmware is crucial. Tools that streamline debugging and firmware flashing can save significant time and avoid frustrations during testing and validation.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Ready-to-Use or Easily Modifiable Drivers:\n   </strong>\n   If your project can utilize a class driver already included in the host operating system, or a chip vendor\u2019s well-documented, bug-free driver, this can accelerate the development process. If the driver requires minimal modifications, it saves time and effort compared to creating a custom driver from scratch.\n  </p>\n</li>\n</ol>\n<p>\n By ensuring these factors are met, you\u2019ll be able to avoid many potential pitfalls and speed up the development process, ultimately reducing time and effort spent troubleshooting or rewriting code.\n</p>\n"}, "Page 171": {"response": "<h3>\n Device Requirements: Key Considerations for Selecting a USB Controller\n</h3>\n<p>\n When selecting a device controller for a USB project, several factors must be taken into account to ensure optimal performance, cost efficiency, and ease of development. These factors are centered around data transfer speed, the type and number of endpoints required, and the need for firmware upgradability.\n</p>\n<h4>\n 1.\n <strong>\n  Data Transfer Speed\n </strong>\n</h4>\n<ul>\n<li>\n  The speed at which data must be transferred is influenced by several elements:\n  <ul>\n<li>\n<strong>\n     Device Speed:\n    </strong>\n    Devices may support low, full, or high-speed USB transfers. The device's speed is critical in determining how fast data can be transmitted.\n   </li>\n<li>\n<strong>\n     Transfer Type and Bus Load:\n    </strong>\n    The transfer type (interrupt, control, bulk, or isochronous) impacts the amount of data that can be moved at once, and how busy the USB bus is can affect performance.\n   </li>\n<li>\n<strong>\n     Low-Speed Devices:\n    </strong>\n    For devices that only require low-speed control and interrupt transfers, a low-speed USB chip might save on costs related to circuit board design, components, and cables. However, low-speed devices are limited to 8 bytes per transaction and can only guarantee 800 bytes/second for interrupt endpoints, which may be too slow for more demanding applications. Additionally, the manufacturing cost of low-speed controllers can sometimes be higher than full or high-speed alternatives.\n   </li>\n<li>\n<strong>\n     Full or High-Speed Devices:\n    </strong>\n    While full-speed (12 Mbps) or high-speed (480 Mbps) devices generally offer better performance, designing circuits for high-speed devices can be more complex and costly. However, it's essential for a high-speed device to be backward compatible with full-speed and low-speed hosts and hubs to ensure broad compatibility.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n 2.\n <strong>\n  Number and Type of Endpoints\n </strong>\n</h4>\n<ul>\n<li>\n  USB devices are equipped with different types of endpoints, and the number of these endpoints directly impacts the functionality of the device. Endpoints can support different transfer types and directions (in or out).\n  <ul>\n<li>\n<strong>\n     Control Transfers:\n    </strong>\n    A device that only needs to handle control transfers requires only the default endpoint.\n   </li>\n<li>\n<strong>\n     Other Transfers:\n    </strong>\n    If the device handles interrupt, bulk, or isochronous transfers, additional endpoints are necessary. Not all controller chips support all transfer types, and most chips support fewer than the maximum number of endpoints.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n 3.\n <strong>\n  Firmware Upgradability\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   Upgradable Firmware:\n  </strong>\n  If the firmware in the device needs to be updated frequently, it's crucial to select a device with easily upgradable memory. Some chips use memory types like windowed EPROM, OTP PROM, or others that aren't easily erased or re-written, making firmware updates more difficult.\n  <ul>\n<li>\n<strong>\n     Non-Volatile Memory:\n    </strong>\n    Using non-volatile memory types, such as Flash or EEPROM, can help ensure that firmware updates can be easily applied without having to replace hardware.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n Selecting the right USB controller chip depends on carefully evaluating these factors to balance performance, cost, and flexibility for the specific needs of the project.\n</p>\n"}, "Page 172": {"response": "<h3>\n Selecting a USB Controller: Key Factors to Consider\n</h3>\n<p>\n When selecting a USB controller for your project, there are several critical factors to evaluate, from firmware upgradeability to hardware requirements. These considerations ensure that you choose the right controller to meet your project's needs while making the development process easier and more efficient.\n</p>\n<h4>\n 1.\n <strong>\n  Firmware Upgradability\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   Firmware Loading:\n  </strong>\n  Some chips, like Cypress' EZ-USB, allow the firmware to be loaded from the host into RAM upon power-up or attachment, eliminating the need for manual updates or chip replacements.\n </li>\n<li>\n<strong>\n   Reprogrammable Memory:\n  </strong>\n  Another option is using Flash memory or EEPROM, which can be electrically reprogrammed. These types of memory can be stored either in the device controller or on an external chip, and allow for easier firmware updates.\n </li>\n<li>\n<strong>\n   Device Firmware Upgrade (DFU) Class:\n  </strong>\n  The DFU class specification outlines a standardized method for loading firmware from a host to a device. This is a useful feature if frequent firmware updates are required. More information on DFU is provided in Chapter 7.\n </li>\n</ul>\n<h4>\n 2.\n <strong>\n  Cable Requirements\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   Flexibility:\n  </strong>\n  Devices like mice are often low-speed devices due to the more flexible and thinner cables allowed by low-speed specifications. Low-speed cables are less stringent but still need to meet certain requirements, such as a braided outer shield and a twisted pair (which is recommended but not mandatory).\n </li>\n<li>\n<strong>\n   Cable Length:\n  </strong>\n  Low-speed device cables have a maximum length of 3 meters, whereas full-speed device cables can extend up to 5 meters.\n </li>\n</ul>\n<h4>\n 3.\n <strong>\n  Hardware Features\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   I/O and Memory Requirements:\n  </strong>\n  Consider the number of general-purpose or specialized I/O pins the device needs, as well as the amount of program and data memory required. You may also need to factor in on-chip timers or any other special features depending on the device's functionality.\n </li>\n</ul>\n<h4>\n 4.\n <strong>\n  Chip Documentation and Development Support\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   Quality Documentation:\n  </strong>\n  High-quality documentation is crucial for a smooth development process. Most vendors provide data sheets along with technical manuals, application notes, and example code to help you get started.\n </li>\n<li>\n<strong>\n   Example Code:\n  </strong>\n  Starting with example code that's similar to your application is highly recommended. It's much easier to modify existing code than to build everything from scratch.\n </li>\n<li>\n<strong>\n   Vendors' Resources:\n  </strong>\n  The availability of documentation and example code can vary greatly between vendors. Therefore, it's important to check the manufacturer's website to see what resources are available before making a decision. Additionally, you may find helpful code from other developers online, as many users share their work on forums and other platforms.\n </li>\n</ul>\n<p>\n By carefully considering these factors\u2014firmware upgradeability, cable and hardware requirements, and the quality of available documentation\u2014you can streamline the development process and select the most suitable USB controller\n</p>\n"}, "Page 173": {"response": "<h3>\n Driver and Debugging Tools for USB Devices\n</h3>\n<p>\n When working with USB devices, it's important to consider both the device drivers at the host side and the debugging tools that will help ensure the device works correctly.\n</p>\n<h4>\n 1.\n <strong>\n  Driver Choices\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   Class-Specific Drivers:\n  </strong>\n  If your device belongs to a standard USB class, the operating system typically provides a driver for you. For example, Human Interface Device (HID)-class devices can be accessed using standard API functions that interact with HID drivers already included in Windows. This means you won\u2019t need to write your own driver.\n </li>\n<li>\n<strong>\n   Generic Drivers:\n  </strong>\n  For devices that don\u2019t fall under a standard USB class, some vendors provide generic drivers that facilitate communication between the device and the host. For example, Cypress offers the CyUSB driver, which can be used for devices that include Cypress controllers but are not part of a standard USB class. Silicon Laboratories also offers a similar generic driver for their chips. For more on classes and device drivers, refer to Chapters 7 and 8.\n </li>\n</ul>\n<h4>\n 2.\n <strong>\n  Debugging Tools\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   Development Boards:\n  </strong>\n  Chip manufacturers often provide development boards, which are valuable tools for testing and debugging new designs. These boards allow you to load firmware into the chip\u2019s memory and emulate the device's hardware, helping you ensure everything functions as expected before moving to the final hardware.\n </li>\n<li>\n<strong>\n   Protocol Analyzers:\n  </strong>\n  A protocol analyzer is a crucial tool for debugging USB communication. It allows you to monitor the data exchanged between the USB device and the host, helping you identify any issues with the data transfer or device behavior. More details about protocol analyzers can be found in Chapter 17.\n </li>\n<li>\n<strong>\n   Dedicated Debugging Interfaces:\n  </strong>\n  Some chips, like Silicon Laboratories' C8051F32x controllers, include dedicated debugging interfaces that don\u2019t use additional memory or port pins on the chip. This simplifies debugging by providing a direct connection to the chip without consuming valuable resources or requiring an emulator.\n </li>\n</ul>\n<p>\n By using the right drivers and debugging tools, such as development boards and protocol analyzers, you can significantly improve the speed and ease of getting your USB device up and running. These resources simplify testing, help identify issues early, and make development more efficient.\n</p>\n"}, "Page 174": {"response": "<h3>\n Debugging and Development Tools for USB Devices\n</h3>\n<p>\n Debugging and development tools are essential for efficiently testing and troubleshooting USB devices. These tools can range from software that monitors the program execution to cost-effective hardware alternatives that help reduce development time and cost.\n</p>\n<h4>\n 1.\n <strong>\n  Debugging Software with Development Boards\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   Monitor Programs:\n  </strong>\n  The debugging software that comes with development boards typically includes a monitor program. This program runs on a PC and allows you to control the execution of your program and observe its results. Key features of this software usually include:\n  <ul>\n<li>\n    Stepping through the program one line at a time.\n   </li>\n<li>\n    Setting breakpoints to halt execution at specific points.\n   </li>\n<li>\n    Viewing the contents of registers and memory within the chip.\n   </li>\n</ul>\n</li>\n<li>\n  You can run both the monitor program and your application simultaneously, allowing you to observe the internal behavior of the chip when it communicates with the application. This gives you detailed insights into how the device performs during operations, making it easier to identify and fix issues.\n </li>\n<li>\n  If you already have a development system for a particular microcontroller family, you may be able to adapt it for USB development, saving time and resources.\n </li>\n</ul>\n<h4>\n 2.\n <strong>\n  Boards from Other Sources\n </strong>\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Inexpensive Alternatives:\n   </strong>\n   If you\u2019re on a budget, there are affordable printed-circuit boards (PCBs) available from various vendors that can be used as an alternative to the more expensive development kits provided by chip manufacturers. These boards are often suitable for one-off or small-scale projects, which can save the time and cost of designing and fabricating a custom PCB for the controller chip.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    I/O Boards:\n   </strong>\n   These boards often contain a USB controller and connector, along with several general-purpose input/output (I/O) pins that can be connected to external circuits you design. For example, the EZ-USB family of chips is well-suited for these types of boards, as their firmware can be downloaded from the host without needing separate programming hardware. Many third-party vendors offer boards with EZ-USB chips.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    DeVaSys USB I2C/IO Board Example:\n   </strong>\n   An example of a cost-effective development board is the USB I2C/IO board from DeVaSys Embedded Systems, which features:\n  </p>\n<ul>\n<li>\n    An AN2131 EZ-USB chip.\n   </li>\n<li>\n    A USB connector with 20 bits of I/O.\n   </li>\n<li>\n    An I2C interface for synchronous serial communications.\n   </li>\n<li>\n    An asynchronous serial interface.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n   The board also includes an onboard 24LC128 I2C EEPROM, which stores up to 16 KB of data, including essential details like the Vendor ID, Product ID, and firmware. The firmware can either be loaded from the EEPROM or from the host at power-up or attachment.\n  </p>\n</li>\n<li>\n<p>\n   DeVaSys provides the schematic, a custom device driver, and firmware for free, enabling applications to establish communication and read or write to the ports, including the I2C port.\n  </p>\n</li>\n</ul>\n<p>\n In summary, debugging software and development boards are critical to testing and refining USB devices. Development boards from chip manufacturers provide in-depth tools for monitoring and debugging, while affordable boards from other vendors offer a budget-friendly option for small-scale projects. Additionally, platforms like the DeVaSys USB I2C/IO board are excellent examples of how third-party boards can facilitate USB development with pre-configured hardware, example drivers, and firmware.\n</p>\n"}, "Page 175": {"response": "<h3>\n Emulating USB Devices with a PC for Development\n</h3>\n<p>\n When developing USB devices, it's often helpful to simulate the behavior of the device before it is physically built. Emulating the device on a PC allows developers to write, test, and debug the device firmware using the familiar tools and environment on their computer.\n</p>\n<h4>\n 1.\n <strong>\n  Using Development Boards and Custom Firmware\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   Load Your Own Driver or Firmware:\n  </strong>\n  Development boards, like the USB I2C/IO board from DeVaSys, allow you to load your custom firmware into the device. Once the firmware is in place, you can use your own driver or rely on a driver provided by Windows to manage the communication between the PC and the USB device.\n </li>\n<li>\n<strong>\n   Flexibility with the EZ-USB Controllers:\n  </strong>\n  Boards using EZ-USB chips (such as those from DeVaSys) give you the flexibility to load and use your own drivers. These boards can work with pre-configured drivers for various applications or enable you to create your own tailored solution for your specific project.\n </li>\n</ul>\n<h4>\n 2.\n <strong>\n  PC as a Device Emulator\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   Development Tools on a PC:\n  </strong>\n  During the early stages of development, it's possible to use your PC to emulate a USB device. This approach allows you to leverage the compilers, debuggers, and other software tools you are already familiar with to compile, run, and debug device code on your PC, without needing the actual hardware in place yet.\n </li>\n<li>\n<strong>\n   PLX Technology\u2019s NET2272 PCI-RDK:\n  </strong>\n  A great example of this type of setup is the PLX Technology NET2272 PCI-RDK development kit. This kit enables developers to use a PC to emulate a USB device during development. The kit includes:\n  <ul>\n<li>\n    A PCI card that can be installed in a PC.\n   </li>\n<li>\n    A daughter card with a NET2272 USB interface chip.\n   </li>\n</ul>\n</li>\n<li>\n  By using this kit, developers can write applications that perform the role of device firmware, effectively communicating with the NET2272 interface chip. These applications can run as console applications on the PC, allowing the user to test device functionality without needing the actual hardware.\n </li>\n</ul>\n<p>\n In conclusion, using a PC to emulate a USB device can greatly enhance the development process, especially during the early stages. Development boards like those from DeVaSys, along with tools that allow you to load custom firmware and drivers, offer a versatile way to prototype. Additionally, solutions like the PLX Technology NET2272 PCI-RDK allow you to simulate the device directly on the PC, making it easier to write, test, and debug USB device code before hardware is available.\n</p>\n"}, "Page 176": {"response": "<h3>\n USB Controllers with Embedded CPUs\n</h3>\n<p>\n When selecting a USB controller for your device, there are many choices, especially among chips with embedded CPUs. These chips offer a range of options, and as new chips are released frequently, it's important to check for the latest offerings.\n</p>\n<h4>\n 1.\n <strong>\n  Advantages of Using Embedded CPUs for USB Controllers\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   Familiarity with Architecture:\n  </strong>\n  Many developers prefer using a USB controller based on a CPU family they are already familiar with. This familiarity with the architecture and instruction set can significantly speed up the development process.\n </li>\n<li>\n<strong>\n   Availability of Tools and Resources:\n  </strong>\n  Popular CPU families typically have better support in terms of programming and debugging tools. Additionally, you are more likely to find example code and other development resources from the community.\n </li>\n</ul>\n<h4>\n 2.\n <strong>\n  USB Controllers for Popular CPU Families\n </strong>\n</h4>\n<ul>\n<li>\n  The\n  <strong>\n   8051 family\n  </strong>\n  is one of the most widely used for USB controllers. Originally developed by Intel, the 8051 family has USB-compatible variants, such as the 8x930 and 8x931. Although Intel no longer produces USB-capable 8051s, other manufacturers still do.\n </li>\n<li>\n  Other popular CPU families that offer USB-compatible controllers include:\n  <ul>\n<li>\n<strong>\n     Atmel's AVR\n    </strong>\n</li>\n<li>\n<strong>\n     Microchip's PICmicro\n    </strong>\n</li>\n<li>\n<strong>\n     Freescale Semiconductor's 68HC05 and 68HC08\n    </strong>\n</li>\n</ul>\n</li>\n<li>\n<strong>\n   Table 6-1\n  </strong>\n  provides a list of various chips that are compatible with these widely-used microcontroller families.\n </li>\n</ul>\n<h4>\n 3.\n <strong>\n  Chips with CPUs Designed Specifically for USB\n </strong>\n</h4>\n<ul>\n<li>\n  Some USB controllers contain CPUs that are specifically designed to handle USB applications. Instead of simply adding USB functionality to an existing CPU architecture, these chips are optimized for USB-related tasks, offering better performance and efficiency for USB communication.\n </li>\n</ul>\n<p>\n In conclusion, when selecting a USB controller for your device, considering embedded CPUs with USB compatibility can save you time and effort. Using controllers that are part of well-known microcontroller families, such as the 8051, AVR, PICmicro, or 68HC05, can simplify development due to your familiarity with the architecture and the availability of programming resources. Additionally, controllers designed specifically for USB applications may offer enhanced performance.\n</p>\n"}, "Page 177": {"response": "<h3>\n USB Controller Chips Compatible with Popular Microcontroller Families\n</h3>\n<p>\n When selecting a USB controller, it's useful to consider chips that are compatible with widely known microcontroller families. Many manufacturers offer a range of USB controllers designed to integrate seamlessly with these families, making development smoother and faster. Below is a breakdown of various USB controller chips compatible with popular microcontroller families.\n</p>\n<h4>\n 1.\n <strong>\n  Optimized USB Designs\n </strong>\n</h4>\n<p>\n Some manufacturers design controllers that are specifically optimized for USB from the start, such as Cypress Semiconductor\u2019s enCoRe family. These designs ensure that the controller has USB functionality built-in, reducing development time and providing enhanced performance for USB applications.\n</p>\n<h4>\n 2.\n <strong>\n  Application-Specific Controllers\n </strong>\n</h4>\n<p>\n For common USB applications like keyboards, drives, and interface converters, there are application-specific controllers available. These chips include hardware specifically designed to support these functions. Vendors often provide example firmware for these applications, further easing development.\n</p>\n<h4>\n 3.\n <strong>\n  USB Controller Chip List\n </strong>\n</h4>\n<p>\n Below is a table listing some USB controller chips from various manufacturers that are compatible with popular microcontroller families. These chips support different bus speeds, such as full-speed (12 Mbps), high-speed (480 Mbps), or low-speed (1.5 Mbps).\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Compatibility\n    </strong>\n</th>\n<th>\n<strong>\n     Manufacturer\n    </strong>\n</th>\n<th>\n<strong>\n     Chips\n    </strong>\n</th>\n<th>\n<strong>\n     Bus Speed\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n    Atmel AVR\n   </td>\n<td>\n    Atmel\n   </td>\n<td>\n    AT43USB35x, AT76C713\n   </td>\n<td>\n    Full\n   </td>\n</tr>\n<tr>\n<td>\n    Freescale/Motorola\n   </td>\n<td>\n    68HC05\n   </td>\n<td>\n    Freescale Semiconductor 68HC05JB3/4\n   </td>\n<td>\n    Low\n   </td>\n</tr>\n<tr>\n<td>\n    Freescale/Motorola\n   </td>\n<td>\n    68HC08\n   </td>\n<td>\n    Freescale Semiconductor 68HC08JB8\n   </td>\n<td>\n    Low\n   </td>\n</tr>\n<tr>\n<td>\n    Freescale/Motorola\n   </td>\n<td>\n    PowerPC\n   </td>\n<td>\n    Freescale Semiconductor MCF5482\n   </td>\n<td>\n    Full/High\n   </td>\n</tr>\n<tr>\n<td>\n    Infineon C166\n   </td>\n<td>\n    Infineon\n   </td>\n<td>\n    C161U\n   </td>\n<td>\n    Full\n   </td>\n</tr>\n<tr>\n<td>\n    Intel 80C186\n   </td>\n<td>\n    AMD\n   </td>\n<td>\n    Am186CC\n   </td>\n<td>\n    Full\n   </td>\n</tr>\n<tr>\n<td>\n    Intel 8051\n   </td>\n<td>\n    Atmel\n   </td>\n<td>\n    AT89C513x\n   </td>\n<td>\n    Full\n   </td>\n</tr>\n<tr>\n<td>\n    Cypress Semiconductor\n   </td>\n<td>\n    EZ-USB\n   </td>\n<td>\n    EZ-USB, EZ-USB FX, EZ-USB FX2\n   </td>\n<td>\n    Full/High\n   </td>\n</tr>\n<tr>\n<td>\n    Prolific Technology\n   </td>\n<td>\n    PL-23xx\n   </td>\n<td>\n</td>\n<td>\n    Full\n   </td>\n</tr>\n<tr>\n<td>\n    Prolific Technology\n   </td>\n<td>\n    PL-25xx\n   </td>\n<td>\n</td>\n<td>\n    Full/High\n   </td>\n</tr>\n<tr>\n<td>\n    Silicon Laboratories\n   </td>\n<td>\n    C8051F32x\n   </td>\n<td>\n</td>\n<td>\n    Full\n   </td>\n</tr>\n<tr>\n<td>\n    Standard Microsystems\n   </td>\n<td>\n    USB97Cxxx, USB222x\n   </td>\n<td>\n</td>\n<td>\n    Full/High\n   </td>\n</tr>\n<tr>\n<td>\n    Texas Instruments\n   </td>\n<td>\n    TUSB3210/3410\n   </td>\n<td>\n</td>\n<td>\n    Full\n   </td>\n</tr>\n<tr>\n<td>\n    Texas Instruments\n   </td>\n<td>\n    TUSB6250\n   </td>\n<td>\n</td>\n<td>\n    Full/High\n   </td>\n</tr>\n<tr>\n<td>\n    Microchip PIC16\n   </td>\n<td>\n    Microchip Technology\n   </td>\n<td>\n    PIC16C7x5\n   </td>\n<td>\n    Low\n   </td>\n</tr>\n<tr>\n<td>\n    Microchip PIC18\n   </td>\n<td>\n    Microchip Technology\n   </td>\n<td>\n    PIC18F2455/2550/4455/4550\n   </td>\n<td>\n    Full/High\n   </td>\n</tr>\n<tr>\n<td>\n    STMicroelectronics\n   </td>\n<td>\n    ST7, ST9\n   </td>\n<td>\n    ST7265X, ST7263, ST92163\n   </td>\n<td>\n    Low, Full\n   </td>\n</tr>\n</tbody>\n</table>\n<p>\n This table highlights a variety of USB controllers with different capabilities. By choosing a chip that\u2019s compatible with your preferred microcontroller family, you can speed up development, as you\u2019ll likely already be familiar with the tools, architectures, and debugging resources associated with that family. Furthermore, these chips offer various features, including support for low, full, and high USB speeds, depending on t\n</p>\n"}, "Page 178": {"response": "<h3>\n Microchip PIC18F4550: A Detailed Overview\n</h3>\n<p>\n The\n <strong>\n  Microchip PIC18F4550\n </strong>\n is part of Microchip Technology\u2019s PICmicro series of microcontrollers. Known for its low cost, power efficiency, and broad availability, the PIC18F4550 is a popular choice for developers working with USB devices. It features an integrated USB controller that supports both low-speed and full-speed communication, making it versatile for various USB applications.\n</p>\n<h4>\n Architecture\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Family\n   </strong>\n   : The PIC18F4550 belongs to the\n   <strong>\n    high-performance, low-cost PIC18 series\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Memory\n   </strong>\n   : It uses\n   <strong>\n    Flash memory\n   </strong>\n   for program storage and includes\n   <strong>\n    256 bytes of EEPROM\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Bootloader\n   </strong>\n   : The microcontroller has a\n   <strong>\n    bootloader routine\n   </strong>\n   that allows firmware updates via the USB port.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    I/O Pins\n   </strong>\n   : It features\n   <strong>\n    34 I/O pins\n   </strong>\n   , providing a wide range of functionality for various applications.\n  </p>\n<ul>\n<li>\n<strong>\n     Analog-to-Digital Converter\n    </strong>\n    : A\n    <strong>\n     10-bit ADC\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     USART\n    </strong>\n    : A\n    <strong>\n     Universal Synchronous Asynchronous Receiver Transmitter\n    </strong>\n    for serial communication.\n   </li>\n<li>\n<strong>\n     Synchronous Serial Ports\n    </strong>\n    : Can be configured for\n    <strong>\n     I2C or SPI\n    </strong>\n    communication.\n   </li>\n<li>\n<strong>\n     PWM\n    </strong>\n    :\n    <strong>\n     Enhanced Pulse Width Modulation\n    </strong>\n    capabilities.\n   </li>\n<li>\n<strong>\n     Analog Comparators\n    </strong>\n    : Two built-in comparators for analog signal comparison.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Clock Management\n   </strong>\n   : The USB controller and the CPU can operate using\n   <strong>\n    separate clock sources\n   </strong>\n   , which allows the CPU to run on a slower, power-efficient clock, reducing overall energy consumption.\n  </p>\n</li>\n</ul>\n<h4>\n USB Controller Features\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Transfer Types\n   </strong>\n   : The USB controller supports\n   <strong>\n    all four transfer types\n   </strong>\n   (Control, Isochronous, Bulk, and Interrupt), making it versatile for various USB communication needs.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Endpoint Addresses\n   </strong>\n   : It can handle up to\n   <strong>\n    30 endpoint addresses\n   </strong>\n   in addition to the default endpoint.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Buffer Memory\n   </strong>\n   : The controller uses\n   <strong>\n    1 kilobyte of buffer memory\n   </strong>\n   shared among the endpoints. It also supports\n   <strong>\n    double buffering\n   </strong>\n   , which enhances data transfer performance.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Isochronous Transfers\n   </strong>\n   : For\n   <strong>\n    isochronous transfers\n   </strong>\n   , USB data can be transferred directly to and from a\n   <strong>\n    streaming parallel port\n   </strong>\n   , which is useful for continuous data flows like audio or video streams.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Memory Allocation for Endpoints\n   </strong>\n   : Each enabled endpoint requires the firmware to reserve memory for both the\n   <strong>\n    buffer\n   </strong>\n   and the\n   <strong>\n    buffer descriptor\n   </strong>\n   .\n  </p>\n<ul>\n<li>\n<strong>\n     Buffer Descriptor\n    </strong>\n    : This consists of four registers:\n    <ul>\n<li>\n<strong>\n       Status Register\n      </strong>\n      : Contains status information and the two highest bits of the endpoint\u2019s byte count.\n     </li>\n<li>\n<strong>\n       Byte Count Register\n      </strong>\n      : Along with the two bits in the status register, it holds the total number of bytes to be transferred in an IN transaction or received in an OUT transaction.\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>\n This detailed architecture and USB controller functionality make the\n <strong>\n  PIC18F4550\n </strong>\n a robust and flexible solution for building USB devices, with a balance of performance and low power usage suitable for a wide r\n</p>\n"}, "Page 179": {"response": "<h3>\n Cypress EZ-USB Controllers: Overview and Features\n</h3>\n<p>\n Cypress Semiconductor\u2019s\n <strong>\n  EZ-USB\n </strong>\n family offers a range of full-speed and full/high-speed controllers, providing flexibility in terms of USB performance. These controllers are designed for use in a variety of USB applications, and they support multiple options for storing firmware, allowing for versatile development of USB-based devices.\n</p>\n<h4>\n Buffer and Memory Management\n</h4>\n<ul>\n<li>\n<strong>\n   Buffer Ownership\n  </strong>\n  : Each endpoint has a set of buffers and buffer descriptors, managed by the microcontroller's\n  <strong>\n   CPU\n  </strong>\n  and the USB\n  <strong>\n   Serial Interface Engine (SIE)\n  </strong>\n  . The\n  <strong>\n   UOWN bit\n  </strong>\n  in the buffer descriptor\u2019s\n  <strong>\n   status register\n  </strong>\n  determines whether the buffer and descriptor are owned by the CPU or the SIE.\n  <ul>\n<li>\n<strong>\n     SIE Ownership\n    </strong>\n    : When the\n    <strong>\n     SIE\n    </strong>\n    has ownership, it is either transmitting or waiting to receive data. The CPU must avoid accessing the buffer or descriptor during this time, except to read the\n    <strong>\n     UOWN bit\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     CPU Ownership\n    </strong>\n    : After a transaction is complete, the SIE clears the\n    <strong>\n     UOWN bit\n    </strong>\n    , returning ownership to the CPU, allowing it to perform further operations.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Endpoint Control\n  </strong>\n  : Each endpoint has a\n  <strong>\n   control register\n  </strong>\n  that configures its functionality. It can enable:\n  <ul>\n<li>\n    Control endpoints\n   </li>\n<li>\n    IN or OUT endpoints\n   </li>\n<li>\n    Pairs of IN/OUT endpoints with the same endpoint number.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Endpoint Status\n  </strong>\n  : Other bits in the control register allow for stalling the endpoint or disabling handshaking for\n  <strong>\n   isochronous transactions\n  </strong>\n  .\n </li>\n</ul>\n<h4>\n USB Communication and Registers\n</h4>\n<ul>\n<li>\n<strong>\n   Device Address\n  </strong>\n  : Registers store the device\u2019s address on the bus, as well as status and control information related to USB communication and interrupts.\n </li>\n</ul>\n<h4>\n USB Firmware Framework\n</h4>\n<ul>\n<li>\n<strong>\n   Microchip\u2019s Firmware Framework\n  </strong>\n  : Microchip provides a\n  <strong>\n   USB Firmware Framework\n  </strong>\n  designed for use with their\n  <strong>\n   C18 C compiler\n  </strong>\n  . This framework simplifies the development of firmware for USB devices, accommodating a wide variety of device classes and vendor-specific applications.\n  <ul>\n<li>\n    The framework is structured to be flexible, allowing easy adaptation for different types of USB devices.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Additional Microchip USB Microcontrollers\n</h4>\n<ul>\n<li>\n<strong>\n   PIC16C745 and PIC16C765\n  </strong>\n  : In addition to the\n  <strong>\n   PIC18F4550\n  </strong>\n  , Microchip offers the\n  <strong>\n   PIC16C745\n  </strong>\n  and\n  <strong>\n   PIC16C765\n  </strong>\n  . These microcontrollers are less flexible compared to the PIC18F4550 as they only support low-speed USB and use\n  <strong>\n   EPROM\n  </strong>\n  instead of\n  <strong>\n   Flash memory\n  </strong>\n  for program storage.\n </li>\n</ul>\n<h3>\n Summary\n</h3>\n<p>\n Cypress's\n <strong>\n  EZ-USB\n </strong>\n controllers, along with Microchip\u2019s various\n <strong>\n  PICmicro\n </strong>\n USB solutions, offer a wide array of options for developers needing USB connectivity. They provide robust memory and buffer management, flexible endpoint configuration, and excellent support for USB communication and firmware development, with frameworks that make it easier to build and update USB devices.\n</p>\n"}, "Page 180": {"response": "<h3>\n EZ-USB Family: Architecture and Features\n</h3>\n<p>\n The\n <strong>\n  EZ-USB family\n </strong>\n from\n <strong>\n  Cypress Semiconductor\n </strong>\n is designed for flexibility and performance in USB device applications. Originally developed by Anchor Chips, which Cypress acquired in 1999, the EZ-USB family has evolved into a robust set of controllers with advanced capabilities. These controllers support loading firmware from the host on each power-up or attachment, making them highly versatile for a range of USB projects.\n</p>\n<h4>\n Architecture Overview\n</h4>\n<ul>\n<li>\n<strong>\n   Core Design\n  </strong>\n  : The EZ-USB architecture is based on the 8051 microcontroller but with significant enhancements. It uses\n  <strong>\n   four clock cycles per instruction\n  </strong>\n  (compared to the original 8051's twelve), making it about\n  <strong>\n   2.5 times faster\n  </strong>\n  than a standard 8051 microcontroller with the same clock speed. Each instruction in the EZ-USB controller takes between one and five cycles.\n </li>\n<li>\n<strong>\n   Instruction Set\n  </strong>\n  : The instruction set remains compatible with the\n  <strong>\n   8051\u2019s\n  </strong>\n  , ensuring ease of use for developers familiar with the 8051.\n </li>\n<li>\n<strong>\n   Memory\n  </strong>\n  : The EZ-USB chips utilize\n  <strong>\n   RAM\n  </strong>\n  for both code and data memory. There is\n  <strong>\n   no on-chip non-volatile memory\n  </strong>\n  . However, non-volatile storage options are supported externally, such as in\n  <strong>\n   I2C serial EEPROM\n  </strong>\n  or external\n  <strong>\n   parallel memory\n  </strong>\n  .\n </li>\n</ul>\n<h4>\n EZ-USB Series\n</h4>\n<p>\n The EZ-USB family consists of three primary series:\n</p>\n<ol>\n<li>\n<strong>\n   EZ-USB (AN21XX series)\n  </strong>\n  : The basic series, offering essential USB functionality.\n </li>\n<li>\n<strong>\n   FX series (CY7C646XX)\n  </strong>\n  : Adds faster I/O and a general-purpose programmable interface that supports configurable, automated handshaking.\n </li>\n<li>\n<strong>\n   FX2 series (CY7C68013)\n  </strong>\n  : Supports high-speed USB communication, making it suitable for more demanding applications.\n </li>\n</ol>\n<p>\n Within each series, different chips vary in features such as the number of\n <strong>\n  I/O pins\n </strong>\n and the availability of an\n <strong>\n  external data bus\n </strong>\n .\n</p>\n<h4>\n Firmware and Development Tools\n</h4>\n<ul>\n<li>\n<strong>\n   Software Support\n  </strong>\n  : Cypress provides\n  <strong>\n   Frameworks firmware in C\n  </strong>\n  , simplifying USB communication development. This framework helps developers by managing most USB communication tasks.\n </li>\n<li>\n<strong>\n   Compiler Options\n  </strong>\n  :\n  <strong>\n   Keil Software\n  </strong>\n  offers a\n  <strong>\n   C compiler\n  </strong>\n  for the EZ-USB family, as well as assembly language support. A free, limited version of the compiler is available for evaluation.\n </li>\n</ul>\n<h4>\n USB Controller Features\n</h4>\n<ul>\n<li>\n<strong>\n   Endpoint Support\n  </strong>\n  : The EZ-USB chips support the full range of\n  <strong>\n   USB endpoints\n  </strong>\n  and\n  <strong>\n   transfer types\n  </strong>\n  , though chips with fewer endpoints are also available for simpler applications.\n </li>\n<li>\n<strong>\n   Flexible Firmware Storage\n  </strong>\n  : One of the key advantages of the EZ-USB family is its flexibility in storing firmware, with various options for loading firmware from external sources.\n </li>\n</ul>\n<h3>\n Summary\n</h3>\n<p>\n The\n <strong>\n  EZ-USB family\n </strong>\n from Cypress is a powerful and flexible choice for developers working with USB devices. The architecture, based on the 8051 core with significant enhancements, provides fast performance, compatibility with existing 8051 tools, and a range of options for memory and firmware storage. With various series offering different features, and the availability of development tools and frameworks, the EZ-USB controllers are well-suited for a wide range of USB applications.\n</p>\n"}, "Page 181": {"response": "<h3>\n EZ-USB Firmware Storage and Enumeration Process\n</h3>\n<p>\n The\n <strong>\n  EZ-USB family\n </strong>\n offers a highly flexible design, which is more complex than other USB controllers. One of its unique features is the ability to load firmware from the host device, a capability that adds considerable versatility but requires a more intricate process for device enumeration.\n</p>\n<h4>\n Dual Enumeration Process\n</h4>\n<p>\n When an EZ-USB device is connected to the host or powered on, the\n <strong>\n  enumeration process\n </strong>\n occurs twice. Here\u2019s how it works:\n</p>\n<ol>\n<li>\n<strong>\n   Initial Enumeration\n  </strong>\n  : The host first attempts to enumerate the device when it\u2019s attached or powered up. However, at this point, the device has no firmware loaded, which could prevent enumeration. To overcome this, the\n  <strong>\n   EZ-USB core\n  </strong>\n  (the part of the chip dedicated to initial communications) takes over. It has the built-in capability to respond to enumeration requests without relying on the 8051 core, which controls the chip during regular operations after enumeration.\n </li>\n<li>\n<strong>\n   Firmware Loading\n  </strong>\n  : The\n  <strong>\n   EZ-USB core\n  </strong>\n  communicates with the host while keeping the 8051 core in a reset state. During this phase, the core also handles\n  <strong>\n   vendor-specific requests\n  </strong>\n  that allow the chip to receive, store, and execute firmware from the host device. This enables the device to load and run the necessary firmware before the 8051 core is activated.\n </li>\n</ol>\n<p>\n This two-step enumeration process is essential for devices that rely on external firmware storage and ensures that they can function immediately upon connection to a USB host.\n</p>\n<h3>\n Features of the EZ-USB Family\n</h3>\n<p>\n Cypress Semiconductor\u2019s EZ-USB family offers a range of controllers with varying features suited for different applications. Below is a summary of the characteristics of the key series:\n</p>\n<h4>\n EZ-USB Family Series Overview\n</h4>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Feature\n    </strong>\n</th>\n<th>\n<strong>\n     AN21xx (EZ-USB)\n    </strong>\n</th>\n<th>\n<strong>\n     CY7C646xx (EZ-USB-FX)\n    </strong>\n</th>\n<th>\n<strong>\n     CY7C68013 (EZ-USB-FX2)\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     Speed\n    </strong>\n</td>\n<td>\n    Full\n   </td>\n<td>\n    Full\n   </td>\n<td>\n    Full/High\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Number of Endpoints\n    </strong>\n</td>\n<td>\n    13, 16, 31\n   </td>\n<td>\n    31\n   </td>\n<td>\n    11\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Compatibility\n    </strong>\n</td>\n<td>\n    80C320, 8051\n   </td>\n<td>\n    80C320, 8051\n   </td>\n<td>\n    80C320, 8051\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     RAM (bytes)\n    </strong>\n</td>\n<td>\n    256 + 4-8K combined data and program memory\n   </td>\n<td>\n    256 + 4-8K combined data and program memory\n   </td>\n<td>\n    256 + 8K combined data and program memory\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Program Memory Type\n    </strong>\n</td>\n<td>\n    RAM, serial EEPROM, external parallel\n   </td>\n<td>\n    RAM, serial EEPROM, external parallel\n   </td>\n<td>\n    RAM, serial EEPROM, external parallel\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Internal Program Memory (bytes)\n    </strong>\n</td>\n<td>\n    4\u20138K combined data and program memory\n   </td>\n<td>\n    4\u20138K combined data and program memory\n   </td>\n<td>\n    8K combined data and program memory\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     External Memory Bus (bytes)\n    </strong>\n</td>\n<td>\n    64K\n   </td>\n<td>\n    64K\n   </td>\n<td>\n    one or two 64K buses\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     General-purpose I/O Pins\n    </strong>\n</td>\n<td>\n    16\u201324\n   </td>\n<td>\n    16\u201340\n   </td>\n<td>\n    16\u201340\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Other I/O\n    </strong>\n</td>\n<td>\n    2 UARTs, I2C\n   </td>\n<td>\n    2 UARTs, I2C\n   </td>\n<td>\n    2 UARTs, I2C\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Power Supply Voltage\n    </strong>\n</td>\n<td>\n    3\u20133.6V\n   </td>\n<td>\n    3\u20133.6V\n   </td>\n<td>\n    3\u20133.6V\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Number of Pins\n    </strong>\n</td>\n<td>\n    44, 48, 80\n   </td>\n<td>\n    52, 80, 128\n   </td>\n<td>\n    56, 100, 128\n   </td>\n</tr>\n</tbody>\n</table>\n<h4>\n Key Features:\n</h4>\n<ul>\n<li>\n<strong>\n   Program Memory\n  </strong>\n  : Each series offers flexibility in memory configuration, allowing the use of internal and external memory to suit the specific needs of your application.\n </li>\n<li>\n<strong>\n   End Point Count\n  </strong>\n  : Different chips within the EZ-USB family support varying numbers of endpoints, with the more advanced FX2 series supporting the highest number of endpoints for complex data transfers.\n </li>\n<li>\n<strong>\n   External Bus Support\n  </strong>\n  : The chips support external memory buses, allowing the use of up to two\n  <strong>\n   64K external memory buses\n  </strong>\n  , useful for applications that need more program or data storage.\n </li>\n<li>\n<strong>\n   I/O Options\n  </strong>\n  : The series provides a range of general-purpose I/O pins (16-40) and additional communication interfaces like\n  <strong>\n   UARTs\n  </strong>\n  and\n  <strong>\n   I2C\n  </strong>\n  for enhanced flexibility.\n </li>\n<li>\n<strong>\n   Voltage\n  </strong>\n  : All chips within the EZ-USB family operate on a\n  <strong>\n   3\u20133.6V\n  </strong>\n  power supply, ensuring compatibility with modern low-voltage devices.\n </li>\n</ul>\n<h3>\n Conclusion\n</h3>\n<p>\n The\n <strong>\n  EZ-USB family\n </strong>\n from Cypress provides a broad range of USB controller chips with flexible options for memory, I/O, and transfer speeds. Their ability to load firmware from the host on boot-up makes them especially adaptable for dynamic applications. The enumeration process may seem more complex compared to other USB controllers, but it provides significant flexibility and allows the device to function without pre-stored firmware, making it an excellent\n</p>\n"}, "Page 182": {"response": "<h3>\n EZ-USB Firmware Loading and Modes of Operation\n</h3>\n<p>\n The\n <strong>\n  EZ-USB family\n </strong>\n offers several options for firmware loading, enabling devices to operate with different configurations depending on their needs. These options are determined by the contents of external memory and the state of certain input pins, such as the\n <strong>\n  EA (External Access)\n </strong>\n pin. Below is a detailed explanation of how the\n <strong>\n  EZ-USB core\n </strong>\n works and the different modes it can operate in.\n</p>\n<h4>\n Firmware Loading and Control Process\n</h4>\n<p>\n The EZ-USB core provides flexibility in how it loads firmware during the device\u2019s initialization:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Initial Firmware Source\n   </strong>\n   : On power-up, the\n   <strong>\n    EZ-USB core\n   </strong>\n   attempts to read the first few bytes from a serial EEPROM via the chip\u2019s\n   <strong>\n    I2C interface\n   </strong>\n   . These bytes, combined with the state of the\n   <strong>\n    EA input\n   </strong>\n   , determine how the firmware is loaded. The options include using the default mode, loading firmware from an external EEPROM, loading it from the host device, or using boot code from an external memory bus (parallel data bus).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    ReNum Register\n   </strong>\n   : The\n   <strong>\n    ReNum\n   </strong>\n   register is crucial for determining which core (EZ-USB or 8051) will respond to endpoint 0 requests:\n  </p>\n<ul>\n<li>\n    On power-up,\n    <strong>\n     ReNum\n    </strong>\n    is set to\n    <strong>\n     zero\n    </strong>\n    , so the\n    <strong>\n     EZ-USB core\n    </strong>\n    takes control of\n    <strong>\n     Endpoint 0\n    </strong>\n    .\n   </li>\n<li>\n    When\n    <strong>\n     ReNum\n    </strong>\n    is set to\n    <strong>\n     one\n    </strong>\n    , the\n    <strong>\n     8051 core\n    </strong>\n    assumes control of\n    <strong>\n     Endpoint 0\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Default Mode\n</h4>\n<p>\n The\n <strong>\n  default mode\n </strong>\n is a fallback configuration that allows the device to operate without relying on external memory or firmware:\n</p>\n<ul>\n<li>\n<strong>\n   Operation\n  </strong>\n  : In this mode, the\n  <strong>\n   EZ-USB core\n  </strong>\n  is responsible for responding to USB enumeration requests. The\n  <strong>\n   8051 core\n  </strong>\n  is held in a reset state during this phase, ensuring that it doesn\u2019t interfere with the enumeration process.\n </li>\n<li>\n<strong>\n   Conditions for Default Mode\n  </strong>\n  : The chip enters this mode under the following conditions:\n  <ul>\n<li>\n    The\n    <strong>\n     EA\n    </strong>\n    input is\n    <strong>\n     low\n    </strong>\n    .\n   </li>\n<li>\n    Either the\n    <strong>\n     serial EEPROM\n    </strong>\n    is not detected or the first byte read from the EEPROM is not\n    <strong>\n     B0h\n    </strong>\n    or\n    <strong>\n     B2h\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n  Once the device is enumerated, the\n  <strong>\n   EZ-USB core\n  </strong>\n  will handle the requests from the host, while the\n  <strong>\n   8051 core\n  </strong>\n  remains in the reset state, controlled by a register bit within the chip.\n </li>\n</ul>\n<h4>\n Host Communication and Driver Loading\n</h4>\n<p>\n When the\n <strong>\n  EZ-USB core\n </strong>\n is operating in default mode, the device is recognized by the host as a\n <strong>\n  Default USB Device\n </strong>\n :\n</p>\n<ul>\n<li>\n  The host retrieves the device descriptors and identifies the device using the\n  <strong>\n   Vendor ID\n  </strong>\n  and\n  <strong>\n   Product ID\n  </strong>\n  values. These values are matched against those in a provided\n  <strong>\n   INF file\n  </strong>\n  .\n </li>\n<li>\n  Based on the device\u2019s\n  <strong>\n   Vendor ID\n  </strong>\n  and\n  <strong>\n   Product ID\n  </strong>\n  , the host can load a\n  <strong>\n   Cypress general-purpose driver\n  </strong>\n  (either the\n  <strong>\n   CyUsb driver\n  </strong>\n  or the older\n  <strong>\n   General Purpose Driver\n  </strong>\n  ).\n </li>\n<li>\n  The\n  <strong>\n   ReNum bit\n  </strong>\n  remains set to\n  <strong>\n   zero\n  </strong>\n  , allowing the\n  <strong>\n   EZ-USB core\n  </strong>\n  to manage communications while the\n  <strong>\n   8051 core\n  </strong>\n  remains inactive.\n </li>\n</ul>\n<h4>\n Summary of Operation Modes\n</h4>\n<p>\n The\n <strong>\n  EZ-USB\n </strong>\n family can operate in several modes, with the primary ones being:\n</p>\n<ul>\n<li>\n<strong>\n   Default Mode\n  </strong>\n  : Basic operation using no external memory, where the EZ-USB core handles enumeration and communication, and the 8051 core remains inactive.\n </li>\n<li>\n<strong>\n   Firmware from Host\n  </strong>\n  : If the device is configured to load firmware from the host, it will enumerate twice, with the host transferring the necessary firmware.\n </li>\n<li>\n<strong>\n   Firmware from EEPROM\n  </strong>\n  : The device can also load firmware from an external EEPROM if specified by the state of the\n  <strong>\n   EA\n  </strong>\n  pin and the contents of the EEPROM.\n </li>\n<li>\n<strong>\n   Boot from Code Memory\n  </strong>\n  : The chip can also boot from an external parallel memory bus if configured for that operation.\n </li>\n</ul>\n<p>\n Each of these modes offer\n</p>\n"}, "Page 183": {"response": "<h3>\n EZ-USB Firmware Loading and Modes of Operation (Continued)\n</h3>\n<p>\n The\n <strong>\n  EZ-USB family\n </strong>\n provides several ways to load firmware, offering flexibility depending on the application. Below is a more detailed explanation of the modes and their applications, including the\n <strong>\n  default mode\n </strong>\n and the\n <strong>\n  firmware loading from the host\n </strong>\n .\n</p>\n<h4>\n Default Mode (for Debugging)\n</h4>\n<p>\n The\n <strong>\n  Default Mode\n </strong>\n is mainly used for debugging purposes. It allows the USB interface to start functioning and supports data transfers, even without writing any custom firmware or device drivers. Here's how it works:\n</p>\n<ul>\n<li>\n<strong>\n   Basic Functionality\n  </strong>\n  : In\n  <strong>\n   Default Mode\n  </strong>\n  , the\n  <strong>\n   EZ-USB core\n  </strong>\n  takes control of the device\u2019s communications. It supports\n  <strong>\n   Endpoint 0\n  </strong>\n  transfers and can use the other three USB transfer types on additional endpoints.\n </li>\n<li>\n<strong>\n   No Firmware Required\n  </strong>\n  : This mode is ideal for initial testing and debugging, as no custom device drivers or firmware need to be written to transfer data.\n </li>\n</ul>\n<h4>\n Loading Firmware from the Host\n</h4>\n<p>\n In addition to\n <strong>\n  Default Mode\n </strong>\n , the\n <strong>\n  EZ-USB\n </strong>\n core can load firmware from the host system during\n <strong>\n  device enumeration\n </strong>\n . Here\u2019s how the process works:\n</p>\n<ul>\n<li>\n<strong>\n   Power-Up Process\n  </strong>\n  : Upon power-up, the\n  <strong>\n   EZ-USB core\n  </strong>\n  reads identifying bytes from the serial EEPROM (if available). The first byte determines how the firmware will be loaded.\n  <ul>\n<li>\n    If the first byte is\n    <strong>\n     B0h\n    </strong>\n    , the chip reads additional bytes from the EEPROM to get the\n    <strong>\n     Vendor ID\n    </strong>\n    ,\n    <strong>\n     Product ID\n    </strong>\n    , and\n    <strong>\n     release number\n    </strong>\n    . These values help the host locate the correct\n    <strong>\n     INF file\n    </strong>\n    , which contains instructions for the host to download firmware to the device.\n   </li>\n<li>\n    The\n    <strong>\n     INF file\n    </strong>\n    instructs the host to use a\n    <strong>\n     vendor-specific Firmware Load\n    </strong>\n    request to send the necessary firmware to the device.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Firmware Loading\n  </strong>\n  : The downloaded firmware includes updated\n  <strong>\n   descriptors\n  </strong>\n  and the\n  <strong>\n   device code\n  </strong>\n  . For example, a\n  <strong>\n   HID (Human Interface Device)\n  </strong>\n  may receive a\n  <strong>\n   report descriptor\n  </strong>\n  and the code to transfer\n  <strong>\n   HID report data\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Post-Download Actions\n  </strong>\n  : After the firmware is successfully transferred, the\n  <strong>\n   host driver\n  </strong>\n  triggers the device to exit the\n  <strong>\n   reset state\n  </strong>\n  by writing to a register. This action activates the new firmware, and the device begins running it.\n </li>\n</ul>\n<h4>\n Firmware Sources for EZ-USB\n</h4>\n<p>\n The\n <strong>\n  EZ-USB core\n </strong>\n can load firmware from different sources depending on the configuration. These sources are controlled by the state of the\n <strong>\n  EA pin\n </strong>\n and the first byte read from the\n <strong>\n  serial EEPROM\n </strong>\n (if available). Below is a breakdown of the firmware source options:\n</p>\n<table>\n<thead>\n<tr>\n<th>\n    Firmware Source\n   </th>\n<th>\n    EA Pin State\n   </th>\n<th>\n    First Byte in Serial EEPROM\n   </th>\n<th>\n    Notes\n   </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     Load from Host\n    </strong>\n</td>\n<td>\n    Don\u2019t care\n   </td>\n<td>\n    EZ-USB: B0h, EZ-USB-FX: B4h, EZ-USB-FX2: C0h\n   </td>\n<td>\n    Host downloads firmware after identifying Vendor ID and Product ID.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Load from Serial EEPROM\n    </strong>\n</td>\n<td>\n    Don\u2019t care\n   </td>\n<td>\n    EZ-USB: B2h, EZ-USB-FX: B6h, EZ-USB-FX2: C2h\n   </td>\n<td>\n    Firmware loaded directly from the EEPROM.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Default USB Device\n    </strong>\n</td>\n<td>\n    Low (L)\n   </td>\n<td>\n    No EEPROM present or invalid first byte\n   </td>\n<td>\n    Device operates in Default Mode without external firmware.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     External Parallel Memory\n    </strong>\n</td>\n<td>\n    High (H)\n   </td>\n<td>\n    No EEPROM present or invalid first byte\n   </td>\n<td>\n    Firmware loaded from an external parallel memory bus.\n   </td>\n</tr>\n</tbody>\n</table>\n<h4>\n Summary\n</h4>\n<p>\n The\n <strong>\n  EZ-USB family\n </strong>\n is designed for flexibility in loading firmware, allowing you to choose the best option based on your device and development needs. Whether you are debugging with the\n <strong>\n  Default Mode\n </strong>\n , loading firmware from the host system, or utilizing external memory sources, the\n <strong>\n  EZ-USB\n </strong>\n core ensures that the device is capable of running the n\n</p>\n"}, "Page 184": {"response": "<h3>\n EZ-USB Firmware Loading Modes: Emulating Re-Attachment and Other Options\n</h3>\n<p>\n The\n <strong>\n  EZ-USB family\n </strong>\n offers a variety of methods for loading firmware, including options for emulating device attachment and using external storage like EEPROM or parallel memory. Here's a detailed breakdown of these additional modes of operation.\n</p>\n<h4>\n Emulating Device Re-Attachment\n</h4>\n<p>\n The\n <strong>\n  DISCON# pin\n </strong>\n in the\n <strong>\n  EZ-USB\n </strong>\n family can be used to emulate the device being removed from and re-attached to the USB bus. Here\u2019s how it works:\n</p>\n<ul>\n<li>\n<strong>\n   Emulation Process\n  </strong>\n  : The firmware controls the\n  <strong>\n   DISCON# pin\n  </strong>\n  to either pull it up or allow it to float. When the pin is pulled up, it signals that the device is attached to the bus, and when it floats, it signals device removal.\n </li>\n<li>\n<strong>\n   Re-enumeration\n  </strong>\n  : By setting the\n  <strong>\n   ReNum bit\n  </strong>\n  to\n  <strong>\n   1\n  </strong>\n  , the firmware ensures that the\n  <strong>\n   8051 core\n  </strong>\n  responds to requests at\n  <strong>\n   Endpoint 0\n  </strong>\n  instead of the\n  <strong>\n   EZ-USB core\n  </strong>\n  . This triggers the host to re-enumerate the device, allowing the updated descriptors to be retrieved.\n </li>\n<li>\n<strong>\n   Advantages\n  </strong>\n  : The primary benefit of this method is the ability to easily update the firmware stored on the host. You can simply store the new version on the host, and the\n  <strong>\n   driver\n  </strong>\n  will send the updated firmware to the device during the next power-up or attachment.\n </li>\n<li>\n<strong>\n   Disadvantages\n  </strong>\n  : While the process allows easy firmware updates, it introduces more complexity into the device driver. Additionally, the host must have the firmware available, and the enumeration time is longer.\n </li>\n</ul>\n<h4>\n Loading Firmware from EEPROM\n</h4>\n<p>\n Another method to store firmware involves using an external\n <strong>\n  serial EEPROM\n </strong>\n . Here\u2019s how the process works:\n</p>\n<ul>\n<li>\n<strong>\n   EEPROM Contents\n  </strong>\n  : If the\n  <strong>\n   first byte\n  </strong>\n  read from the EEPROM is\n  <strong>\n   B2h\n  </strong>\n  , the\n  <strong>\n   EZ-USB core\n  </strong>\n  loads the entire contents of the EEPROM into\n  <strong>\n   RAM\n  </strong>\n  upon power-up. This EEPROM must contain:\n  <ul>\n<li>\n    The\n    <strong>\n     Vendor ID\n    </strong>\n    ,\n    <strong>\n     Product ID\n    </strong>\n    , and\n    <strong>\n     release number\n    </strong>\n</li>\n<li>\n    All the\n    <strong>\n     descriptors\n    </strong>\n    required for enumeration\n   </li>\n<li>\n    Any other necessary\n    <strong>\n     firmware\n    </strong>\n    or\n    <strong>\n     data\n    </strong>\n    for USB communication.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Device Initialization\n  </strong>\n  : Once the EEPROM is loaded into RAM, the device exits the\n  <strong>\n   reset state\n  </strong>\n  , and the\n  <strong>\n   ReNum bit\n  </strong>\n  is set to\n  <strong>\n   1\n  </strong>\n  , which enables the\n  <strong>\n   8051 core\n  </strong>\n  to control the device. During enumeration, the host reads the descriptors from the loaded firmware and loads the appropriate device driver.\n </li>\n<li>\n<strong>\n   No Re-enumeration\n  </strong>\n  : Unlike other methods, when using EEPROM to load the firmware, there is no re-enumeration after loading the firmware.\n </li>\n</ul>\n<h4>\n Running Code from External Parallel Memory\n</h4>\n<p>\n If the\n <strong>\n  EZ-USB core\n </strong>\n does not detect an EEPROM or the first byte from the EEPROM isn\u2019t valid (not\n <strong>\n  B0h\n </strong>\n or\n <strong>\n  B2h\n </strong>\n ), and if the\n <strong>\n  EA pin\n </strong>\n is logic high, the device will boot from\n <strong>\n  external parallel memory\n </strong>\n . Here\u2019s how this works:\n</p>\n<ul>\n<li>\n<strong>\n   External Memory\n  </strong>\n  : This memory can be one of several types, including\n  <strong>\n   EPROM\n  </strong>\n  ,\n  <strong>\n   EEPROM\n  </strong>\n  ,\n  <strong>\n   Flash memory\n  </strong>\n  , or\n  <strong>\n   battery-backed RAM\n  </strong>\n  . The memory contains all necessary firmware, including descriptors and other data required for the device to function.\n </li>\n<li>\n<strong>\n   ReNum and Enumeration\n  </strong>\n  : The\n  <strong>\n   ReNum bit\n  </strong>\n  is set to\n  <strong>\n   1\n  </strong>\n  , and the device is enumerated by the host, which loads the appropriate device driver. Like the EEPROM method, there is\n  <strong>\n   no re-enumeration\n  </strong>\n  after the firmware is loaded.\n </li>\n</ul>\n<h4>\n Summary\n</h4>\n<p>\n The\n <strong>\n  EZ-USB family\n </strong>\n provides multiple methods for loading firmware, each suited to different use cases:\n</p>\n<ol>\n<li>\n<strong>\n   Emulated Re-Attachment\n  </strong>\n  : Easily update firmware stored on the host, but requires a more complex device driver and longer enumeration time.\n </li>\n<li>\n<strong>\n   Load from EEPROM\n  </strong>\n  : Store firmware in an external EEPROM and load it into RAM during power-up for immediate USB communication.\n </li>\n<li>\n<strong>\n   Run Code from External Memory\n  </strong>\n  : Use external parallel memory for firmware storage when no EEPROM is present or valid.\n </li>\n</ol>\n<p>\n These options allow developers to choose the most suitable firmware loading method for their device\u2019s requirements and the specific capabilities of\n</p>\n"}, "Page 185": {"response": "<h3>\n Cypress enCoRe II: Low-Speed USB Controllers\n</h3>\n<p>\n The\n <strong>\n  Cypress enCoRe II\n </strong>\n series offers cost-effective, low-speed USB controllers optimized for USB communication. These controllers are designed for applications where basic USB functionality is required, with a focus on simplicity and low power consumption.\n</p>\n<h4>\n CPU Architecture\n</h4>\n<p>\n The\n <strong>\n  enCoRe II\n </strong>\n series is an updated version of Cypress\u2019s original\n <strong>\n  enCoRe\n </strong>\n controllers. The key difference is that the\n <strong>\n  enCoRe II\n </strong>\n chips feature\n <strong>\n  Flash memory\n </strong>\n for program storage instead of the\n <strong>\n  OTP EPROM\n </strong>\n used in earlier models. Here are the main aspects of the chip's architecture:\n</p>\n<ul>\n<li>\n<strong>\n   Instruction Set\n  </strong>\n  : The architecture is proprietary to Cypress, meaning that developers must learn a new assembly language instruction set if they are programming at that level. However, the instruction set is compact and should be easy to learn for those with experience in assembly programming. Additionally, a C compiler is available for easier development.\n </li>\n<li>\n<strong>\n   Chip Variants\n  </strong>\n  : The\n  <strong>\n   enCoRe II\n  </strong>\n  series includes chips with different amounts of\n  <strong>\n   program memory\n  </strong>\n  ,\n  <strong>\n   I/O pins\n  </strong>\n  , and packaging options. For example:\n  <ul>\n<li>\n<strong>\n     Up to 256 bytes of RAM\n    </strong>\n</li>\n<li>\n<strong>\n     8 kilobytes of Flash memory\n    </strong>\n</li>\n<li>\n<strong>\n     Up to 36 I/O pins\n    </strong>\n    , with two pins dedicated to the USB interface.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Internal Oscillators\n  </strong>\n  : These controllers come with built-in oscillators, eliminating the need for external crystals or resonators.\n </li>\n<li>\n<strong>\n   Dual Functionality for USB Pins\n  </strong>\n  : When the chip is not in USB mode, the two USB pins can serve as an interface for\n  <strong>\n   serial programming\n  </strong>\n  mode, enabling Flash programming directly.\n </li>\n</ul>\n<h4>\n USB Controller Features\n</h4>\n<p>\n The\n <strong>\n  enCoRe II\n </strong>\n controllers support basic USB functionality with limited endpoints:\n</p>\n<ul>\n<li>\n<strong>\n   Three Endpoints\n  </strong>\n  :\n  <ul>\n<li>\n    Endpoint 0 is required for all USB devices.\n   </li>\n<li>\n<strong>\n     Endpoints 1 and 2\n    </strong>\n    are designated for\n    <strong>\n     interrupt transfers\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Interrupt Transfers\n  </strong>\n  : The chip supports either:\n  <ul>\n<li>\n    One interrupt\n    <strong>\n     IN\n    </strong>\n    endpoint and one interrupt\n    <strong>\n     OUT\n    </strong>\n    endpoint, or\n   </li>\n<li>\n    Two interrupt endpoints in the same direction.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Buffer Size\n  </strong>\n  : Each of these endpoints has an\n  <strong>\n   8-byte buffer\n  </strong>\n  in RAM, allowing small data packets to be transferred efficiently.\n </li>\n<li>\n<strong>\n   Firmware Support\n  </strong>\n  : Since USB communication requires significant firmware support,\n  <strong>\n   example code\n  </strong>\n  is provided to help developers get started with using the\n  <strong>\n   enCoRe II\n  </strong>\n  controllers.\n </li>\n</ul>\n<p>\n In summary, the\n <strong>\n  Cypress enCoRe II\n </strong>\n chips are designed for low-cost, low-speed USB applications, offering flexible program memory options and a simple USB controller with minimal endpoints. They are ideal for projects requiring basic USB functionality with low power\n</p>\n"}, "Page 186": {"response": "<h3>\n Freescale MC68HC908JB16: Low-Speed USB Microcontroller\n</h3>\n<p>\n The\n <strong>\n  Freescale MC68HC908JB16\n </strong>\n is a low-speed USB microcontroller from Freescale\u2019s\n <strong>\n  MC68HC08\n </strong>\n family. This family of 8-bit microcontrollers is designed to be an upgrade from the older\n <strong>\n  MC68HC05\n </strong>\n series, offering better performance and efficiency. Freescale Semiconductor, which was formed in 2004 after Motorola\u2019s Semiconductor Products sector was spun off, manufactures this chip.\n</p>\n<h4>\n Architecture\n</h4>\n<ul>\n<li>\n<strong>\n   Flash Memory\n  </strong>\n  : The\n  <strong>\n   MC68HC908JB16\n  </strong>\n  includes\n  <strong>\n   16 kilobytes of Flash memory\n  </strong>\n  , which allows for program storage and easy updating.\n </li>\n<li>\n<strong>\n   I/O Pins\n  </strong>\n  : This microcontroller has\n  <strong>\n   21 I/O pins\n  </strong>\n  in total. Among these, two pins are dedicated to the\n  <strong>\n   USB interface\n  </strong>\n  , while the others support various functions such as\n  <strong>\n   synchronous serial communication\n  </strong>\n  and\n  <strong>\n   keyboard interfaces\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Monitor ROM\n  </strong>\n  : The chip includes a\n  <strong>\n   monitor ROM\n  </strong>\n  , which allows for\n  <strong>\n   Flash-memory programming\n  </strong>\n  and\n  <strong>\n   debugging\n  </strong>\n  over an\n  <strong>\n   asynchronous serial interface\n  </strong>\n  using a single pin on the chip.\n </li>\n</ul>\n<h4>\n USB Controller\n</h4>\n<ul>\n<li>\n<strong>\n   Low-Speed USB\n  </strong>\n  : The\n  <strong>\n   MC68HC908JB16\n  </strong>\n  features a\n  <strong>\n   low-speed USB controller\n  </strong>\n  that supports:\n  <ul>\n<li>\n<strong>\n     Endpoint 0\n    </strong>\n    : The standard endpoint required for all USB devices.\n   </li>\n<li>\n<strong>\n     One Interrupt IN Endpoint\n    </strong>\n    : This endpoint is used for interrupt-driven data transfers.\n   </li>\n<li>\n<strong>\n     One Configurable Endpoint\n    </strong>\n    : This can be set as either an\n    <strong>\n     interrupt IN\n    </strong>\n    or\n    <strong>\n     interrupt OUT\n    </strong>\n    endpoint.\n   </li>\n</ul>\n</li>\n</ul>\n<hr/>\n<h3>\n Freescale MCF5482 ColdFire: High-End USB Controller\n</h3>\n<p>\n The\n <strong>\n  Freescale MCF5482 ColdFire\n </strong>\n is a high-performance\n <strong>\n  32-bit microprocessor\n </strong>\n that offers\n <strong>\n  full/high-speed USB capabilities\n </strong>\n . It integrates a range of features, making it suitable for more advanced applications.\n</p>\n<h4>\n Architecture\n</h4>\n<ul>\n<li>\n<strong>\n   32-bit CPU\n  </strong>\n  : The\n  <strong>\n   MCF5482 ColdFire\n  </strong>\n  chip is powered by a\n  <strong>\n   32-bit CPU\n  </strong>\n  , offering substantial computational power compared to 8-bit microcontrollers.\n </li>\n<li>\n<strong>\n   USB Controller\n  </strong>\n  : This microprocessor includes a\n  <strong>\n   full/high-speed USB device controller\n  </strong>\n  , making it capable of supporting faster data transfer speeds compared to low-speed USB controllers.\n </li>\n<li>\n<strong>\n   Ethernet Controller\n  </strong>\n  : The chip also comes with an\n  <strong>\n   Ethernet controller\n  </strong>\n  , providing additional connectivity options.\n </li>\n<li>\n<strong>\n   Request Processor\n  </strong>\n  : A built-in\n  <strong>\n   request processor\n  </strong>\n  automates the handling of many standard USB requests. For instance, when the\n  <strong>\n   Get_Descriptor\n  </strong>\n  request is received, the request processor retrieves the requested descriptor from RAM and returns it to the host automatically.\n </li>\n<li>\n<strong>\n   Endpoint Support\n  </strong>\n  : The\n  <strong>\n   MCF5482\n  </strong>\n  supports\n  <strong>\n   Endpoint 0\n  </strong>\n  and\n  <strong>\n   seven additional endpoint addresses\n  </strong>\n  , allowing for more complex data transfers.\n </li>\n</ul>\n<p>\n In summary, the\n <strong>\n  Freescale MC68HC908JB16\n </strong>\n is a low-cost, low-speed USB controller suited for basic USB applications, while the\n <strong>\n  MCF5482 ColdFire\n </strong>\n is a more advanced microprocessor with support for full/high-speed USB and additional features like Ethernet, making it ide\n</p>\n"}, "Page 187": {"response": "<h3>\n Controllers That Interface with External CPUs\n</h3>\n<p>\n Controllers that interface with an external CPU provide a way to add USB functionality to systems where the CPU and USB controller are separate. This approach offers flexibility but comes with trade-offs, as it requires two chips instead of a single chip solution where the CPU and USB controller are combined. Additionally, using an external CPU means that example circuits and code for USB communications may not be readily available, making development potentially more complex.\n</p>\n<h4>\n Key Features\n</h4>\n<ul>\n<li>\n<strong>\n   Command Set or Registers\n  </strong>\n  : The external CPU interacts with the USB controller via a command set or registers that store USB-related data, configuration settings, status, and control information.\n </li>\n<li>\n<strong>\n   Data Bus\n  </strong>\n  : Most interface chips have a local data bus, typically a parallel interface, to communicate with the CPU.\n </li>\n<li>\n<strong>\n   Direct Memory Access (DMA)\n  </strong>\n  : Many interface chips support\n  <strong>\n   DMA\n  </strong>\n  , allowing the CPU to transfer data blocks to and from memory without actively managing the transfer, which speeds up data handling.\n </li>\n<li>\n<strong>\n   Serial Interfaces\n  </strong>\n  : Some controllers, particularly when the CPU doesn't have a parallel bus, can use synchronous or asynchronous serial interfaces for communication.\n </li>\n<li>\n<strong>\n   Interrupts\n  </strong>\n  : An interrupt pin can signal the CPU when the USB controller has received data or when it needs to send data, allowing the CPU to manage the process efficiently.\n </li>\n</ul>\n<h3>\n National Semiconductor USBN9603\n</h3>\n<p>\n The\n <strong>\n  USBN9603\n </strong>\n from National Semiconductor is an interface chip designed to connect a CPU to USB functionality. It offers flexibility in terms of how it communicates with the CPU and is capable of interfacing with various types of CPUs, including those with parallel data buses, Microwire interfaces, or even just a few I/O pins controlled by firmware.\n</p>\n<h4>\n Architecture\n</h4>\n<ul>\n<li>\n<strong>\n   Serial Interface Engine\n  </strong>\n  : The USBN9603 features a\n  <strong>\n   serial interface engine\n  </strong>\n  (SIE) that handles the USB communication protocol, managing the exchange of data with the USB host.\n </li>\n<li>\n<strong>\n   USB Endpoint Buffers\n  </strong>\n  : The chip includes\n  <strong>\n   endpoint buffers\n  </strong>\n  that store data for USB transactions.\n </li>\n<li>\n<strong>\n   Registers for Control and Status\n  </strong>\n  : It also features\n  <strong>\n   status and control registers\n  </strong>\n  that allow the CPU to configure and monitor the USB operations.\n </li>\n</ul>\n<p>\n In summary, the\n <strong>\n  USBN9603\n </strong>\n allows a wide range of microcontrollers to interface with USB, making it a versatile solution for adding USB support to various CPU-based systems. However, it requires handling communication between the CPU and the controller, which can be more complex compared to\n</p>\n"}, "Page 188": {"response": "<h3>\n National Semiconductor USBN9603: Data Bus and Interface Options\n</h3>\n<p>\n The\n <strong>\n  USBN9603\n </strong>\n chip from National Semiconductor is designed to interface with CPUs through various data bus configurations. It includes a serial interface engine (SIE), endpoint buffers, and status/control registers that can be accessed through an external local bus.\n</p>\n<h4>\n Data Bus Access Options\n</h4>\n<p>\n The USBN9603 offers three different options for accessing the local data bus:\n</p>\n<ol>\n<li>\n<strong>\n   Non-Multiplexed Parallel\n  </strong>\n  : A direct, non-multiplexed parallel connection for communicating with the CPU.\n </li>\n<li>\n<strong>\n   Multiplexed Parallel\n  </strong>\n  : A parallel connection where data lines are shared for multiple purposes, requiring some additional logic for interfacing with the CPU.\n </li>\n<li>\n<strong>\n   Microwire Synchronous Serial\n  </strong>\n  : A synchronous serial interface that requires fewer pins (just four) and is ideal for CPUs that lack an external data bus.\n </li>\n</ol>\n<h4>\n High-Speed Data Transfers\n</h4>\n<p>\n For systems that need faster data transfers, the chip supports\n <strong>\n  burst mode\n </strong>\n , where the CPU writes a starting address and then transmits or receives multiple consecutive bytes in a single operation. This mode allows for efficient data handling but requires the CPU to support burst transfers and the external data bus to be fast enough for the required USB throughput.\n</p>\n<p>\n Parallel interfaces also support\n <strong>\n  DMA (Direct Memory Access)\n </strong>\n , further improving data transfer efficiency by allowing the transfer of data to or from memory without CPU involvement.\n</p>\n<h4>\n Microwire Interface for Microcontrollers Without External Data Bus\n</h4>\n<p>\n For microcontrollers that do not have an external parallel bus, the\n <strong>\n  Microwire interface\n </strong>\n provides a solution using just four I/O pins:\n</p>\n<ul>\n<li>\n<strong>\n   SIN (Serial In)\n  </strong>\n  : Data input\n </li>\n<li>\n<strong>\n   SOUT (Serial Out)\n  </strong>\n  : Data output\n </li>\n<li>\n<strong>\n   CS (Chip Select)\n  </strong>\n  : Used to select the chip\n </li>\n<li>\n<strong>\n   SYNC (Clock)\n  </strong>\n  : Provides timing for data shifts\n </li>\n</ul>\n<p>\n With Microwire, data and command bytes shift in and out bit by bit, with the\n <strong>\n  SYNC\n </strong>\n line acting as the timing reference. The CPU controls the SYNC line and can toggle the signal as needed, as long as the timing can keep up with USB traffic. This option is ideal for systems with limited I/O pins or for cases where only small data blocks are transferred occasionally.\n</p>\n<h4>\n Summary\n</h4>\n<p>\n The\n <strong>\n  USBN9603\n </strong>\n is a versatile interface chip offering multiple methods to connect CPUs to USB systems. It supports full-speed data transfers through parallel and serial communication methods. The ability to handle burst mode and DMA transfers makes it ideal for high-speed applications, while the Microwire interface allows use with microcontrollers with limited I/O pins.\n</p>\n<hr/>\n<h3>\n Table 6-4: USB Controllers That Interface to an External CPU\n</h3>\n<p>\n The following table compares various USB controllers that interface with an external CPU. These chips provide flexibility in integrating USB into systems with different types of CPUs:\n</p>\n<table>\n<thead>\n<tr>\n<th>\n    Company\n   </th>\n<th>\n    Chips\n   </th>\n<th>\n    CPU Interface\n   </th>\n<th>\n    Bus Speed\n   </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     Agere Systems\n    </strong>\n</td>\n<td>\n    USS-820D\n   </td>\n<td>\n    Parallel\n   </td>\n<td>\n    Full\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     FTDI Chip\n    </strong>\n</td>\n<td>\n    FT232BM, FT245BM\n   </td>\n<td>\n    Asynchronous serial\n   </td>\n<td>\n    Full\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     National Semiconductor\n    </strong>\n</td>\n<td>\n    USBN9603/4\n   </td>\n<td>\n    Parallel, Microwire\n   </td>\n<td>\n    Full\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Philips Semiconductors\n    </strong>\n</td>\n<td>\n    PDIUSBD12, ISP1181/83\n   </td>\n<td>\n    Parallel\n   </td>\n<td>\n    Full\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Philips Semiconductors\n    </strong>\n</td>\n<td>\n    ISP1581\n   </td>\n<td>\n    Parallel\n   </td>\n<td>\n    Full/High\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     PLX Technology\n    </strong>\n</td>\n<td>\n    NET22272\n   </td>\n<td>\n    Parallel\n   </td>\n<td>\n    Full/High\n   </td>\n</tr>\n</tbody>\n</table>\n<p>\n This table highlights a range of options, from full-speed USB controllers that use parallel inte\n</p>\n"}, "Page 189": {"response": "<h3>\n National Semiconductor USBN9603: Endpoint Configuration and Features\n</h3>\n<p>\n The\n <strong>\n  USBN9603\n </strong>\n chip from National Semiconductor supports seven endpoint addresses, which are crucial for handling various types of data transfers in USB communication. The available endpoints are:\n</p>\n<ul>\n<li>\n<strong>\n   Endpoint 0\n  </strong>\n  : This is reserved for control transfers.\n </li>\n<li>\n<strong>\n   Three IN endpoints\n  </strong>\n  : These endpoints allow the chip to send data to the host.\n </li>\n<li>\n<strong>\n   Three OUT endpoints\n  </strong>\n  : These endpoints allow the chip to receive data from the host.\n </li>\n</ul>\n<p>\n Each endpoint has its own buffer, with\n <strong>\n  Endpoint 0\n </strong>\n having an 8-byte buffer, and the other endpoints having 64-byte buffers. The size of these buffers can be exceeded in specific situations:\n</p>\n<ul>\n<li>\n<strong>\n   Receiving data\n  </strong>\n  : If incoming data exceeds the buffer size, the firmware must read the data fast enough to prevent the buffer from overflowing.\n </li>\n<li>\n<strong>\n   Sending data\n  </strong>\n  : Similarly, if a packet sent from the endpoint is larger than the buffer, the firmware must write data fast enough to prevent the buffer from emptying.\n </li>\n</ul>\n<p>\n The\n <strong>\n  USBN9604\n </strong>\n is a variant of the USBN9603, with one key difference: it resets both the chip\u2019s core and clock-generation circuits when reset is triggered. This makes the USBN9604 more suitable for bus-powered devices, as it ensures the clock circuitry is properly reset along with the chip.\n</p>\n<hr/>\n<h3>\n Philips Semiconductors ISP1181B: Full-Speed USB Controller\n</h3>\n<p>\n The\n <strong>\n  ISP1181B\n </strong>\n is a full-speed USB controller from Philips Semiconductors that interfaces with an external CPU via a parallel data bus. The chip has a serial interface engine (SIE) for managing USB traffic and is equipped with a configurable\n <strong>\n  8- or 16-bit data bus\n </strong>\n and a\n <strong>\n  2-bit address bus\n </strong>\n for communication with the CPU.\n</p>\n<h4>\n Architecture and Communication\n</h4>\n<p>\n The ISP1181B uses a command set for communication. When the\n <strong>\n  address bit A0\n </strong>\n is set to 1, the chip interprets the lower byte of the data bus as a command. If the command requires additional data, the CPU sets\n <strong>\n  address bit A0 to 0\n </strong>\n and transfers the required data to or from a register or endpoint buffer.\n</p>\n<p>\n The ISP1181B also supports both\n <strong>\n  multiplexed and non-multiplexed address buses\n </strong>\n and\n <strong>\n  DMA transfers\n </strong>\n , allowing for more efficient data handling, especially in high-speed applications.\n</p>\n<h4>\n Variants\n</h4>\n<p>\n The\n <strong>\n  ISP1183\n </strong>\n is a low-power version of the ISP1181B, with an\n <strong>\n  8-bit data bus\n </strong>\n and only\n <strong>\n  32 pins\n </strong>\n , compared to the 48 pins of the ISP1181B. Another earlier version, the\n <strong>\n  PDIUSBD12\n </strong>\n , is similar in architecture but has a slower data bus and fewer endpoints, making it less capable than the ISP1181B.\n</p>\n<p>\n In summary, the ISP1181B is a powerful, full-speed USB controller suitable for high-performance USB communication, offering flexibility in data bus configuration and supporting features l\n</p>\n"}, "Page 190": {"response": "<h3>\n Philips Semiconductors ISP1181B: USB Controller with Multiple Endpoints\n</h3>\n<p>\n The\n <strong>\n  ISP1181B\n </strong>\n from Philips Semiconductors is a full-speed USB controller that can manage a significant number of endpoints, making it highly flexible for various applications.\n</p>\n<h4>\n USB Controller and Endpoint Management\n</h4>\n<p>\n The USB controller supports\n <strong>\n  Endpoint 0\n </strong>\n (the control endpoint) and up to\n <strong>\n  14 additional endpoint addresses\n </strong>\n . These endpoints share a total of\n <strong>\n  2462 bytes of buffer memory\n </strong>\n . Specifically:\n</p>\n<ul>\n<li>\n<strong>\n   Control Endpoint (Endpoint 0)\n  </strong>\n  : This endpoint is allocated a\n  <strong>\n   64-byte buffer\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Other Endpoints\n  </strong>\n  : The buffer sizes for these endpoints are configurable, allowing customization based on the needs of the application.\n </li>\n<li>\n<strong>\n   Isochronous and Bulk Endpoints\n  </strong>\n  : These endpoints are\n  <strong>\n   double-buffered\n  </strong>\n  to ensure smooth data flow and minimize data loss.\n </li>\n</ul>\n<h4>\n Bus Attachment and Firmware Control\n</h4>\n<p>\n Firmware controls when the chip connects to the USB bus. Initially, the chip appears detached from the bus, and it will remain in this state until the external CPU sends a command to activate an internal\n <strong>\n  pull-up resistor\n </strong>\n on the D+ line. This gives the chip time to initialize after power-up before it is enumerated by the host.\n</p>\n<p>\n A\n <strong>\n  status output\n </strong>\n is available to connect to an LED that provides visual feedback. The LED lights up when a USB connection is established and blinks during data transfers, providing useful status updates.\n</p>\n<hr/>\n<h3>\n Philips Semiconductors ISP1581: Full/High-Speed USB Controller\n</h3>\n<p>\n The\n <strong>\n  ISP1581\n </strong>\n is another USB controller from Philips Semiconductors, supporting both full-speed and high-speed USB. It interfaces with an external CPU via a parallel interface, offering improved performance for high-speed applications.\n</p>\n<h4>\n Architecture and Data Communication\n</h4>\n<p>\n The\n <strong>\n  ISP1581\n </strong>\n features a\n <strong>\n  16-bit data bus\n </strong>\n and an\n <strong>\n  8-bit address bus\n </strong>\n . Communication between the chip and the external CPU is managed through a series of registers, which can be accessed by the CPU.\n</p>\n<p>\n Like the ISP1181B, the ISP1581 supports\n <strong>\n  multiplexed and non-multiplexed address buses\n </strong>\n and\n <strong>\n  DMA transfers\n </strong>\n , providing flexibility and high efficiency in data handling.\n</p>\n<h4>\n USB Controller and Endpoint Support\n</h4>\n<p>\n The USB controller in the ISP1581 supports\n <strong>\n  both full and high speeds\n </strong>\n , making it adaptable for different USB transfer rates. In addition to\n <strong>\n  Endpoint 0\n </strong>\n , the chip can manage up to:\n</p>\n<ul>\n<li>\n<strong>\n   Seven IN endpoint addresses\n  </strong>\n</li>\n<li>\n<strong>\n   Seven OUT endpoint addresses\n  </strong>\n</li>\n</ul>\n<p>\n All of these endpoints share a total of\n <strong>\n  8 kilobytes of buffer memory\n </strong>\n . Specifically:\n</p>\n<ul>\n<li>\n<strong>\n   Control Endpoint (Endpoint 0)\n  </strong>\n  : This endpoint is allocated\n  <strong>\n   64-byte buffers\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Other Endpoints\n  </strong>\n  : The memory for these endpoints is configurable, and any endpoint can use\n  <strong>\n   double buffering\n  </strong>\n  for improved data handling.\n </li>\n</ul>\n<h4>\n Firmware-Controlled Bus Attachment\n</h4>\n<p>\n Similar to the ISP1181B, the\n <strong>\n  ISP1581\n </strong>\n allows the firmware to control when the chip attaches to the USB bus. The chip uses an external\n <strong>\n  pull-up resistor\n </strong>\n connected to its\n <strong>\n  RPU pin\n </strong>\n , which enables the chip to connect to the bus after initialization. This control mechanism ensures the chip is ready for enumeration and communication with the host.\n</p>\n<hr/>\n<h3>\n Summary\n</h3>\n<p>\n Both the\n <strong>\n  ISP1181B\n </strong>\n and\n <strong>\n  ISP1581\n </strong>\n from Philips Semiconductors are capable USB controllers offering full flexibility in terms of endpoint support, buffer management, and communication with external CPUs. They support multiple data transfer modes, can be used with a variety of address bus configurations, and allow firmware-controlled bus attachment. These features make them suitable for a wide range of applicati\n</p>\n"}, "Page 191": {"response": "<h3>\n PLX Technology NET2272: Full/High-Speed USB Controller\n</h3>\n<p>\n The\n <strong>\n  NET2272\n </strong>\n from\n <strong>\n  PLX Technology\n </strong>\n is a\n <strong>\n  full/high-speed USB controller\n </strong>\n that interfaces with an external CPU through a\n <strong>\n  parallel interface\n </strong>\n . It offers advanced features for handling USB data transfers and is designed for use in a variety of USB-enabled applications.\n</p>\n<h4>\n Architecture and Register Access\n</h4>\n<p>\n The\n <strong>\n  NET2272\n </strong>\n uses several\n <strong>\n  registers\n </strong>\n to hold important configuration data and status information. Additionally, it employs\n <strong>\n  packet buffers\n </strong>\n to store USB data that has been received or is ready to be transmitted. The chip communicates with the external CPU using a\n <strong>\n  parallel interface\n </strong>\n that includes\n <strong>\n  5 address bits\n </strong>\n and\n <strong>\n  16 data bits\n </strong>\n . The data transfers to and from the packet buffers can be done in either\n <strong>\n  8-bit\n </strong>\n or\n <strong>\n  16-bit\n </strong>\n sizes.\n</p>\n<p>\n The chip supports three distinct modes for accessing its registers:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Direct Address Mode\n   </strong>\n   : In this mode, the\n   <strong>\n    5 address bits\n   </strong>\n   directly specify the register to be read or written. This is the simplest mode for accessing frequently used registers.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Multiplexed Address Mode\n   </strong>\n   : The register address is placed on the\n   <strong>\n    data bits\n   </strong>\n   , and the chip reads the address on the falling edge of the\n   <strong>\n    ALE\n   </strong>\n   control signal.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Indirect Address Mode\n   </strong>\n   : The\n   <strong>\n    lowest address bit\n   </strong>\n   is used to differentiate between a register address pointer (0) and data (1). First, the CPU writes a register address pointer to specify which configuration register to access, and then it reads or writes data at the address pointed to. This mode allows access to all registers.\n  </p>\n</li>\n</ol>\n<h4>\n Data Transfer and DMA Support\n</h4>\n<p>\n The\n <strong>\n  NET2272\n </strong>\n supports\n <strong>\n  Direct Memory Access (DMA)\n </strong>\n , which allows the CPU to perform high-speed data transfers directly to or from memory without involving the CPU in each transaction. The chip is capable of:\n</p>\n<ul>\n<li>\n<strong>\n   Writing to the NET2272\n  </strong>\n  at speeds up to\n  <strong>\n   60 Megabytes per second\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Reading from the NET2272\n  </strong>\n  at speeds up to\n  <strong>\n   57 Megabytes per second\n  </strong>\n  in DMA mode.\n </li>\n</ul>\n<p>\n These speeds enable fast and efficient data handling, making the NET2272 suitable for high-performance applications.\n</p>\n<h4>\n Accessing Endpoint Data\n</h4>\n<p>\n To interact with endpoint data stored in the packet buffers, the CPU must first\n <strong>\n  select the endpoint\n </strong>\n . This is done by writing to the\n <strong>\n  Endpoint Page Select register\n </strong>\n or the\n <strong>\n  DMA Endpoint Select register\n </strong>\n , depending on the mode of access being used. This selection allows the CPU to read from or write to the specific data associated with the selected endpoint.\n</p>\n<hr/>\n<h3>\n Summary\n</h3>\n<p>\n The\n <strong>\n  NET2272\n </strong>\n from\n <strong>\n  PLX Technology\n </strong>\n is a versatile USB controller that supports full and high-speed USB communication. It features advanced\n <strong>\n  register access modes\n </strong>\n ,\n <strong>\n  DMA support\n </strong>\n , and efficient\n <strong>\n  data transfer speeds\n </strong>\n , making it suitable for high-performance USB devices. The ability to select endpoints and manage data buffers via the registers ensures that the NET2272 can handle a variety of USB communication tasks, from control transfers to\n</p>\n"}, "Page 192": {"response": "<h3>\n FTDI Chip FT232BM and FT245BM: Hardware-Managed USB Interfaces\n</h3>\n<p>\n<strong>\n  FTDI Chip\n </strong>\n offers two unique USB interface controllers: the\n <strong>\n  FT232BM USB UART\n </strong>\n and the\n <strong>\n  FT245BM USB FIFO\n </strong>\n . These chips stand out because they handle most USB communication tasks, such as enumeration, entirely in hardware. This approach minimizes the need for custom firmware, making the chips an attractive option for developers looking for simple and efficient USB solutions.\n</p>\n<h4>\n Key Features:\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    No USB-Specific Firmware Required\n   </strong>\n   : The FT232BM and FT245BM are designed to manage USB communications through hardware. This means that you don\u2019t need to write complex USB-specific firmware, reducing development time and effort.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Host-Provided Drivers\n   </strong>\n   : FTDI provides the necessary host drivers, which simplifies the process of integrating these chips into your device. You can also use FTDI\u2019s\n   <strong>\n    Vendor ID\n   </strong>\n   when developing and marketing your devices, which further streamlines the process for OEMs.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    EEPROM Support for Descriptors\n   </strong>\n   : Although the chips manage the USB protocol entirely in hardware, you can still use an\n   <strong>\n    EEPROM\n   </strong>\n   to store specific descriptor values. These could include information like device identifiers, product IDs, or other configurable parameters.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Communication Types\n   </strong>\n   : These controllers support\n   <strong>\n    bulk\n   </strong>\n   and\n   <strong>\n    isochronous\n   </strong>\n   data transfer types in each direction. However, they are not intended for devices that require more than one bulk or isochronous port.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Simple Data Handling\n   </strong>\n   : The firmware in these chips only needs to manage the data that needs to be sent and received. The FTDI chip handles the rest of the communication automatically, making it ideal for applications that don\u2019t require complex USB interactions.\n  </p>\n</li>\n</ol>\n<h4>\n USB Controller:\n</h4>\n<p>\n The\n <strong>\n  FT232BM\n </strong>\n and\n <strong>\n  FT245BM\n </strong>\n both include a\n <strong>\n  USB controller\n </strong>\n that supports full-speed USB communication. These chips simplify the process of integrating USB capabilities into your device by eliminating the need for extensive custom USB firmware. They are a great choice for projects where ease of use and quick integration are priorities, particularly when your device does not need complex or multiple endpoints.\n</p>\n<p>\n In summary, the\n <strong>\n  FT232BM\n </strong>\n and\n <strong>\n  FT245BM\n </strong>\n from FTDI offer an excellent solution for developers looking for a straightforward USB interface solution, where the majority of the USB protocol handling is taken care of by hardware. The use of FTDI\u2019s drivers and optional EEPROM for custom descriptors makes them flexible and easy to integrate into a w\n</p>\n"}, "Page 193": {"response": "<h3>\n FTDI Chip FT245BM and FT232BM: Pin Functions and Interface Options\n</h3>\n<p>\n Both the\n <strong>\n  FT245BM\n </strong>\n and\n <strong>\n  FT232BM\n </strong>\n are full-speed USB interface controllers offered by FTDI, but they serve different communication purposes based on their unique interfaces. Here's an overview of their architecture, pin functions, and different use cases.\n</p>\n<h4>\n FT245BM: Parallel Interface for Data Transfer\n</h4>\n<p>\n The\n <strong>\n  FT245BM\n </strong>\n is designed with a\n <strong>\n  parallel interface\n </strong>\n , making it suitable for applications where fast data transfer is essential. It has 8 data lines and 4 handshaking signals that allow an external CPU to interface directly with the chip.\n</p>\n<ul>\n<li>\n<strong>\n   Pin Functions:\n  </strong>\n<ul>\n<li>\n<strong>\n     RXF# (Receive FIFO Empty)\n    </strong>\n    : This output signal goes low when the external CPU can read a byte of data received from the USB host.\n   </li>\n<li>\n<strong>\n     RD# (Read Strobe)\n    </strong>\n    : The CPU strobe signal that reads the byte from the FT245BM\u2019s buffer.\n   </li>\n<li>\n<strong>\n     TXE# (Transmit FIFO Empty)\n    </strong>\n    : This output signal goes low when the CPU can write a byte to send to the USB host.\n   </li>\n<li>\n<strong>\n     WR (Write Strobe)\n    </strong>\n    : The CPU strobe signal that writes data into the FT245BM\u2019s buffer to send to the USB host.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n The external CPU can interface with the FT245BM using a data bus or by using spare port pins. These handshaking signals ensure proper synchronization for reading and writing data.\n</p>\n<h4>\n FT232BM: USB to Asynchronous Serial Interface\n</h4>\n<p>\n The\n <strong>\n  FT232BM\n </strong>\n serves a different purpose\u2014it converts between\n <strong>\n  USB\n </strong>\n and an\n <strong>\n  asynchronous serial interface\n </strong>\n . This is typically used for serial communication with RS-232 or RS-485 devices.\n</p>\n<ul>\n<li>\n<strong>\n   Pin Functions:\n  </strong>\n<ul>\n<li>\n<strong>\n     TXD (Transmit Data)\n    </strong>\n    : The data output pin for transmitting data to the connected device.\n   </li>\n<li>\n<strong>\n     RXD (Receive Data)\n    </strong>\n    : The data input pin for receiving data from the connected device.\n   </li>\n<li>\n<strong>\n     RS-232 Handshaking Signals\n    </strong>\n    : Includes standard handshaking pins such as\n    <strong>\n     RTS\n    </strong>\n    ,\n    <strong>\n     CTS\n    </strong>\n    ,\n    <strong>\n     DTR\n    </strong>\n    ,\n    <strong>\n     DSR\n    </strong>\n    ,\n    <strong>\n     DCD\n    </strong>\n    , and\n    <strong>\n     RI\n    </strong>\n    . These are used for flow control and signaling in serial communication.\n   </li>\n<li>\n<strong>\n     TXDEN (Transmit Enable)\n    </strong>\n    : When this output is high, it indicates that data is being transmitted on the\n    <strong>\n     TXD\n    </strong>\n    line. It can be used to directly control the transmit-enable input of an RS-485 transceiver, eliminating the need for extra firmware or hardware.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n The\n <strong>\n  FT232BM\n </strong>\n operates as a\n <strong>\n  DTE (Data Terminal Equipment)\n </strong>\n , meaning the signals work in a specific way when compared to\n <strong>\n  DCE (Data Communication Equipment)\n </strong>\n . For instance, on a DTE device,\n <strong>\n  TXD\n </strong>\n ,\n <strong>\n  RTS\n </strong>\n , and\n <strong>\n  DTR\n </strong>\n are output signals, while\n <strong>\n  RXD\n </strong>\n ,\n <strong>\n  CTS\n </strong>\n , and\n <strong>\n  DSR\n </strong>\n are inputs. To connect two DTE devices, you can use a\n <strong>\n  null-modem cable\n </strong>\n to swap the necessary signal pairs, enabling the devices to communicate.\n</p>\n<h4>\n Bit Bang Mode\n</h4>\n<p>\n Both the\n <strong>\n  FT245BM\n </strong>\n and\n <strong>\n  FT232BM\n </strong>\n support a\n <strong>\n  Bit Bang mode\n </strong>\n . In this mode, the chip can operate as a basic controller without needing to connect to an external CPU. This mode is useful when simple control or signaling is required, allowing the chip to directly interface with other devices or systems.\n</p>\n<h4>\n Applications:\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    USB to RS-232 Converter\n   </strong>\n   : The\n   <strong>\n    FT232BM\n   </strong>\n   can be used to convert\n   <strong>\n    USB\n   </strong>\n   to\n   <strong>\n    RS-232\n   </strong>\n   signals. To make this conversion, you would typically use an additional chip like the\n   <strong>\n    Maxim MAX3245\n   </strong>\n   to handle the voltage level conversion between the 5V logic used by the FT232BM and the higher voltages used by RS-232 signals.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    USB to RS-485 Conversion\n   </strong>\n   : Similarly, the\n   <strong>\n    FT232BM\n   </strong>\n   can be interfaced with an\n   <strong>\n    RS-485\n   </strong>\n   transceiver to convert USB data into RS-485 format, making it compatible with industrial and networking applications.\n  </p>\n</li>\n</ol>\n<h3>\n Summary:\n</h3>\n<ul>\n<li>\n  The\n  <strong>\n   FT245BM\n  </strong>\n  offers a parallel interface and is suited for applications requiring fast data transfer with an external CPU.\n </li>\n<li>\n  The\n  <strong>\n   FT232BM\n  </strong>\n  provides a USB-to-serial conversion (including RS-232/RS-485) with standard asynchronous serial signaling and is ideal for connecting USB-enabled devices to legacy serial systems.\n </li>\n<li>\n  Both chips can operate in\n  <strong>\n   Bit Bang mode\n  </strong>\n  , offering basic control capabil\n </li>\n</ul>\n"}, "Page 194": {"response": "<h3>\n Pinout of the FT245BM USB FIFO\n</h3>\n<p>\n The\n <strong>\n  FT245BM\n </strong>\n USB FIFO is designed with a variety of pins for different purposes, including power, data transmission, EEPROM support, and control functions. Here's an explanation of each pin:\n</p>\n<h4>\n Power Pins\n</h4>\n<ul>\n<li>\n<strong>\n   VCC (Pin 3, Pin 26)\n  </strong>\n  : Provides power to the chip. The acceptable voltage range is\n  <strong>\n   4.35 to 5.25V\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   GND (Pin 9, Pin 17)\n  </strong>\n  : Ground pin for the chip.\n </li>\n<li>\n<strong>\n   VCCIO (Pin 13)\n  </strong>\n  : Provides power for I/O pins, with a voltage range of\n  <strong>\n   3.0 to 5.25V\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   3V3OUT (Pin 6)\n  </strong>\n  : A regulated\n  <strong>\n   +3.3V output\n  </strong>\n  for use by external components.\n </li>\n<li>\n<strong>\n   AVCC (Pin 30)\n  </strong>\n  : Analog power supply pin.\n </li>\n<li>\n<strong>\n   AGND (Pin 29)\n  </strong>\n  : Analog ground pin.\n </li>\n</ul>\n<h4>\n Reset and Control Pins\n</h4>\n<ul>\n<li>\n<strong>\n   RESET# (Pin 4)\n  </strong>\n  : Input pin used to reset the chip.\n </li>\n<li>\n<strong>\n   RSTOUT# (Pin 5)\n  </strong>\n  : Output pin for the Reset Generator, signaling the reset state of the chip.\n </li>\n<li>\n<strong>\n   PWREN# (Pin 10)\n  </strong>\n  : Output that goes low when the device is configured and high in the\n  <strong>\n   Suspend\n  </strong>\n  state.\n </li>\n<li>\n<strong>\n   SI/WU (Pin 11)\n  </strong>\n  : Input pin to send USB data on the next bulk IN or request remote wakeup.\n </li>\n<li>\n<strong>\n   TEST (Pin 31)\n  </strong>\n  : Input pin used to enable\n  <strong>\n   Test mode\n  </strong>\n  by bringing it high.\n </li>\n</ul>\n<h4>\n Data Pins\n</h4>\n<ul>\n<li>\n<strong>\n   USBDP (Pin 7)\n  </strong>\n  and\n  <strong>\n   USBDM (Pin 8)\n  </strong>\n  : The\n  <strong>\n   D+\n  </strong>\n  and\n  <strong>\n   D-\n  </strong>\n  pins for USB data transmission.\n </li>\n<li>\n<strong>\n   D0\u2013D7 (Pins 18 to 25)\n  </strong>\n  : The 8 data pins (D0 to D7) for data transfer between the chip and external devices.\n </li>\n</ul>\n<h4>\n EEPROM Support Pins\n</h4>\n<ul>\n<li>\n<strong>\n   EESK (Pin 1)\n  </strong>\n  : Output pin for the\n  <strong>\n   EEPROM clock\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   EEDATA (Pin 2)\n  </strong>\n  : Output pin for\n  <strong>\n   EEPROM data\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   EECS (Pin 32)\n  </strong>\n  : Chip select pin for the\n  <strong>\n   EEPROM\n  </strong>\n  .\n </li>\n</ul>\n<h4>\n FIFO and Data Transfer Control\n</h4>\n<ul>\n<li>\n<strong>\n   RXF# (Pin 12)\n  </strong>\n  : Output pin that goes low when the FIFO contains data the CPU can read.\n </li>\n<li>\n<strong>\n   TXE# (Pin 14)\n  </strong>\n  : Output pin that goes low when the CPU can write data to the FIFO.\n </li>\n<li>\n<strong>\n   WR (Pin 15)\n  </strong>\n  : Input pin that, on a high-to-low transition, writes data (D0\u2013D7) to the transmit FIFO buffer.\n </li>\n<li>\n<strong>\n   RD# (Pin 16)\n  </strong>\n  : Input pin that, on a high-to-low transition, places a byte from the receive FIFO buffer onto D0\u2013D7 for the CPU to read.\n </li>\n</ul>\n<h4>\n Oscillator Pins\n</h4>\n<ul>\n<li>\n<strong>\n   XTIN (Pin 27)\n  </strong>\n  : Input pin for the crystal oscillator cell.\n </li>\n<li>\n<strong>\n   XTOUT (Pin 28)\n  </strong>\n  : Output pin for the crystal oscillator cell.\n </li>\n</ul>\n<p>\n This pinout enables the FT245BM to manage USB data transfers and communicate with external devices effectively. It also provides control, power, and data management features, including FIFO buffering, EEPROM integration, and\n</p>\n"}, "Page 195": {"response": "<h3>\n Pinout of the FT232BM USB UART\n</h3>\n<p>\n The\n <strong>\n  FT232BM\n </strong>\n USB UART is designed for converting USB to asynchronous serial communication. Here\u2019s a detailed explanation of each pin and its function:\n</p>\n<h4>\n Power Pins\n</h4>\n<ul>\n<li>\n<strong>\n   VCC (Pin 3, Pin 26)\n  </strong>\n  : Provides power to the chip, with an acceptable voltage range of\n  <strong>\n   4.35 to 5.25V\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   GND (Pin 9, Pin 17)\n  </strong>\n  : Ground pin for the chip.\n </li>\n<li>\n<strong>\n   VCCIO (Pin 13)\n  </strong>\n  : Power pin for the I/O sections, with a voltage range of\n  <strong>\n   3.0 to 5.25V\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   3V3OUT (Pin 6)\n  </strong>\n  : Provides a regulated\n  <strong>\n   +3.3V output\n  </strong>\n  for use by external components.\n </li>\n<li>\n<strong>\n   AVCC (Pin 30)\n  </strong>\n  : Analog power supply pin.\n </li>\n<li>\n<strong>\n   AGND (Pin 29)\n  </strong>\n  : Analog ground pin.\n </li>\n</ul>\n<h4>\n Reset and Control Pins\n</h4>\n<ul>\n<li>\n<strong>\n   RESET# (Pin 4)\n  </strong>\n  : Input pin used to reset the chip.\n </li>\n<li>\n<strong>\n   RSTOUT# (Pin 5)\n  </strong>\n  : Output pin from the reset generator indicating a reset condition.\n </li>\n<li>\n<strong>\n   SLEEP# (Pin 10)\n  </strong>\n  : Output pin that goes low when the chip enters the\n  <strong>\n   Suspend state\n  </strong>\n  to conserve power.\n </li>\n<li>\n<strong>\n   PWREN# (Pin 15)\n  </strong>\n  : Output that goes low when the device is configured and high in the Suspend state.\n </li>\n<li>\n<strong>\n   PWRCTL (Pin 14)\n  </strong>\n  : Input pin to control the power mode; tie it low for bus-powered and high for self-powered configurations.\n </li>\n<li>\n<strong>\n   TEST (Pin 31)\n  </strong>\n  : Input pin used to enable\n  <strong>\n   Test mode\n  </strong>\n  by bringing it high.\n </li>\n</ul>\n<h4>\n USB Data Pins\n</h4>\n<ul>\n<li>\n<strong>\n   USBDP (Pin 7)\n  </strong>\n  and\n  <strong>\n   USBDM (Pin 8)\n  </strong>\n  :\n  <strong>\n   D+\n  </strong>\n  and\n  <strong>\n   D-\n  </strong>\n  USB data pins for communication.\n </li>\n</ul>\n<h4>\n LED and Indicator Pins\n</h4>\n<ul>\n<li>\n<strong>\n   RXLED# (Pin 11)\n  </strong>\n  : Output for driving a\n  <strong>\n   Receive LED\n  </strong>\n  , which is an open-collector pin that lights up during data reception.\n </li>\n<li>\n<strong>\n   TXLED# (Pin 12)\n  </strong>\n  : Output for driving a\n  <strong>\n   Transmit LED\n  </strong>\n  , which is also open-collector and indicates data transmission.\n </li>\n</ul>\n<h4>\n UART Communication Pins\n</h4>\n<ul>\n<li>\n<strong>\n   TXDEN (Pin 16)\n  </strong>\n  : Output pin for enabling the\n  <strong>\n   RS-485\n  </strong>\n  transmitter.\n </li>\n<li>\n<strong>\n   RI# (Pin 18)\n  </strong>\n  : Input pin for the\n  <strong>\n   Ring Indicator\n  </strong>\n  signal, used in telecommunication applications.\n </li>\n<li>\n<strong>\n   DCD (Pin 19)\n  </strong>\n  : Output pin for\n  <strong>\n   Data Carrier Detect\n  </strong>\n  , indicating a connection to a remote device.\n </li>\n<li>\n<strong>\n   DSR# (Pin 20)\n  </strong>\n  : Input pin for\n  <strong>\n   Data Set Ready\n  </strong>\n  , signaling that the device is ready for communication.\n </li>\n<li>\n<strong>\n   DTR# (Pin 21)\n  </strong>\n  : Output pin for\n  <strong>\n   Data Terminal Ready\n  </strong>\n  , signaling readiness of the terminal for communication.\n </li>\n<li>\n<strong>\n   CTS# (Pin 22)\n  </strong>\n  : Input pin for\n  <strong>\n   Clear To Send\n  </strong>\n  , indicating readiness of the other end to receive data.\n </li>\n<li>\n<strong>\n   RTS# (Pin 23)\n  </strong>\n  : Output pin for\n  <strong>\n   Request To Send\n  </strong>\n  , signaling the other end to prepare for receiving data.\n </li>\n<li>\n<strong>\n   RXD (Pin 24)\n  </strong>\n  : Input pin for\n  <strong>\n   Receive Data\n  </strong>\n  from the UART.\n </li>\n<li>\n<strong>\n   TXD (Pin 25)\n  </strong>\n  : Output pin for\n  <strong>\n   Transmit Data\n  </strong>\n  to the UART.\n </li>\n</ul>\n<h4>\n EEPROM Support Pins\n</h4>\n<ul>\n<li>\n<strong>\n   EESK (Pin 1)\n  </strong>\n  : Output pin for the\n  <strong>\n   EEPROM clock\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   EEDATA (Pin 2)\n  </strong>\n  : Output pin for\n  <strong>\n   EEPROM data\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   EECS (Pin 32)\n  </strong>\n  : Chip select pin for the\n  <strong>\n   EEPROM\n  </strong>\n  .\n </li>\n</ul>\n<h4>\n Oscillator Pins\n</h4>\n<ul>\n<li>\n<strong>\n   XTIN (Pin 27)\n  </strong>\n  : Input pin for the crystal oscillator cell, used to drive the chip's clock.\n </li>\n<li>\n<strong>\n   XTOUT (Pin 28)\n  </strong>\n  : Output pin from the crystal oscillator cell, providing the clock signal.\n </li>\n</ul>\n<p>\n This detailed pinout enables the FT232BM to serve as a reliable USB-to-UART converter with versatile options for power management, UART communicatio\n</p>\n"}, "Page 196": {"response": "<h3>\n FTDI Chip Controllers: FT232BM and FT245BM\n</h3>\n<p>\n The\n <strong>\n  FT232BM\n </strong>\n and\n <strong>\n  FT245BM\n </strong>\n chips from FTDI Chip are unique in that they handle USB communication entirely in hardware, which simplifies development. These chips are not designed as general-purpose controllers like other USB devices but instead come with specific driver options and features to interface with external components.\n</p>\n<h4>\n Data-Bus Functionality\n</h4>\n<ul>\n<li>\n<strong>\n   FT245BM\n  </strong>\n  : The data-bus pins on this chip function as an 8-bit\n  <strong>\n   I/O port\n  </strong>\n  , allowing you to interface with external circuits such as LEDs or relays.\n </li>\n<li>\n<strong>\n   FT232BM\n  </strong>\n  : The data and handshaking pins also serve as\n  <strong>\n   I/O ports\n  </strong>\n  , providing additional flexibility. These pins can be configured as inputs or outputs via FTDI Chip's driver software. Inputs can connect to switches, while outputs can control external devices.\n </li>\n</ul>\n<h4>\n USB Communication with Host\n</h4>\n<p>\n Unlike other USB controllers, the\n <strong>\n  FT232BM\n </strong>\n and\n <strong>\n  FT245BM\n </strong>\n chips don't require a custom driver for every device type. Instead, FTDI Chip provides two main driver options for managing communication between the device and the host system:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Virtual COM Port (VCP) Driver\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This driver makes the device appear as if it's connected to an\n    <strong>\n     RS-232 COM port\n    </strong>\n    on the host system.\n   </li>\n<li>\n<strong>\n     RS-232 devices\n    </strong>\n    converted to USB using the\n    <strong>\n     FT232BM\n    </strong>\n    typically require no changes to the software that interacts with the device.\n   </li>\n<li>\n    Under\n    <strong>\n     Windows\n    </strong>\n    , applications can access the device using\n    <strong>\n     standard API functions\n    </strong>\n    like\n    <code>\n     ReadFile\n    </code>\n    and\n    <code>\n     WriteFile\n    </code>\n    , or through other COM-port communication libraries.\n   </li>\n<li>\n    The\n    <strong>\n     FT245BM\n    </strong>\n    can also use the Virtual COM Port driver.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    D2XX Direct Driver\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This driver is ideal if you prefer not to use COM-port programming, need\n    <strong>\n     higher performance\n    </strong>\n    , or want to utilize the\n    <strong>\n     Bit Bang mode\n    </strong>\n    .\n   </li>\n<li>\n    It offers a set of\n    <strong>\n     vendor-specific functions\n    </strong>\n    that allow direct communication with the device, providing more control and flexibility.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n EEPROM Interface and Configuration\n</h4>\n<p>\n Both the\n <strong>\n  FT232BM\n </strong>\n and\n <strong>\n  FT245BM\n </strong>\n support a\n <strong>\n  Microwire interface\n </strong>\n to an\n <strong>\n  EEPROM\n </strong>\n . This EEPROM can store important vendor-specific data, including:\n</p>\n<ul>\n<li>\n<strong>\n   Vendor ID\n  </strong>\n</li>\n<li>\n<strong>\n   Product ID\n  </strong>\n</li>\n<li>\n<strong>\n   Serial number\n  </strong>\n</li>\n<li>\n<strong>\n   Manufacturer and product description\n  </strong>\n</li>\n<li>\n<strong>\n   Power type\n  </strong>\n  (whether the device is bus-powered or self-powered)\n </li>\n</ul>\n<p>\n If no EEPROM is available, the chip will use\n <strong>\n  default values\n </strong>\n for these fields. FTDI Chip provides a utility that allows you to program the EEPROM with your device\u2019s details.\n</p>\n<ul>\n<li>\n<strong>\n   Vendor ID and Product ID\n  </strong>\n  :\n  <br/>\n  If you don\u2019t have an EEPROM, the chips will use FTDI\u2019s default\n  <strong>\n   Vendor ID\n  </strong>\n  and\n  <strong>\n   Product ID\n  </strong>\n  . However, FTDI Chip also allows developers to request their own\n  <strong>\n   Vendor ID\n  </strong>\n  and a\n  <strong>\n   Product ID\n  </strong>\n  assigned by FTDI.\n </li>\n</ul>\n<p>\n These features simplify the process of USB device developme\n</p>\n"}, "Page 197": {"response": "<h3>\n FTDI Chip Controllers: FT232BM, FT245BM, and FT2232C\n</h3>\n<p>\n FTDI Chip offers several USB controller options, including the\n <strong>\n  FT232BM\n </strong>\n ,\n <strong>\n  FT245BM\n </strong>\n , and\n <strong>\n  FT2232C\n </strong>\n . These controllers are known for their ease of use, robust performance, and practical features, making them suitable for various applications, especially for developers working on inexpensive products that sell in small quantities.\n</p>\n<h4>\n<strong>\n  FT232BM and FT245BM Performance and Buffers\n </strong>\n</h4>\n<p>\n Both the\n <strong>\n  FT232BM\n </strong>\n and\n <strong>\n  FT245BM\n </strong>\n chips come with the following key features:\n</p>\n<ul>\n<li>\n<strong>\n   Transmit Buffer\n  </strong>\n  : 384 bytes\n </li>\n<li>\n<strong>\n   Receive Buffer\n  </strong>\n  : 128 bytes\n </li>\n</ul>\n<p>\n<strong>\n  FT245BM\n </strong>\n has a\n <strong>\n  data bus\n </strong>\n capable of transferring up to\n <strong>\n  1 Megabyte per second\n </strong>\n . Meanwhile, the\n <strong>\n  FT232BM\n </strong>\n uses an asynchronous\n <strong>\n  serial port\n </strong>\n that can transfer data at speeds of up to\n <strong>\n  3 million baud\n </strong>\n , which is equivalent to\n <strong>\n  300 kilobytes per second\n </strong>\n when using one Start bit and one Stop bit per byte.\n</p>\n<p>\n These chips primarily use\n <strong>\n  bulk transfers\n </strong>\n for data communication, but there is also a driver available for\n <strong>\n  isochronous transfers\n </strong>\n if needed for specific applications.\n</p>\n<h4>\n<strong>\n  Advantages of FTDI Chips for Small-Scale Products\n </strong>\n</h4>\n<p>\n One significant advantage of using FTDI chips is that developers do not need to buy their own\n <strong>\n  Vendor ID\n </strong>\n for their devices. This is especially useful for those creating inexpensive products in smaller quantities. FTDI allows the use of its\n <strong>\n  Vendor ID\n </strong>\n and will even assign a unique\n <strong>\n  Product ID\n </strong>\n to a developer\u2019s product. This reduces costs and simplifies the development process for smaller-scale products.\n</p>\n<h4>\n<strong>\n  FT2232C Dual USB UART/FIFO\n </strong>\n</h4>\n<p>\n Another option from FTDI Chip is the\n <strong>\n  FT2232C Dual USB UART/FIFO\n </strong>\n . This chip includes two separate controllers, each supporting several configurations:\n</p>\n<ul>\n<li>\n<strong>\n   FT232BM or FT245BM interface\n  </strong>\n  : Standard serial communication modes.\n </li>\n<li>\n<strong>\n   Synchronous serial interface\n  </strong>\n  : Useful for systems requiring precise timing in data transfers.\n </li>\n<li>\n<strong>\n   8051-compatible parallel interface\n  </strong>\n  : For systems using the 8051 microcontroller family.\n </li>\n<li>\n<strong>\n   Optoisolated serial-interface mode\n  </strong>\n  : Enables creating isolated systems using external optoisolators, ensuring that the data interface is electrically isolated from the rest of the system.\n </li>\n<li>\n<strong>\n   High-drive-level option\n  </strong>\n  : This mode allows the I/O pins to source and sink\n  <strong>\n   up to 6 milliamperes\n  </strong>\n  at\n  <strong>\n   3.2V minimum\n  </strong>\n  for sourcing current and\n  <strong>\n   0.6V maximum\n  </strong>\n  for sinking current.\n </li>\n</ul>\n<h4>\n<strong>\n  Prototyping with FTDI Modules\n </strong>\n</h4>\n<p>\n For easier prototyping and testing, FTDI Chip offers\n <strong>\n  DLP Design\u2019s DLP-USB232M\n </strong>\n and\n <strong>\n  DLP-USBS245M\n </strong>\n modules, which are compatible with the FTDI controllers. These modules provide a convenient way to interface with FTDI\u2019s chips and simplify development, especially when quick testing or experimentation is required.\n</p>\n<p>\n These chips and their features are ideal for developers who need a reliable, easy-to-use USB interface with minimal software complexity, while also offering flexibility for a variety of use cases such as UART-to-USB\n</p>\n"}, "Page 198": {"response": "<h3>\n Prototyping with FTDI Chips: Surface-Mount Packages and Pre-assembled Modules\n</h3>\n<p>\n FTDI's USB controller chips, including the\n <strong>\n  FT232BM\n </strong>\n ,\n <strong>\n  FT245BM\n </strong>\n , and\n <strong>\n  FT2232C\n </strong>\n , are only available in\n <strong>\n  surface-mount packages\n </strong>\n . This means that they are designed for use with more compact, professional manufacturing processes, making them less suitable for through-hole prototyping.\n</p>\n<p>\n However, for easier prototyping and experimentation, a variety of circuit boards are available that come pre-mounted with these chips,\n <strong>\n  EEPROMs\n </strong>\n , a\n <strong>\n  USB connector\n </strong>\n , and\n <strong>\n  headers\n </strong>\n . These pre-assembled boards allow for quick and straightforward attachment to a\n <strong>\n  CPU\n </strong>\n or other circuits, making them ideal for developers who need to test their designs without the hassle of creating their own circuit boards.\n</p>\n<p>\n One reliable source for such boards is\n <strong>\n  DLP Design\n </strong>\n , which offers the\n <strong>\n  DLP-USB232M\n </strong>\n and\n <strong>\n  DLP-USBS245M\n </strong>\n modules. These modules come with\n <strong>\n  24-pin DIP sockets\n </strong>\n , allowing for easy connections and modifications during prototyping. The designs on these modules follow the\n <strong>\n  example schematics\n </strong>\n provided by FTDI, making them an excellent resource for development.\n</p>\n<p>\n For detailed guidance on how to integrate these chips into your devices,\n <strong>\n  Chapter 14\n </strong>\n of the book provides further information, including\n <strong>\n  example applications\n </strong>\n and tips on designing devices using FTDI\u2019s USB chips. This makes it easier for developers to understand how to leverage the chips effectively in\n</p>\n"}, "Page 199": {"response": "<h3>\n Device Classes in USB\n</h3>\n<p>\n In this chapter, we explore the concept of\n <strong>\n  USB device classes\n </strong>\n and how to determine whether a new design should align with an existing class or require a custom driver.\n</p>\n<h4>\n What are Device Classes?\n</h4>\n<p>\n USB devices often share common characteristics with others that perform similar functions. For example:\n</p>\n<ul>\n<li>\n<strong>\n   Mice\n  </strong>\n  all send data about movements and clicks.\n </li>\n<li>\n<strong>\n   Storage drives\n  </strong>\n  all transfer files.\n </li>\n<li>\n<strong>\n   Printers\n  </strong>\n  all receive data to print and return status information.\n </li>\n</ul>\n<p>\n When a group of devices shares similar attributes or performs similar tasks, it's efficient to define these attributes and services in a\n <strong>\n  class specification\n </strong>\n . This specification serves as a guideline for:\n</p>\n<ul>\n<li>\n  Developers designing and programming devices that fall under this class.\n </li>\n<li>\n  Programmers writing device drivers that facilitate communication between the device and the host system.\n </li>\n</ul>\n<p>\n By defining device classes, operating systems can offer built-in drivers for common types of devices. This eliminates the need for device manufacturers to provide custom drivers for each device, making it easier for end-users and developers t\n</p>\n"}, "Page 200": {"response": "<h3>\n Device Working Groups and Class Specifications\n</h3>\n<h4>\n Custom Drivers vs. Filter Drivers\n</h4>\n<p>\n When a device falls under a class supported by the operating system, but has unique features not supported by the existing class driver, the device manufacturer may provide a\n <strong>\n  filter driver\n </strong>\n . This filter driver adds support for the new features without needing to develop a completely custom driver. However, if a filter driver isn't suitable, the device will require a full\n <strong>\n  custom driver\n </strong>\n .\n</p>\n<p>\n Even if a class isn't yet supported by the operating system, it may be included in a future version. Devices built to comply with a class specification are more likely to be compatible with drivers that are added in future OS releases.\n</p>\n<h4>\n Device Working Groups and USB-IF\n</h4>\n<p>\n The\n <strong>\n  USB Implementers Forum (USB-IF)\n </strong>\n is responsible for releasing class specifications, which are developed by\n <strong>\n  Device Working Groups\n </strong>\n . These groups are composed of members who have expertise and interest in specific areas of USB device functionality. For instance, the\n <strong>\n  hub class\n </strong>\n is defined within the main USB 2.0 specification rather than in a separate document, as every operating system must support the hub class due to the host's need for a root hub for communication.\n</p>\n<h4>\n Approved Class Specifications\n</h4>\n<p>\n The USB-IF approves class specifications once they reach version 1.0 or higher. These specifications serve as references for developing both devices and drivers that are intended for commercial use.\n <strong>\n  Table 7-1\n </strong>\n outlines the classes with approved specifications, while\n <strong>\n  Table 7-2\n </strong>\n lists the class drivers added in each version of Windows. Over time, as Windows and class specifications evolve, the number of supported classes and the level of support for them improves. For instance,\n <strong>\n  Windows\n </strong>\n now includes drivers for many classes, though some lesser-known classes, such as\n <strong>\n  Device Firmware Upgrade\n </strong>\n , still lack native driver support, despite having an approved specification for years.\n</p>\n<h4>\n Common Class Specification\n</h4>\n<p>\n All USB class specifications are built on a\n <strong>\n  Common Class specification\n </strong>\n , which dictates the required information for each class specification. This serves as a standard template for how class specifications are structured and what content they must include to ensure compatibility and functionali\n</p>\n"}, "Page 201": {"response": "<h3>\n Elements of a Class Specification\n</h3>\n<h4>\n Structure and Endpoint Requirements\n</h4>\n<p>\n A\n <strong>\n  class specification\n </strong>\n outlines how to organize the document and details specific requirements for devices within that class. This includes specifying the\n <strong>\n  number\n </strong>\n and\n <strong>\n  type\n </strong>\n of required and optional\n <strong>\n  endpoints\n </strong>\n . It may also define how data should be transferred, including both\n <strong>\n  application data\n </strong>\n (such as keystrokes or video data) and\n <strong>\n  status/control information\n </strong>\n related to the device's operation.\n</p>\n<h4>\n Functions and Capabilities\n</h4>\n<p>\n Some class specifications also describe specific\n <strong>\n  functions\n </strong>\n or\n <strong>\n  capabilities\n </strong>\n , dictating how the data transferred should be interpreted. For example, the\n <strong>\n  HID (Human Interface Device)\n </strong>\n class provides\n <strong>\n  Usage Tables\n </strong>\n that describe how data from devices like keyboards, mice, and joysticks should be understood. Some classes even use\n <strong>\n  USB\n </strong>\n to transfer data formatted according to another specification, such as the\n <strong>\n  SCSI\n </strong>\n commands used in\n <strong>\n  mass-storage devices\n </strong>\n .\n</p>\n<h4>\n Descriptors and Requests\n</h4>\n<p>\n A class specification defines\n <strong>\n  standard descriptor values\n </strong>\n and\n <strong>\n  class-specific descriptors\n </strong>\n . It also details how\n <strong>\n  interfaces\n </strong>\n ,\n <strong>\n  endpoints\n </strong>\n , and\n <strong>\n  control requests\n </strong>\n are used. For instance, the device descriptor for a\n <strong>\n  hub\n </strong>\n has a\n <code>\n  bDeviceClass\n </code>\n value of\n <code>\n  09h\n </code>\n to categorize it as a hub. The hub also includes a\n <strong>\n  class-specific hub descriptor\n </strong>\n with a descriptor type of\n <code>\n  29h\n </code>\n . Hubs must support specific requests, like\n <strong>\n  Get_Port_Status\n </strong>\n , where the host sends a request containing a port number and receives corresponding status information about the port.\n</p>\n<h4>\n Table 7-1: List of Approved Class Specifications\n</h4>\n<p>\n The following classes have approved specifications:\n</p>\n<ul>\n<li>\n<strong>\n   Audio\n  </strong>\n</li>\n<li>\n<strong>\n   Chip/Smart Card Interface\n  </strong>\n</li>\n<li>\n<strong>\n   Communication Device or Interface\n  </strong>\n</li>\n<li>\n<strong>\n   Content Security\n  </strong>\n</li>\n<li>\n<strong>\n   Device Firmware Upgrade\n  </strong>\n  (Interface subclass of Application-Specific Interface)\n </li>\n<li>\n<strong>\n   Human Interface Device (HID)\n  </strong>\n</li>\n<li>\n<strong>\n   IrDA Bridge\n  </strong>\n  (Interface subclass of Application-Specific Interface)\n </li>\n<li>\n<strong>\n   Mass Storage\n  </strong>\n</li>\n<li>\n<strong>\n   Printer\n  </strong>\n</li>\n<li>\n<strong>\n   Still Image Capture\n  </strong>\n</li>\n<li>\n<strong>\n   Test and Measurement\n  </strong>\n  (Interface subclass of Application-Specific Interface)\n </li>\n<li>\n<strong>\n   Video\n  </strong>\n</li>\n</ul>\n<p>\n These classes are formally recognized and described in class specifications, which guide the develop\n</p>\n"}, "Page 202": {"response": "<h3>\n Microsoft Windows USB Class Support\n</h3>\n<p>\n Each version of\n <strong>\n  Windows\n </strong>\n has added support for more\n <strong>\n  USB classes\n </strong>\n , with additional drivers for various devices. The table below outlines the key USB versions and the class drivers included with each\n <strong>\n  Windows edition\n </strong>\n . Each release typically includes drivers from earlier versions, unless otherwise noted.\n</p>\n<h4>\n Table 7-2: USB Drivers Added in Different Windows Versions\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Windows 98 Gold (Original Release)\n   </strong>\n</p>\n<ul>\n<li>\n<strong>\n     USB Version Compliance\n    </strong>\n    : 1.0\n   </li>\n<li>\n<strong>\n     Drivers Added\n    </strong>\n    :\n    <ul>\n<li>\n      Audio\n     </li>\n<li>\n      HID 1.0\n     </li>\n<li>\n      Video (USB camera minidriver library - USBCAMD 1.0; not supported in Windows 2000)\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Windows 98 SE\n   </strong>\n</p>\n<ul>\n<li>\n<strong>\n     USB Version Compliance\n    </strong>\n    : 1.1\n   </li>\n<li>\n<strong>\n     Drivers Added\n    </strong>\n    :\n    <ul>\n<li>\n      Communication device: modem\n     </li>\n<li>\n      HID 1.1 (added ability for interrupt OUT transfers)\n     </li>\n<li>\n      Still image (first phase/preliminary)\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Windows 2000\n   </strong>\n</p>\n<ul>\n<li>\n<strong>\n     USB Version Compliance\n    </strong>\n    : 1.1 (2.0 support added in Service Pack 4)\n   </li>\n<li>\n<strong>\n     Drivers Added\n    </strong>\n    :\n    <ul>\n<li>\n      Mass storage (support for multiple Logical Units (LUNs) or partitions added in Service Pack 3)\n     </li>\n<li>\n      Printer\n     </li>\n<li>\n      Communication device: Remote NDIS (Network Device Interface Specification)\n     </li>\n<li>\n      Still image (much improved)\n     </li>\n<li>\n      Chip/Smart Card Interface (available from Windows Update)\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Windows Me\n   </strong>\n</p>\n<ul>\n<li>\n<strong>\n     USB Version Compliance\n    </strong>\n    : 1.1\n   </li>\n<li>\n<strong>\n     Drivers Added\n    </strong>\n    :\n    <ul>\n<li>\n      Audio: MIDI\n     </li>\n<li>\n      Video (USB camera minidriver library - USBCAMD 2.0)\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Windows XP\n   </strong>\n</p>\n<ul>\n<li>\n<strong>\n     USB Version Compliance\n    </strong>\n    : 1.1; 2.0 support added in Service Pack 1; interface association descriptor support added in Service Pack 2\n   </li>\n<li>\n<strong>\n     Drivers Added\n    </strong>\n    :\n    <ul>\n<li>\n      Audio: MIDI (improved)\n     </li>\n<li>\n      Video-class driver added in Service Pack 2\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>\n This table shows how the support for various USB classes has evolved, with newer versions of Windows providing more comprehensive su\n</p>\n"}, "Page 203": {"response": "<h3>\n Defined USB Classes: Audio Class Overview\n</h3>\n<p>\n The\n <strong>\n  Audio class\n </strong>\n is specifically designed for devices that handle audio data, which can include sounds such as voice, music, or other audio formats. These devices can either send or receive audio, and they often work in combination with other functions like video or storage. The audio data can be transferred using\n <strong>\n  isochronous transfers\n </strong>\n (for real-time audio streams) or\n <strong>\n  bulk transfers\n </strong>\n (for data encoded using the\n <strong>\n  MIDI\n </strong>\n protocol).\n</p>\n<h4>\n Key Points about the Audio Class:\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Audio Class Version 1.0\n   </strong>\n   : The current version of the audio specification is 1.0, though version 2.0 is under development and will not be backward compatible with 1.0. Devices supporting version 2.0 will not work with drivers that support version 1.0.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Future of Version 2.0\n   </strong>\n   : The upcoming version 2.0 will include complete support for\n   <strong>\n    high-speed operation\n   </strong>\n   , the\n   <strong>\n    interface association descriptor\n   </strong>\n   , and many new features and controls that will enhance the functionality of audio devices.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Documentation\n   </strong>\n   : The audio specification is divided into several documents, including:\n  </p>\n<ul>\n<li>\n<strong>\n     Audio Devices\n    </strong>\n    : Defines the core audio device features.\n   </li>\n<li>\n<strong>\n     Audio Data Formats\n    </strong>\n    : Specifies the formats in which audio data can be transferred.\n   </li>\n<li>\n<strong>\n     Terminal Types\n    </strong>\n    : Defines the different terminal types that audio devices may have.\n   </li>\n<li>\n<strong>\n     MIDI Devices\n    </strong>\n    : Relates to the Musical Instrument Digital Interface (MIDI) standard, which is managed by the\n    <strong>\n     MIDI Manufacturers Association\n    </strong>\n    (available at\n    <a rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n     www\n     .midi\n     .org\n    </a>\n    ).\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Audio Interface Collection:\n</h4>\n<p>\n Every\n <strong>\n  audio function\n </strong>\n in a device is organized into an\n <strong>\n  Audio Interface Collection\n </strong>\n , which includes the following interfaces:\n</p>\n<ul>\n<li>\n<strong>\n   AudioControl (AC) Interface\n  </strong>\n  : Manages the control of the audio device.\n </li>\n<li>\n<strong>\n   AudioStreaming (AS) Interfaces\n  </strong>\n  : Handles the streaming of audio data.\n </li>\n<li>\n<strong>\n   MIDIStreaming (MS) Interfaces\n  </strong>\n  : Deals with MIDI data streaming.\n </li>\n</ul>\n<p>\n These interfaces work together to allow audio devices to process and transmi\n</p>\n"}, "Page 204": {"response": "<h3>\n Audio Interface Collection and Descriptors\n</h3>\n<p>\n The\n <strong>\n  Audio Interface Collection\n </strong>\n includes several components that handle different aspects of audio functionality. These components are:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    AudioControl Interface\n   </strong>\n   : This interface allows for the management of audio settings, such as controlling volume, mute, bass, and treble. It provides the controls necessary to manage the overall operation of the audio device.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    AudioStreaming Interface\n   </strong>\n   : This interface is responsible for transferring audio data via\n   <strong>\n    isochronous transfers\n   </strong>\n   , which ensures a steady, real-time flow of audio data. It is crucial for streaming audio with low latency.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    MIDIStreaming Interface\n   </strong>\n   : This interface handles the transfer of\n   <strong>\n    MIDI\n   </strong>\n   data. MIDI (Musical Instrument Digital Interface) is a widely used protocol for controlling electronic musical instruments, synthesizers, sound cards, and similar devices. MIDI data typically contains values for pitch, length, volume, and other musical attributes.\n  </p>\n<ul>\n<li>\n    A\n    <strong>\n     pure MIDI hardware interface\n    </strong>\n    uses asynchronous data transfer at 31.25 kilobits per second. However, with USB, MIDI data travels using\n    <strong>\n     bulk transfers\n    </strong>\n    instead of the traditional asynchronous interface.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Multiple Audio Interface Collections\n</h4>\n<p>\n A device can support multiple\n <strong>\n  Audio Interface Collections\n </strong>\n that work simultaneously. Each collection can manage a separate and independent audio function, allowing for the operation of different audio features or devices within the same system.\n</p>\n<h4>\n Descriptors for Audio Interfaces\n</h4>\n<p>\n To enable communication with the host, each type of audio interface uses both\n <strong>\n  standard\n </strong>\n and\n <strong>\n  class-specific descriptors\n </strong>\n . These descriptors provide critical information about the interface, its\n <strong>\n  endpoints\n </strong>\n , and the type of data each endpoint is expected to transfer. This helps the host understand how to properly interact with\n</p>\n"}, "Page 205": {"response": "<h3>\n AudioControl Interface and Descriptors\n</h3>\n<p>\n The\n <strong>\n  AudioControl Interface\n </strong>\n is responsible for managing various audio settings and functions within a device. It uses a combination of standard and class-specific descriptors to communicate its features and capabilities to the host. These descriptors are essential for the host to understand how to interact with and control the audio device.\n</p>\n<h4>\n Descriptors in the AudioControl Interface\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    AudioControl Interface Descriptor\n   </strong>\n   : This descriptor identifies the interface as belonging to the audio class. It has the value\n   <code>\n    bInterfaceClass = 01h\n   </code>\n   for the audio class and\n   <code>\n    bInterfaceSubclass = 01h\n   </code>\n   to indicate that it is an\n   <strong>\n    AudioControl\n   </strong>\n   subclass.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Class-specific AC Interface Descriptor\n   </strong>\n   : Following the AudioControl interface descriptor is a class-specific descriptor, which provides further details about the audio control interface. This descriptor contains a\n   <strong>\n    Class-specific AC Interface Header descriptor\n   </strong>\n   that provides the total length of the descriptor and any associated\n   <strong>\n    Terminal\n   </strong>\n   or\n   <strong>\n    Unit\n   </strong>\n   descriptors.\n  </p>\n</li>\n</ul>\n<h4>\n Terminal Descriptors\n</h4>\n<p>\n A\n <strong>\n  Terminal descriptor\n </strong>\n defines an addressable logical object that represents either a USB endpoint or another interface connecting the audio function to the external environment. There are two key types of Terminal descriptors:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Input Terminal\n   </strong>\n   : This descriptor is associated with an\n   <strong>\n    IN endpoint\n   </strong>\n   , which receives audio information from the host. It defines the characteristics of the endpoint receiving the audio data.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Output Terminal\n   </strong>\n   : This descriptor is associated with an\n   <strong>\n    OUT endpoint\n   </strong>\n   , which transmits audio information to the host. It defines the endpoint through which the device sends audio data.\n  </p>\n</li>\n</ul>\n<p>\n Both the\n <strong>\n  Input\n </strong>\n and\n <strong>\n  Output\n </strong>\n Terminal descriptors are required for every isochronous endpoint in an audio interface. These terminals define how the audio data flows in and out of the device, with their terminology based on the perspective of the audio function rather than the USB host. For example, an\n <strong>\n  IN endpoint\n </strong>\n corresponds to an\n <strong>\n  Output Terminal\n </strong>\n from the audio function\u2019s perspective.\n</p>\n<p>\n The\n <strong>\n  Terminal descriptor\n </strong>\n helps the host system understand where the audio data is coming from (Input) and where it is going (Output), allowing for accurate\n</p>\n"}, "Page 206": {"response": "<h3>\n Audio Terminals and Units in Audio Functions\n</h3>\n<p>\n In the AudioControl Interface,\n <strong>\n  Terminals\n </strong>\n and\n <strong>\n  Unit descriptors\n </strong>\n are key elements in defining how audio data is routed within the device.\n</p>\n<h4>\n Terminals\n</h4>\n<ul>\n<li>\n<strong>\n   Input Terminal\n  </strong>\n  : This terminal handles incoming audio data from the host. It is associated with an\n  <strong>\n   IN endpoint\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Output Terminal\n  </strong>\n  : This terminal sends audio data to the host and is linked with an\n  <strong>\n   OUT endpoint\n  </strong>\n  .\n </li>\n</ul>\n<p>\n Other terminals might represent connections to audio components like microphones or speakers. For example:\n</p>\n<ul>\n<li>\n  A\n  <strong>\n   microphone\n  </strong>\n  could send data to an\n  <strong>\n   Input Terminal\n  </strong>\n  , which then transmits the data to the host via an\n  <strong>\n   Output Terminal\n  </strong>\n  .\n </li>\n<li>\n  Alternatively, audio data received from the host at an\n  <strong>\n   Input Terminal\n  </strong>\n  (OUT endpoint) could be sent to a\n  <strong>\n   speaker\n  </strong>\n  via an\n  <strong>\n   Output Terminal\n  </strong>\n  .\n </li>\n</ul>\n<h4>\n Unit Descriptors\n</h4>\n<p>\n A\n <strong>\n  Unit descriptor\n </strong>\n represents a logical object within an audio function, which could be a subfunction such as a\n <strong>\n  microphone\n </strong>\n or a\n <strong>\n  speaker\n </strong>\n . These units help identify and organize the components within the audio system.\n</p>\n<p>\n Table 7-3 lists the\n <strong>\n  Unit types\n </strong>\n defined in the audio specification, helping to categorize different subfunctions.\n</p>\n<p>\n If the\n <strong>\n  AudioControl Interface\n </strong>\n has an interrupt endpoint, there will also be an\n <strong>\n  endpoint descriptor\n </strong>\n for that endpoint.\n</p>\n<hr/>\n<h3>\n AudioStreaming Interface\n</h3>\n<p>\n After the\n <strong>\n  AudioControl\n </strong>\n interface, the\n <strong>\n  Audio Interface Collection\n </strong>\n may include one or more\n <strong>\n  AudioStreaming interfaces\n </strong>\n . These interfaces define the data flow for audio and provide specific information about the data formats and processing delays.\n</p>\n<h4>\n AudioStreaming Interface Descriptors\n</h4>\n<ul>\n<li>\n<strong>\n   AudioStreaming Interface Descriptor\n  </strong>\n  : This descriptor identifies the interface as belonging to the audio class with\n  <code>\n   bInterfaceClass = 01h\n  </code>\n  and\n  <code>\n   bInterfaceSubclass = 02h\n  </code>\n  for AudioStreaming.\n </li>\n<li>\n<strong>\n   Class-Specific AudioStreaming Interface Descriptor\n  </strong>\n  : This descriptor follows the AudioStreaming Interface descriptor and provides more details, such as the associated terminal and the data format used, including formats like\n  <strong>\n   Pulse Code Modulation (PCM)\n  </strong>\n  ,\n  <strong>\n   AC-3\n  </strong>\n  (Digital Audio Compression), and\n  <strong>\n   MPEG\n  </strong>\n  .\n </li>\n</ul>\n<p>\n Some formats may require additional\n <strong>\n  AS Format-specific Type descriptors\n </strong>\n to define particular characteristics.\n</p>\n<h4>\n Isochronous Endpoints\n</h4>\n<p>\n Each\n <strong>\n  AudioStreaming\n </strong>\n interface typically has one isochronous endpoint. Isochronous transfers are necessary for handling continuous data streams like audio, where timing is critical. The endpoint will have:\n</p>\n<ul>\n<li>\n<strong>\n   Standard Endpoint Descriptor\n  </strong>\n  : This descriptor defines the basic properties of the endpoint.\n </li>\n<li>\n<strong>\n   Class-Specific AS Isochronous Audio Data Endpoint Descriptor\n  </strong>\n  : This descriptor indicates the specific audio controls supported by the endpoint and includes details such as whether the endpoint requires non-zero-length data packets and the maximum packet size (\n  <code>\n   wMaxPacketSize\n  </code>\n  ).\n </li>\n</ul>\n<p>\n These descriptors work together to ensure that audio data is transferred efficiently, with timing precision nece\n</p>\n"}, "Page 207": {"response": "<h3>\n MIDIStreaming Interface\n</h3>\n<p>\n The\n <strong>\n  MIDIStreaming Interface\n </strong>\n is used to support MIDI (Musical Instrument Digital Interface) data within an audio device. MIDI is a protocol for transmitting data that represents music or other sound control information, and in the context of USB, it allows MIDI devices to communicate with the host via USB.\n</p>\n<h4>\n MIDIStreaming Interface Descriptors\n</h4>\n<p>\n The\n <strong>\n  MIDIStreaming\n </strong>\n interface is a type of\n <strong>\n  Audio Interface Collection\n </strong>\n . In this interface:\n</p>\n<ul>\n<li>\n<strong>\n   bInterfaceClass\n  </strong>\n  = 01h to identify it as part of the audio class.\n </li>\n<li>\n<strong>\n   bInterfaceSubclass\n  </strong>\n  = 03h to specify it as a\n  <strong>\n   MIDIStreaming\n  </strong>\n  interface.\n </li>\n</ul>\n<p>\n Following this initial descriptor, there are\n <strong>\n  class-specific MIDIStreaming descriptors\n </strong>\n . The first one in the series is the\n <strong>\n  MIDIStreaming Interface Header descriptor\n </strong>\n , which provides the total length of the descriptor itself, along with all subsequent\n <strong>\n  Jack\n </strong>\n and/or\n <strong>\n  Element\n </strong>\n descriptors.\n</p>\n<p>\n These descriptors help the host system identify the MIDI-related capabilities of the device and determine how to handle MIDI data transfers.\n</p>\n<h4>\n Purpose of MIDIStreaming\n</h4>\n<p>\n MIDI is primarily used for controlling sound devices such as synthesizers, sound cards, and other musical instruments. It transmits control information about various characteristics of sounds, such as pitch, volume, and length. In the case of USB, MIDI data uses a specific format but differs from traditional MIDI interfaces because it travels over USB using bulk transfers instead of asynchronous data packets. This format allows for more robust and high-speed communication.\n</p>\n<p>\n The MIDIStreaming interface ensures that MIDI data is properly routed through the USB bus, allowing users to connect MIDI devices, such as controllers or synthesizers, to a co\n</p>\n"}, "Page 208": {"response": "<h3>\n MIDIStreaming Interface (Continued)\n</h3>\n<h4>\n MIDI Elements and Jack Types\n</h4>\n<p>\n In the\n <strong>\n  MIDIStreaming Interface\n </strong>\n , an\n <strong>\n  Element\n </strong>\n serves as the intermediary between MIDI and audio data streams or between multiple MIDI streams. These Elements are critical for translating and routing the MIDI data effectively within the system. There are several types of\n <strong>\n  MIDI Jacks\n </strong>\n , each serving a different role:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    MIDI IN Jack\n   </strong>\n   \u2013 This jack receives MIDI data from external sources, such as other MIDI devices.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    MIDI OUT Jack\n   </strong>\n   \u2013 This jack sends MIDI data to external devices.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Embedded MIDI Jack\n   </strong>\n   \u2013 This type of jack represents a USB endpoint and is typically used in a virtual connection between the USB system and a MIDI device:\n  </p>\n<ul>\n<li>\n<strong>\n     Embedded MIDI OUT Jack\n    </strong>\n    corresponds to a USB IN endpoint.\n   </li>\n<li>\n<strong>\n     Embedded MIDI IN Jack\n    </strong>\n    corresponds to a USB OUT endpoint.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    External MIDI Jack\n   </strong>\n   \u2013 This is a physical jack that connects the USB device to other MIDI devices in the external environment, allowing direct communication between the USB system and external MIDI equipment.\n  </p>\n</li>\n</ol>\n<h4>\n USB to MIDI Data Conversion\n</h4>\n<p>\n Every\n <strong>\n  USB MIDI device\n </strong>\n contains a\n <strong>\n  USB/MIDI converter\n </strong>\n that manages the conversion between USB data and MIDI data. Specifically, this converter translates the USB communication protocol into MIDI messages that can be understood by MIDI devices and vice versa.\n</p>\n<ul>\n<li>\n  A single\n  <strong>\n   USB endpoint\n  </strong>\n  can be connected to up to\n  <strong>\n   16 Embedded MIDI Jacks\n  </strong>\n  .\n </li>\n<li>\n  MIDI data travels in\n  <strong>\n   32-bit USBMIDI Event Packets\n  </strong>\n  , where the first 4 bits of the packet specify the specific MIDI event being communicated.\n </li>\n</ul>\n<p>\n This structure enables the efficient and flexible transmission of MIDI data over USB, allowing for rich, real-time control and communication between MIDI devices\n</p>\n"}, "Page 209": {"response": "<h3>\n Embedded MIDI Jacks and MIDIStreaming Interfaces\n</h3>\n<h4>\n Embedded and External MIDI Jacks\n</h4>\n<p>\n In a\n <strong>\n  MIDIStreaming interface\n </strong>\n ,\n <strong>\n  Embedded MIDI Jacks\n </strong>\n serve as internal points of connection for MIDI data within a device. These are linked to\n <strong>\n  External MIDI Jacks\n </strong>\n or other\n <strong>\n  Embedded MIDI Jacks\n </strong>\n , allowing data to flow seamlessly between different components.\n</p>\n<ul>\n<li>\n<strong>\n   External MIDI Jacks\n  </strong>\n  provide physical connections for linking the device to other MIDI devices.\n </li>\n<li>\n  Multiple\n  <strong>\n   External MIDI OUT Jacks\n  </strong>\n  can be used in a configuration called\n  <strong>\n   MIDI PARALLEL OUT\n  </strong>\n  , allowing for simultaneous data transmission to multiple external devices.\n </li>\n</ul>\n<p>\n Each\n <strong>\n  MIDI IN Jack\n </strong>\n ,\n <strong>\n  MIDI OUT Jack\n </strong>\n , and\n <strong>\n  Element\n </strong>\n within the device has its own\n <strong>\n  class-specific descriptor\n </strong>\n , which helps identify and manage the data flow between these components.\n</p>\n<h4>\n MIDIStreaming Endpoints\n</h4>\n<p>\n A\n <strong>\n  MIDIStreaming interface\n </strong>\n can include various endpoints for handling MIDI data. These endpoints can be:\n</p>\n<ol>\n<li>\n<strong>\n   Standard MS Bulk Data endpoints\n  </strong>\n  \u2013 Used for the general bulk transfer of MIDI data.\n </li>\n<li>\n<strong>\n   Class-specific MS Transfer Bulk Data endpoints\n  </strong>\n  \u2013 Specialized endpoints that handle more specific or higher-bandwidth MIDI data transfers.\n </li>\n</ol>\n<ul>\n<li>\n  For many MIDI devices,\n  <strong>\n   one Standard Bulk Data IN endpoint\n  </strong>\n  and\n  <strong>\n   one Standard Bulk Data OUT endpoint\n  </strong>\n  are sufficient to manage the traffic.\n </li>\n<li>\n  Devices that require greater bandwidth may use additional\n  <strong>\n   MS Transfer Bulk Data endpoints\n  </strong>\n  .\n </li>\n</ul>\n<p>\n The\n <strong>\n  Set_Endpoint_Control\n </strong>\n request can be used by the host to dynamically allocate a\n <strong>\n  Transfer Bulk Data endpoint\n </strong>\n to a specific\n <strong>\n  Element\n </strong>\n . This flexibility is useful for specific tasks like transferring\n <strong>\n  DownLoadable Sounds (DLS)\n </strong>\n to a\n <strong>\n  Synthesizer Element\n </strong>\n or uploading\n <strong>\n  program code\n </strong>\n to a\n <strong>\n  programmable Element\n </strong>\n .\n</p>\n<h4>\n Unit Types in Audio Class\n</h4>\n<p>\n The\n <strong>\n  Audio Class specification\n </strong>\n defines several\n <strong>\n  Unit Types\n </strong>\n , which correspond to different functional components or processing capabilities in an audio system. These include:\n</p>\n<ol>\n<li>\n<strong>\n   Mixer\n  </strong>\n  \u2013 Combines multiple input channels into output channels.\n </li>\n<li>\n<strong>\n   Selector\n  </strong>\n  \u2013 Routes selected audio channel clusters to an output without modification.\n </li>\n<li>\n<strong>\n   Feature\n  </strong>\n  \u2013 Provides controls for parameters like volume, tone, and mute.\n </li>\n<li>\n<strong>\n   Processing\n  </strong>\n  \u2013 Transforms input audio channels into a single output cluster.\n </li>\n<li>\n<strong>\n   Up/Down-mix Processing\n  </strong>\n  \u2013 Combines or splits audio channels to alter the output channel count.\n </li>\n<li>\n<strong>\n   Dolby Prologic Processing\n  </strong>\n  \u2013 A specialized\n  <strong>\n   Up/Down-mix Processing Unit\n  </strong>\n  for extracting additional audio data.\n </li>\n<li>\n<strong>\n   3D-Stereo Extender Processing\n  </strong>\n  \u2013 Adds spatial effects to stereo sound.\n </li>\n<li>\n<strong>\n   Reverberation Processing\n  </strong>\n  \u2013 Adds acoustic effects simulating different room environments.\n </li>\n<li>\n<strong>\n   Chorus Processing\n  </strong>\n  \u2013 Adds a chorus effect to the audio.\n </li>\n<li>\n<strong>\n   Dynamic Range Compressor\n  </strong>\n  \u2013 Controls the dynamic range of the audio signal, limiting extremes in volume.\n </li>\n<li>\n<strong>\n   Extension Unit\n  </strong>\n  \u2013 Allows for the addition of custom, vendor-specific functionality.\n </li>\n</ol>\n<p>\n These\n <strong>\n  Unit Types\n </strong>\n provide a variety of functions, enhancing the flexibility and capability of audio devices. Each unit typically includes a descriptor that desc\n</p>\n"}, "Page 210": {"response": "<h3>\n Audio Class Endpoints and Class-specific Requests\n</h3>\n<h4>\n Endpoints for MIDI and Audio Data\n</h4>\n<p>\n Each\n <strong>\n  MIDIStreaming\n </strong>\n and\n <strong>\n  AudioStreaming\n </strong>\n endpoint must have a\n <strong>\n  standard endpoint descriptor\n </strong>\n . In the case of\n <strong>\n  Standard Bulk Data endpoints\n </strong>\n , an additional\n <strong>\n  MS Bulk Data endpoint descriptor\n </strong>\n is used, which links the endpoint to the\n <strong>\n  Embedded MIDI Jacks\n </strong>\n associated with it. This setup ensures the accurate routing of MIDI or audio data to the correct internal and external connections.\n</p>\n<h4>\n Class-specific Requests for Audio Controls\n</h4>\n<p>\n The\n <strong>\n  audio class\n </strong>\n specification defines several\n <strong>\n  optional class-specific requests\n </strong>\n . These requests allow for:\n</p>\n<ol>\n<li>\n<strong>\n   Setting and getting the state of audio controls\n  </strong>\n  \u2013 This allows the host to control audio properties such as volume, mute, and other parameters.\n </li>\n<li>\n<strong>\n   Accessing memory\n  </strong>\n  \u2013 This enables direct memory manipulation in devices that support it, often used for tasks like storing audio configurations or presets.\n </li>\n<li>\n<strong>\n   Requesting status information\n  </strong>\n  \u2013 This provides the host with updates on the current state or any error conditions of the audio device.\n </li>\n</ol>\n<p>\n These requests are used to fine-tune the operation of audio devices and interact with their internal settings and memory.\n</p>\n<h3>\n USB Chips for Audio Support\n</h3>\n<p>\n There are various\n <strong>\n  USB-capable chips\n </strong>\n available that provide built-in support for audio functions. These chips typically include support for encoding/decoding (codec functions), analog-to-digital conversion (ADC), digital-to-analog conversion (DAC), and can handle the\n <strong>\n  Sony/Philips Digital Interface (S/PDIF)\n </strong>\n , which is used for transmitting digital audio data.\n</p>\n<p>\n Here are some common chips:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Texas Instruments PCM2900\n   </strong>\n   : A stereo audio codec that integrates a full-speed USB port, a 16-bit\n   <strong>\n    ADC\n   </strong>\n   and\n   <strong>\n    DAC\n   </strong>\n   , and an\n   <strong>\n    AudioControl interface\n   </strong>\n   . It also supports\n   <strong>\n    AudioStreaming\n   </strong>\n   interfaces for both input and output directions and includes a\n   <strong>\n    HID interface\n   </strong>\n   to report pin statuses. It doesn't require user programming but allows for customization through vendor-specific IDs and strings. The\n   <strong>\n    PCM2902\n   </strong>\n   model additionally supports\n   <strong>\n    S/PDIF encoding\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Philips Semiconductors UDA1325\n   </strong>\n   : Another\n   <strong>\n    USB audio codec\n   </strong>\n   for handling stereo audio with a USB interface.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Texas Instruments PCM2702\n   </strong>\n   : A 16-bit stereo DAC with a\n   <strong>\n    full-speed USB interface\n   </strong>\n   . It supports audio sampling rates of\n   <strong>\n    48 kHz\n   </strong>\n   ,\n   <strong>\n    44.1 kHz\n   </strong>\n   , and\n   <strong>\n    32 kHz\n   </strong>\n   , and can handle either\n   <strong>\n    16-bit stereo\n   </strong>\n   or\n   <strong>\n    monaural audio data\n   </strong>\n   . It also features\n   <strong>\n    digital attenuation\n   </strong>\n   and a\n   <strong>\n    soft-mute\n   </strong>\n   option for controlling audio volume smoothly.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Texas Instruments TUSB3200A\n   </strong>\n   : A\n   <strong>\n    USB Streaming Controller\n   </strong>\n   with a built-in\n   <strong>\n    8052-compatible microcontroller\n   </strong>\n   . It can handle up to\n   <strong>\n    seven IN endpoints\n   </strong>\n   and\n   <strong>\n    seven OUT endpoints\n   </strong>\n   . This chip provides audio support with a codec port interface, a\n   <strong>\n    DMA controller\n   </strong>\n   (Direct Memory Access) for streaming\n   <strong>\n    isochronous data\n   </strong>\n   to and from the codec, and includes a\n   <strong>\n    phase lock loop (PLL)\n   </strong>\n   and\n   <strong>\n    adaptive clock generator (ACG)\n   </strong>\n   to maintain synchronization during audio data transmission.\n  </p>\n</li>\n</ul>\n<p>\n These chips simplify the design and development of USB-based audio devices, as they handle much of the complex functionality\n</p>\n"}, "Page 211": {"response": "<h3>\n Windows Support for USB Audio Devices and Smart Card Interfaces\n</h3>\n<h4>\n USB Audio Devices on Windows\n</h4>\n<p>\n Windows offers support for USB audio devices, including MIDI devices, through the\n <strong>\n  usbaudio.sys\n </strong>\n minidriver. However, in versions up to\n <strong>\n  Windows XP\n </strong>\n , this driver only supports a subset of the features specified in the USB audio standard. To address these limitations,\n <strong>\n  Microsoft\u2019s Universal Audio Architecture (UAA)\n </strong>\n initiative promises an enhanced driver architecture for future Windows releases. A detailed white paper,\n <em>\n  USB Audio Devices and Windows\n </em>\n , explains the capabilities and constraints of Windows XP\u2019s audio driver system.\n</p>\n<p>\n Applications on Windows can interact with USB audio devices in a few ways:\n</p>\n<ol>\n<li>\n<strong>\n   DirectMusic\n  </strong>\n  and\n  <strong>\n   DirectSound\n  </strong>\n  components of\n  <strong>\n   DirectX\n  </strong>\n  technology for audio streaming.\n </li>\n<li>\n  Traditional\n  <strong>\n   Windows Multimedia audio functions\n  </strong>\n  , offering basic audio capabilities.\n </li>\n</ol>\n<h4>\n Chip/Smart Card Interface\n</h4>\n<p>\n Smart cards are widely used for various purposes such as making phone calls, accessing toll roads, providing keyless entry, storing medical and insurance information, and even enabling satellite TV receivers. These cards contain memory and, in some cases, a processor (CPU). Many smart cards allow for updates to their stored data (such as changing monetary value or entry codes).\n</p>\n<p>\n Smart cards come in two types:\n</p>\n<ul>\n<li>\n<strong>\n   Contact cards\n  </strong>\n  , which have exposed electrical contacts.\n </li>\n<li>\n<strong>\n   Contactless cards\n  </strong>\n  , which communicate via embedded antennas.\n </li>\n</ul>\n<p>\n A\n <strong>\n  Chip Card Interface Device (CCID)\n </strong>\n is used to access the data on a smart card. These devices are typically known as\n <strong>\n  smart card readers\n </strong>\n , but many also have the ability to write data to cards.\n <strong>\n  USB interfaces\n </strong>\n are common in modern CCIDs for communication with USB hosts, enabling easy connection to computers.\n</p>\n<h4>\n Documentation and Standards for Smart Card Interfaces\n</h4>\n<p>\n The\n <strong>\n  USB Chip/Smart Card Interface Devices\n </strong>\n specification defines the protocol for CCIDs that communicate via USB. The latest version at the time of writing is\n <strong>\n  version 1.0\n </strong>\n . Additionally, the\n <strong>\n  ISO/IEC 7816 standard\n </strong>\n , available from the International Organization for Standardization (ISO), outlines the physical characteristics and communication methods for smart cards, providing further details for i\n</p>\n"}, "Page 212": {"response": "<h3>\n Chip/Smart Card Interface Overview\n</h3>\n<h4>\n CCID Requirements\n</h4>\n<p>\n For any\n <strong>\n  Chip Card Interface Device (CCID)\n </strong>\n to function properly, it must have at least one bulk endpoint in each direction (IN and OUT). Devices that allow for removable smart cards must also feature an\n <strong>\n  interrupt IN endpoint\n </strong>\n to handle specific communication tasks.\n</p>\n<p>\n The communication between the\n <strong>\n  host\n </strong>\n and\n <strong>\n  device\n </strong>\n occurs via bulk endpoints. A\n <strong>\n  CCID message\n </strong>\n typically consists of a\n <strong>\n  10-byte header\n </strong>\n , followed by data that is specific to the message. The specification defines\n <strong>\n  14 commands\n </strong>\n that the host can use to send various types of data, including status and control information, as well as requesting additional data.\n</p>\n<ul>\n<li>\n  Each command sent by the host requires a\n  <strong>\n   response message\n  </strong>\n  from the CCID. This response contains:\n  <ul>\n<li>\n    A\n    <strong>\n     message code\n    </strong>\n</li>\n<li>\n<strong>\n     Status information\n    </strong>\n</li>\n<li>\n    Optionally,\n    <strong>\n     additional requested data\n    </strong>\n</li>\n</ul>\n</li>\n</ul>\n<p>\n In addition to responding to commands, the CCID uses its interrupt endpoint to report errors, as well as the insertion or removal of a smart card.\n</p>\n<h4>\n Descriptors for CCID\n</h4>\n<p>\n The\n <strong>\n  CCID function\n </strong>\n is defined at the interface level, and this is reflected in the\n <strong>\n  interface descriptor\n </strong>\n . To specify the CCID class, the\n <strong>\n  bInterfaceClass\n </strong>\n is set to\n <strong>\n  0Bh\n </strong>\n .\n</p>\n<p>\n Following the interface descriptor, a\n <strong>\n  class-specific CCID descriptor\n </strong>\n is included, where\n <strong>\n  bDescriptorType\n </strong>\n is set to\n <strong>\n  21h\n </strong>\n . The CCID descriptor provides several important parameters, including:\n</p>\n<ul>\n<li>\n  The\n  <strong>\n   number of slots\n  </strong>\n  available for cards.\n </li>\n<li>\n<strong>\n   Slot voltages\n  </strong>\n  that the device can support.\n </li>\n<li>\n<strong>\n   Supported protocols\n  </strong>\n  for communication.\n </li>\n<li>\n<strong>\n   Supported clock frequencies\n  </strong>\n  and\n  <strong>\n   data rates\n  </strong>\n  .\n </li>\n<li>\n  The\n  <strong>\n   maximum message length\n  </strong>\n  that the device can handle.\n </li>\n</ul>\n<p>\n This structure ensures that the host and the device can properly interpret and manage the data exchanged, including the oper\n</p>\n"}, "Page 213": {"response": "<h3>\n Class-Specific Requests and Communication Devices\n</h3>\n<h4>\n Class-Specific Control Requests for CCID\n</h4>\n<p>\n There are three key\n <strong>\n  class-specific control requests\n </strong>\n for Chip Card Interface Devices (CCID). These requests are used to manage various aspects of CCID communication, such as setting parameters for smart card interactions.\n</p>\n<ul>\n<li>\n<strong>\n   Abort (Request 01h)\n  </strong>\n  : This request is required to terminate ongoing operations and reset the communication flow.\n </li>\n<li>\n<strong>\n   Get_Clock_Frequencies (Request 02h)\n  </strong>\n  : This request is necessary if the CCID device doesn't automatically select the appropriate clock frequency. The request helps retrieve available clock frequencies.\n </li>\n<li>\n<strong>\n   Get_Data_Rates (Request 03h)\n  </strong>\n  : Similar to the clock frequency request, this is required if the CCID doesn't automatically adjust the data rate. It helps obtain the supported data rates.\n </li>\n</ul>\n<h4>\n Chips Supporting CCID\n</h4>\n<p>\n CCID devices can utilize various\n <strong>\n  USB controllers\n </strong>\n . Some controllers, particularly those designed for smart card readers, may have\n <strong>\n  built-in CCID functionality\n </strong>\n . Examples include:\n</p>\n<ul>\n<li>\n<strong>\n   Alcor Micro Corporation\u2019s AU9510\n  </strong>\n  chip, which supports USB communication for CCID functions.\n </li>\n<li>\n<strong>\n   Winbond Electronics Corporation\u2019s W81E381D\n  </strong>\n  , a microcontroller compatible with the\n  <strong>\n   8052 architecture\n  </strong>\n  , offering both USB and smart card reader interfaces.\n </li>\n</ul>\n<h4>\n Windows Support for CCIDs\n</h4>\n<p>\n Earlier versions of\n <strong>\n  Windows (up to Windows XP)\n </strong>\n did not include a built-in USB driver for CCIDs. However, since\n <strong>\n  Windows 2000\n </strong>\n , a USB driver has been available via\n <strong>\n  Windows Update\n </strong>\n . This driver facilitates communication between the host and the CCID.\n</p>\n<p>\n Applications communicate with CCID devices using the\n <strong>\n  DeviceIoControl\n </strong>\n API functions, but there are limitations with this driver. Notably, the driver does not support features such as\n <strong>\n  PIN entry\n </strong>\n or\n <strong>\n  multi-slot readers\n </strong>\n .\n</p>\n<h4>\n Communication Devices: Modems and Networks\n</h4>\n<p>\n The\n <strong>\n  communication device class\n </strong>\n covers two primary types of devices:\n <strong>\n  telephones\n </strong>\n and\n <strong>\n  medium-speed networking devices\n </strong>\n .\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Telephones\n   </strong>\n   include various types, such as:\n  </p>\n<ul>\n<li>\n<strong>\n     Analog phones\n    </strong>\n</li>\n<li>\n<strong>\n     Modems\n    </strong>\n    (e.g., V.250 modems)\n   </li>\n<li>\n<strong>\n     ISDN terminal adapters\n    </strong>\n</li>\n<li>\n<strong>\n     Digital phones\n    </strong>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Networking devices\n   </strong>\n   include:\n  </p>\n<ul>\n<li>\n<strong>\n     ADSL modems\n    </strong>\n</li>\n<li>\n<strong>\n     Cable modems\n    </strong>\n</li>\n<li>\n<strong>\n     Ethernet adapters\n    </strong>\n    and\n    <strong>\n     hubs\n    </strong>\n    (e.g.,\n    <strong>\n     10BASE-T Ethernet\n    </strong>\n    )\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n For communication devices, the\n <strong>\n  USB interface\n </strong>\n typically carries data using\n <strong>\n  application-specific protocols\n </strong>\n , including\n</p>\n"}, "Page 214": {"response": "<h3>\n Communication Devices: Modems and Networks\n</h3>\n<h4>\n Overview of Communication Device Class\n</h4>\n<p>\n The\n <strong>\n  communication-device class\n </strong>\n (CDC) encompasses devices used for telephony and networking, supporting protocols like\n <strong>\n  modem control\n </strong>\n or\n <strong>\n  Ethernet\n </strong>\n for data transmission. This class can also include devices that operate through\n <strong>\n  COM-port functions\n </strong>\n on the host computer. It is broadly applied in the context of modems, wireless devices, Ethernet adapters, and other networking hardware.\n</p>\n<h4>\n Documentation for Communication Devices\n</h4>\n<p>\n The main specification for communication devices is the\n <strong>\n  CDC (Communication Device Class)\n </strong>\n specification. There are also specific subclasses that have their own documentation:\n</p>\n<ul>\n<li>\n<strong>\n   Wireless Mobile Communications (WMC) Subclass\n  </strong>\n  : This subclass defines devices that can handle both audio and data communications, typically for wireless equipment.\n </li>\n<li>\n<strong>\n   Ethernet Emulation Model (EEM) Devices Subclass\n  </strong>\n  : This defines devices that send and receive Ethernet frames.\n </li>\n</ul>\n<p>\n The latest versions of the specifications are:\n</p>\n<ul>\n<li>\n<strong>\n   CDC\n  </strong>\n  : Version 1.1\n </li>\n<li>\n<strong>\n   WMC and EEM\n  </strong>\n  : Version 1.0\n </li>\n</ul>\n<p>\n Additionally, the\n <strong>\n  V.250 standard\n </strong>\n (formerly V.25ter, which includes the\n <strong>\n  Hayes AT command set\n </strong>\n ) defines modem communication protocols. Documentation for this can be found at the\n <strong>\n  International Telecommunication Union\n </strong>\n (\n <a rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n  www\n  .itu\n  .int\n </a>\n ).\n</p>\n<p>\n For Ethernet-related devices, the\n <strong>\n  IEEE 802.3\n </strong>\n standard applies, and can be accessed via\n <strong>\n  IEEE\n </strong>\n (\n <a rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n  www\n  .ieee\n  .org\n </a>\n ).\n</p>\n<p>\n The\n <strong>\n  Remote Network Driver Interface Specification (NDIS)\n </strong>\n defines how network interfaces (including USB devices) are configured and used to send Ethernet data.\n <strong>\n  Remote NDIS\n </strong>\n , which is based on the NDIS protocol, is supported by\n <strong>\n  Windows\n </strong>\n but not by other operating systems. Documentation for\n <strong>\n  NDIS\n </strong>\n and\n <strong>\n  Remote NDIS\n </strong>\n is available from\n <strong>\n  Microsoft\n </strong>\n (\n <a rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n  www\n  .microsoft\n  .com\n </a>\n ).\n</p>\n<h4>\n Communication Device Responsibilities\n</h4>\n<p>\n A communication device typically handles three main tasks:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Device Management\n   </strong>\n   : This includes tasks like controlling the device, configuring its settings, and notifying the host of events (e.g., device status changes).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Call Management\n   </strong>\n   : For devices like modems or telephones, this involves establishing and terminating calls or connections. However, not all communication devices require call management functionality.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Data Transmission\n   </strong>\n   : This refers to sending and receiving application data, such as phone conversations through a modem or file transfers over a network.\n  </p>\n</li>\n</ol>\n<h4>\n Models for Communication\n</h4>\n<p>\n The communication device class supports\n <strong>\n  three primary models\n </strong>\n for communication:\n</p>\n<ul>\n<li>\n<strong>\n   POTS (Plain Old Telephone Service)\n  </strong>\n  : This model applies to traditional phone services, such as landline modems.\n </li>\n<li>\n  Additional models include those designed for mobile and networking communications, al\n </li>\n</ul>\n"}, "Page 215": {"response": "<h3>\n Communication Devices: Modems and Networks (Continued)\n</h3>\n<h4>\n Communication Models\n</h4>\n<p>\n The\n <strong>\n  communication device class\n </strong>\n supports several communication models, designed for different types of data transfer:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    POTS (Plain Old Telephone Service)\n   </strong>\n   : This is used for traditional telephony services, like landline modems that work over regular phone lines.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    ISDN (Integrated Services Digital Network)\n   </strong>\n   : This model is used for phone lines with ISDN interfaces, offering higher-speed data transmission than standard phone lines.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Networking Model\n   </strong>\n   : This model is for devices that communicate via\n   <strong>\n    Ethernet\n   </strong>\n   or\n   <strong>\n    ATM (Asynchronous Transfer Mode)\n   </strong>\n   networks, offering broadband networking capabilities.\n  </p>\n</li>\n</ol>\n<p>\n Additionally, some\n <strong>\n  USB/Ethernet\n </strong>\n devices may use the\n <strong>\n  POTS model\n </strong>\n combined with a\n <strong>\n  vendor-specific protocol\n </strong>\n .\n</p>\n<h4>\n Notifications and Communication\n</h4>\n<p>\n<strong>\n  Notifications\n </strong>\n are used to announce events like ring detection, network connections, or disconnections. These notifications are sent to the host using either an\n <strong>\n  interrupt\n </strong>\n or\n <strong>\n  bulk pipe\n </strong>\n . Most devices prefer\n <strong>\n  interrupt pipes\n </strong>\n for these notifications.\n</p>\n<p>\n Each notification consists of:\n</p>\n<ul>\n<li>\n  An\n  <strong>\n   8-byte header\n  </strong>\n  .\n </li>\n<li>\n  A\n  <strong>\n   variable-length data field\n  </strong>\n  that contains the event information.\n </li>\n</ul>\n<h4>\n Descriptors for Communication Devices\n</h4>\n<p>\n Communication devices can be defined either at the\n <strong>\n  device\n </strong>\n level or the\n <strong>\n  interface\n </strong>\n level.\n</p>\n<ul>\n<li>\n  At the\n  <strong>\n   device level\n  </strong>\n  , all interfaces within the device are part of the communication function. The device descriptor indicates this by setting\n  <strong>\n   bDeviceClass = 02h\n  </strong>\n  , marking the device as a\n  <strong>\n   communication-device class\n  </strong>\n  .\n </li>\n<li>\n  At the\n  <strong>\n   interface level\n  </strong>\n  , the communication function is defined separately for each interface, and each interface has its own set of descriptors.\n </li>\n</ul>\n<p>\n In the\n <strong>\n  device descriptor\n </strong>\n ,\n <strong>\n  bDeviceClass = 02h\n </strong>\n signifies that the device belongs to the communication device class. Descriptors at the interface level (shown in Figure 7-5) describe the endpoi\n</p>\n"}, "Page 216": {"response": "<h3>\n Communication Device Class: Interface Descriptors and Functional Units\n</h3>\n<h4>\n Interface and Subclass Descriptors\n</h4>\n<p>\n Communication devices can be defined at both the\n <strong>\n  device\n </strong>\n and\n <strong>\n  interface\n </strong>\n levels. If defined at the\n <strong>\n  interface level\n </strong>\n , an\n <strong>\n  interface descriptor\n </strong>\n specifies which interfaces belong to the communication function. However, not all operating systems may support the\n <strong>\n  associated interface descriptor\n </strong>\n . The\n <strong>\n  1.1 communication-device class specification\n </strong>\n mentions that a method for associating interfaces is under development, and this method could be an option for future devices.\n</p>\n<p>\n Each\n <strong>\n  communication device\n </strong>\n must have an\n <strong>\n  interface descriptor\n </strong>\n with\n <strong>\n  bInterfaceClass = 02h\n </strong>\n , identifying the interface as part of the\n <strong>\n  communication device class\n </strong>\n . The\n <strong>\n  bInterfaceSubClass\n </strong>\n field within the descriptor specifies the communication model being used, as shown in\n <strong>\n  Table 7-4\n </strong>\n . Additionally, the\n <strong>\n  bInterfaceProtocol\n </strong>\n field names the specific protocol supported by the subclass, with defined values found in\n <strong>\n  Table 7-5\n </strong>\n .\n</p>\n<h4>\n Functional Descriptors\n</h4>\n<p>\n Following the\n <strong>\n  Communication Interface descriptor\n </strong>\n , there is a\n <strong>\n  class-specific Functional descriptor\n </strong>\n that provides detailed information about the communication function. This descriptor includes a\n <strong>\n  Header Functional descriptor\n </strong>\n followed by other\n <strong>\n  Functional descriptors\n </strong>\n .\n <strong>\n  Table 7-6\n </strong>\n lists the defined values for these descriptors.\n</p>\n<p>\n A key\n <strong>\n  Functional descriptor\n </strong>\n is the\n <strong>\n  Union Functional descriptor\n </strong>\n , which defines relationships among multiple interfaces to form a functional unit. The\n <strong>\n  master interface\n </strong>\n in the group is the controlling interface, which can send and receive messages that apply to the entire group. For example, a\n <strong>\n  Communication interface\n </strong>\n can be a master for a group consisting of a\n <strong>\n  Communication interface\n </strong>\n and a\n <strong>\n  Data interface\n </strong>\n . The group can also include other related interfaces like\n <strong>\n  audio\n </strong>\n or\n <strong>\n  HID\n </strong>\n interfaces.\n</p>\n<h4>\n Endpoints for Event Notifications\n</h4>\n<p>\n If the\n <strong>\n  Communication interface\n </strong>\n includes a bulk or interrupt endpoint for event notifications (such as call status or connection events), the endpoint will have a\n <strong>\n  standard endpoint descriptor\n </strong>\n .\n</p>\n<h4>\n Data Interface\n</h4>\n<p>\n In addition to the\n <strong>\n  Communication interface\n </strong>\n , a communication device may also include a\n <strong>\n  Data interface\n </strong>\n . This interface has\n <strong>\n  bInterfaceClass = 0Ah\n </strong>\n to indicate that it is part of the data transfer function. The\n <strong>\n  Data interface\n </strong>\n can include\n <strong>\n  bulk\n </strong>\n or\n <strong>\n  isochronous\n </strong>\n endpoints that are responsible for carrying application data. Like other interfaces, these endpoints will have a\n <strong>\n  standard endpoint descriptor\n </strong>\n .\n</p>\n<p>\n In summary, the\n <strong>\n  Communication Device Class\n </strong>\n is structured to support the management of communication functions, including device management, call management, and data transmission, with the option to include multiple interfaces and functional descriptors that define spe\n</p>\n"}, "Page 217": {"response": "<h3>\n Device Classes in USB Communication\n</h3>\n<p>\n In USB devices, the\n <strong>\n  Device Class\n </strong>\n defines the specific type of communication interface the device uses. Certain devices use a\n <strong>\n  Communication Interface\n </strong>\n for transmitting data, such as audio or Ethernet, and a\n <strong>\n  Data Interface\n </strong>\n for handling the actual data transfer.\n</p>\n<p>\n For example, a\n <strong>\n  USB/Ethernet converter\n </strong>\n using the\n <strong>\n  Remote NDIS\n </strong>\n (Remote Network Driver Interface Specification) device is split into two primary interfaces:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Communication Interface\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     bInterfaceSubClass\n    </strong>\n    value is set to\n    <code>\n     02h\n    </code>\n    (Abstract Control Model) to identify the model of communication.\n   </li>\n<li>\n    The\n    <strong>\n     bInterfaceProtocol\n    </strong>\n    is set to\n    <code>\n     FFh\n    </code>\n    for a vendor-specific protocol.\n   </li>\n<li>\n    This interface uses an\n    <strong>\n     interrupt endpoint\n    </strong>\n    to handle communication.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Data Interface\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    It has two\n    <strong>\n     bulk endpoints\n    </strong>\n    for efficient data transfer.\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n Each endpoint in these interfaces is described using an\n <strong>\n  Endpoint Descriptor\n </strong>\n .\n</p>\n<h3>\n Interface Descriptor: bInterfaceSubClass Field\n</h3>\n<p>\n The\n <strong>\n  bInterfaceSubClass\n </strong>\n field in the interface descriptor of a communication device specifies the communication model the device supports. Here\u2019s a breakdown of the codes and their meanings:\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Code (bInterfaceSubClass)\n    </strong>\n</th>\n<th>\n<strong>\n     Description\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     00h\n    </strong>\n</td>\n<td>\n    Reserved\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     01h\n    </strong>\n</td>\n<td>\n<strong>\n     Direct Line Control Model\n    </strong>\n    : Used by telephone modems, where the host provides data compression and error correction.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     02h\n    </strong>\n</td>\n<td>\n<strong>\n     Abstract Control Model\n    </strong>\n    : Used by telephone modems where the device provides data compression, error correction, and modulation/demodulation.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     03h\n    </strong>\n</td>\n<td>\n<strong>\n     Telephone Control Model\n    </strong>\n    : Used by telephones.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     04h\n    </strong>\n</td>\n<td>\n<strong>\n     Multi-Channel Control Model\n    </strong>\n    : For ISDN devices with multiple multiplexed channels.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     05h\n    </strong>\n</td>\n<td>\n<strong>\n     CAPI Control Model\n    </strong>\n    : For ISDN devices supporting\n    <strong>\n     COMMON-ISDN-API (CAPI)\n    </strong>\n    commands and messages.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     06h\n    </strong>\n</td>\n<td>\n<strong>\n     Ethernet Networking Control Model\n    </strong>\n    : For devices exchanging Ethernet-framed data.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     07h\n    </strong>\n</td>\n<td>\n<strong>\n     ATM Networking Control Model\n    </strong>\n    : For ATM devices.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     08h\u20130Bh\n    </strong>\n</td>\n<td>\n<strong>\n     WMC Models\n    </strong>\n    : For wireless mobile communication devices.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     0Ch\n    </strong>\n</td>\n<td>\n<strong>\n     Ethernet Emulation Model (EEM)\n    </strong>\n    : For devices that exchange Ethernet frames.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     0Dh\u20137Fh\n    </strong>\n</td>\n<td>\n    Reserved for future use.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     80h\u2013FEh\n    </strong>\n</td>\n<td>\n    Vendor-specific models.\n   </td>\n</tr>\n</tbody>\n</table>\n<p>\n This table defines how USB devices identify the communication model and the specific type of data transfer they support.\n</p>\n"}, "Page 218": {"response": "<h3>\n Ethernet Emulation Model and Class-Specific Requests\n</h3>\n<p>\n The\n <strong>\n  Ethernet Emulation Model (EEM)\n </strong>\n subclass offers an alternative method for using USB to transmit Ethernet frames. It is designed to be more cost-effective and efficient compared to the\n <strong>\n  Ethernet Networking Control Model\n </strong>\n , which is part of the communication-device class specification.\n</p>\n<h3>\n Class-Specific Requests\n</h3>\n<p>\n The communication-device class includes various\n <strong>\n  class-specific requests\n </strong>\n that allow for managing device status and control settings. However, not all requests are applicable to every device. Examples include:\n</p>\n<ul>\n<li>\n<strong>\n   Set_Hook_State\n  </strong>\n  : Used for placing a phone line on or off hook.\n </li>\n<li>\n<strong>\n   Set_Ethernet_Packet_Filter\n  </strong>\n  : Allows filtering of Ethernet traffic based on specific criteria.\n </li>\n</ul>\n<h3>\n Chips for Communication Devices\n</h3>\n<p>\n For\n <strong>\n  modems\n </strong>\n ,\n <strong>\n  Cypress Semiconductor\n </strong>\n provides reference designs using\n <strong>\n  EZ-USB controllers\n </strong>\n in combination with modem components from partner companies.\n</p>\n<p>\n For\n <strong>\n  USB/Ethernet bridges\n </strong>\n ,\n <strong>\n  Asix Electronics Corporation\n </strong>\n offers chips like the\n <strong>\n  AX88172 controller\n </strong>\n . This chip facilitates the conversion between full- or high-speed USB and 10- or 100-Mbps Ethernet. Key features of the chip include:\n</p>\n<ul>\n<li>\n  The\n  <strong>\n   Ethernet interface\n  </strong>\n  connects to an external Ethernet PHY.\n </li>\n<li>\n  An\n  <strong>\n   external serial EEPROM\n  </strong>\n  can store essential data such as the device\u2019s Ethernet hardware address, USB descriptors, and configuration settings.\n </li>\n<li>\n  The chip supports two\n  <strong>\n   bulk endpoints\n  </strong>\n  for efficient Ethernet data transfer.\n </li>\n</ul>\n<h3>\n bInterfaceProtocol Field in Communication Devices\n</h3>\n<p>\n The\n <strong>\n  bInterfaceProtocol\n </strong>\n field in the interface descriptor for a communication device specifies the protocol supported by the communications model. Here's a breakdown of the values:\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Code (bInterfaceProtocol)\n    </strong>\n</th>\n<th>\n<strong>\n     Description\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     00h\n    </strong>\n</td>\n<td>\n    No class-specific protocol required.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     01h\n    </strong>\n</td>\n<td>\n<strong>\n     AT commands\n    </strong>\n    (specified in ITU V.250).\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     02h\u201306h\n    </strong>\n</td>\n<td>\n<strong>\n     AT commands\n    </strong>\n    for wireless mobile communication (WMC) devices.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     07h\u2013FDh\n    </strong>\n</td>\n<td>\n    Reserved for future use.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     FEh\n    </strong>\n</td>\n<td>\n<strong>\n     External protocol\n    </strong>\n    for WMC devices.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     FFh\n    </strong>\n</td>\n<td>\n    Vendor-specific protocol.\n   </td>\n</tr>\n</tbody>\n</table>\n"}, "Page 219": {"response": "<h3>\n Vendor-Specific Chips and Windows Support for Modems\n</h3>\n<p>\n Several chip manufacturers provide solutions for\n <strong>\n  USB/Ethernet bridges\n </strong>\n and\n <strong>\n  modems\n </strong>\n :\n</p>\n<ul>\n<li>\n<strong>\n   Kawasaki Microelectronics\n  </strong>\n  offers chips that integrate\n  <strong>\n   Ethernet\n  </strong>\n  ,\n  <strong>\n   USB\n  </strong>\n  , and\n  <strong>\n   serial-EEPROM interfaces\n  </strong>\n  , as well as a\n  <strong>\n   16-bit CPU\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Freescale Semiconductor\n  </strong>\n  provides the\n  <strong>\n   MCF5482 ColdFire microprocessor\n  </strong>\n  , a\n  <strong>\n   32-bit\n  </strong>\n  processor that includes both a\n  <strong>\n   full/high-speed USB device controller\n  </strong>\n  and an\n  <strong>\n   Ethernet controller\n  </strong>\n  .\n </li>\n</ul>\n<h3>\n Windows Support for Modems\n</h3>\n<p>\n Windows 98 SE and later versions include the\n <strong>\n  usbser.sys\n </strong>\n modem driver, which is compatible with modems using the\n <strong>\n  Abstract Control Model\n </strong>\n . This driver facilitates the connection between the computer and USB modems that adhere to this standard.\n</p>\n<h3>\n Functional Descriptors\n</h3>\n<p>\n A\n <strong>\n  Functional Descriptor\n </strong>\n in a communication device consists of a\n <strong>\n  Header functional descriptor\n </strong>\n followed by specific descriptors that define the functionality of the device. Below are the values for the\n <strong>\n  bInterfaceSubClass\n </strong>\n and the associated\n <strong>\n  Functional Descriptor Types\n </strong>\n :\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     bInterfaceSubClass\n    </strong>\n</th>\n<th>\n<strong>\n     Functional Descriptor Type\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     00h\n    </strong>\n</td>\n<td>\n    Header\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     01h\n    </strong>\n</td>\n<td>\n    Call Management\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     02h\n    </strong>\n</td>\n<td>\n    Abstract Control Management\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     03h\n    </strong>\n</td>\n<td>\n    Direct Line Control Management\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     04h\n    </strong>\n</td>\n<td>\n    Telephone Ringer\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     05h\n    </strong>\n</td>\n<td>\n    Telephone Call and Line State Reporting Capabilities\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     06h\n    </strong>\n</td>\n<td>\n    Union\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     07h\n    </strong>\n</td>\n<td>\n    Country Selection\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     08h\n    </strong>\n</td>\n<td>\n    Telephone Operational Modes\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     09h\n    </strong>\n</td>\n<td>\n    USB Terminal\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     0Ah\n    </strong>\n</td>\n<td>\n    Network Channel Terminal\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     0Bh\n    </strong>\n</td>\n<td>\n    Protocol Unit\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     0Ch\n    </strong>\n</td>\n<td>\n    Extension Unit\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     0Dh\n    </strong>\n</td>\n<td>\n    Multi-channel Management\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     0Eh\n    </strong>\n</td>\n<td>\n    CAPI Control Management\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     0Fh\n    </strong>\n</td>\n<td>\n    Ethernet Networking\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     10h\n    </strong>\n</td>\n<td>\n    ATM Networking\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     11h\u201318h\n    </strong>\n</td>\n<td>\n    Wireless Mobile Communication (WMC) Functional Descriptors\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     19h\u2013FFh\n    </strong>\n</td>\n<td>\n    Reserved\n   </td>\n</tr>\n</tbody>\n</table>\n<p>\n These descriptors are part of the class-specific configuration and provide essential information about the device's capabilities and features.\n</p>\n"}, "Page 220": {"response": "<h3>\n Content Security in USB Devices\n</h3>\n<p>\n The\n <strong>\n  Content Security class\n </strong>\n in USB provides a method for content owners to control access to digital media like files, music, and video. This control is achieved using one of two defined\n <strong>\n  Content Security Methods (CSM)\n </strong>\n :\n</p>\n<ul>\n<li>\n<strong>\n   Basic Authorization\n  </strong>\n</li>\n<li>\n<strong>\n   Digital Transmission Content Protection (DTCP)\n  </strong>\n</li>\n</ul>\n<h3>\n Content Security Methods (CSM)\n</h3>\n<p>\n Each CSM has a specific specification document. As of now, the latest version of these specifications is\n <strong>\n  1.0\n </strong>\n . The\n <strong>\n  DTCP\n </strong>\n specification, along with license information, can be found through the\n <strong>\n  Digital Transmission Licensing Administrator\n </strong>\n at\n <strong>\n<a rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n   www\n   .dtcp\n   .com\n  </a>\n</strong>\n .\n</p>\n<h3>\n Protocol Overview\n</h3>\n<p>\n The Content Security class defines a protocol to:\n</p>\n<ol>\n<li>\n<strong>\n   Activate and deactivate\n  </strong>\n  a content security method (CSM).\n </li>\n<li>\n<strong>\n   Associate a CSM to a channel\n  </strong>\n  . A channel is a connection between an interface or endpoint and one or more CSMs. Note that only one CSM can be active on a channel at a time.\n </li>\n</ol>\n<h3>\n Basic Authorization (CSM-1)\n</h3>\n<p>\n<strong>\n  Basic Authorization\n </strong>\n (also known as\n <strong>\n  CSM-1\n </strong>\n ) involves a single class-specific request:\n <strong>\n  Get_Unique_ID\n </strong>\n . This request allows the host to retrieve a unique ID value from the device.\n</p>\n<h3>\n Windows Driver Support for Modems and Devices\n</h3>\n<ol>\n<li>\n<p>\n<strong>\n    Modem Driver Support\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     INF files\n    </strong>\n    : Devices using the Windows Telephony Application Programming Interface (TAPI) need a specific\n    <strong>\n     INF file\n    </strong>\n    . Microsoft offers a\n    <strong>\n     Modem Development Kit\n    </strong>\n    that includes tools, sample INF files, and documentation for creating and testing modem INF files.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Virtual COM Port\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Non-modem devices can also use the\n    <strong>\n     usbser.sys\n    </strong>\n    driver. To access such a device via\n    <strong>\n     COM-port functions\n    </strong>\n    (virtual COM port), the\n    <strong>\n     bInterfaceSubClass\n    </strong>\n    must be set to\n    <strong>\n     Abstract Control Model\n    </strong>\n    . However, for better performance, many developers opt to use third-party drivers instead.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Remote NDIS Support\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    For devices using Remote NDIS, the\n    <strong>\n     usb8023.sys\n    </strong>\n    driver is used to map this functionality to USB under Windows 2000 and later.\n   </li>\n</ul>\n</li>\n</ol>\n"}, "Page 221": {"response": "<h3>\n Content Security Methods (CSM) and Descriptors\n</h3>\n<h4>\n Content Security Method 2 (CSM-2): Digital Transmission Content Protection (DTCP)\n</h4>\n<p>\n<strong>\n  DTCP (Digital Transmission Content Protection)\n </strong>\n , or\n <strong>\n  CSM-2\n </strong>\n , was developed to prevent unauthorized copying of audio and video content transmitted via USB or other buses. With DTCP, a content owner can:\n</p>\n<ul>\n<li>\n  Specify whether content copying is allowed.\n </li>\n<li>\n  Identify authorized users.\n </li>\n<li>\n  Choose an encryption method for content protection.\n </li>\n</ul>\n<p>\n A\n <strong>\n  DTCP interface\n </strong>\n must include an\n <strong>\n  interrupt endpoint\n </strong>\n in both directions to handle event notifications, ensuring communication between the device and host.\n</p>\n<p>\n For content providers wanting to use DTCP, they must sign a\n <strong>\n  license agreement\n </strong>\n and pay a significant annual fee.\n</p>\n<h4>\n Other Content Security Methods\n</h4>\n<p>\n Two additional\n <strong>\n  Content Security Methods\n </strong>\n are being developed but don't yet have USB specifications:\n</p>\n<ul>\n<li>\n<strong>\n   CSM-3\n  </strong>\n  : Open Copy Protection System\n </li>\n<li>\n<strong>\n   CSM-4\n  </strong>\n  : Elliptic Curve Content Protection Protocol\n </li>\n</ul>\n<h4>\n Descriptors for Content Security\n</h4>\n<p>\n The\n <strong>\n  Content Security class\n </strong>\n is defined at the interface level, using\n <strong>\n  bInterfaceClass = 0Dh\n </strong>\n to indicate the Content Security class. There are four key\n <strong>\n  class-specific descriptors\n </strong>\n :\n</p>\n<ol>\n<li>\n<strong>\n   CS_GENERAL\n  </strong>\n  : Identifies the version number of the Content Security Interface. This descriptor is used once per interface.\n </li>\n<li>\n<strong>\n   Channel\n  </strong>\n  : Specifies one or more\n  <strong>\n   CSMs\n  </strong>\n  assigned to a channel, based on the interface number and endpoint address. This descriptor is used once per channel.\n </li>\n<li>\n<strong>\n   Content Security Method\n  </strong>\n  : Describes the\n  <strong>\n   CSM\n  </strong>\n  implemented on the device. This descriptor is used once per CSM.\n </li>\n<li>\n<strong>\n   Content Security Method Variant\n  </strong>\n  : Describes a variant of the associated CSM. This descriptor is not used by\n  <strong>\n   CSM-1\n  </strong>\n  (Basic Authorization) or\n  <strong>\n   CSM-2\n  </strong>\n  (DTCP).\n </li>\n</ol>\n<p>\n In addition to these,\n <strong>\n  CSM-2\n </strong>\n defines a\n <strong>\n  String descriptor\n </strong>\n containing the version information: \"Digital Transmission Content Protection Version 1.00\".\n</p>\n<h4>\n Class-Specific Requests for Content Security\n</h4>\n<p>\n There are two class-specific requests that apply to all\n <strong>\n  CSM interfaces\n </strong>\n :\n</p>\n<ol>\n<li>\n<strong>\n   Get_Channel_Settings\n  </strong>\n  : Allows the host to determine which\n  <strong>\n   CSM\n  </strong>\n  is assigned to a specific channel.\n </li>\n<li>\n<strong>\n   Set_Channel_Settings\n  </strong>\n  : Enables the host to assign a\n  <strong>\n   CSM\n  </strong>\n  to a channel or deactivate a previously assigned\n  <strong>\n   CSM\n  </strong>\n  .\n </li>\n</ol>\n"}, "Page 222": {"response": "<h3>\n Content Security Method 2 (CSM-2) Control Requests and Chips\n</h3>\n<p>\n<strong>\n  CSM-2 (Digital Transmission Content Protection)\n </strong>\n has additional control requests to handle\n <strong>\n  Authentication and Key Exchange (AKE)\n </strong>\n commands and responses, which are crucial for secure content protection during transmission.\n</p>\n<h4>\n Chips for Content Security\n</h4>\n<p>\n For devices that use\n <strong>\n  content security\n </strong>\n , the choice of\n <strong>\n  USB controller\n </strong>\n primarily depends on the required capabilities for exchanging the protected content. To implement a\n <strong>\n  Content-Security function\n </strong>\n , typically, only the\n <strong>\n  control endpoint\n </strong>\n and, for\n <strong>\n  CSM-2\n </strong>\n ,\n <strong>\n  two interrupt endpoints\n </strong>\n are needed.\n</p>\n<h3>\n Windows Support for Content Security\n</h3>\n<p>\n Windows does not include a dedicated driver for the\n <strong>\n  Content Security class\n </strong>\n , except for a specific function. In\n <strong>\n  Windows XP\n </strong>\n and later versions, if a device has a\n <strong>\n  CSM-1\n </strong>\n interface (Basic Authorization), an application can use the\n <strong>\n  DeviceIoControl\n </strong>\n function with the\n <strong>\n  dwIoControlCode\n </strong>\n parameter set to\n <strong>\n  IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER\n </strong>\n . This function allows the application to request the device\u2019s serial number from Windows' generic parent driver.\n</p>\n<h3>\n Device Firmware Upgrade (DFU) Class\n</h3>\n<p>\n The\n <strong>\n  Device Firmware Upgrade (DFU)\n </strong>\n class defines a protocol that enables a host to send firmware updates or patches to a device. After receiving the upgrade, the device re-enumerates itself using the new firmware version.\n</p>\n<h4>\n DFU Specification\n</h4>\n<p>\n The DFU specification outlines how the class operates. As of this writing, the current version is\n <strong>\n  1.0\n </strong>\n .\n</p>\n<h4>\n DFU Process Overview\n</h4>\n<p>\n To perform a\n <strong>\n  firmware upgrade\n </strong>\n , a device must support two sets of descriptors:\n</p>\n<ol>\n<li>\n<strong>\n   Run-time Descriptors\n  </strong>\n  : These are used during normal operation. They also inform the host that the device is capable of receiving firmware upgrades.\n </li>\n<li>\n<strong>\n   DFU-mode Descriptors\n  </strong>\n  : These descriptors are used when the device is in\n  <strong>\n   DFU mode\n  </strong>\n  , which is a special mode dedicated to receiving firmware upgrades.\n </li>\n</ol>\n"}, "Page 223": {"response": "<h3>\n Device Firmware Upgrade (DFU) Process and Descriptors\n</h3>\n<h4>\n DFU Process Overview\n</h4>\n<p>\n The\n <strong>\n  Device Firmware Upgrade (DFU)\n </strong>\n process involves four main phases:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Device Enumeration Phase\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The device sends its\n    <strong>\n     run-time descriptors\n    </strong>\n    to the host and operates normally (e.g., a keyboard sends keypress data).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Reconfiguration Phase\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The host sends a\n    <strong>\n     DFU_Upgrade\n    </strong>\n    request to initiate the upgrade. The device is then reset, and it re-enumerates using its\n    <strong>\n     DFU-mode descriptors\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Transfer Phase\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The host transfers the firmware upgrade to the device.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Manifestation Phase\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The device informs the host that the upgrade has been received. The host resets the bus, and the device re-enumerates using the new firmware, resuming its normal operation.\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n During these phases, the device transitions through defined states like\n <strong>\n  dfuIdle\n </strong>\n (waiting for DFU requests) or\n <strong>\n  dfuError\n </strong>\n (an error has occurred).\n</p>\n<h4>\n Firmware Upgrade File\n</h4>\n<p>\n The\n <strong>\n  upgrade file\n </strong>\n stored on the host contains the firmware and a\n <strong>\n  DFU suffix\n </strong>\n that helps ensure the firmware is valid and appropriate for the device. The\n <strong>\n  DFU suffix\n </strong>\n includes:\n</p>\n<ul>\n<li>\n  An error-checking value.\n </li>\n<li>\n  The ASCII signature \"DFU\".\n </li>\n<li>\n  Optional values such as\n  <strong>\n   Vendor ID\n  </strong>\n  ,\n  <strong>\n   Product ID\n  </strong>\n  , and\n  <strong>\n   product release number\n  </strong>\n  to match the firmware with the correct device.\n </li>\n</ul>\n<p>\n The suffix is for the\n <strong>\n  host\u2019s use only\n </strong>\n and is not sent to the device.\n</p>\n<h4>\n Device Identification and Driver Switching\n</h4>\n<p>\n To ensure that the host loads a new driver for the upgrade process, the device should use\n <strong>\n  different Product IDs\n </strong>\n in its\n <strong>\n  run-time\n </strong>\n and\n <strong>\n  DFU-mode\n </strong>\n descriptors.\n</p>\n<h4>\n DFU Communications\n</h4>\n<ul>\n<li>\n<strong>\n   DFU communications\n  </strong>\n  occur solely over the\n  <strong>\n   control endpoint\n  </strong>\n  .\n </li>\n</ul>\n<h3>\n DFU Descriptors\n</h3>\n<p>\n In a device supporting DFU, both the\n <strong>\n  run-time\n </strong>\n and\n <strong>\n  DFU-mode\n </strong>\n descriptors include a standard\n <strong>\n  interface descriptor\n </strong>\n with the following values:\n</p>\n<ul>\n<li>\n<strong>\n   bInterfaceClass = FEh\n  </strong>\n  : Indicates an\n  <strong>\n   Application Specific\n  </strong>\n  class.\n </li>\n<li>\n<strong>\n   bInterfaceSubClass = 01h\n  </strong>\n  : Identifies the device as supporting\n  <strong>\n   DFU\n  </strong>\n  (Device Firmware Upgrade).\n </li>\n</ul>\n"}, "Page 224": {"response": "<h3>\n Device Firmware Upgrade (DFU) Descriptors and Requests\n</h3>\n<h4>\n DFU Mode and Functional Descriptor\n</h4>\n<p>\n In\n <strong>\n  DFU mode\n </strong>\n , the DFU interface must be the\n <strong>\n  only active interface\n </strong>\n in the device. Both the\n <strong>\n  run-time\n </strong>\n and\n <strong>\n  DFU-mode\n </strong>\n descriptor sets include a\n <strong>\n  Run-time DFU Functional descriptor\n </strong>\n , which provides key information about the upgrade process:\n</p>\n<ul>\n<li>\n<strong>\n   Communication availability\n  </strong>\n  : Specifies if the device can communicate on the bus immediately after the\n  <strong>\n   manifestation phase\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Reset delay\n  </strong>\n  : Indicates how long the device should wait for a reset after receiving the\n  <strong>\n   DFU_Upgrade\n  </strong>\n  request.\n </li>\n<li>\n<strong>\n   Data transfer size\n  </strong>\n  : Defines the maximum number of bytes the device can accept in a\n  <strong>\n   control Write transfer\n  </strong>\n  during the firmware upgrade.\n </li>\n</ul>\n<h4>\n Class-Specific Requests\n</h4>\n<p>\n There are\n <strong>\n  seven class-specific requests\n </strong>\n in the DFU process, which handle various tasks during the firmware upgrade. These requests are:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    DFU_Detach\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    If a\n    <strong>\n     bus reset\n    </strong>\n    occurs within the specified time, this request causes the device to re-enumerate using the\n    <strong>\n     DFU-mode descriptors\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    DFU_Dnload\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Accepts new firmware during the\n    <strong>\n     Data stage\n    </strong>\n    of the request. If\n    <strong>\n     wLength = 0\n    </strong>\n    , it indicates that all firmware has been transferred.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    DFU_Upload\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Sends firmware to the host during the\n    <strong>\n     Data stage\n    </strong>\n    of the request.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    DFU_GetStatus\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Returns the device\u2019s status and any error information. If an error is encountered, the device enters the\n    <strong>\n     dfuError\n    </strong>\n    state.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    DFU_ClrStatus\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Clears the\n    <strong>\n     dfuError\n    </strong>\n    state and transitions to the\n    <strong>\n     dfuIdle\n    </strong>\n    state after a\n    <strong>\n     DFU_GetStatus\n    </strong>\n    request.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    DFU_GetState\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Similar to\n    <strong>\n     DFU_GetStatus\n    </strong>\n    , but the state remains unchanged even if there\u2019s an error.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    DFU_Abort\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Aborts the current upgrade process and returns the device to the\n    <strong>\n     dfuIdle\n    </strong>\n    state.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Chip Requirements for DFU\n</h4>\n<p>\n The choice of\n <strong>\n  USB controller\n </strong>\n for a device depends on the device's requirements in\n <strong>\n  run-time mode\n </strong>\n . The device must have enough\n <strong>\n  memory\n </strong>\n and other resources to store and implement the upgraded firmware.\n</p>\n<h4>\n Windows Support for DFU\n</h4>\n<p>\n Windows does not provide a default driver for the\n <strong>\n  DFU class\n </strong>\n . However,\n <strong>\n  STMicroelectronics\n </strong>\n offers a\n <strong>\n  Windows driver\n </strong>\n and\n <strong>\n  firmware examples\n </strong>\n for use with its\n <strong>\n  ST7 microcontrollers\n </strong>\n , which feature\n <strong>\n  Flash memory\n </strong>\n for firmware storage.\n</p>\n"}, "Page 225": {"response": "<h3>\n Human Interface Device (HID) Class Overview\n</h3>\n<p>\n The\n <strong>\n  Human Interface Device (HID)\n </strong>\n class encompasses devices like\n <strong>\n  keyboards\n </strong>\n ,\n <strong>\n  pointing devices\n </strong>\n (e.g., mice), and\n <strong>\n  game controllers\n </strong>\n , which allow the host to receive and act on human input. The primary goal is for the host to respond quickly enough so that users don't notice any delay between their actions and the corresponding response.\n</p>\n<h4>\n HID Data and Reports\n</h4>\n<p>\n All\n <strong>\n  HID data\n </strong>\n is transmitted in\n <strong>\n  reports\n </strong>\n , which are structured data packets with defined formats. These reports contain\n <strong>\n  Usage tags\n </strong>\n that instruct the host or device on how to interpret the received data. For example:\n</p>\n<ul>\n<li>\n  A\n  <strong>\n   Usage Page\n  </strong>\n  value of\n  <strong>\n   09h\n  </strong>\n  represents a button.\n </li>\n<li>\n  A corresponding\n  <strong>\n   Usage ID\n  </strong>\n  value identifies which button was pressed.\n </li>\n</ul>\n<p>\n Although primarily used for human-interface applications, the\n <strong>\n  HID class\n </strong>\n can also be used for vendor-specific functions. HID devices can exchange any type of data, but they are limited to using\n <strong>\n  control\n </strong>\n and\n <strong>\n  interrupt transfers\n </strong>\n for communication.\n</p>\n<h4>\n HID Specification and Documentation\n</h4>\n<p>\n The\n <strong>\n  HID specification\n </strong>\n is outlined in multiple documents. The current version of the HID specification is\n <strong>\n  1.11\n </strong>\n , which introduces a significant change from version\n <strong>\n  1.0\n </strong>\n : allowing the host to send reports via\n <strong>\n  interrupt OUT transfers\n </strong>\n , instead of the previous requirement of using\n <strong>\n  control transfers\n </strong>\n for all reports.\n</p>\n<p>\n Various\n <strong>\n  Usage Tables\n </strong>\n define values for different types of HID devices, such as keyboards, pointing devices, game controllers, displays, and telephone controls. Additionally, specialized documents define\n <strong>\n  Usage-tag values\n </strong>\n for other specific devices:\n</p>\n<ul>\n<li>\n<strong>\n   Class Definition for Physical Interface Devices (PID)\n  </strong>\n  : Defines values for devices that provide\n  <strong>\n   force-feedback\n  </strong>\n  or physical feedback, such as joysticks.\n </li>\n</ul>\n<h3>\n HID Drivers and Operating System Support\n</h3>\n<p>\n Since the introduction of USB support,\n <strong>\n  Windows\n </strong>\n and other operating systems have included\n <strong>\n  HID drivers\n </strong>\n . The availability of these class drivers has contributed to the popularity of HID for devices beyond traditional human-interface applications. These drivers make it easier to develop and use HID-based devices.\n</p>\n"}, "Page 226": {"response": "<h3>\n Human Interface Device (HID) Communication and Descriptors\n</h3>\n<h4>\n HID Communication\n</h4>\n<p>\n HID devices communicate by exchanging\n <strong>\n  reports\n </strong>\n using\n <strong>\n  control\n </strong>\n and\n <strong>\n  interrupt transfers\n </strong>\n . These reports are structured data packets that include information on user input, such as keypresses or mouse movements. There are three main types of reports in HID communication:\n</p>\n<ol>\n<li>\n<strong>\n   Input and Output Reports\n  </strong>\n  : These can use either control or interrupt transfers.\n </li>\n<li>\n<strong>\n   Feature Reports\n  </strong>\n  : These always use control transfers.\n </li>\n</ol>\n<p>\n A\n <strong>\n  report descriptor\n </strong>\n defines the size and structure of each report and provides\n <strong>\n  Usage values\n </strong>\n that explain what data is contained in the report.\n</p>\n<h4>\n HID Descriptors\n</h4>\n<p>\n At the\n <strong>\n  interface level\n </strong>\n , an HID function is defined by the following descriptors:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Interface Descriptor\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     bInterfaceClass = 03h\n    </strong>\n    : Indicates that the device belongs to the HID class.\n   </li>\n<li>\n<strong>\n     bInterfaceSubClass\n    </strong>\n    : Specifies whether the HID supports a\n    <strong>\n     boot protocol\n    </strong>\n    . This protocol allows devices, like mice and keyboards, to be used before the full HID driver is loaded by the host.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Class-Specific HID Descriptor\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This descriptor specifies the size of the\n    <strong>\n     report descriptor\n    </strong>\n    . The report descriptor contains detailed information about the data structure of HID reports.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Optional Physical Descriptor\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This describes the part(s) of the human body that interact with the device's controls (e.g., finger movements on a touchpad or keypresses on a keyboard).\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Class-Specific Requests\n</h4>\n<p>\n HID devices use six\n <strong>\n  class-specific control requests\n </strong>\n to manage communication and settings:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Sending and Receiving Reports\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    These requests allow for the transfer of HID data between the device and the host.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Idle Rate\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     Idle rate\n    </strong>\n    refers to how often the device sends a report when there is no change in the data. The HID can set or read the Idle rate.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Protocol\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     active protocol\n    </strong>\n    can be either\n    <strong>\n     boot\n    </strong>\n    or\n    <strong>\n     report\n    </strong>\n    . The host can set or read the currently active protocol.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Descriptors\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Requests can be made to obtain the\n    <strong>\n     report descriptor\n    </strong>\n    or\n    <strong>\n     physical descriptor\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Additional HID Usage Tables\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Monitor Control Class\n   </strong>\n   : Defines controls for\n   <strong>\n    display monitors\n   </strong>\n   , managing settings like brightness, contrast, and power. It is important to note that the\n   <strong>\n    HID interface\n   </strong>\n   only controls display settings, while the image data travels through a different hardware interface.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Power Devices\n   </strong>\n   : The\n   <strong>\n    HID Power Devices\n   </strong>\n   Usage Table defines values for devices like\n   <strong>\n    Uninterruptible Power Supplies (UPS)\n   </strong>\n   , which the host uses to monitor and control power components such as batteries.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Point of Sale (POS) Devices\n   </strong>\n   : The\n   <strong>\n    POS Usage Tables\n   </strong>\n   include values for devices like\n   <strong>\n    barcode readers\n   </strong>\n   ,\n   <strong>\n    weighing devices\n   </strong>\n   , and\n   <strong>\n    magnetic stripe readers\n   </strong>\n   .\n  </p>\n</li>\n</ul>\n"}, "Page 227": {"response": "<h3>\n HID Communication and Device Support\n</h3>\n<h4>\n Class-Specific Requests for HID Descriptors\n</h4>\n<p>\n To access HID descriptors, the host sends a\n <strong>\n  Get_Descriptor\n </strong>\n request to the interface. The\n <strong>\n  wValue\n </strong>\n parameter is used to specify the descriptor type:\n</p>\n<ul>\n<li>\n  The\n  <strong>\n   high byte\n  </strong>\n  of\n  <strong>\n   wValue\n  </strong>\n  is set to\n  <strong>\n   01h\n  </strong>\n  to indicate a class-specific descriptor.\n </li>\n<li>\n  The\n  <strong>\n   low byte\n  </strong>\n  of\n  <strong>\n   wValue\n  </strong>\n  can be set to\n  <strong>\n   22h\n  </strong>\n  to request the\n  <strong>\n   report descriptor\n  </strong>\n  or\n  <strong>\n   23h\n  </strong>\n  to request the\n  <strong>\n   physical descriptor\n  </strong>\n  .\n </li>\n</ul>\n<p>\n These descriptors are essential for understanding how the device communicates and interacts with the host.\n</p>\n<h4>\n HID Chipsets and Controllers\n</h4>\n<p>\n For many HID devices,\n <strong>\n  low speed\n </strong>\n USB is sufficient to handle user input without any noticeable delay. This speed is often chosen because it requires a cheaper and more flexible cable. However, HIDs are not limited to low speed and can operate at any speed.\n</p>\n<p>\n Various chipsets are available to support HIDs, including:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Atmel's AT43USB325\n   </strong>\n   : This chipset contains an AVR microcontroller and a 5-port hub. One of the hub's ports connects to an embedded function supporting a\n   <strong>\n    20 x 8 keyboard matrix\n   </strong>\n   , and it supports\n   <strong>\n    low\n   </strong>\n   and\n   <strong>\n    full speeds\n   </strong>\n   . A similar version of this chipset supports an\n   <strong>\n    18 x 8 keyboard matrix\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Cypress' CY7C63743\n   </strong>\n   : A general-purpose controller that supports both\n   <strong>\n    USB\n   </strong>\n   and\n   <strong>\n    PS/2\n   </strong>\n   interfaces, making it suitable for designing dual-interface devices.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Code Mercenaries\n   </strong>\n   : Offers\n   <strong>\n    MouseWarrior\n   </strong>\n   ,\n   <strong>\n    KeyWarrior\n   </strong>\n   , and\n   <strong>\n    JoyWarrior\n   </strong>\n   series chips. These chips are designed for various types of input devices, such as\n   <strong>\n    keyboards\n   </strong>\n   ,\n   <strong>\n    pointing devices\n   </strong>\n   , and\n   <strong>\n    game controllers\n   </strong>\n   . They support multiple interfaces, including\n   <strong>\n    USB\n   </strong>\n   ,\n   <strong>\n    PS/2\n   </strong>\n   ,\n   <strong>\n    asynchronous serial\n   </strong>\n   , and\n   <strong>\n    Apple Desktop Bus (ADB)\n   </strong>\n   .\n  </p>\n</li>\n</ul>\n<h4>\n Windows Support for HID Devices\n</h4>\n<p>\n Applications that interact with HID devices can use\n <strong>\n  API functions\n </strong>\n to exchange reports. Common functions include:\n</p>\n<ul>\n<li>\n<strong>\n   ReadFile\n  </strong>\n  and\n  <strong>\n   WriteFile\n  </strong>\n  : Standard functions for reading and writing data.\n </li>\n<li>\n<strong>\n   HidD_SetFeature\n  </strong>\n  and\n  <strong>\n   HidD_GetFeature\n  </strong>\n  : HID-specific functions for interacting with device features.\n </li>\n</ul>\n<p>\n For game controllers, applications can use\n <strong>\n  DirectInput\n </strong>\n , a component of\n <strong>\n  DirectX\n </strong>\n , for more direct and faster access to device inputs. This is especially useful for real-time applications like gaming, where minimizing input lag is critical.\n</p>\n"}, "Page 228": {"response": "<h3>\n Windows Handling of HID Input and IrDA Bridges\n</h3>\n<h4>\n HID Input Handling in Windows\n</h4>\n<p>\n Windows manages input from system keyboards and pointing devices exclusively. This means applications cannot directly access reports containing information about keypresses, mouse movements, or button clicks. The operating system automatically handles this data, providing higher-level functionality. For instance, a Visual Basic application doesn\u2019t need to manually read mouse events to detect clicks; these events trigger automatically in the operating system.\n</p>\n<p>\n If a system has multiple keyboards or pointing devices, Windows treats them as a single \"virtual\" device. However, if you want to control which applications can access a specific keyboard or pointing device, or if you want to identify the source of input, you need to:\n</p>\n<ul>\n<li>\n  Create a\n  <strong>\n   digitally signed filter driver\n  </strong>\n  .\n </li>\n<li>\n  Design a\n  <strong>\n   vendor-specific device\n  </strong>\n  that the host doesn\u2019t recognize as a standard system keyboard or pointing device.\n </li>\n</ul>\n<p>\n This helps in ensuring that only authorized applications can interact with specific input devices or that devices are handled uniquely.\n</p>\n<h4>\n IrDA Bridge for Infrared Communication\n</h4>\n<p>\n The\n <strong>\n  IrDA Bridge\n </strong>\n enables communication between USB and\n <strong>\n  Infrared Data Association (IrDA)\n </strong>\n devices. IrDA defines the hardware and protocols for data transfer via infrared light, typically for short-range communication between devices.\n</p>\n<h5>\n Documentation and Overview\n</h5>\n<p>\n The\n <strong>\n  USB IrDA bridge\n </strong>\n specification is detailed in the\n <strong>\n  IrDA Bridge Device Definition\n </strong>\n , version\n <strong>\n  1.0\n </strong>\n . Further IrDA-related specifications can be accessed through\n <strong>\n<a rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n   www\n   .irda\n   .org\n  </a>\n</strong>\n .\n</p>\n<p>\n Data in an IrDA communication uses the\n <strong>\n  Infrared Link Access Protocol (IrLAP)\n </strong>\n . This protocol defines the format for frames exchanged over the IrDA link, which includes:\n</p>\n<ul>\n<li>\n<strong>\n   IrLAP Payload\n  </strong>\n  : The main content of the frame, which contains:\n  <ul>\n<li>\n<strong>\n     Address\n    </strong>\n    : Identifies the source and destination of the data.\n   </li>\n<li>\n<strong>\n     Control\n    </strong>\n    : Specifies how the data is handled.\n   </li>\n<li>\n<strong>\n     Optional Data Fields\n    </strong>\n    : The actual data being transferred.\n   </li>\n</ul>\n</li>\n<li>\n  Each frame also includes:\n  <ul>\n<li>\n    An\n    <strong>\n     error-checking value\n    </strong>\n    for data integrity.\n   </li>\n<li>\n    Markers indicating the\n    <strong>\n     start\n    </strong>\n    and\n    <strong>\n     end\n    </strong>\n    of the frame.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n This allows devices to exchange data, monitor, and control each other over short distances via infrared.\n</p>\n"}, "Page 229": {"response": "<h3>\n USB IrDA Bridge Overview\n</h3>\n<h4>\n Data Transfer with USB IrDA Bridge\n</h4>\n<p>\n The\n <strong>\n  USB IrDA bridge\n </strong>\n facilitates communication between the host and an IrDA device by using\n <strong>\n  bulk pipes\n </strong>\n for data transfer. Both the host and the bridge use headers to exchange status and control information.\n</p>\n<ul>\n<li>\n<p>\n   When the IrDA bridge receives data from the IrDA link, it extracts the\n   <strong>\n    IrLAP Payload\n   </strong>\n   , adds a header, and passes it along to the host.\n  </p>\n</li>\n<li>\n<p>\n   The header contains information such as:\n  </p>\n<ul>\n<li>\n<strong>\n     Media_Busy\n    </strong>\n    : Indicates if the link is busy.\n   </li>\n<li>\n<strong>\n     Link_Speed\n    </strong>\n    : Specifies the data transfer speed.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n   When the host sends data to the IrDA bridge, it adds its own header, which may include:\n  </p>\n<ul>\n<li>\n    New\n    <strong>\n     Link_Speed\n    </strong>\n    values.\n   </li>\n<li>\n<strong>\n     Beginning-of-frame\n    </strong>\n    markers to mark the start of the frame.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n   The bridge then encapsulates the\n   <strong>\n    IrDA Payload\n   </strong>\n   into an\n   <strong>\n    IrDA frame\n   </strong>\n   for transmission.\n  </p>\n</li>\n</ul>\n<h4>\n IrDA Bridge Descriptors\n</h4>\n<p>\n The\n <strong>\n  IrDA bridge\n </strong>\n is defined at the\n <strong>\n  interface subclass level\n </strong>\n . The interface descriptor includes the following information:\n</p>\n<ul>\n<li>\n<strong>\n   bInterfaceClass = FEh\n  </strong>\n  : Indicates an application-specific interface.\n </li>\n<li>\n<strong>\n   bInterfaceSubclass = 02h\n  </strong>\n  : Identifies the device as an IrDA Bridge.\n </li>\n</ul>\n<p>\n A\n <strong>\n  class-specific descriptor\n </strong>\n provides additional IrDA-specific details, such as:\n</p>\n<ul>\n<li>\n  The maximum number of bytes the device can handle in an\n  <strong>\n   IrDA frame\n  </strong>\n  .\n </li>\n<li>\n  The supported\n  <strong>\n   Baud rates\n  </strong>\n  for communication.\n </li>\n</ul>\n<h4>\n Class-Specific Requests\n</h4>\n<p>\n The IrDA Bridge supports five\n <strong>\n  class-specific control requests\n </strong>\n :\n</p>\n<table>\n<thead>\n<tr>\n<th>\n    Request\n   </th>\n<th>\n    bRequest\n   </th>\n<th>\n    Description\n   </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n    Receiving\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Checks if the device is currently receiving an\n    <strong>\n     IrLAP frame\n    </strong>\n    .\n   </td>\n</tr>\n<tr>\n<td>\n    Check_Media_Busy\n   </td>\n<td>\n    3\n   </td>\n<td>\n    Determines if there is\n    <strong>\n     infrared traffic\n    </strong>\n    present.\n   </td>\n</tr>\n<tr>\n<td>\n    Set_IrDA_Rate_Sniff\n   </td>\n<td>\n    4\n   </td>\n<td>\n    Configures the device to accept frames at any speed or a specific speed.\n   </td>\n</tr>\n<tr>\n<td>\n    Set_IrDA_Unicast_List\n   </td>\n<td>\n    5\n   </td>\n<td>\n    Configures the device to accept frames only from specified addresses.\n   </td>\n</tr>\n<tr>\n<td>\n    Get_Class_Specific_Descriptors\n   </td>\n<td>\n    6\n   </td>\n<td>\n    Retrieves the\n    <strong>\n     class-specific descriptor\n    </strong>\n    from the device.\n   </td>\n</tr>\n</tbody>\n</table>\n<h4>\n Chips Supporting IrDA Bridge Functionality\n</h4>\n<p>\n<strong>\n  SigmaTel\u2019s STIR4000\n </strong>\n is a chip that supports IrDA communication through USB. It contains a\n <strong>\n  full-speed USB transceiver\n </strong>\n and an interface for an\n <strong>\n  IrDA transceiver\n </strong>\n . The host interacts with this chip through a series of registers to:\n</p>\n<ul>\n<li>\n  Configure the device.\n </li>\n<li>\n  Retrieve\n  <strong>\n   status information\n  </strong>\n  .\n </li>\n<li>\n  Exchange\n  <strong>\n   data\n  </strong>\n  .\n </li>\n</ul>\n"}, "Page 230": {"response": "<h3>\n USB Mass Storage Class Overview\n</h3>\n<h4>\n General Overview of Mass Storage Devices\n</h4>\n<p>\n The\n <strong>\n  mass-storage class\n </strong>\n supports devices that transfer files between the device and a host computer. This class is typically used for devices such as:\n</p>\n<ul>\n<li>\n<strong>\n   Floppy drives\n  </strong>\n</li>\n<li>\n<strong>\n   Hard drives\n  </strong>\n</li>\n<li>\n<strong>\n   CD/DVD drives\n  </strong>\n</li>\n<li>\n<strong>\n   Flash memory devices\n  </strong>\n</li>\n<li>\n<strong>\n   Cameras\n  </strong>\n  (for accessing picture files stored in the camera\u2019s memory)\n </li>\n</ul>\n<p>\n Devices that use the mass-storage class are recognized by\n <strong>\n  Windows\n </strong>\n as drives, which allows users to perform file operations such as\n <strong>\n  copying\n </strong>\n ,\n <strong>\n  moving\n </strong>\n , and\n <strong>\n  deleting\n </strong>\n files. These devices typically use file systems that can be accessed easily through\n <strong>\n  My Computer\n </strong>\n in Windows.\n</p>\n<h4>\n Documentation\n</h4>\n<p>\n The specification for USB mass-storage devices is divided into several documents, covering various aspects of the class:\n</p>\n<ol>\n<li>\n<strong>\n   Overview Document (version 1.2)\n  </strong>\n  : Provides an introduction to the mass-storage class.\n </li>\n<li>\n<strong>\n   Bulk-Only Transport Protocol (version 1.0)\n  </strong>\n  : Defines a protocol that supports bulk data transfer between devices and hosts.\n </li>\n<li>\n<strong>\n   Control/Bulk/Interrupt (CBI) Transport Protocol (version 1.1)\n  </strong>\n  : Provides an alternative protocol for data transfer, combining control, bulk, and interrupt transfers.\n </li>\n<li>\n<strong>\n   Universal Floppy Interface (UFI) Commands (version 1.0)\n  </strong>\n  : Details commands specific to floppy disks for mass storage purposes.\n </li>\n</ol>\n<h4>\n IrDA Bridge Chips\n</h4>\n<p>\n<strong>\n  SigmaTel\u2019s STIR4000\n </strong>\n is a popular chip that supports USB-to-IrDA bridge functionality. It offers a full-speed USB transceiver and an interface for an IrDA transceiver, which allows the host to communicate with IrDA devices. This chip uses\n <strong>\n  vendor-specific control requests\n </strong>\n to read and write to internal registers. The\n <strong>\n  STIR4200\n </strong>\n is an advanced, high-speed version of this chip.\n</p>\n<p>\n Another method for adding IrDA functionality to a USB host involves using a\n <strong>\n  USB/asynchronous-serial converter\n </strong>\n with IrDA support. For example,\n <strong>\n  Texas Instruments\u2019 TUSB3410\n </strong>\n chip is designed for both wired and IrDA serial interfaces. It features an internal\n <strong>\n  UART\n </strong>\n for serial communication and an internal\n <strong>\n  IrDA encoder/decoder\n </strong>\n for IrDA data, which connects to an external IrDA transceiver for communication.\n</p>\n<h4>\n Windows Support for IrDA\n</h4>\n<p>\n Windows XP supports\n <strong>\n  IrDA communications\n </strong>\n through two software profiles:\n</p>\n<ol>\n<li>\n<strong>\n   Dial-Up Networking Profile\n  </strong>\n  : This profile enables an IrDA connection between a\n  <strong>\n   PC and mobile phone\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   LAN Access Profile\n  </strong>\n  : This allows for the use of the\n  <strong>\n   Point-to-Point Protocol (PPP)\n  </strong>\n  for peer-to-peer connections, or for connecting directly to a network access point.\n </li>\n</ol>\n<p>\n However,\n <strong>\n  Windows XP does not include a generic driver\n </strong>\n for the USB IrDA bridge function.\n <strong>\n  SigmaTel\n </strong>\n provides drivers for their chips to enable proper support for the USB IrDA bridge on Windows XP.\n</p>\n<p>\n This detailed structure of USB mass-storage class and IrDA bridge functionality shows how different devices and chips are supported, how they interact with the host, and how software enables seamless communication and data transfer.\n</p>\n"}, "Page 231": {"response": "<h3>\n USB Mass Storage Class: Media Types and Protocols\n</h3>\n<h4>\n Industry-Standard Command-Block Sets for Mass Storage Devices\n</h4>\n<p>\n Mass storage devices use industry-standard\n <strong>\n  command-block sets\n </strong>\n to control devices and retrieve status information. These standards vary depending on the type of media used. Below are the specifications for various device types supported by the\n <strong>\n  mass-storage class\n </strong>\n :\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    ATAPI CD/DVD devices\n   </strong>\n   : These devices follow the\n   <strong>\n    ATA/ATAPI\n   </strong>\n   specification (available at\n   <a href=\"http://www.t13.org\" rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n    www\n    .t13\n    .org\n   </a>\n   ) and the\n   <strong>\n    MultiMedia Command Set (MMC)\n   </strong>\n   (available at\n   <a href=\"http://www.t10.org\" rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n    www\n    .t10\n    .org\n   </a>\n   ). The earlier version of the ATA/ATAPI specification was called\n   <strong>\n    SFF 8020i\n   </strong>\n   . ATAPI removable media uses the\n   <strong>\n    SFF-8070i\n   </strong>\n   specification, which is a supplement to the ATA/ATAPI standard and is available at\n   <a href=\"http://www.sffcommittee.com\" rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n    www\n    .sffcommittee\n    .com\n   </a>\n   . Floppy drives typically belong to this subclass.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Generic SCSI media\n   </strong>\n   : These devices use commands from the\n   <strong>\n    SCSI Primary Command (SPC)\n   </strong>\n   and\n   <strong>\n    SCSI Block Command (SBC)\n   </strong>\n   Sets, available at\n   <a href=\"http://www.t10.org\" rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n    www\n    .t10\n    .org\n   </a>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    QIC-157 tape drives\n   </strong>\n   : These devices use the\n   <strong>\n    Common SCSI/ATAPI Command Set for Streaming Tape\n   </strong>\n   , which can be found at\n   <a href=\"http://www.qic.org\" rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n    www\n    .qic\n    .org\n   </a>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    UFI devices\n   </strong>\n   : The\n   <strong>\n    UFI Command Specification\n   </strong>\n   is used, based on the\n   <strong>\n    SCSI-2\n   </strong>\n   and\n   <strong>\n    SFF-8070i\n   </strong>\n   command sets. This specification is available at\n   <a href=\"http://www.usb.org\" rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n    www\n    .usb\n    .org\n   </a>\n   .\n  </p>\n</li>\n</ul>\n<h4>\n Overview of Mass-Storage Data Transfers\n</h4>\n<p>\n Mass-storage devices use\n <strong>\n  bulk transfers\n </strong>\n to exchange data, as this method is ideal for transferring large amounts of information efficiently.\n <strong>\n  Control transfers\n </strong>\n are used for sending class-specific requests and clearing\n <strong>\n  Stall\n </strong>\n conditions on bulk endpoints. Two transport protocols are commonly used for exchanging other information:\n</p>\n<ol>\n<li>\n<strong>\n   Bulk-Only\n  </strong>\n  : This protocol is generally recommended for all new devices of any type.\n </li>\n<li>\n<strong>\n   Control/Bulk/Interrupt (CBI)\n  </strong>\n  : This protocol is approved only for\n  <strong>\n   full-speed floppy drives\n  </strong>\n  .\n </li>\n</ol>\n<h5>\n Bulk-Only Protocol\n</h5>\n<p>\n In the\n <strong>\n  bulk-only protocol\n </strong>\n , a successful data transfer is completed in three stages:\n</p>\n<ol>\n<li>\n<strong>\n   Command Transport\n  </strong>\n  : The host sends a command to the device within a\n  <strong>\n   Command Block Wrapper (CBW)\n  </strong>\n  . The CBW structure contains essential information to identify the command being sent to the device.\n </li>\n<li>\n<strong>\n   Data Transport\n  </strong>\n  : The host or the device sends the requested data. This phase involves the transfer of data based on the command issued in the first stage.\n </li>\n<li>\n<strong>\n   Status Transport\n  </strong>\n  : The device sends a status message to indicate whether the operation was successful or if any error occurred.\n </li>\n</ol>\n<p>\n This three-stage process ensures reliable communication between the host and the mass-storage device, allowing the exchange of data, control commands, and status updates efficiently.\n</p>\n"}, "Page 232": {"response": "<h3>\n Command Block Wrapper (CBW) and Command Status Wrapper (CSW)\n</h3>\n<p>\n In mass-storage data transfers, the\n <strong>\n  Command Block Wrapper (CBW)\n </strong>\n and\n <strong>\n  Command Status Wrapper (CSW)\n </strong>\n are essential structures used to manage data exchanges between the host and the device. Here's a detailed breakdown of each:\n</p>\n<h4>\n Command Block Wrapper (CBW)\n</h4>\n<p>\n The\n <strong>\n  CBW\n </strong>\n is a 31-byte structure used to send commands from the host to the device. The device uses this structure to understand what action it should take and whether data will be transferred. The\n <strong>\n  CBW\n </strong>\n consists of several fields that help the device interpret the command properly.\n</p>\n<p>\n Key fields in the\n <strong>\n  CBW\n </strong>\n :\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    dCBWSignature (32 bits)\n   </strong>\n   : This field contains the value\n   <strong>\n    43425355h\n   </strong>\n   , which identifies the structure as a\n   <strong>\n    CBW\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    dCBWTag (32 bits)\n   </strong>\n   : This field is a tag used to associate the\n   <strong>\n    CBW\n   </strong>\n   with the\n   <strong>\n    CSW\n   </strong>\n   (Command Status Wrapper) that the device will send in response to this command.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    dCBWDataTransferLength (32 bits)\n   </strong>\n   : This field indicates how many bytes the host expects to transfer in the data-transport stage.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bmCBWFlags (8 bits)\n   </strong>\n   : This specifies the direction of the data-transport stage. If bit 7 is 0, it means an\n   <strong>\n    OUT\n   </strong>\n   transfer (host to device); if bit 7 is 1, it means an\n   <strong>\n    IN\n   </strong>\n   transfer (device to host). If no data transfer is needed, this field is ignored.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Reserved (4 bits)\n   </strong>\n   : These bits are set to zero and are unused.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bCBWLUN (4 bits)\n   </strong>\n   : For devices with multiple\n   <strong>\n    LUNs (Logical Unit Numbers)\n   </strong>\n   , this specifies the\n   <strong>\n    LUN\n   </strong>\n   to which the command block is directed. If the device has a single\n   <strong>\n    LUN\n   </strong>\n   , this value is set to zero.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Reserved (3 bits)\n   </strong>\n   : Set to zero and unused.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bCBWCBLength (5 bits)\n   </strong>\n   : Specifies the length of the command block (in bytes), ranging from 1 to 16.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    CBWCB (128 bits)\n   </strong>\n   : This field contains the actual\n   <strong>\n    command block\n   </strong>\n   with the details of the command the device should execute. The size of this field can vary depending on the length specified in\n   <strong>\n    bCBWCBLength\n   </strong>\n   .\n  </p>\n</li>\n</ul>\n<p>\n When the device receives a\n <strong>\n  CBW\n </strong>\n , it must verify that it is valid. A\n <strong>\n  CBW\n </strong>\n is considered valid if:\n</p>\n<ul>\n<li>\n  It has been received after a\n  <strong>\n   CSW\n  </strong>\n  or reset.\n </li>\n<li>\n  It is exactly 31 bytes in length.\n </li>\n<li>\n  The\n  <strong>\n   dCBWSignature\n  </strong>\n  is correct.\n </li>\n<li>\n  The\n  <strong>\n   bCBWLUN\n  </strong>\n  value is supported.\n </li>\n<li>\n  The\n  <strong>\n   bCBWCBLength\n  </strong>\n  and\n  <strong>\n   CBWCB\n  </strong>\n  match the subclass of the device.\n </li>\n</ul>\n<h4>\n Command Status Wrapper (CSW)\n</h4>\n<p>\n The\n <strong>\n  CSW\n </strong>\n is a 13-byte structure used by the device to send status information back to the host after the command has been executed. The\n <strong>\n  CSW\n </strong>\n tells the host whether the operation was successful, and if not, what the error might be.\n</p>\n<p>\n Key fields in the\n <strong>\n  CSW\n </strong>\n :\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    dCSWSignature (32 bits)\n   </strong>\n   : This field contains the value\n   <strong>\n    53425355h\n   </strong>\n   , identifying the structure as a\n   <strong>\n    CSW\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    dCSWTag (32 bits)\n   </strong>\n   : The tag that associates this\n   <strong>\n    CSW\n   </strong>\n   with the original\n   <strong>\n    CBW\n   </strong>\n   sent by the host.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    dCSWDataResidue (32 bits)\n   </strong>\n   : This field indicates the number of bytes that were not transferred during the data-transport stage.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bmCSWStatus (8 bits)\n   </strong>\n   : This field specifies the status of the command. If the operation was successful, this will be\n   <strong>\n    00h\n   </strong>\n   ; for errors, the value will be\n   <strong>\n    01h\n   </strong>\n   or\n   <strong>\n    02h\n   </strong>\n   depending on the type of error.\n  </p>\n</li>\n</ul>\n<p>\n When the device receives a\n <strong>\n  CSW\n </strong>\n , it must check that it is valid. A\n <strong>\n  CSW\n </strong>\n is valid if:\n</p>\n<ul>\n<li>\n  It is exactly 13 bytes in length.\n </li>\n<li>\n  The\n  <strong>\n   dCSWSignature\n  </strong>\n  is correct.\n </li>\n<li>\n  It matches the\n  <strong>\n   dCSWTag\n  </strong>\n  value in the corresponding\n  <strong>\n   CBW\n  </strong>\n  .\n </li>\n</ul>\n<p>\n The\n <strong>\n  CSW\n </strong>\n is important because it allows the host to understand the result of a command and take any necessary actions based on success or error conditions.\n</p>\n"}, "Page 233": {"response": "<h3>\n Command Status Wrapper (CSW) - Details and Descriptors\n</h3>\n<h4>\n CSW Fields and Validation\n</h4>\n<p>\n The\n <strong>\n  Command Status Wrapper (CSW)\n </strong>\n is used by the device to return status information to the host after processing a command. Here's a breakdown of its fields:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    dCSWSignature (32 bits)\n   </strong>\n   : This field contains the value\n   <strong>\n    53425355h\n   </strong>\n   , which identifies the structure as a\n   <strong>\n    CSW\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    dCBWTag (32 bits)\n   </strong>\n   : This field should match the\n   <strong>\n    dCBWTag\n   </strong>\n   from the\n   <strong>\n    CBW\n   </strong>\n   the host sent earlier, linking the\n   <strong>\n    CSW\n   </strong>\n   to the corresponding\n   <strong>\n    CBW\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    dCSWDataResidue (32 bits)\n   </strong>\n   : This field indicates the number of bytes not processed in the data-transport stage:\n  </p>\n<ul>\n<li>\n    For\n    <strong>\n     OUT\n    </strong>\n    transfers (host to device), it shows the difference between\n    <strong>\n     dCBWDataTransferLength\n    </strong>\n    and the number of bytes processed by the device.\n   </li>\n<li>\n    For\n    <strong>\n     IN\n    </strong>\n    transfers (device to host), it shows the difference between\n    <strong>\n     dCBWDataTransferLength\n    </strong>\n    and the number of bytes sent by the device.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    bCSWStatus (8 bits)\n   </strong>\n   : This field shows the status of the command:\n  </p>\n<ul>\n<li>\n<strong>\n     00h\n    </strong>\n    : Command succeeded (passed).\n   </li>\n<li>\n<strong>\n     01h\n    </strong>\n    : Command failed.\n   </li>\n<li>\n<strong>\n     02h\n    </strong>\n    : Phase error (e.g., an error in the phase of the command processing).\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n A\n <strong>\n  CSW\n </strong>\n is considered valid and meaningful if:\n</p>\n<ul>\n<li>\n  It has the correct\n  <strong>\n   dCSWSignature\n  </strong>\n  and\n  <strong>\n   dCSWTag\n  </strong>\n  matching the\n  <strong>\n   CBW\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   bCSWStatus\n  </strong>\n  is either\n  <strong>\n   02h\n  </strong>\n  or\n  <strong>\n   00h\n  </strong>\n  /\n  <strong>\n   01h\n  </strong>\n  (with\n  <strong>\n   dCSWDataResidue\n  </strong>\n  less than or equal to\n  <strong>\n   dCBWDataTransferLength\n  </strong>\n  ).\n </li>\n</ul>\n<h4>\n Mass Storage Descriptors\n</h4>\n<p>\n In the mass-storage class, the\n <strong>\n  interface descriptor\n </strong>\n defines the function and capabilities of the device:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    bInterfaceClass = 08h\n   </strong>\n   : This value indicates the interface belongs to the\n   <strong>\n    mass-storage class\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bInterfaceSubClass\n   </strong>\n   : This field identifies the supported command-block set, which can vary depending on the type of mass storage device. The following are common sub-classes:\n  </p>\n<ul>\n<li>\n<strong>\n     02h\n    </strong>\n    :\n    <strong>\n     ATAPI CD/DVD devices\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     03h\n    </strong>\n    :\n    <strong>\n     QIC-157 tape devices\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     04h\n    </strong>\n    :\n    <strong>\n     USB Floppy Interface (UFI)\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     05h\n    </strong>\n    :\n    <strong>\n     ATAPI removable media\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     06h\n    </strong>\n    :\n    <strong>\n     Generic SCSI media\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n Each subclass defines the appropriate command set and how commands are processed for that specific type of mass-storage device.\n</p>\n"}, "Page 234": {"response": "<h3>\n Mass Storage Class: Protocols, Serial Numbers, and Requests\n</h3>\n<h4>\n bInterfaceProtocol Field\n</h4>\n<p>\n The\n <strong>\n  bInterfaceProtocol\n </strong>\n field in the interface descriptor of a mass-storage device specifies the transport protocol the device uses. The following protocols are supported for mass-storage devices:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    00h\n   </strong>\n   :\n   <strong>\n    CBI with command completion interrupt transfers\n   </strong>\n   \u2013 This protocol includes an interrupt transfer to signal when a command has been completed.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    01h\n   </strong>\n   :\n   <strong>\n    CBI without command completion interrupt transfers\n   </strong>\n   \u2013 This protocol does not use interrupt transfers for command completion notifications.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    50h\n   </strong>\n   :\n   <strong>\n    Bulk only\n   </strong>\n   \u2013 A common protocol used in many mass-storage devices, where data is transferred in bulk without any interrupt-based command completion notifications.\n  </p>\n</li>\n</ul>\n<h4>\n Serial Number Requirement\n</h4>\n<p>\n Mass-storage devices that use the\n <strong>\n  bulk-only\n </strong>\n protocol must have a\n <strong>\n  serial number\n </strong>\n that is at least 12 characters long, using only the characters\n <strong>\n  0-9\n </strong>\n and\n <strong>\n  A-F\n </strong>\n . This serial number is important for system management, as it helps the operating system track device properties, such as:\n</p>\n<ul>\n<li>\n  Retaining the\n  <strong>\n   drive letter\n  </strong>\n  and\n  <strong>\n   access policies\n  </strong>\n  when the device is moved to a different port or when multiple devices with the same\n  <strong>\n   Vendor ID\n  </strong>\n  and\n  <strong>\n   Product ID\n  </strong>\n  are connected.\n </li>\n</ul>\n<p>\n The serial number is stored in a string descriptor, and the device descriptor includes an\n <strong>\n  iSerialNumber\n </strong>\n field that references it. The serial number must be unique among all devices that share the same\n <strong>\n  Vendor ID\n </strong>\n ,\n <strong>\n  Product ID\n </strong>\n , and\n <strong>\n  Device version\n </strong>\n (as specified in the\n <strong>\n  idVendor\n </strong>\n ,\n <strong>\n  idProduct\n </strong>\n , and\n <strong>\n  bcdDevice\n </strong>\n fields of the device descriptor).\n</p>\n<h4>\n Bulk Endpoints\n</h4>\n<p>\n A mass-storage device must support at least one\n <strong>\n  bulk endpoint\n </strong>\n for both\n <strong>\n  IN\n </strong>\n (device to host) and\n <strong>\n  OUT\n </strong>\n (host to device) data transfers.\n</p>\n<h4>\n Class-Specific Requests\n</h4>\n<p>\n For the\n <strong>\n  bulk-only protocol\n </strong>\n , two\n <strong>\n  control requests\n </strong>\n are defined:\n</p>\n<ol>\n<li>\n<strong>\n   Bulk Only Mass Storage Reset\n  </strong>\n  : This command resets the device.\n </li>\n<li>\n<strong>\n   Get Max Lun\n  </strong>\n  : This command retrieves the number of\n  <strong>\n   Logical Units\n  </strong>\n  (LUNs) or partitions supported by the device.\n </li>\n</ol>\n<p>\n For the\n <strong>\n  Control/Bulk/Interrupt (CBI)\n </strong>\n protocol, there is one defined control request:\n</p>\n<ul>\n<li>\n<strong>\n   Accept Device-Specific Command (ADSC)\n  </strong>\n  : This request carries the device-specific command in its data stage. Devices can use an interrupt transfer to signal when the command has been completed.\n </li>\n</ul>\n<h4>\n Controller Chips\n</h4>\n<p>\n Mass-storage devices can use a variety of\n <strong>\n  full-speed\n </strong>\n or\n <strong>\n  high-speed\n </strong>\n controller chips. Some manufacturers, like\n <strong>\n  Prolific Technology\n </strong>\n and\n <strong>\n  Standard Microsystems Corporation (SMSC)\n </strong>\n , offer chips specifically designed for mass-storage devices, with interfaces tailored for different types of storage devices. These chips are optimized for handling the different data transfer requirements and protocols used in mass-storage devices.\n</p>\n"}, "Page 235": {"response": "<h3>\n ATA/ATAPI Devices and Windows Support\n</h3>\n<h4>\n ATA/ATAPI Devices\n</h4>\n<p>\n ATA/ATAPI devices, commonly used in mass storage, can be supported by a variety of controller chips. Some examples of these chips include:\n</p>\n<ul>\n<li>\n<strong>\n   Philips Semiconductor\u2019s ISP1183\n  </strong>\n</li>\n<li>\n<strong>\n   Texas Instruments\u2019 TUSB6250\n  </strong>\n</li>\n<li>\n<strong>\n   Cypress Semiconductor\u2019s EZUSB AT2\n  </strong>\n</li>\n</ul>\n<p>\n These chips help enable communication between USB and ATA/ATAPI devices, allowing them to be used with different types of storage media.\n</p>\n<h4>\n Windows Support for Mass Storage\n</h4>\n<p>\n Windows 2000 and later versions include drivers that support mass-storage devices using the\n <strong>\n  bulk-only\n </strong>\n and\n <strong>\n  CBI\n </strong>\n protocols. When a device\u2019s descriptors identify it as a mass-storage device, Windows loads the USB storage port driver (\n <strong>\n  usbstor.sys\n </strong>\n ). This driver manages communication between lower-level USB drivers and Windows' storage-class drivers.\n</p>\n<p>\n Once a mass-storage device is connected, formatted with a supported file system, and recognized, Windows assigns it a\n <strong>\n  drive letter\n </strong>\n , making it visible in\n <strong>\n  My Computer\n </strong>\n .\n</p>\n<ul>\n<li>\n<strong>\n   Windows XP\n  </strong>\n  supports the\n  <strong>\n   bInterfaceSubClass\n  </strong>\n  codes\n  <strong>\n   02h, 05h, and 06h\n  </strong>\n  (used for specific types of mass-storage devices).\n </li>\n<li>\n  Support for devices with multiple\n  <strong>\n   Logical Unit Numbers (LUNs)\n  </strong>\n  was added in\n  <strong>\n   Windows 2000 SP3\n  </strong>\n  .\n </li>\n</ul>\n<h4>\n Removable Devices vs. Removable Media in Windows\n</h4>\n<p>\n In Windows, there is a distinction between\n <strong>\n  removable devices\n </strong>\n and\n <strong>\n  removable media\n </strong>\n :\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Removable Devices\n   </strong>\n   : All USB storage devices are considered removable because they can be easily attached and detached from the system.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Removable Media\n   </strong>\n   : This refers to the type of storage medium in the device. Examples of removable media include:\n  </p>\n<ul>\n<li>\n<strong>\n     CDs, DVDs, and floppy disks\n    </strong>\n    (which are physically removable).\n   </li>\n</ul>\n<p>\n   On the other hand,\n   <strong>\n    hard drives\n   </strong>\n   are considered to have non-removable media, since the disk cannot be easily removed from the drive.\n  </p>\n</li>\n</ul>\n<p>\n Additionally,\n <strong>\n  Windows Autorun\n </strong>\n (also known as\n <strong>\n  AutoPlay\n </strong>\n ) applies to devices with removable media. This feature automatically runs a program, plays media, or performs other actions when a removable disk is inserted into the system.\n</p>\n<hr/>\n<h3>\n Printer Class\n</h3>\n<p>\n The\n <strong>\n  printer class\n </strong>\n is a USB device class for printers, which are devices that convert received data into printed output, such as text or images, on paper or other media.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Basic Printers\n   </strong>\n   : These typically print lines of text using a single font.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Advanced Printers\n   </strong>\n   : Most\n   <strong>\n    laser\n   </strong>\n   and\n   <strong>\n    inkjet\n   </strong>\n   printers are capable of interpreting one or more\n   <strong>\n    page description languages (PDLs)\n   </strong>\n   , allowing them to print complex text, images, and graphics in various fonts and layouts.\n  </p>\n</li>\n</ul>\n<p>\n This flexibility allows modern printers to handle a wide range of print jobs, from simple documents to high-quality color images.\n</p>\n"}, "Page 236": {"response": "<h3>\n Printer Class Overview\n</h3>\n<h4>\n Documentation\n</h4>\n<p>\n The\n <strong>\n  USB Printing Devices\n </strong>\n specification defines how printers of all types interact with USB. The current version of this specification is\n <strong>\n  1.1\n </strong>\n . The\n <strong>\n  IEEE-1284 standard\n </strong>\n , which is available at\n <a href=\"http://www.ieee.org\" rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n  www\n  .ieee\n  .org\n </a>\n , provides details on the interface used by parallel-port printers, and also outlines the format for\n <strong>\n  Device IDs\n </strong>\n used by USB printers.\n</p>\n<h4>\n Overview of Printer Data Transfer\n</h4>\n<p>\n Printer data typically uses a\n <strong>\n  bulk OUT pipe\n </strong>\n for communication. This means that data is sent from the host to the printer via bulk transfer. Additionally, status information can be obtained through\n <strong>\n  control requests\n </strong>\n or, optionally, through a\n <strong>\n  bulk IN pipe\n </strong>\n .\n</p>\n<h4>\n Descriptors\n</h4>\n<p>\n In the\n <strong>\n  interface descriptor\n </strong>\n , the\n <strong>\n  bInterfaceClass\n </strong>\n field is set to\n <strong>\n  07h\n </strong>\n , indicating the printer class. The\n <strong>\n  bInterfaceProtocol\n </strong>\n field in the interface descriptor specifies the type of printer interface being used. There are three main protocol types:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Unidirectional Protocol (01h)\n   </strong>\n   : In this protocol, the host sends data to the printer using the bulk OUT endpoint. The host can retrieve status information by sending a class-specific\n   <strong>\n    Get_Port_Status\n   </strong>\n   request.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Bidirectional Protocol (02h)\n   </strong>\n   : Similar to the unidirectional protocol, the host uses the bulk OUT endpoint to send data to the printer. However, with the bidirectional protocol, the host can obtain status information either through the\n   <strong>\n    Get_Port_Status\n   </strong>\n   request or via the\n   <strong>\n    bulk IN pipe\n   </strong>\n   , which allows for more detailed status information.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    IEEE-1284.4-compatible Bidirectional Protocol (03h)\n   </strong>\n   : This protocol is an extension of the bidirectional protocol, providing added support for communication with individual functions in a\n   <strong>\n    multifunction peripheral\n   </strong>\n   (MFP). This is useful in devices that combine printing with other functions such as scanning or faxing.\n  </p>\n</li>\n</ol>\n<h4>\n Summary\n</h4>\n<ul>\n<li>\n  The\n  <strong>\n   printer class\n  </strong>\n  is managed via bulk OUT pipes for data and can use either control requests or a bulk IN pipe for status information.\n </li>\n<li>\n  The\n  <strong>\n   bInterfaceProtocol\n  </strong>\n  field identifies the printer interface type, with options for unidirectional, bidirectional, and IEEE-1284.4-compatible bidirectional communication.\n </li>\n</ul>\n"}, "Page 237": {"response": "<h3>\n Printer Class-Specific Requests\n</h3>\n<h4>\n Overview of Class-Specific Requests\n</h4>\n<p>\n The printer class has three key class-specific requests that manage communication and interaction between the host and the printer. These are:\n</p>\n<ol>\n<li>\n<strong>\n   GET_DEVICE_ID\n  </strong>\n</li>\n<li>\n<strong>\n   GET_PORT_STATUS\n  </strong>\n</li>\n<li>\n<strong>\n   SOFT_RESET\n  </strong>\n</li>\n</ol>\n<h4>\n GET_DEVICE_ID Request\n</h4>\n<p>\n When the host sends a\n <strong>\n  GET_DEVICE_ID\n </strong>\n request, the printer responds with a\n <strong>\n  Device ID\n </strong>\n formatted according to the\n <strong>\n  IEEE-1284 standard\n </strong>\n . The first two bytes of the Device ID represent the length of the ID (in bytes), with the most significant byte first. After the length, the Device ID contains a string of\n <strong>\n  key-value pairs\n </strong>\n , formatted like this:\n</p>\ncss\nCopy code\n<code class=\"!whitespace-pre hljs language-css\">\n key: value {,value};\n</code>\n<p>\n All Device IDs must include the following keys:\n</p>\n<ul>\n<li>\n<strong>\n   MANUFACTURER (MFG)\n  </strong>\n  : Specifies the printer's manufacturer.\n </li>\n<li>\n<strong>\n   COMMAND SET (CMD)\n  </strong>\n  : Lists the page description languages (PDLs) supported by the printer, such as\n  <strong>\n   PCL\n  </strong>\n  (Printer Control Language) or\n  <strong>\n   PostScript\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   MODEL (MDL)\n  </strong>\n  : Specifies the printer's model.\n </li>\n</ul>\n<p>\n Additionally, optional keys may be present, which can be vendor-specific.\n</p>\n<p>\n<strong>\n  Example Device ID\n </strong>\n :\n</p>\ncss\nCopy code\n<code class=\"!whitespace-pre hljs language-css\">\n MFG:My Printer Company;\nMDL:Model\n 5\n T;\nCMD:MLC,PCL,PML;\nDESCRIPTION:My Printer Company Laser Printer\n 5\n T;\nCLASS:PRINTER;\nREV:\n 1.3\n .\n 2\n ;\n</code>\n<h4>\n GET_PORT_STATUS Request\n</h4>\n<p>\n When the host sends a\n <strong>\n  GET_PORT_STATUS\n </strong>\n request, the printer responds with a single byte that emulates the\n <strong>\n  Status-port byte\n </strong>\n on a parallel printer port. This byte contains three bits of status information:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Bit 3: Not Error\n   </strong>\n</p>\n<ul>\n<li>\n<strong>\n     1\n    </strong>\n    : No error\n   </li>\n<li>\n<strong>\n     0\n    </strong>\n    : Error detected\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Bit 4: Select\n   </strong>\n</p>\n<ul>\n<li>\n<strong>\n     1\n    </strong>\n    : Printer is selected\n   </li>\n<li>\n<strong>\n     0\n    </strong>\n    : Printer is not selected\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Bit 5: Paper Empty\n   </strong>\n</p>\n<ul>\n<li>\n<strong>\n     1\n    </strong>\n    : Printer is out of paper\n   </li>\n<li>\n<strong>\n     0\n    </strong>\n    : Printer is not out of paper\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n SOFT_RESET Request\n</h4>\n<p>\n The\n <strong>\n  SOFT_RESET\n </strong>\n request is used to reset the printer without fully powering it off. The specific action taken by the printer depends on the implementation, but typically, it clears the current state and prepares the printer for new commands or data.\n</p>\n<h4>\n Summary\n</h4>\n<ul>\n<li>\n  The\n  <strong>\n   GET_DEVICE_ID\n  </strong>\n  request retrieves a Device ID string, which includes manufacturer, model, command set, and other details.\n </li>\n<li>\n  The\n  <strong>\n   GET_PORT_STATUS\n  </strong>\n  request provides the status of the printer's port, including error, selection, and paper status.\n </li>\n<li>\n  The\n  <strong>\n   SOFT_RESET\n  </strong>\n  request is used to reset the printer\u2019s state.\n </li>\n</ul>\n"}, "Page 238": {"response": "<h3>\n Printer Class \u2013 Handling Printer Status and Commands\n</h3>\n<h4>\n Printer Status and Error Handling\n</h4>\n<p>\n When a printer cannot retrieve the requested status information, it should return\n <strong>\n  0x18\n </strong>\n to indicate no error, the printer is selected, and it is not out of paper. Note that parallel-port printers use two additional status bits,\n <strong>\n  Busy\n </strong>\n and\n <strong>\n  Ack\n </strong>\n , which are relevant for handshaking in parallel communication but do not apply to USB printers.\n</p>\n<h4>\n Soft_Reset Request Handling\n</h4>\n<p>\n Upon receiving a\n <strong>\n  Soft_Reset\n </strong>\n request, the printer should perform the following actions:\n</p>\n<ol>\n<li>\n<strong>\n   Flush all buffers\n  </strong>\n  : Clear any remaining data or commands.\n </li>\n<li>\n<strong>\n   Reset the interface's bulk pipes\n  </strong>\n  to their default state.\n </li>\n<li>\n<strong>\n   Clear all Stall conditions\n  </strong>\n  : Reset any previous transmission errors or interruptions.\n </li>\n</ol>\n<p>\n For a\n <strong>\n  Soft_Reset\n </strong>\n request, the\n <strong>\n  bmRequestType\n </strong>\n value in the\n <strong>\n  Setup\n </strong>\n transaction should be\n <strong>\n  0x21\n </strong>\n , indicating a class-specific request to an interface with no data stage. However, the first version of the printer class specification mistakenly listed the\n <strong>\n  bmRequestType\n </strong>\n for\n <strong>\n  Soft_Reset\n </strong>\n as\n <strong>\n  0x23\n </strong>\n . To ensure compatibility, devices should accept a\n <strong>\n  bmRequestType\n </strong>\n of\n <strong>\n  0x23\n </strong>\n , and hosts should retry the correct value (0x21) if they encounter a\n <strong>\n  STALL\n </strong>\n condition.\n</p>\n<h4>\n Chips for Printer Devices\n</h4>\n<p>\n For most full- or high-speed controller chips that manage USB printers, the devices typically use one or two bulk endpoints. For example,\n <strong>\n  Prolific Technology\n </strong>\n offers the\n <strong>\n  PL-2305 USB-to-IEEE-1284 Bridge Controller\n </strong>\n , which supports three endpoints: one\n <strong>\n  bulk IN\n </strong>\n , one\n <strong>\n  bulk OUT\n </strong>\n , and one\n <strong>\n  interrupt IN\n </strong>\n . This chip is useful for connecting parallel-port printers to a USB interface, allowing it to communicate via an existing parallel port (IEEE-1284 standard).\n</p>\n<h4>\n Windows Support for Printers\n</h4>\n<p>\n Windows provides built-in drivers to handle printing tasks for both\n <strong>\n  non-PostScript\n </strong>\n and\n <strong>\n  PostScript\n </strong>\n printers. Printer manufacturers can customize these drivers for specific printer models by using a\n <strong>\n  minidriver\n </strong>\n . A minidriver consists of one or more text files containing customization information specific to the printer model.\n</p>\n<p>\n In the printing process:\n</p>\n<ol>\n<li>\n  When an application sends a print request, the printer driver passes the data to the\n  <strong>\n   print spooler's print processor\n  </strong>\n  .\n </li>\n<li>\n  If the printer uses a USB interface, the print processor sends the data to either:\n  <ul>\n<li>\n    The\n    <strong>\n     Usbmon\n    </strong>\n    port driver, which directly communicates with the USB printer.\n   </li>\n<li>\n    A\n    <strong>\n     language monitor\n    </strong>\n    , which modifies the data stream before sending it to the printer.\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n This system allows efficient management and customization of printing tasks for different printer types.\n</p>\n"}, "Page 239": {"response": "<h3>\n Still Image Capture Devices (Cameras and Scanners)\n</h3>\n<h4>\n Purpose and Overview\n</h4>\n<p>\n The\n <strong>\n  Still Image Capture\n </strong>\n class includes devices like cameras and scanners that capture still images, rather than video. The primary function of a USB interface in these devices is to transfer image data from the device to the host. Some devices may also allow image data to be received from the host.\n</p>\n<p>\n For simpler use cases, where only image files need to be transferred (e.g., from a camera to a computer), the\n <strong>\n  mass-storage\n </strong>\n driver can also be an alternative solution.\n</p>\n<h4>\n Documentation and Specifications\n</h4>\n<p>\n The\n <strong>\n  Still Image Capture Device Definition\n </strong>\n USB class specification includes requirements based on the\n <strong>\n  PIMA 15740: 2000 Picture Transfer Protocol (PTP)\n </strong>\n , which outlines the process of transferring files and controlling digital still cameras. The latest version of the still-image specification is\n <strong>\n  1.0\n </strong>\n . The PIMA document is available from the\n <strong>\n  International Imaging Industry Association (I3A)\n </strong>\n at\n <a href=\"http://www.i3a.org\" rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n  www\n  .i3a\n  .org\n </a>\n .\n</p>\n<h4>\n Data Transfer and Endpoints\n</h4>\n<p>\n A still-image device typically uses:\n</p>\n<ul>\n<li>\n<strong>\n   One bulk IN endpoint\n  </strong>\n  (for transferring image data to the host).\n </li>\n<li>\n<strong>\n   One bulk OUT endpoint\n  </strong>\n  (for transferring non-image data from the host to the device).\n </li>\n<li>\n<strong>\n   One interrupt IN endpoint\n  </strong>\n  (for sending event data, such as button presses or status updates).\n </li>\n</ul>\n<p>\n Data transferred through these pipes is organized in specific structures called\n <strong>\n  containers\n </strong>\n . There are four main types of containers used for communication:\n</p>\n<ol>\n<li>\n<strong>\n   Command Block\n  </strong>\n  : Used for sending commands to the device.\n </li>\n<li>\n<strong>\n   Data Block\n  </strong>\n  : Carries actual image or non-image data.\n </li>\n<li>\n<strong>\n   Response Block\n  </strong>\n  : Sent from the device in reply to a command, often with data or status.\n </li>\n<li>\n<strong>\n   Event Block\n  </strong>\n  : Sent by the device to notify the host of an event (e.g., a user action like pressing a button).\n </li>\n</ol>\n<p>\n In summary, the still-image device uses bulk and interrupt pipes to facilitate data exchange, with distinct containers assigned to each type of data for organization and efficient transfer.\n</p>\n"}, "Page 240": {"response": "<h3>\n Still Image Capture Device Communication and Descriptors\n</h3>\n<h4>\n Data Transfer Protocol\n</h4>\n<p>\n For still-image devices, data transfer occurs over\n <strong>\n  bulk pipes\n </strong>\n using a three-phase protocol:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Command Phase\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The host sends a\n    <strong>\n     Command Block\n    </strong>\n    , specifying an operation from the\n    <strong>\n     PIMA 15740\n    </strong>\n    standard. The Command Block includes an operation code that indicates whether the operation involves a data transfer, and if so, specifies the direction of that transfer.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Data Phase\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    If the operation requires data transfer, data is sent in a\n    <strong>\n     Data Block\n    </strong>\n    . The first four bytes of this Data Block indicate the length of the data being transferred. Some operations may not require a Data phase.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Response Phase\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    In this phase, the device sends a\n    <strong>\n     Response Block\n    </strong>\n    back to the host, providing information about the completion of the operation.\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n A\n <strong>\n  short packet\n </strong>\n indicates the end of each phase. For example, if the operation doesn't involve data transfer, the Data phase is skipped, and only the Command and Response phases are used.\n</p>\n<h4>\n Interrupt Pipe for Event Notifications\n</h4>\n<p>\n The\n <strong>\n  interrupt IN pipe\n </strong>\n is used for transmitting\n <strong>\n  Event Blocks\n </strong>\n . An Event Block can contain up to three\n <strong>\n  Event Codes\n </strong>\n with status information, such as:\n</p>\n<ul>\n<li>\n  Low battery warnings.\n </li>\n<li>\n  Notifications about memory card removals.\n </li>\n<li>\n  Other device-specific events.\n </li>\n</ul>\n<p>\n If the host needs more detailed information about an event, it can use the\n <strong>\n  Get_Extended_Event_Data\n </strong>\n request.\n</p>\n<h4>\n Cancelling and Resuming Transfers\n</h4>\n<p>\n If a device needs to cancel a data transfer, it does so by\n <strong>\n  stalling\n </strong>\n its bulk endpoints. When this happens, the host can:\n</p>\n<ul>\n<li>\n  Send a\n  <strong>\n   Get_Device_Status\n  </strong>\n  request to check the device's status.\n </li>\n<li>\n  Use the\n  <strong>\n   Clear_Feature\n  </strong>\n  request to clear the stalled endpoints.\n </li>\n</ul>\n<p>\n To resume normal operation, the device must respond with\n <strong>\n  OK (PIMA 15740 Response Code 2001h)\n </strong>\n to a\n <strong>\n  Get_Device_Status\n </strong>\n request, signaling that it is ready to continue data transfers.\n</p>\n<h4>\n Descriptors for Still-Image Devices\n</h4>\n<p>\n A still-image device's function is defined in the\n <strong>\n  interface descriptor\n </strong>\n . Key fields in the descriptor include:\n</p>\n<ul>\n<li>\n<strong>\n   bInterfaceClass = 06h\n  </strong>\n  : Specifies the still-image device class.\n </li>\n<li>\n<strong>\n   bInterfaceSubclass = 01h\n  </strong>\n  : Indicates an image interface.\n </li>\n<li>\n<strong>\n   bInterfaceProtocol = 01h\n  </strong>\n  : Identifies the device as a still-image capture device.\n </li>\n</ul>\n<p>\n The descriptor must also include information for the\n <strong>\n  bulk IN\n </strong>\n ,\n <strong>\n  bulk OUT\n </strong>\n , and\n <strong>\n  interrupt IN\n </strong>\n endpoints, which are crucial for transferring image and event data.\n</p>\n<p>\n In summary, still-image devices use bulk and interrupt pipes with a structured, multi-phase data transfer process to communicate with the host. Event-driven communication is handled via interrupt pipes, while cancellation and resumption of transfers are managed through class-specific requests.\n</p>\n"}, "Page 241": {"response": "<h3>\n Still Image Class-Specific Requests and Windows Support\n</h3>\n<h4>\n Class-Specific Requests\n</h4>\n<p>\n Still-image devices have four class-specific control requests that manage their operation:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Cancel_Request (64h)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The host uses this request to cancel a specific\n    <strong>\n     PIMA 15740\n    </strong>\n    transaction. It is useful when a transfer or operation needs to be aborted.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Get_Extended_Event_Data (65h)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This request allows the host to retrieve more detailed information about an event or a vendor-specific condition. It helps in managing events like low battery warnings or other device-specific status notifications.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Device_Reset_Request (66h)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This request asks the device to return to its\n    <strong>\n     Idle\n    </strong>\n    state. It is typically used after a bulk endpoint has returned a\n    <strong>\n     STALL\n    </strong>\n    condition or to clear a specific vendor-related issue. It helps reset the device for normal operation.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Get_Device_Status (67h)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The host uses this request to obtain information needed to clear\n    <strong>\n     halted endpoints\n    </strong>\n    . This is used when the device has canceled a data transfer, and the host needs to know the status in order to resume communication.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Chips for Still-Image Devices\n</h4>\n<p>\n Most full-speed or high-speed USB controllers are capable of handling the three endpoints required by the still-image class. These endpoints include bulk IN, bulk OUT, and interrupt IN endpoints, ensuring that the device can handle image data transfer and event notifications.\n</p>\n<h4>\n Windows Support for Still-Image Devices\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Windows Image Acquisition (WIA) API\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Recent versions of Windows support the\n    <strong>\n     WIA API\n    </strong>\n    , which facilitates communication with devices in the still-image class, such as cameras and scanners. Applications interact with these devices using functions like\n    <strong>\n     ReadFile\n    </strong>\n    ,\n    <strong>\n     WriteFile\n    </strong>\n    , and\n    <strong>\n     DeviceIoControl\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    USB Support for WIA\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    For cameras following the\n    <strong>\n     Picture Transfer Protocol (PTP)\n    </strong>\n    based on the\n    <strong>\n     PIMA 15740\n    </strong>\n    standard,\n    <strong>\n     Windows XP and later\n    </strong>\n    provide built-in support with no need for additional vendor drivers. However, vendors can create a\n    <strong>\n     minidriver\n    </strong>\n    to extend functionality and support custom features.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Scanners\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Scanners require a\n    <strong>\n     microdriver\n    </strong>\n    (a helper DLL) provided by the vendor. This microdriver translates the communication between the device and the host system, enabling the scanner to understand the driver\u2019s commands.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n In summary, the still-image class utilizes specific control requests to manage transactions, event data, and device resets. Windows provides comprehensive support for these devices through the WIA API, with built-in support for cameras and the need for vendor-supplied microdrivers for scanners.\n</p>\n"}, "Page 242": {"response": "<h3>\n Test and Measurement Class (USBTMC)\n</h3>\n<h4>\n Overview\n</h4>\n<p>\n The\n <strong>\n  Test and Measurement Class (USBTMC)\n </strong>\n is designed for instrumentation devices that typically don't require precise timing for their data transmissions. These devices often include components like\n <strong>\n  Analog-to-Digital Converters (ADCs)\n </strong>\n ,\n <strong>\n  Digital-to-Analog Converters (DACs)\n </strong>\n , sensors, and transducers. They can be stand-alone units or part of a larger system, such as a computer.\n</p>\n<p>\n Many test-and-measurement devices previously used the\n <strong>\n  IEEE-488 parallel interface\n </strong>\n (also known as\n <strong>\n  General Purpose Interface Bus (GPIB)\n </strong>\n ), but with the introduction of USB, the\n <strong>\n  USB488 subclass\n </strong>\n of USBTMC was created to support communication in the IEEE-488 format, allowing these devices to communicate using the GPIB data format and commands.\n</p>\n<h4>\n Documentation\n</h4>\n<ul>\n<li>\n  The\n  <strong>\n   Test and Measurement Class specification\n  </strong>\n  outlines the core USBTMC functionality, while a separate document covers the\n  <strong>\n   USB488 subclass\n  </strong>\n  . Both specifications are currently at version\n  <strong>\n   1.0\n  </strong>\n  .\n </li>\n<li>\n  The IEEE-488 standards can be accessed from\n  <strong>\n<a href=\"http://www.ieee.org\" rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n    www\n    .ieee\n    .org\n   </a>\n</strong>\n  .\n </li>\n</ul>\n<h4>\n Endpoint Requirements\n</h4>\n<p>\n Test-and-measurement devices typically require the following USB endpoints:\n</p>\n<ul>\n<li>\n<strong>\n   Bulk OUT endpoint\n  </strong>\n  : Used for sending command messages from the host to the device.\n </li>\n<li>\n<strong>\n   Bulk IN endpoint\n  </strong>\n  : Used for receiving response messages from the device.\n </li>\n<li>\n<strong>\n   Interrupt IN endpoint\n  </strong>\n  : This is required for devices in the\n  <strong>\n   USB488 subclass\n  </strong>\n  to return event or status information. For other devices in the class, it is optional.\n </li>\n</ul>\n<h4>\n Data Transmission\n</h4>\n<p>\n Communication between the host and test-and-measurement devices occurs through the\n <strong>\n  bulk pipes\n </strong>\n . A message consists of two parts:\n</p>\n<ol>\n<li>\n<strong>\n   Header\n  </strong>\n  : This includes essential information such as:\n  <ul>\n<li>\n<strong>\n     Message ID\n    </strong>\n    : Identifies the message.\n   </li>\n<li>\n<strong>\n     bTag value\n    </strong>\n    : A unique identifier for the transfer.\n   </li>\n<li>\n<strong>\n     Message-specific data\n    </strong>\n    : Information specific to the command or response.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Data\n  </strong>\n  : This follows the header and contains the relevant data associated with the message.\n </li>\n</ol>\n<ul>\n<li>\n  For command messages, the\n  <strong>\n   Bulk OUT endpoint\n  </strong>\n  receives the message, and for response messages, the\n  <strong>\n   Bulk IN endpoint\n  </strong>\n  sends the message.\n </li>\n</ul>\n<h3>\n Windows Support for Test and Measurement Devices\n</h3>\n<p>\n Like other device classes, test-and-measurement devices also need specific drivers for proper communication with Windows systems. For devices in the\n <strong>\n  USB488 subclass\n </strong>\n , Windows uses\n <strong>\n  custom drivers\n </strong>\n to handle communications using the IEEE-488 data format.\n</p>\n<p>\n In summary, the USBTMC class is intended for test-and-measurement devices, which communicate through bulk and interrupt endpoints. The USB488 subclass allows USB devices to use the IEEE-488 standard for GPIB communication. Windows provides support for these devices via specialized drivers.\n</p>\n"}, "Page 243": {"response": "<h3>\n Test and Measurement Class (USBTMC) \u2013 Additional Details\n</h3>\n<h4>\n Message Structure\n</h4>\n<p>\n When communicating via USB, the\n <strong>\n  test-and-measurement devices\n </strong>\n exchange messages that consist of two parts:\n</p>\n<ol>\n<li>\n<strong>\n   Header\n  </strong>\n  : Includes the\n  <strong>\n   Message ID\n  </strong>\n  ,\n  <strong>\n   bTag\n  </strong>\n  (transfer identifier), and other\n  <strong>\n   message-specific details\n  </strong>\n  . The\n  <strong>\n   Message ID\n  </strong>\n  indicates whether the command is device-dependent, vendor-specific, or requires a response from the device.\n </li>\n<li>\n<strong>\n   Data\n  </strong>\n  : Follows the header and contains the actual data associated with the command or response.\n </li>\n</ol>\n<p>\n The\n <strong>\n  bTag value\n </strong>\n helps link a command and its corresponding response, ensuring proper tracking and identification of each transfer.\n</p>\n<h4>\n Descriptors\n</h4>\n<p>\n In the\n <strong>\n  Test and Measurement Class\n </strong>\n , functionality is defined at the\n <strong>\n  interface subclass level\n </strong>\n .\n</p>\n<ul>\n<li>\n<strong>\n   bInterfaceClass\n  </strong>\n  =\n  <strong>\n   FEh\n  </strong>\n  : Denotes an application-specific interface.\n </li>\n<li>\n<strong>\n   bInterfaceSubClass\n  </strong>\n  =\n  <strong>\n   03h\n  </strong>\n  : Specifies the test-and-measurement class.\n </li>\n</ul>\n<p>\n This class doesn't include additional\n <strong>\n  class-specific descriptors\n </strong>\n , unlike other USB device classes.\n</p>\n<h4>\n Class-Specific Requests\n</h4>\n<p>\n The\n <strong>\n  Test and Measurement Class\n </strong>\n defines\n <strong>\n  eight control requests\n </strong>\n that are used for managing and querying the status of an interface or transfer. These requests can also retrieve information about the interface's capabilities and attributes.\n</p>\n<h4>\n Chips\n</h4>\n<p>\n Any\n <strong>\n  full-speed or high-speed USB controller\n </strong>\n will be compatible with the\n <strong>\n  two to three endpoints\n </strong>\n required by the\n <strong>\n  Test and Measurement Class\n </strong>\n .\n</p>\n<h4>\n Windows Support\n</h4>\n<p>\n Currently,\n <strong>\n  Windows\n </strong>\n does not include built-in drivers for the\n <strong>\n  Test and Measurement Class\n </strong>\n . However:\n</p>\n<ul>\n<li>\n<strong>\n   National Instruments\n  </strong>\n  provides its own driver for hardware that follows this class.\n </li>\n<li>\n  For devices that use\n  <strong>\n   bulk transfers\n  </strong>\n  , other options include using the\n  <strong>\n   mass-storage class\n  </strong>\n  or implementing a\n  <strong>\n   vendor-specific driver\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   HID-class devices\n  </strong>\n  can also be used for test-and-measurement functions.\n </li>\n<li>\n  For devices with an existing\n  <strong>\n   IEEE-488 interface\n  </strong>\n  , a quick solution is to use a commercial\n  <strong>\n   IEEE-488/USB converter\n  </strong>\n  .\n </li>\n</ul>\n<hr/>\n<h3>\n Video Class \u2013 Overview\n</h3>\n<p>\n The\n <strong>\n  Video Class\n </strong>\n supports devices such as\n <strong>\n  digital camcorders\n </strong>\n ,\n <strong>\n  webcams\n </strong>\n , and other video devices that capture, transmit, or manipulate moving images. It also includes functionality for transferring\n <strong>\n  still images\n </strong>\n from video devices.\n</p>\n<h4>\n Bandwidth Considerations\n</h4>\n<p>\n Because video, especially high-quality video, requires significant bandwidth for transmission, USB has become an increasingly viable option for video devices. This is primarily due to the availability of\n <strong>\n  high-speed hosts and devices\n </strong>\n , which provide the necessary bandwidth to transmit large volumes of video data.\n</p>\n<p>\n The class is optimized to handle the specific needs of video capture and playback, making it suitable for applications like streaming, video conferencing, and digital video recording.\n</p>\n"}, "Page 244": {"response": "<h3>\n Video Class \u2013 Documentation and Overview\n</h3>\n<h4>\n Video Specification Documents\n</h4>\n<p>\n The\n <strong>\n  Video Class\n </strong>\n specification is made up of several important documents that detail how video devices communicate via USB. These documents include:\n</p>\n<ol>\n<li>\n<strong>\n   Video Class Definition\n  </strong>\n  : This defines the standard descriptors and control requests used for video devices, such as webcams and camcorders.\n </li>\n<li>\n<strong>\n   Media Transport Terminal Specification\n  </strong>\n  : This focuses on devices like video cameras and digital VCRs, which stream data from sequential media (like tapes or discs). These devices may support functions like play, record, rewind, and eject.\n </li>\n<li>\n<strong>\n   Payload Specifications\n  </strong>\n  : These contain format-specific information for different video formats, including MJPEG, MPEG2-TS, DV, and uncompressed video.\n </li>\n<li>\n<strong>\n   Version 1.1 Updates\n  </strong>\n  : The upcoming version of the Video Class specification (1.1) will phase out some older formats from version 1.0 and introduce generic frame-based and stream-based formats.\n </li>\n<li>\n<strong>\n   Other Documents\n  </strong>\n  :\n  <ul>\n<li>\n<strong>\n     Video Camera Example\n    </strong>\n    : Provides a practical example for video devices.\n   </li>\n<li>\n<strong>\n     FAQ\n    </strong>\n    : Answers common questions regarding video devices.\n   </li>\n<li>\n<strong>\n     Identifiers Document\n    </strong>\n    : A compilation of identifier values used across different video-class specifications.\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n At the time of writing, the current version for all these documents is\n <strong>\n  1.0\n </strong>\n .\n</p>\n<h4>\n Video Interface Structure\n</h4>\n<p>\n As shown in\n <strong>\n  Figure 7-6\n </strong>\n , a\n <strong>\n  USB video function\n </strong>\n consists of:\n</p>\n<ul>\n<li>\n<strong>\n   VideoControl Interface\n  </strong>\n  : Every video device must include this interface, which handles control operations like setting video parameters.\n </li>\n<li>\n<strong>\n   VideoStreaming Interfaces\n  </strong>\n  : These interfaces are used for transmitting video data (the actual video streams). A device can have multiple video streaming interfaces, depending on its capabilities.\n </li>\n</ul>\n<p>\n These interfaces work together to manage both control and data flow for video devices.\n</p>\n"}, "Page 245": {"response": "<h3>\n Video Control and Streaming Interfaces\n</h3>\n<h4>\n Video Interface Collection\n</h4>\n<p>\n A\n <strong>\n  Video Interface Collection\n </strong>\n consists of the\n <strong>\n  VideoControl interface\n </strong>\n and its related\n <strong>\n  VideoStreaming interfaces\n </strong>\n . A device with only a VideoControl interface does not belong to a Video Interface Collection. However, a device can have multiple independent VideoControl interfaces and corresponding Video Interface Collections.\n</p>\n<ul>\n<li>\n<strong>\n   VideoControl Interface\n  </strong>\n  : This interface provides control over inputs, outputs, and other aspects of the video function.\n </li>\n<li>\n<strong>\n   VideoStreaming Interfaces\n  </strong>\n  : These interfaces manage the transfer of video data. They include one isochronous or bulk endpoint dedicated to video data, as well as an optional bulk endpoint for still images.\n </li>\n</ul>\n<h4>\n Video Control Interface Structure\n</h4>\n<p>\n The\n <strong>\n  VideoControl interface\n </strong>\n utilizes a\n <strong>\n  control endpoint\n </strong>\n and may also use an\n <strong>\n  interrupt IN endpoint\n </strong>\n . This setup ensures smooth communication between the device and host. Each\n <strong>\n  VideoStreaming interface\n </strong>\n (used for video data transfer) requires its own set of isochronous or bulk endpoints.\n</p>\n<h4>\n Descriptors for Video Devices\n</h4>\n<p>\n The video class provides an array of descriptors that allow a video device to communicate its capabilities in detail. The descriptors help devices describe their features, such as video input/output functions and supported media formats. Key descriptors include:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Interface Association Descriptor\n   </strong>\n   : For each\n   <strong>\n    Video Interface Collection\n   </strong>\n   , this descriptor links the first\n   <strong>\n    VideoControl interface\n   </strong>\n   and the related\n   <strong>\n    VideoStreaming interfaces\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    VideoControl Interface Descriptor\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Standard Interface Descriptor\n    </strong>\n    : This descriptor indicates the video class with\n    <code>\n     bInterfaceClass = 0Eh\n    </code>\n    .\n   </li>\n<li>\n<strong>\n     Class-Specific VideoControl Interface Descriptor\n    </strong>\n    : This contains a header followed by various terminal and unit descriptors.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Terminal and Unit Descriptors\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Terminal Descriptors\n   </strong>\n   : Terminals define the start or end points of data flow within a device. A terminal could represent a USB endpoint, a CCD sensor, a display module, or a video input/output. There are two main types of terminal descriptors:\n  </p>\n<ul>\n<li>\n<strong>\n     Input Terminal\n    </strong>\n    : For describing an input device like a camera.\n   </li>\n<li>\n<strong>\n     Output Terminal\n    </strong>\n    : For describing output components such as a display or media transport output.\n   </li>\n</ul>\n<p>\n   The\n   <strong>\n    wTerminalType field\n   </strong>\n   identifies the terminal\u2019s function (e.g., camera, media input/output).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Unit Descriptors\n   </strong>\n   : Units describe how data is processed within the device. There are three types of unit descriptors:\n  </p>\n<ul>\n<li>\n<strong>\n     Selector Unit\n    </strong>\n    : Used to route a data stream to an output.\n   </li>\n<li>\n<strong>\n     Processing Unit\n    </strong>\n    : Controls video attributes (e.g., brightness, contrast).\n   </li>\n<li>\n<strong>\n     Extension Unit\n    </strong>\n    : A vendor-defined unit for additional functions specific to the device.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n These descriptors are crucial for defining the full capabilities of a video device, including how data is input, processed, and output.\n</p>\n"}, "Page 246": {"response": "<h3>\n VideoStreaming Interface and Endpoints\n</h3>\n<h4>\n Interrupt Endpoint in Video Control\n</h4>\n<p>\n If the\n <strong>\n  VideoControl interface\n </strong>\n includes an\n <strong>\n  interrupt endpoint\n </strong>\n , it will be described by both a\n <strong>\n  standard endpoint descriptor\n </strong>\n and a\n <strong>\n  class-specific endpoint descriptor\n </strong>\n . This allows for the handling of control or status notifications that require immediate attention.\n</p>\n<h4>\n VideoStreaming Interface Structure\n</h4>\n<p>\n The\n <strong>\n  VideoStreaming interface\n </strong>\n (Figure 7-8) is where the actual video data transfer takes place. It is structured as follows:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Standard Interface Descriptor\n   </strong>\n   : This is the basic descriptor for the interface.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Class-Specific Headers\n   </strong>\n   : Depending on whether the interface is receiving or transmitting data, it will have one of the following:\n  </p>\n<ul>\n<li>\n<strong>\n     VideoStreaming Input Header Descriptor\n    </strong>\n    : For interfaces with an IN endpoint, this descriptor provides essential information for incoming video data.\n   </li>\n<li>\n<strong>\n     VideoStreaming Output Header Descriptor\n    </strong>\n    : For interfaces with an OUT endpoint, this descriptor handles outgoing video data.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Payload Format Descriptors\n   </strong>\n   : After the header descriptor, each supported video format will have its own\n   <strong>\n    Payload Format descriptor\n   </strong>\n   . This descriptor defines the specific format of the video data, including the way the data is packaged for transfer.\n  </p>\n<ul>\n<li>\n<strong>\n     Frame-Based Formats\n    </strong>\n    : For frame-based formats, the Payload Format descriptor is followed by one or more\n    <strong>\n     Frame descriptors\n    </strong>\n    . These descriptors provide detailed information about each video frame, such as its resolution, frame rate, and any other characteristics necessary for proper video streaming.\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n The\n <strong>\n  VideoStreaming interface\n </strong>\n is essential for handling the continuous transfer of video data and ensuring it is formatted correctly for display or storage. The combination of headers and descriptors allows the device to describe the video data flow in detail, including all its supported formats and attributes.\n</p>\n"}, "Page 247": {"response": "<h3>\n VideoStreaming Interface and Class-Specific Requests\n</h3>\n<h4>\n Payload Format and Color Matching\n</h4>\n<p>\n A\n <strong>\n  Payload Format descriptor\n </strong>\n provides details about the video format being used, including important characteristics like the\n <strong>\n  dimensions of video frames\n </strong>\n . It also supports the inclusion of a\n <strong>\n  Color Matching descriptor\n </strong>\n , which defines the color profile used for the video data. This is important for ensuring the video is displayed with accurate colors, especially when different devices might interpret color data differently.\n</p>\n<p>\n Each\n <strong>\n  VideoStreaming interface\n </strong>\n must include either an\n <strong>\n  isochronous endpoint\n </strong>\n (for continuous data flow like video streaming) or a\n <strong>\n  bulk endpoint\n </strong>\n for video data, and there may be an additional optional\n <strong>\n  bulk endpoint\n </strong>\n for transferring still images.\n</p>\n<h4>\n Class-Specific Requests\n</h4>\n<p>\n In the video class,\n <strong>\n  class-specific control requests\n </strong>\n are used to manage the control settings within the\n <strong>\n  VideoControl\n </strong>\n and\n <strong>\n  VideoStreaming interfaces\n </strong>\n . These requests allow for controlling various parameters, such as the state of the video stream or the configuration of video settings.\n</p>\n<h4>\n Chip Support for Video Devices\n</h4>\n<p>\n For hardware implementation, chips like\n <strong>\n  Vista Imaging\u2019s ViCAM-III\n </strong>\n provide a programmable digital imaging engine with strong support for video functionalities and come with a built-in USB controller. Additionally,\n <strong>\n  Cypress Semiconductor\n </strong>\n has partnered with other companies to offer reference designs that utilize\n <strong>\n  EZ-USB controllers\n </strong>\n tailored for different video applications. These chips make it easier to integrate video capabilities into USB-enabled devices.\n</p>\n"}, "Page 248": {"response": "<h3>\n VideoStreaming Interface, Class-Specific Requests, and Chip Support\n</h3>\n<h4>\n Payload Format and Color Matching\n</h4>\n<p>\n In video devices, the\n <strong>\n  Payload Format descriptor\n </strong>\n defines the video format and its characteristics, such as the\n <strong>\n  dimensions of video frames\n </strong>\n . It can also include a\n <strong>\n  Color Matching descriptor\n </strong>\n , which ensures that the video colors are consistently displayed across different devices by describing the color profile used for the video data.\n</p>\n<p>\n Each\n <strong>\n  VideoStreaming interface\n </strong>\n requires an\n <strong>\n  isochronous endpoint\n </strong>\n (for video data transfer) or a\n <strong>\n  bulk endpoint\n </strong>\n , and it may optionally include a second\n <strong>\n  bulk endpoint\n </strong>\n for still images. This setup allows for efficient video and image streaming over USB connections.\n</p>\n<h4>\n Class-Specific Requests\n</h4>\n<p>\n The video class includes\n <strong>\n  class-specific control requests\n </strong>\n that enable communication with\n <strong>\n  VideoControl\n </strong>\n and\n <strong>\n  VideoStreaming interfaces\n </strong>\n . These requests allow the host to adjust settings and read the current states of the video controls, ensuring that the video device operates as intended.\n</p>\n<h4>\n Chip Support for Video Devices\n</h4>\n<p>\n For hardware solutions,\n <strong>\n  Vista Imaging\u2019s ViCAM-III chip\n </strong>\n integrates a\n <strong>\n  programmable digital imaging engine\n </strong>\n , offering extensive video function support along with a built-in USB controller. Additionally,\n <strong>\n  Cypress Semiconductor\n </strong>\n collaborates with other companies to provide reference designs using\n <strong>\n  EZ-USB controllers\n </strong>\n in a variety of video applications, facilitating easy integration of USB video capabilities into devices.\n</p>\n"}, "Page 249": {"response": "<h3>\n Windows Support for Video Devices and Implementing Non-Standard Functions\n</h3>\n<h4>\n Windows Support for Video Devices\n</h4>\n<p>\n Starting from\n <strong>\n  Windows XP SP2\n </strong>\n ,\n <strong>\n  usbvideo.sys\n </strong>\n was released to provide support for video class devices. Vendors using this driver don't need to supply any custom driver software. However, they can provide\n <strong>\n  Control or Streaming extensions\n </strong>\n to add support for device-specific features and functions.\n</p>\n<p>\n Applications interact with video devices using the\n <strong>\n  DirectShow\n </strong>\n component of\n <strong>\n  DirectX\n </strong>\n , which is supported beginning with\n <strong>\n  DirectX version 9.2\n </strong>\n .\n</p>\n<p>\n For older versions of Windows, such as\n <strong>\n  Windows XP and earlier\n </strong>\n , video device manufacturers need to provide a\n <strong>\n  minidriver\n </strong>\n . This minidriver specifies the streaming video format, implements device-specific functions, and handles bulk transfers for video data. Windows uses the\n <strong>\n  USBCAMD driver\n </strong>\n to manage\n <strong>\n  isochronous data transfers\n </strong>\n , including synchronizing, starting, stopping, and recovering from errors during communication. This driver works with the\n <strong>\n  stream-class driver\n </strong>\n and lower-level\n <strong>\n  USB drivers\n </strong>\n .\n</p>\n<h4>\n Implementing Non-Standard Functions\n</h4>\n<p>\n Some devices don\u2019t fit neatly into the predefined USB device classes, such as certain\n <strong>\n  data-acquisition devices\n </strong>\n or\n <strong>\n  controllers for motors, relays, or other circuits\n </strong>\n . USB\u2019s flexibility allows it to accommodate these vendor-specific devices.\n</p>\n<p>\n Additionally, devices that link two hosts together (a scenario often handled by legacy\n <strong>\n  serial\n </strong>\n or\n <strong>\n  parallel ports\n </strong>\n ) also benefit from USB\u2019s versatile capabilities.\n</p>\n<h4>\n Standard vs. Custom Drivers\n</h4>\n<p>\n When designing devices, it is generally preferred to use an established\n <strong>\n  class driver\n </strong>\n provided by the operating system. This significantly reduces development time and effort.\n</p>\n<p>\n For devices with\n <strong>\n  vendor-specific functions\n </strong>\n , one option is to design them as\n <strong>\n  Human Interface Devices (HID)\n </strong>\n . A HID doesn\u2019t need to be a standard device type and may not even require a human interface. The key requirement is that the device\u2019s\n <strong>\n  descriptors\n </strong>\n must meet the HID specifications, allowing for flexibility while still conforming to the USB standard.\n</p>\n"}, "Page 250": {"response": "<h3>\n Converting RS-232 Devices to USB and Using Standard Drivers\n</h3>\n<h4>\n Using HID or Mass-Storage Class for Non-Standard Devices\n</h4>\n<p>\n When designing USB devices that don\u2019t fall into a predefined class, one option is to use the\n <strong>\n  Human Interface Device (HID)\n </strong>\n class. HIDs are flexible in that they don't need to be a specific type of device or even require a human interface. The device only needs to meet the HID descriptors' requirements and use\n <strong>\n  interrupt\n </strong>\n or\n <strong>\n  control transfers\n </strong>\n as defined in the HID specification.\n</p>\n<p>\n Another option is the\n <strong>\n  mass-storage class\n </strong>\n , suitable for devices that exchange data in the form of files, particularly if the device supports a file system that the host system can recognize.\n</p>\n<h4>\n Custom Drivers and Third-Party Solutions\n</h4>\n<p>\n Some devices may require custom drivers. An easy solution is to use a driver provided by a\n <strong>\n  chip manufacturer\n </strong>\n . This approach saves time and effort in driver development but can create dependency on the chip vendor to resolve bugs and ensure compatibility with future operating system versions. More detailed information on creating custom drivers can be found in\n <strong>\n  Chapter 8\n </strong>\n .\n</p>\n<h4>\n Converting RS-232 Devices to USB\n</h4>\n<p>\n The\n <strong>\n  RS-232 serial port\n </strong>\n has been a standard part of PCs for a long time, with many peripherals relying on it. Almost any device that uses RS-232 can be adapted to USB, and there are multiple methods for making this transition.\n</p>\n<p>\n The first step is to determine if the device can be classified into an existing USB class. For example:\n</p>\n<ul>\n<li>\n<strong>\n   Modems\n  </strong>\n  should use the\n  <strong>\n   communication-device class\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Pointing devices\n  </strong>\n  ,\n  <strong>\n   uninterruptible power supplies (UPS)\n  </strong>\n  , and\n  <strong>\n   point-of-sale devices\n  </strong>\n  should be designed as\n  <strong>\n   HIDs\n  </strong>\n  .\n </li>\n</ul>\n<p>\n For other types of devices, one simple solution is using\n <strong>\n  FTDI Chip\u2019s FT232BM USB UART\n </strong>\n , which can convert existing RS-232 devices to USB with minimal changes. This conversion typically requires few design adjustments and often doesn\u2019t require modifications to the host software.\n</p>\n<p>\n For instance, a typical device with an\n <strong>\n  RS-232 interface\n </strong>\n uses a\n <strong>\n  UART (Universal Asynchronous Receiver/Transmitter)\n </strong>\n to convert between serial and parallel data. The UART connects to a converter that adapts RS-232 voltages to the 5V logic used by the UART. The line side of this converter links to an RS-232 cable that connects to a remote computer.\n</p>\n<p>\n To convert such a device to USB, simply replace the RS-232 converter with the\n <strong>\n  FT232BM\n </strong>\n chip. On the host computer,\n <strong>\n  FTDI Chip\u2019s Virtual COM port driver\n </strong>\n enables applications to interact with the device using standard RS-232 communication functions.\n</p>\n"}, "Page 251": {"response": "<h3>\n Simplified RS-232 to USB Conversion Using Modules\n</h3>\n<p>\n For even easier\n <strong>\n  RS-232 to USB\n </strong>\n conversion, a ready-made\n <strong>\n  RS-232/USB converter module\n </strong>\n can be used. These modules typically include an\n <strong>\n  FT232BM chip\n </strong>\n or a similar USB-to-serial chip, an RS-232 interface chip, an RS-232 connector, and a USB connector. With this solution, users can choose to continue using the original RS-232 interface or add the converter to switch to a USB connection.\n</p>\n<p>\n The benefit of using such a module is that it requires minimal setup and offers a straightforward way to connect devices that originally used RS-232 to USB, allowing them to function just like standard USB devices.\n</p>\n<p>\n In this setup, the\n <strong>\n  driver provided by FTDI\n </strong>\n makes the device appear as a regular\n <strong>\n  COM-port device\n </strong>\n to host applications, ensuring seamless compatibility with software that relies on serial communication.\n</p>\n"}, "Page 252": {"response": "<h3>\n Converting from Parallel Port to USB\n</h3>\n<p>\n The\n <strong>\n  parallel port\n </strong>\n , originally intended for printers, was once a universal PC connection for a wide range of devices, including scanners and external drives. Although the parallel port is faster than the RS-232 serial port, it has been largely replaced by\n <strong>\n  USB\n </strong>\n for these devices, which now use USB classes designed for printers, scanners, and drives.\n</p>\n<p>\n However, for devices that still require a parallel port connection, there are several options to convert from parallel to USB. A\n <strong>\n  parallel-port interface\n </strong>\n typically has 8 bidirectional data pins, 5 status outputs, and 4 control inputs. A\n <strong>\n  USB controller\n </strong>\n with at least 17 I/O bits can emulate a parallel port, allowing for conversion. For example,\n <strong>\n  Prolific Technology\u2019s PL-2305\n </strong>\n chip provides a\n <strong>\n  USB interface\n </strong>\n and a full\n <strong>\n  PC-side IEEE-1284 parallel port\n </strong>\n , which can directly connect to existing parallel devices.\n</p>\n<p>\n Devices that require only\n <strong>\n  control\n </strong>\n and\n <strong>\n  interrupt transfers\n </strong>\n could potentially use the\n <strong>\n  HID class\n </strong>\n . This may involve replacing the device\u2019s original driver with one that communicates through\n <strong>\n  HID drivers\n </strong>\n , requiring changes to the application software. Alternatively, a\n <strong>\n  custom driver\n </strong>\n can be developed to mimic the functions that the original parallel port driver provided, minimizing changes to the software.\n</p>\n<h3>\n PC-to-PC Communication via USB\n</h3>\n<p>\n USB was designed for communication between a\n <strong>\n  host\n </strong>\n and a\n <strong>\n  device\n </strong>\n , not between two hosts. Therefore, while USB doesn\u2019t allow direct communication between two PCs, there are workarounds. One solution is\n <strong>\n  USB On-The-Go (OTG)\n </strong>\n , which allows devices to act as hosts, enabling peer-to-peer communication. However, most PCs lack\n <strong>\n  On-The-Go host controllers\n </strong>\n . In such cases, other methods or adapters may be needed to facilitate PC-to-PC communication through USB, especially if the PCs do not have\n <strong>\n  Ethernet ports\n </strong>\n .\n</p>\n"}, "Page 253": {"response": "<h3>\n PC-to-PC Communication via USB Host-to-Host Bridge\n</h3>\n<p>\n USB is typically designed for communication between a host and a device, but there are ways to make USB work for PC-to-PC communication. One such method involves using a\n <strong>\n  host-to-host bridge cable\n </strong>\n that connects two PCs via\n <strong>\n  serial interface engines (SIEs)\n </strong>\n . In this setup, each PC connects to one of the SIEs, and the two devices communicate through a shared buffer. The process works by sending data from one PC to one SIE, which passes the data through the shared buffer, and then the other SIE sends the data to the second PC.\n</p>\n<p>\n An example of a chip designed for this type of communication is the\n <strong>\n  Prolific Technology PL-2501 Hi-Speed USB Host-to-Host Bridge Controller\n </strong>\n . This chip includes an\n <strong>\n  8032 microcontroller\n </strong>\n and two USB\n <strong>\n  SIEs\n </strong>\n , which can access the shared buffer to transfer data between the PCs. A lower-speed version, the\n <strong>\n  PL-2301\n </strong>\n , also exists for full-speed applications. Many commercial\n <strong>\n  data-link file-transfer cables\n </strong>\n use these chips, with drivers that allow each PC to recognize the other as if they were connected over a network.\n</p>\n<p>\n Another method to enable PC-to-PC communication through USB is to use two\n <strong>\n  FTDI Chip USB UARTs\n </strong>\n and connect their asynchronous interfaces in a\n <strong>\n  null modem configuration\n </strong>\n . This setup makes the PCs appear as\n <strong>\n  COM-port devices\n </strong>\n to each other. Alternatively, a\n <strong>\n  USB/Ethernet converter\n </strong>\n can be attached to each PC, connecting the PCs to a\n <strong>\n  local network\n </strong>\n for data transfer.\n</p>\n"}, "Page 254": {"response": "<h3>\n Using a Generic Driver for Non-Standard Devices\n</h3>\n<p>\n For devices that don't fit into a predefined USB class, using a\n <strong>\n  generic driver\n </strong>\n can be a viable solution. These drivers allow applications to perform transfers such as\n <strong>\n  control\n </strong>\n ,\n <strong>\n  interrupt\n </strong>\n ,\n <strong>\n  bulk\n </strong>\n , and\n <strong>\n  isochronous\n </strong>\n using a driver-specific API.\n</p>\n<p>\n Two examples of generic drivers are the\n <strong>\n  DriverX USB toolkit\n </strong>\n from Tetradyne Software and the\n <strong>\n  USBIO Development Kit\n </strong>\n from Thesycon Systemsoftware &amp; Consulting GmbH.\n</p>\n<ul>\n<li>\n  The\n  <strong>\n   DriverX USB toolkit\n  </strong>\n  includes:\n  <ul>\n<li>\n    A generic driver\n   </li>\n<li>\n    Header and library files for use with\n    <strong>\n     Visual C++\n    </strong>\n    and\n    <strong>\n     Borland C++ Builder\n    </strong>\n</li>\n<li>\n    Additional support for\n    <strong>\n     Delphi\n    </strong>\n    and\n    <strong>\n     Visual Basic\n    </strong>\n</li>\n</ul>\n</li>\n<li>\n  The\n  <strong>\n   USBIO Development Kit\n  </strong>\n  provides several options for communication with the driver, such as:\n  <ul>\n<li>\n    Standard\n    <strong>\n     Windows API functions\n    </strong>\n    like\n    <strong>\n     ReadFile\n    </strong>\n    ,\n    <strong>\n     WriteFile\n    </strong>\n    , and\n    <strong>\n     DeviceIoControl\n    </strong>\n</li>\n<li>\n    A\n    <strong>\n     C++ class library\n    </strong>\n</li>\n<li>\n    Native interfaces for\n    <strong>\n     Delphi\n    </strong>\n    and\n    <strong>\n     Java\n    </strong>\n</li>\n<li>\n    A\n    <strong>\n     USBIO COM interface\n    </strong>\n    based on Microsoft's\n    <strong>\n     Component Object Model (COM)\n    </strong>\n    technology\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n These tools make it easier for developers to interact with non-standard USB devices without requiring a specific class driver.\n</p>\n"}, "Page 255": {"response": "<p>\n It seems like you've provided a heading without any specific content to restate. Could you please provide the text or content you'd like me to explain and summarize? I'll be happy to help!\n</p>\n"}, "Page 256": {"response": "<h3>\n How the Host Communicates\n</h3>\n<p>\n In Windows, to communicate with a USB peripheral, an application must go through a device driver that understands how to interact with the system's USB drivers. This chapter explains how Windows manages USB communications and outlines the options for device drivers.\n</p>\n<h3>\n Device Driver Basics\n</h3>\n<p>\n A device driver is a software component that allows applications to interact with a hardware device. These devices could be printers, modems, keyboards, video displays, data acquisition units, or any hardware controlled by circuits that the CPU can access. Some devices are internal, like disk drives within the computer, while others, such as USB devices, are external and connect via cables or wireless links.\n</p>\n<p>\n As mentioned in Chapter 7, certain device drivers are class drivers. These are generic drivers designed to manage communication with various devices that perform similar functions.\n</p>\n"}, "Page 257": {"response": "<h3>\n Insulating Applications from the Details\n</h3>\n<p>\n Applications are the programs that users run, from word processors and databases to specialized software that communicates with custom hardware. A device driver plays a crucial role by insulating these applications from needing to understand the technical details, such as physical connections, signals, and protocols required to interact with a device.\n</p>\n<h3>\n How Device Drivers Work\n</h3>\n<p>\n A device driver enables an application to access a peripheral by simply knowing the device\u2019s name (e.g., HP LaserJet 2300) or its function (e.g., joystick, scanner, or drive). The application doesn't need to know the exact physical port the device connects to or manage the control and handshaking signals. It also doesn't need to be aware of whether the device uses USB or another interface. The application remains the same for different devices with similar functions, even if they use different interfaces. All hardware-specific details are handled at a lower level.\n</p>\n<p>\n The device driver acts as a translator between the application and the hardware. Applications communicate with drivers using functions provided by the operating system, while the driver manages the protocols necessary for accessing the peripheral's hardware, including monitoring the status signals and toggling control signals at the right times.\n</p>\n<h3>\n Windows Driver Model\n</h3>\n<p>\n Windows uses a layered driver model for USB devices. Each layer performs a specific part of the communication:\n</p>\n<ul>\n<li>\n<strong>\n   Client Driver\n  </strong>\n  : The top layer contains the client device driver (also called a function driver), which handles communication between applications and the lower-level bus drivers.\n </li>\n<li>\n<strong>\n   Bus Drivers\n  </strong>\n  : The bottom layer manages communication between the client driver and the hardware.\n </li>\n<li>\n<strong>\n   Filter Drivers\n  </strong>\n  : In addition to client and bus drivers, filter drivers may be used to modify or enhance communication between layers.\n </li>\n</ul>\n<p>\n This layered approach simplifies driver development. Devices can share common code for similar tasks. Windows includes the drivers that handle communication with the system\u2019s USB hardware, so developers writing client drivers don\u2019t have to manage these details themselves.\n</p>\n<h3>\n Application Restrictions\n</h3>\n<p>\n Because of the layered driver model, applications cannot directly access USB ports in Windows. Instead, all communication must go through a driver assigned to the specific device. This helps maintain system stability and ensures that USB hardware is properly managed.\n</p>\n"}, "Page 258": {"response": "<h3>\n Options for USB Devices\n</h3>\n<p>\n When developing a USB device, there are several options for obtaining a driver. Many devices can utilize drivers that are already included with Windows or provided by chip vendors or other sources. However, some devices may require custom drivers. In such cases, there are toolkits available that help simplify and speed up the driver development process. Depending on factors like ease, cost, and performance, more than one solution may work for a given device.\n</p>\n<p>\n As explained in Chapter 7, many devices fit into standard classes like disk drives, printers, modems, keyboards, and mice. These devices can use various interfaces, including USB. For instance, a disk drive may use interfaces such as ATA/ATAPI, SCSI, IEEE-1394, or USB. When devices in a class support multiple hardware interfaces, supplemental drivers can be used to accommodate the different interfaces. If a device offers more features than what a class driver supports, a device-specific filter driver may be used to handle those additional capabilities.\n</p>\n<h3>\n User and Kernel Modes\n</h3>\n<p>\n To understand how a device driver functions, it\u2019s important to recognize where it fits in the communication path during a data transfer. Even if you\u2019re not writing the driver for your device, understanding its role will help you in writing application-level code.\n</p>\n<p>\n In general, a device driver handles the communication details for hardware devices interfacing with a CPU. In Windows, there are two modes in which program code can run: user mode and kernel mode. The main difference between the two is the level of privilege granted to the code in accessing memory and other system resources.\n</p>\n<ul>\n<li>\n<strong>\n   User Mode\n  </strong>\n  : Applications run in this mode and have limited privileges, meaning they can only access specific portions of system memory and resources.\n </li>\n<li>\n<strong>\n   Kernel Mode\n  </strong>\n  : Most drivers, including USB drivers, run in kernel mode. This mode provides greater privilege, allowing drivers to directly access system resources and perform more advanced operations that applications in user mode cannot.\n </li>\n</ul>\n<p>\n By operating in kernel mode, USB drivers are able to manage the low-level communication with hardware and handle system interactions efficiently, which is critical for ensuring proper functioning of USB devices.\n</p>\n"}, "Page 259": {"response": "<h3>\n User Mode and Kernel Mode in USB Communication\n</h3>\n<p>\n In Windows, program code can run in two different modes:\n <strong>\n  user mode\n </strong>\n and\n <strong>\n  kernel mode\n </strong>\n . These modes provide different levels of access to system resources and memory, which affects how device drivers and applications interact with the operating system.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    User Mode\n   </strong>\n   : This is the environment where applications run. It has restricted access to system resources to ensure that an application cannot directly interfere with the core operations of the system. The operating system manages this memory protection to allow multiple applications to run simultaneously without affecting each other. For example, if one application crashes, it shouldn't cause other applications to fail. On x86 processors, user mode corresponds to\n   <strong>\n    Ring 3\n   </strong>\n   , a level of privilege with limited access to system resources.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Kernel Mode\n   </strong>\n   : Most device drivers, including USB drivers, operate in kernel mode. This mode provides the driver with higher privileges, allowing it to access system memory and resources directly to manage hardware devices. Kernel mode corresponds to\n   <strong>\n    Ring 0\n   </strong>\n   on x86 processors, which has full access to all system resources, enabling the drivers to perform essential low-level functions.\n  </p>\n</li>\n</ul>\n<h3>\n USB Communication with a Layered Driver Model\n</h3>\n<p>\n USB communication in Windows follows a\n <strong>\n  layered driver model\n </strong>\n , where different drivers interact with different layers in the communication stack. The\n <strong>\n  device drivers\n </strong>\n manage the device-specific functionality, while the\n <strong>\n  bus drivers\n </strong>\n handle communication between the device and the system. There may also be\n <strong>\n  filter drivers\n </strong>\n that add extra functionality or handle additional device-specific features.\n</p>\n<ul>\n<li>\n<strong>\n   User-Mode Driver\n  </strong>\n  : In addition to kernel-mode drivers, some USB devices may have supplementary user-mode drivers that handle higher-level functionality or provide an interface for user applications.\n </li>\n<li>\n<strong>\n   Kernel-Mode Driver\n  </strong>\n  : This is the core driver that interacts with the hardware and manages communication between the operating system and the USB device.\n </li>\n</ul>\n<p>\n This model helps in organizing the driver software efficiently, enabling better management of hardware resources and providing a structured approach to device communication.\n</p>\n"}, "Page 260": {"response": "<h3>\n Kernel Mode Drivers and Communication in Windows\n</h3>\n<p>\n In Windows, drivers operate in\n <strong>\n  kernel mode\n </strong>\n , where they have full access to system resources, including memory management and input/output (I/O) control. This privileged access allows kernel-mode drivers to manage hardware devices more efficiently.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Kernel Mode\n   </strong>\n   : In kernel mode, drivers can execute memory-management instructions, access I/O ports, and respond to hardware interrupts. This mode allows drivers to control which applications can access specific hardware. For example, a joystick driver can manage access by either allowing all applications to use the device or restricting it to exclusive access for a single application. Kernel mode corresponds to\n   <strong>\n    Ring 0\n   </strong>\n   in x86 processors, granting full control over system resources.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    I/O Request Packets (IRPs)\n   </strong>\n   : Communication between drivers is managed through\n   <strong>\n    I/O Request Packets (IRPs)\n   </strong>\n   . Each IRP represents a single input or output action that drivers use to send requests to each other. For instance, a client driver for a USB device sends IRPs to bus drivers (which handle the USB communications) to request data transfer or other operations. These IRPs simplify communication and ensure a standardized method of requesting and processing data between different driver layers.\n  </p>\n</li>\n</ul>\n<h3>\n How Applications Interact with Drivers\n</h3>\n<p>\n Applications communicate with\n <strong>\n  client drivers\n </strong>\n through the\n <strong>\n  Windows API\n </strong>\n (Application Programming Interface), which abstracts the complexities of hardware interaction. This allows application developers to write software without needing to understand the specifics of hardware protocols, such as USB. The\n <strong>\n  WIN32 subsystem\n </strong>\n is responsible for managing the interaction between applications and client drivers, making it easier for developers to work with hardware devices.\n</p>\n<h3>\n WDM Drivers for USB Devices\n</h3>\n<p>\n USB device drivers for Windows must conform to the\n <strong>\n  Windows Driver Model (WDM)\n </strong>\n , which is required for compatibility with Windows 98 and later versions. These drivers are kernel-mode drivers with the\n <strong>\n  .sys\n </strong>\n extension and are responsible for managing USB device communications.\n</p>\n<ul>\n<li>\n<strong>\n   Writing USB Drivers\n  </strong>\n  : To create a USB driver for Windows, developers must use a tool capable of compiling WDM drivers. The\n  <strong>\n   Windows Driver Development Kit (DDK)\n  </strong>\n  includes a\n  <strong>\n   C compiler\n  </strong>\n  for this purpose. However, some toolkits offer\n  <strong>\n   generic drivers\n  </strong>\n  that require little to no programming effort from the developer, making it easier to create a functional driver without building one from scratch.\n </li>\n</ul>\n"}, "Page 261": {"response": "<h3>\n Layered Driver Model for USB Communication\n</h3>\n<p>\n In the USB communication system, Windows uses a\n <strong>\n  layered driver model\n </strong>\n to manage the various components involved in USB data transfer. This model splits the communication process into distinct layers, with each layer handling a specific task. This structure promotes efficiency and reusability, as devices with similar tasks can share common drivers for those tasks.\n</p>\n<ul>\n<li>\n<strong>\n   Benefits of Layered Drivers\n  </strong>\n  : The layered driver model helps avoid redundancy. For instance, all USB devices, regardless of their specific type, can use the same set of drivers to handle USB-specific tasks. This eliminates the need for each device driver to individually manage USB communication, which would otherwise involve significant duplication of effort. By providing these common drivers with Windows, device manufacturers can save time and resources, as they don\u2019t need to develop USB communication code from scratch.\n </li>\n</ul>\n<h3>\n Client Drivers\n</h3>\n<p>\n A\n <strong>\n  client driver\n </strong>\n is responsible for managing communication with a specific device or class of devices. It can consist of one or more files, including a\n <strong>\n  class driver\n </strong>\n provided by Windows or a vendor-specific driver. The client driver ensures that the correct device is accessed and controlled based on the specific tasks it needs to perform.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Class Drivers\n   </strong>\n   : A class driver handles communication for a group of similar devices. For example, a class driver may manage all devices of a particular category, like USB keyboards or USB printers. If a device has additional, specific requirements, the class driver may interact with a\n   <strong>\n    miniclass driver\n   </strong>\n   . Miniclass drivers handle communications for a specific subset of devices within a broader class.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Filter Drivers\n   </strong>\n   : Both\n   <strong>\n    upper\n   </strong>\n   and\n   <strong>\n    lower\n   </strong>\n   filter drivers can be used to modify or monitor communications between different layers. An\n   <strong>\n    upper filter driver\n   </strong>\n   sits between the application and the client driver, allowing it to observe and potentially alter the data being sent to the client driver. A\n   <strong>\n    lower filter driver\n   </strong>\n   , on the other hand, sits between the client driver and the bus drivers, allowing it to monitor or modify the data as it is communicated with the USB bus.\n  </p>\n</li>\n</ul>\n<p>\n In summary, the layered driver model simplifies device driver development, enables code reuse, and reduces redundancy, which is crucial for efficiently managing a wide range of USB devices in Windows.\n</p>\n"}, "Page 262": {"response": "<h3>\n Composite Devices and the Generic Parent Driver in Windows XP\n</h3>\n<p>\n In the case of\n <strong>\n  composite devices\n </strong>\n (devices that combine multiple functionalities, such as a webcam with a microphone), Windows XP utilizes a\n <strong>\n  USB common-class generic parent driver\n </strong>\n . This driver is loaded between the bus drivers and the client drivers for the device\u2019s interfaces. The primary role of this\n <strong>\n  generic parent driver\n </strong>\n is to manage several key functions for the entire composite device:\n</p>\n<ol>\n<li>\n<strong>\n   Synchronization\n  </strong>\n  : Ensures that data and commands are properly coordinated across the multiple interfaces of the composite device.\n </li>\n<li>\n<strong>\n   Plug-and-Play (PnP)\n  </strong>\n  : Facilitates the device\u2019s ability to be recognized and configured by the system automatically when it is connected or disconnected.\n </li>\n<li>\n<strong>\n   Power Management\n  </strong>\n  : Manages the power settings for the composite device, ensuring that the device is powered appropriately based on its usage and the system\u2019s power policies.\n </li>\n</ol>\n<p>\n The generic parent driver also handles communication between the bus drivers (which manage USB communications) and the various\n <strong>\n  client drivers\n </strong>\n that control the individual functions or interfaces of the composite device.\n</p>\n<p>\n In this setup, the device is treated as a whole, with the parent driver coordinating and simplifying the management of its different components, making the system more efficient in handling composite devices.\n</p>\n"}, "Page 263": {"response": "<h3>\n USB Drivers in Windows XP\n</h3>\n<p>\n In\n <strong>\n  Windows XP\n </strong>\n , the USB bus drivers are made up of three key components: the\n <strong>\n  host-controller driver\n </strong>\n ,\n <strong>\n  miniport drivers\n </strong>\n , and the\n <strong>\n  hub driver\n </strong>\n .\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Host-Controller Driver\n   </strong>\n   : This driver is also known as the\n   <strong>\n    port driver\n   </strong>\n   and is responsible for managing tasks that are common to all USB host controllers. It works alongside miniport drivers and helps manage communication with the USB hardware. The host controller driver is composed of:\n  </p>\n<ul>\n<li>\n<strong>\n     usbport.sys\n    </strong>\n    : The core driver that handles general communication with the USB hardware.\n   </li>\n<li>\n<strong>\n     Miniport Drivers\n    </strong>\n    : These drivers are specialized and handle communication with specific types of host controllers. Each miniport driver is designed to work with one of the three types of host controllers available for USB.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Hub Driver\n   </strong>\n   : This driver manages communication with USB hubs. In\n   <strong>\n    Windows XP\n   </strong>\n   , the\n   <strong>\n    hub driver\n   </strong>\n   is represented by\n   <strong>\n    usbhub.sys\n   </strong>\n   , which controls the interaction between the system and the USB hubs, ensuring that data is properly routed to and from various connected USB devices.\n  </p>\n</li>\n</ol>\n<p>\n These\n <strong>\n  bus drivers\n </strong>\n are already integrated into Windows, meaning that developers working with USB devices do not need to worry about the intricacies of the bus drivers themselves. The\n <strong>\n  host-controller\n </strong>\n and\n <strong>\n  hub drivers\n </strong>\n handle all the low-level details of USB communication, simplifying the development process for application and device driver writers.\n</p>\n<p>\n In summary, the USB bus drivers in Windows XP are essential for ensuring that USB devices communicate effectively with the system, with the host-controller driver, miniport drivers, and hub driver all working together to manage the USB connections.\n</p>\n"}, "Page 264": {"response": "<h3>\n Host Controller Types and Differences\n</h3>\n<p>\n There are three types of\n <strong>\n  host controllers\n </strong>\n used in USB communication, each supporting different speeds of data transfer. These controllers are crucial for facilitating the connection between USB devices and the system. The three types are:\n</p>\n<ol>\n<li>\n<strong>\n   Open Host Controller Interface (OHCI)\n  </strong>\n  : This controller supports\n  <strong>\n   low-speed\n  </strong>\n  and\n  <strong>\n   full-speed\n  </strong>\n  USB communications. It was developed by Compaq, Microsoft, and National Semiconductor.\n </li>\n<li>\n<strong>\n   Universal Host Controller Interface (UHCI)\n  </strong>\n  : Like OHCI, this controller also supports\n  <strong>\n   low-speed\n  </strong>\n  and\n  <strong>\n   full-speed\n  </strong>\n  USB communications but uses a different approach to implement the functions. It was developed by Intel.\n </li>\n<li>\n<strong>\n   Enhanced Host Controller Interface (EHCI)\n  </strong>\n  : This controller supports\n  <strong>\n   high-speed\n  </strong>\n  USB communications and is specifically designed for faster data transfer.\n </li>\n</ol>\n<h3>\n Understanding the Differences Between OHCI and UHCI\n</h3>\n<p>\n In\n <strong>\n  Windows XP\n </strong>\n , there are specific drivers associated with each host controller type:\n</p>\n<ul>\n<li>\n<strong>\n   usbohci.sys\n  </strong>\n  : This driver is for\n  <strong>\n   OHCI-compliant\n  </strong>\n  controllers.\n </li>\n<li>\n<strong>\n   usbuhci.sys\n  </strong>\n  : This driver is for\n  <strong>\n   UHCI-compliant\n  </strong>\n  controllers.\n </li>\n</ul>\n<p>\n The key difference between OHCI and UHCI lies in how they handle the communication process:\n</p>\n<ul>\n<li>\n<strong>\n   UHCI\n  </strong>\n  : It places more of the communication workload on the\n  <strong>\n   software\n  </strong>\n  , allowing the use of simpler, more affordable hardware.\n </li>\n<li>\n<strong>\n   OHCI\n  </strong>\n  : This controller shifts more of the burden to the\n  <strong>\n   hardware\n  </strong>\n  , resulting in simpler software control.\n </li>\n</ul>\n<p>\n Both\n <strong>\n  OHCI\n </strong>\n and\n <strong>\n  UHCI\n </strong>\n are fully compliant with the USB specification, meaning they adhere to the standard for USB communication. However, their performance may differ based on how they distribute the workload between software and hardware. It\u2019s important to note that the choice of host controller type can affect the overall performance, so testing across different host controller types is recommended.\n</p>\n<h3>\n Identifying the Host Controller in Windows\n</h3>\n<p>\n In\n <strong>\n  Windows\n </strong>\n , you can use the\n <strong>\n  Device Manager\n </strong>\n to view information about the host controllers on your PC. To check the driver type:\n</p>\n<ol>\n<li>\n  Open\n  <strong>\n   Device Manager\n  </strong>\n  .\n </li>\n<li>\n  Right-click on the host controller\u2019s name.\n </li>\n<li>\n  Select\n  <strong>\n   Properties\n  </strong>\n  , then go to the\n  <strong>\n   Driver\n  </strong>\n  tab and click on\n  <strong>\n   Driver Details\n  </strong>\n  .\n </li>\n</ol>\n<p>\n This will show you which driver is associated with the host controller. You should see\n <strong>\n  ohci\n </strong>\n ,\n <strong>\n  uhci\n </strong>\n , or\n <strong>\n  ehci\n </strong>\n in the driver name, depending on the host controller type.\n</p>\n<p>\n Understanding these host controller types and their differences is vital for developers to ensure proper communication between devices and the system. The differences may not always be obvious, but they can affect performance, so testing with various controller types is important for ensuring optimal functionality.\n</p>\n"}, "Page 265": {"response": "<h3>\n Understanding OHCI, UHCI, and EHCI Controllers\n</h3>\n<p>\n USB host controllers play a crucial role in managing the communication between the CPU and USB devices. There are three types of host controllers\u2014OHCI, UHCI, and EHCI\u2014that handle different data transfer speeds and protocols. Here\u2019s a breakdown of their capabilities:\n</p>\n<h4>\n OHCI vs. UHCI: Key Differences\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Control Transfer Scheduling\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    An\n    <strong>\n     OHCI\n    </strong>\n    (Open Host Controller Interface) controller can schedule multiple stages of a\n    <strong>\n     control transfer\n    </strong>\n    within a single frame, making it more efficient in some cases.\n   </li>\n<li>\n    A\n    <strong>\n     UHCI\n    </strong>\n    (Universal Host Controller Interface) controller, however, schedules each stage of a control transfer in separate frames, leading to potentially more processing time.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Bulk Endpoint Transactions\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    For\n    <strong>\n     bulk endpoints\n    </strong>\n    with packet sizes under 64 bytes, a\n    <strong>\n     UHCI\n    </strong>\n    driver attempts only one transaction per frame.\n   </li>\n<li>\n    On the other hand, an\n    <strong>\n     OHCI\n    </strong>\n    driver can attempt multiple transactions within a frame, optimizing the use of available bandwidth.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Interrupt Endpoint Polling\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    An\n    <strong>\n     OHCI\n    </strong>\n    controller will poll an\n    <strong>\n     interrupt endpoint\n    </strong>\n    at least once every\n    <strong>\n     32 milliseconds\n    </strong>\n    , even if the endpoint is set for a\n    <strong>\n     maximum latency of 255 milliseconds\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     UHCI\n    </strong>\n    controllers have more flexibility and may poll less frequently, depending on the device\u2019s configuration.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Potential Issues and Compatibility\n</h4>\n<p>\n It\u2019s important to note that developers who are accustomed to\n <strong>\n  UHCI\n </strong>\n controllers may encounter problems when connecting their devices to\n <strong>\n  OHCI\n </strong>\n hosts. This is because\n <strong>\n  OHCI controllers\n </strong>\n may attempt multiple transactions within a single frame, which might not be expected by the device. This discrepancy can lead to unexpected behavior or device failures. Therefore, it's crucial to test your USB devices on both types of host controllers to ensure compatibility.\n</p>\n<h4>\n EHCI: Supporting High-Speed Communications\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    EHCI Controllers\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     EHCI\n    </strong>\n    (Enhanced Host Controller Interface) is designed specifically to handle\n    <strong>\n     high-speed communications\n    </strong>\n    (USB 2.0). It is capable of transferring data at speeds of up to\n    <strong>\n     480 Mbps\n    </strong>\n    .\n   </li>\n<li>\n    According to the\n    <strong>\n     EHCI specification\n    </strong>\n    , a host that supports EHCI must also support low-speed and full-speed devices. However, in most cases,\n    <strong>\n     EHCI\n    </strong>\n    is accompanied by either an\n    <strong>\n     OHCI\n    </strong>\n    or\n    <strong>\n     UHCI\n    </strong>\n    controller to manage these slower devices.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Supporting Multiple Speeds\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    While an\n    <strong>\n     EHCI controller\n    </strong>\n    handles high-speed communication, it requires a companion\n    <strong>\n     OHCI\n    </strong>\n    or\n    <strong>\n     UHCI\n    </strong>\n    controller to manage devices operating at lower speeds (low-speed or full-speed).\n   </li>\n<li>\n    Many PCs with\n    <strong>\n     EHCI controllers\n    </strong>\n    also feature companion\n    <strong>\n     OHCI\n    </strong>\n    or\n    <strong>\n     UHCI controllers\n    </strong>\n    for backward compatibility with older USB devices.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Windows Handling\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Users and application developers generally don\u2019t need to worry about which host controller (EHCI, OHCI, or UHCI) is handling communication with a device, as\n    <strong>\n     Windows\n    </strong>\n    abstracts these details away.\n   </li>\n<li>\n    However, if a high-speed-capable device is attached to a\n    <strong>\n     1.x hub\n    </strong>\n    , Windows will issue a warning about the mismatch between the device\u2019s capabilities and the hub\u2019s capabilities.\n   </li>\n<li>\n    The\n    <strong>\n     EHCI driver\n    </strong>\n    used in Windows is\n    <strong>\n     usbechi.sys\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Summary\n</h4>\n<ul>\n<li>\n<strong>\n   OHCI\n  </strong>\n  and\n  <strong>\n   UHCI\n  </strong>\n  controllers differ in how they handle control transfers, bulk transactions, and interrupt endpoint polling. OHCI generally offers more efficient use of resources by scheduling multiple transactions in a single frame.\n </li>\n<li>\n  The\n  <strong>\n   EHCI controller\n  </strong>\n  is designed to support high-speed USB 2.0 devices, while\n  <strong>\n   OHCI\n  </strong>\n  and\n  <strong>\n   UHCI controllers\n  </strong>\n  manage low and full-speed devices. These controllers can share a bus, and compatibility with all speeds is ensured by having appropriate companion controllers.\n </li>\n<li>\n  Developers should ensure their devices work with both\n  <strong>\n   OHCI\n  </strong>\n  and\n  <strong>\n   UHCI\n  </strong>\n  hosts to ensure cross-platform compatibility and avoid surprises during testing.\n </li>\n</ul>\n"}, "Page 266": {"response": "<h3>\n Understanding the Communication Flow in USB Transfers\n</h3>\n<p>\n When a USB device is connected to a system, several steps and processes take place to enable successful communication between the application and the device. Here\u2019s an overview of the key stages involved in a typical USB transfer.\n</p>\n<h4>\n Preliminary Requirements\n</h4>\n<p>\n Before any data can be exchanged, Windows manages the\n <strong>\n  enumeration\n </strong>\n process, as explained in Chapter 4. This process identifies the connected device and prepares it for communication. Here's how it works:\n</p>\n<ol>\n<li>\n<strong>\n   Device Identification\n  </strong>\n  :\n  <ul>\n<li>\n    Windows retrieves the\n    <strong>\n     descriptors\n    </strong>\n    from the attached device, which contain information about the device's capabilities, such as its vendor ID, device ID, and supported configurations.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Driver Selection\n  </strong>\n  :\n  <ul>\n<li>\n    Using the information from the descriptors, Windows matches the device with the appropriate\n    <strong>\n     driver\n    </strong>\n    from the system\u2019s\n    <strong>\n     INF files\n    </strong>\n    (information files that describe device characteristics). This is crucial for identifying the proper driver to manage the device\u2019s communication.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Configuration Selection\n  </strong>\n  :\n  <ul>\n<li>\n    If the device supports multiple configurations (such as different modes of operation), the system selects one configuration that will be used for the device.\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n Once this process is completed, the application gains access to the device through a\n <strong>\n  handle\n </strong>\n , which is a unique identifier for the device that allows the application to communicate with it.\n</p>\n<h4>\n Initiating Data Transfers\n</h4>\n<p>\n Once the application has established communication with the device, the data transfer process can begin. For example, when interacting with a data-acquisition device, the following scenarios may occur:\n</p>\n<ol>\n<li>\n<strong>\n   User Actions\n  </strong>\n  :\n  <ul>\n<li>\n    A user might initiate a transfer by pressing a button in a data-acquisition application or selecting an option to request periodic data readings (e.g., once every minute).\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Automatic Data Collection\n  </strong>\n  :\n  <ul>\n<li>\n    In some cases, data collection can start automatically when the device\u2019s driver is loaded or when the user runs the application. This ensures that the device begins capturing and transmitting data without requiring explicit user input.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n The Application\u2019s Role in Data Transfer\n</h4>\n<p>\n To interact with a USB device, applications rely on\n <strong>\n  API functions\n </strong>\n provided by Windows. These functions enable communication between the application and the device\u2019s\n <strong>\n  client driver\n </strong>\n , which manages the data transfer. Here\u2019s how the process works:\n</p>\n<ol>\n<li>\n<strong>\n   Opening Communication\n  </strong>\n  :\n  <ul>\n<li>\n    The application typically starts by opening communication with the device using the\n    <strong>\n     CreateFile\n    </strong>\n    function. This function is used to get a handle to the device, enabling further communication.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Data Exchange\n  </strong>\n  :\n  <ul>\n<li>\n    Once communication is established, the application can exchange data using a combination of functions such as:\n    <ul>\n<li>\n<strong>\n       ReadFile/ReadFileEx\n      </strong>\n      : For reading data from the device.\n     </li>\n<li>\n<strong>\n       WriteFile/WriteFileEx\n      </strong>\n      : For sending data to the device.\n     </li>\n<li>\n<strong>\n       DeviceIoControl\n      </strong>\n      : For controlling or querying the device with specific commands or actions.\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<strong>\n   Closing Communication\n  </strong>\n  :\n  <ul>\n<li>\n    After the data exchange is completed, the application can close the communication with the device using\n    <strong>\n     CloseHandle\n    </strong>\n    to release resources and properly disconnect.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Simplified Programming with Intermediate Layers\n</h4>\n<p>\n To make programming easier and more efficient, many modern programming environments, such as\n <strong>\n  Microsoft\u2019s .NET platform\n </strong>\n , provide high-level\n <strong>\n  classes and methods\n </strong>\n . These allow developers to interact with devices without directly calling many of the low-level API functions mentioned earlier. These layers abstract the complexity of interacting with USB devices, making the development process safer and more accessible.\n</p>\n<h4>\n Summary\n</h4>\n<ul>\n<li>\n  The\n  <strong>\n   enumeration process\n  </strong>\n  ensures that the connected device is identified and matched with the correct driver.\n </li>\n<li>\n  Once a device is identified, the application can begin initiating\n  <strong>\n   data transfers\n  </strong>\n  using standard Windows API functions.\n </li>\n<li>\n  The application interacts with the device through client drivers, using functions like\n  <strong>\n   CreateFile\n  </strong>\n  ,\n  <strong>\n   ReadFile\n  </strong>\n  , and\n  <strong>\n   WriteFile\n  </strong>\n  for communication.\n </li>\n<li>\n  Advanced programming platforms like\n  <strong>\n   .NET\n  </strong>\n  provide simplified access to USB devices by using intermediate layers, which reduces the need to directly handle complex API functions.\n </li>\n</ul>\n<p>\n This process ensures smooth and efficient communication between applications and USB devices in a Windows environment.\n</p>\n"}, "Page 267": {"response": "<h3>\n Understanding Device Communication Using API Functions\n</h3>\n<p>\n In Windows, applications communicate with devices through API functions, allowing them to interact with hardware via drivers. Here's how these functions work and the role they play in facilitating device communication.\n</p>\n<h4>\n Simplified Access Through Intermediate Layers\n</h4>\n<p>\n Programming environments like\n <strong>\n  Microsoft's .NET platform\n </strong>\n provide an intermediate layer, the\n <strong>\n  Common Language Runtime (CLR)\n </strong>\n , which in turn calls low-level API functions. This simplifies programming by providing higher-level methods to interact with devices. For example, in\n <strong>\n  Visual Basic .NET\n </strong>\n , the\n <code>\n  PrintDocument\n </code>\n class offers methods to send text and images to a printer, abstracting away the complexity of device communication.\n</p>\n<p>\n However, certain interactions, such as detecting device attachment and removal via\n <strong>\n  WM_DEVICECHANGE\n </strong>\n messages, require direct API calls, as .NET doesn\u2019t offer built-in methods for this.\n</p>\n<h4>\n Key API Functions for Device Communication\n</h4>\n<p>\n Applications communicate with devices through several API functions that handle data transfer, device control, and communication management. The most commonly used functions are:\n</p>\n<ol>\n<li>\n<strong>\n   ReadFile and WriteFile\n  </strong>\n  :\n  <ul>\n<li>\n    These functions are traditionally used for file operations but can also be used for communication with any driver that supports\n    <strong>\n     handle-based operations\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     ReadFile\n    </strong>\n    and\n    <strong>\n     WriteFile\n    </strong>\n    (as well as their extended versions,\n    <strong>\n     ReadFileEx\n    </strong>\n    and\n    <strong>\n     WriteFileEx\n    </strong>\n    ) transfer data between the application and a driver. The data is transferred via a buffer specified in the function call.\n   </li>\n<li>\n    It's important to note that calling\n    <strong>\n     ReadFile\n    </strong>\n    doesn\u2019t always require the driver to retrieve data from the device. Sometimes, it simply returns data that the driver has previously retrieved and stored in a buffer.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   DeviceIoControl\n  </strong>\n  :\n  <ul>\n<li>\n    This function allows applications to send control requests to drivers, transferring data in both directions. Each\n    <strong>\n     DeviceIoControl\n    </strong>\n    request includes a\n    <strong>\n     control code\n    </strong>\n    , which identifies the specific action to be performed.\n   </li>\n<li>\n    Unlike\n    <strong>\n     ReadFile\n    </strong>\n    and\n    <strong>\n     WriteFile\n    </strong>\n    ,\n    <strong>\n     DeviceIoControl\n    </strong>\n    can transfer data in both directions during a single call, depending on the control code.\n   </li>\n<li>\n    Control codes are defined by\n    <strong>\n     Windows drivers\n    </strong>\n    for common devices. For instance:\n    <ul>\n<li>\n<strong>\n       IOCTL_STORAGE_CHECK_VERIFY\n      </strong>\n      checks whether removable media is present and readable.\n     </li>\n<li>\n<strong>\n       IOCTL_STORAGE_GET_MEDIA_TYPES\n      </strong>\n      identifies the types of media supported by a storage device.\n     </li>\n</ul>\n</li>\n<li>\n<strong>\n     Vendor-specific drivers\n    </strong>\n    can also define their own control codes, which are used exclusively by the specific driver, making it irrelevant if other drivers use the same codes.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Summary\n</h4>\n<p>\n Applications use a combination of API functions, such as\n <strong>\n  ReadFile\n </strong>\n ,\n <strong>\n  WriteFile\n </strong>\n , and\n <strong>\n  DeviceIoControl\n </strong>\n , to communicate with devices in a Windows environment. While higher-level programming languages like\n <strong>\n  .NET\n </strong>\n offer simplified access through intermediate layers, certain device interactions still require direct API calls. These functions allow data to be transferred and controlled between the application and the device, with each function tailored for specific types of communication (reading, writing, or controlling a device). The ability to define and use control codes enhances flexibility, allowing drivers to implement customized control behaviors.\n</p>\n"}, "Page 268": {"response": "<h3>\n The Role of Client Drivers in USB Communication\n</h3>\n<p>\n In USB communication, the client driver plays a crucial role in facilitating data transfer and interaction between the application and the USB device. Here's an overview of how client drivers operate and their interaction with the system.\n</p>\n<h4>\n Communication via DeviceIoControl Codes\n</h4>\n<p>\n Client drivers, like\n <strong>\n  CyUsb.sys\n </strong>\n , define a set of\n <strong>\n  DeviceIoControl\n </strong>\n codes that help manage data transfer, device configuration, and status queries. For example, these codes can be used for tasks such as sending or receiving data, configuring a device, or requesting device status.\n</p>\n<p>\n In addition, some drivers, like the\n <strong>\n  HID driver\n </strong>\n , provide application-specific functions. These functions, such as\n <strong>\n  Hid_GetFeature\n </strong>\n and\n <strong>\n  HidD_SetFeature\n </strong>\n , are built on\n <strong>\n  DeviceIoControl\n </strong>\n but are tailored for specific use cases, like sending and receiving\n <strong>\n  Feature reports\n </strong>\n for HID devices. These functions make it easier for application developers to interact with hardware without needing to directly manage lower-level communication.\n</p>\n<h4>\n The Client Driver\u2019s Function in Data Transfer\n</h4>\n<p>\n When an application requests to read from or write to a USB device, the call is passed through the\n <strong>\n  client driver\n </strong>\n . This driver translates the request into a format that the\n <strong>\n  USB bus-class driver\n </strong>\n can understand.\n</p>\n<p>\n To manage the communication between drivers, Windows uses\n <strong>\n  I/O Request Packets (IRPs)\n </strong>\n , which contain\n <strong>\n  USB Request Blocks (URBs)\n </strong>\n for USB transfers. These blocks define the action or operation being requested. For instance, when a client driver wants to retrieve a descriptor from the device, it submits an IRP containing the URB\n <strong>\n  URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE\n </strong>\n .\n</p>\n<h4>\n How Transfers Are Managed by Drivers\n</h4>\n<p>\n When initiating a data transfer, the client driver creates an\n <strong>\n  URB\n </strong>\n (USB Request Block) and submits it to a lower-level driver through an IRP. The\n <strong>\n  bus and host controller drivers\n </strong>\n then take over and handle the scheduling of transactions on the USB bus.\n</p>\n<p>\n For certain types of transfers, such as\n <strong>\n  interrupt\n </strong>\n or\n <strong>\n  isochronous transfers\n </strong>\n , the host controller schedules the transaction at the appropriate time. If no IRP is submitted for an endpoint by the time its scheduled transfer occurs, the host controller will skip the transaction.\n</p>\n<p>\n When a transfer requires multiple transactions, the client driver can submit a single IRP for the entire transfer. This allows the bus drivers to schedule all transactions related to the transfer in sequence without needing to interact with the client driver for each one.\n</p>\n<h4>\n Writing vs. Using Client Drivers\n</h4>\n<p>\n If you\u2019re using an existing client driver (for example, one that is provided with the operating system or by a third-party vendor), you don\u2019t need to worry about the details of\n <strong>\n  IRPs\n </strong>\n and\n <strong>\n  URBs\n </strong>\n . You simply need to understand how to access the application-level interface that the driver exposes.\n</p>\n<p>\n However, if you are writing your own client driver, you must handle the creation and submission of IRPs and URBs to facilitate communication with the system\u2019s USB drivers. This requires a deeper understanding of how data is transferred at the driver level.\n</p>\n<h4>\n Summary\n</h4>\n<p>\n Client drivers are responsible for managing the communication between applications and USB devices, ensuring that data is transferred correctly and efficiently. They handle the creation of IRPs and URBs, which define the actions required for a transfer. Understanding how client drivers interact with bus-class drivers, and how they handle scheduling and multiple transactions, is essential for both using and developing USB device drivers.\n</p>\n"}, "Page 269": {"response": "<h3>\n The Hub and Host-Controller Drivers in USB Communication\n</h3>\n<p>\n The hub and host-controller drivers play essential roles in facilitating communication between USB devices and the host system. Here's a detailed look at their functions in the communication process.\n</p>\n<h4>\n The Hub Driver\u2019s Role\n</h4>\n<p>\n The\n <strong>\n  hub driver\n </strong>\n is responsible for managing the USB hubs connected to the system. A hub is a central component that allows multiple devices to connect to a single USB port. The hub driver, also known as the\n <strong>\n  bus driver\n </strong>\n , is pre-installed in the system and does not require any additional programming from device developers. It ensures that data passed through the hubs reaches the correct destination.\n</p>\n<h4>\n The Host-Controller Driver\u2019s Role\n</h4>\n<p>\n The\n <strong>\n  host-controller driver\n </strong>\n handles the communication between the\n <strong>\n  host-controller hardware\n </strong>\n and the\n <strong>\n  USB bus\n </strong>\n . When a client driver sends data, the host-controller driver passes it on to the hardware, which then transmits the data over the USB bus. Similar to the hub driver, the host-controller driver is provided by the system and does not require any special programming from device developers. It ensures smooth data transfer from the host system to the bus.\n</p>\n<h4>\n The Device\u2019s Role\n</h4>\n<p>\n Once data reaches the\n <strong>\n  hub\n </strong>\n connected to a device, the data is forwarded to the device itself. The device identifies itself using its assigned address, processes the incoming data, and takes the necessary action. This could involve sending data back to the host or performing a task based on the command it received.\n</p>\n<h4>\n The Response\n</h4>\n<p>\n Most USB communications require a response from the device. This could be the requested data or a status code indicating the success or failure of the operation. The response follows the reverse path from the device back to the host system: it travels through the device\u2019s hub, over the bus, and reaches the host system\u2019s hardware and software. The\n <strong>\n  client driver\n </strong>\n may pass this response to the application, which will take the appropriate action, such as displaying the result or performing further operations based on the data received.\n</p>\n<h4>\n Ending Communications\n</h4>\n<p>\n Once the communication process is completed, the application can use the\n <strong>\n  CloseHandle\n </strong>\n API function to release any system resources that were allocated during the communication. This ensures that resources are freed up for other tasks.\n</p>\n<h4>\n Examples of Initiating Communication\n</h4>\n<p>\n While the process described applies to most USB devices, there are different ways that communication can be initiated. For example:\n</p>\n<ul>\n<li>\n  A user may click on the icon of a\n  <strong>\n   USB drive\n  </strong>\n  to access its folders, which triggers a data transfer.\n </li>\n<li>\n  A user might click\n  <strong>\n   Print\n  </strong>\n  in an application to send a file to a USB printer.\n </li>\n</ul>\n<p>\n These are common ways that USB device communication is initiated, and the process follows the same general flow as described, with the application requesting data and receiving a response from the device.\n</p>\n<h4>\n Summary\n</h4>\n<p>\n The\n <strong>\n  hub driver\n </strong>\n ,\n <strong>\n  host-controller driver\n </strong>\n , and\n <strong>\n  device\n </strong>\n each play vital roles in facilitating the transfer of data over the USB bus. Data flows through the system from the host to the device, and responses travel back in reverse order. Once the communication is finished, resources are released to ensure system efficiency. Understanding the roles of these drivers is key to managing USB communications effectively.\n</p>\n"}, "Page 270": {"response": "<h3>\n Communication Flow in USB Systems and Creating a Custom Driver\n</h3>\n<p>\n This section explains the flow of communication for USB devices and outlines the process of creating a custom driver for Windows operating systems.\n</p>\n<h4>\n Data Transfer Initiation\n</h4>\n<p>\n In a typical USB communication,\n <strong>\n  data transfers\n </strong>\n occur when an\n <strong>\n  application\n </strong>\n requests communication, causing the\n <strong>\n  device driver\n </strong>\n to fill a buffer with data to be sent or make a buffer available to receive data. However, there are cases where data is continuously requested by the host even if the application hasn\u2019t made any requests. For instance:\n</p>\n<ul>\n<li>\n  A\n  <strong>\n   keyboard driver\n  </strong>\n  causes the host to request keypress data at regular intervals, as it cannot predict when a key will be pressed.\n </li>\n<li>\n  The host sends enumeration requests during system power-up or when a device is attached to the system. The\n  <strong>\n   device\u2019s hub\n  </strong>\n  notifies the host of the device\u2019s presence, prompting these requests.\n </li>\n</ul>\n<p>\n In addition,\n <strong>\n  suspended devices\n </strong>\n can use the USB feature called\n <strong>\n  remote-wakeup\n </strong>\n to signal their\n <strong>\n  hub\n </strong>\n , which in turn notifies the host to resume communication.\n</p>\n<h4>\n Writing a Custom USB Driver\n</h4>\n<p>\n Creating a\n <strong>\n  custom driver\n </strong>\n for a USB device involves significant technical knowledge, especially in C programming and understanding how\n <strong>\n  Windows\n </strong>\n interacts with both hardware and software. While writing a driver from scratch is a complex task, several tools and products can simplify and expedite the process.\n</p>\n<h5>\n Tools for Writing a USB Driver\n</h5>\n<p>\n To create a\n <strong>\n  WDM (Windows Driver Model) driver\n </strong>\n , the minimum requirement is the\n <strong>\n  Windows Driver Development Kit (DDK)\n </strong>\n . The DDK provides essential tools such as:\n</p>\n<ul>\n<li>\n  A\n  <strong>\n   C compiler\n  </strong>\n</li>\n<li>\n<strong>\n   Linker\n  </strong>\n</li>\n<li>\n<strong>\n   Build utilities\n  </strong>\n</li>\n<li>\n<strong>\n   Documentation\n  </strong>\n</li>\n</ul>\n<p>\n It also includes example source code for common types of drivers, including filter drivers and those handling\n <strong>\n  bulk\n </strong>\n or\n <strong>\n  isochronous transfers\n </strong>\n . These examples serve as a valuable starting point for developing custom drivers.\n</p>\n<h5>\n Writing a Driver from Scratch\n</h5>\n<p>\n Writing a USB driver from scratch is a detailed and specialized process. To guide developers through this process, one highly recommended resource is\n <strong>\n  \"Programming the Microsoft Windows Driver Model\"\n </strong>\n by\n <strong>\n  Walter Oney\n </strong>\n . This book delves into the complexities of creating drivers from the ground up and provides valuable insights for those who wish to understand and write custom drivers for USB devices on Windows.\n</p>\n<h4>\n Summary\n</h4>\n<p>\n Creating a custom USB driver is a challenging task that requires expertise in C programming and knowledge of Windows hardware communication. While writing such a driver from scratch is complex, tools like the Windows DDK and example source code can help simplify the process. For developers looking to dive deeper into USB driver creation, specialized resources like\n <strong>\n  Walter Oney\u2019s book\n </strong>\n are essential references.\n</p>\n"}, "Page 271": {"response": "<h3>\n Using a Driver Toolkit for USB Driver Development\n</h3>\n<p>\n A\n <strong>\n  driver toolkit\n </strong>\n is a helpful resource that can significantly speed up the process of USB driver development by handling much of the work automatically. These toolkits come in different forms, providing either a\n <strong>\n  generic driver\n </strong>\n for quick development or\n <strong>\n  libraries\n </strong>\n and tools to help write a custom driver. Below, we break down these toolkits and their functionalities.\n</p>\n<h4>\n Types of Driver Toolkits\n</h4>\n<ol>\n<li>\n<strong>\n   Generic Driver Toolkits\n  </strong>\n  :\n  <ul>\n<li>\n    These toolkits offer a pre-made driver capable of managing USB communications. They can automatically generate a device-specific\n    <strong>\n     user-mode driver\n    </strong>\n    and an\n    <strong>\n     INF file\n    </strong>\n    for device installation.\n   </li>\n<li>\n    The main advantage of this approach is speed: no programming is required to create the driver. However, this solution is not suitable for every scenario, as it may not cover all specific needs of a device.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Custom Driver Toolkits\n  </strong>\n  :\n  <ul>\n<li>\n    These toolkits provide libraries and tools to help you write a\n    <strong>\n     custom driver\n    </strong>\n    for a specific device. While offering more flexibility, this option requires\n    <strong>\n     programming expertise\n    </strong>\n    .\n   </li>\n<li>\n    These toolkits are ideal for developers who need to address unique communication requirements that a generic driver cannot handle.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Automated Driver Generation\n</h4>\n<p>\n Since all USB communications follow standardized protocols, a\n <strong>\n  single generic driver\n </strong>\n can theoretically communicate with most devices. A robust generic USB driver should:\n</p>\n<ul>\n<li>\n  Support all\n  <strong>\n   four transfer types\n  </strong>\n  (Control, Bulk, Interrupt, Isochronous).\n </li>\n<li>\n  Handle\n  <strong>\n   vendor-defined control requests\n  </strong>\n  .\n </li>\n<li>\n  Include\n  <strong>\n   power-management\n  </strong>\n  and\n  <strong>\n   Plug-and-Play\n  </strong>\n  capabilities, which are necessary for WDM drivers.\n </li>\n<li>\n  Be able to retrieve\n  <strong>\n   descriptors\n  </strong>\n  , select\n  <strong>\n   configurations\n  </strong>\n  , and manage\n  <strong>\n   interfaces\n  </strong>\n  .\n </li>\n</ul>\n<h5>\n Example of Automated Driver Generation: Jungo's WinDriver Toolkit\n</h5>\n<p>\n<strong>\n  Jungo\u2019s WinDriver USB Device toolkit\n </strong>\n requires no programming at all. It automates the process of generating the necessary driver files. Here's how it works:\n</p>\n<ol>\n<li>\n<strong>\n   DriverWizard\n  </strong>\n  : The key component in WinDriver that creates files you can compile into a\n  <strong>\n   user-mode driver\n  </strong>\n  in the form of an executable (.exe).\n </li>\n<li>\n<strong>\n   Kernel-mode Driver\n  </strong>\n  : The user-mode driver communicates with this kernel-mode driver to interact with the USB device.\n </li>\n<li>\n<strong>\n   Compilation Options\n  </strong>\n  : You can compile the files using tools like\n  <strong>\n   Visual C++\n  </strong>\n  ,\n  <strong>\n   C++ Builder\n  </strong>\n  , or\n  <strong>\n   Delphi\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   INF File Creation\n  </strong>\n  : The DriverWizard also generates an\n  <strong>\n   INF file\n  </strong>\n  , which is used to install the driver on the system.\n </li>\n</ol>\n<p>\n Once the driver is created and installed, you can test communication with the device by reading and writing to its endpoints directly through the DriverWizard. From there, applications can use device-specific functions like\n <strong>\n  MyDevice_Open\n </strong>\n and\n <strong>\n  MyDevice_GetDeviceInfo\n </strong>\n to interact with the device.\n</p>\n<h4>\n Summary\n</h4>\n<p>\n Using a\n <strong>\n  driver toolkit\n </strong>\n can greatly simplify the USB driver development process. You can either use a\n <strong>\n  generic driver\n </strong>\n for fast and easy development or take advantage of\n <strong>\n  libraries and tools\n </strong>\n to build a more custom solution. Jungo\u2019s\n <strong>\n  WinDriver toolkit\n </strong>\n is an example of an automated system that requires no programming, making it easy to generate the necessary files for a USB driver. However, for more complex needs, custom driver toolkits offer flexibility but require programming skills.\n</p>\n"}, "Page 272": {"response": "<h3>\n Advanced Driver Development and Tools for USB Communication\n</h3>\n<p>\n When developing USB drivers, especially for performance-sensitive applications, there are various tools and methods available to help optimize and streamline the process. Below, we explore how driver toolkits provide different levels of assistance and performance, and the role of\n <strong>\n  Globally Unique Identifiers (GUIDs)\n </strong>\n in device class identification.\n</p>\n<h4>\n Improving Performance with Kernel PlugIns\n</h4>\n<p>\n For enhanced performance, you can move certain parts of your code from the user-mode driver to a\n <strong>\n  kernel-mode driver\n </strong>\n . This\n <strong>\n  Kernel PlugIn\n </strong>\n is compiled with\n <strong>\n  Visual C++\n </strong>\n for more efficient execution. Additionally, a\n <strong>\n  Debug Monitor\n </strong>\n application is included to help you monitor and debug the communications handled by the driver, which can be crucial in troubleshooting.\n</p>\n<p>\n The\n <strong>\n  WinDriver USB\n </strong>\n toolkit supports multiple operating systems, including\n <strong>\n  Windows\n </strong>\n ,\n <strong>\n  Windows CE .NET\n </strong>\n , and\n <strong>\n  Linux\n </strong>\n , offering broad compatibility for driver development.\n</p>\n<h4>\n Driver Toolkits for Custom Driver Creation\n</h4>\n<p>\n Automated toolkits are great for quickly generating generic drivers but may not be sufficient for creating more specific or high-performance drivers. For example, they don\u2019t support the creation of\n <strong>\n  filter drivers\n </strong>\n or highly custom solutions. If you need a completely custom driver, or one that provides better performance, you can turn to toolkits like:\n</p>\n<ol>\n<li>\n<strong>\n   CompuWare\u2019s DriverWorks\n  </strong>\n  (part of the\n  <strong>\n   DriverStudio suite\n  </strong>\n  ):\n  <ul>\n<li>\n    This toolkit helps you build custom drivers for USB devices (and even other types of devices).\n   </li>\n<li>\n    It offers Wizards and code libraries that handle much of the work, but you still need to complete the code and compile the driver.\n   </li>\n<li>\n    The performance of the final driver can be comparable to one written from scratch.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Jungo\u2019s KernelDriver USB\n  </strong>\n  :\n  <ul>\n<li>\n    This toolkit is designed to help you write\n    <strong>\n     kernel-mode drivers\n    </strong>\n    and provides similar tools to DriverWorks.\n   </li>\n<li>\n    It\u2019s optimized for non-USB devices with a separate product for kernel-mode drivers on non-USB buses.\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n Both toolkits give you flexibility and performance without requiring you to write everything from the ground up, but they still require programming expertise to fine-tune and complete the drivers.\n</p>\n<h4>\n The Role of GUIDs in Driver and Device Identification\n</h4>\n<p>\n A\n <strong>\n  Globally Unique Identifier (GUID)\n </strong>\n is a 128-bit value used to uniquely identify classes or entities in the system. In the context of device drivers, GUIDs are crucial for Windows to identify and interact with different types of device classes.\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Device Setup GUID\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Identifies a\n    <strong>\n     device setup class\n    </strong>\n    , which groups together devices that are installed in a similar manner. Devices that belong to the same setup class are installed using the same process.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Device Interface GUID\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Identifies a\n    <strong>\n     device interface class\n    </strong>\n    , which provides a way for applications to communicate with a driver assigned to devices in that class.\n   </li>\n<li>\n    While many devices in a setup class also share an interface class, the\n    <strong>\n     device interface GUID\n    </strong>\n    allows applications to interact with the driver directly.\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n Windows provides APIs such as\n <strong>\n  SetupDi_\n </strong>\n that work with these GUIDs, allowing for access to different types of information depending on the GUID type. The correct usage of GUIDs is important for ensuring proper device identification and interaction with drivers in the system.\n</p>\n<h4>\n Summary\n</h4>\n<p>\n Driver toolkits such as\n <strong>\n  WinDriver USB\n </strong>\n ,\n <strong>\n  DriverWorks\n </strong>\n , and\n <strong>\n  KernelDriver USB\n </strong>\n offer varying levels of support for creating custom USB drivers, from fully automated solutions to flexible, customizable approaches for high-performance needs. For identification purposes,\n <strong>\n  GUIDs\n </strong>\n play a crucial role in classifying and enabling communication with devices and their drivers, making them essential in the device-driver interaction process.\n</p>\n"}, "Page 273": {"response": "<h3>\n GUIDs for Device Setup and Interface Classes in USB\n</h3>\n<p>\n A\n <strong>\n  Globally Unique Identifier (GUID)\n </strong>\n is a 128-bit value used by Windows to identify and manage different device classes and interfaces. These identifiers are crucial for distinguishing between types of devices and ensuring proper setup and communication with drivers. Here\u2019s a breakdown of how GUIDs are formatted, and how they are used for device setup and interface classes.\n</p>\n<h4>\n GUID Format\n</h4>\n<p>\n GUIDs are typically expressed in a specific format: five sets of hexadecimal characters separated by hyphens. For example:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    HID Device Setup Class GUID\n   </strong>\n   :\n   <br/>\n<code>\n    745a17a0-74d3-11d0-b6fe-00a0c90f57da\n   </code>\n</p>\n</li>\n<li>\n<p>\n<strong>\n    HID Device Interface Class GUID\n   </strong>\n   :\n   <br/>\n<code>\n    4d1e55b2-f16f-11cf-88cb-001111000030\n   </code>\n</p>\n</li>\n</ul>\n<p>\n This standardized format ensures that GUIDs remain unique and traceable across systems.\n</p>\n<h4>\n Generating Custom GUIDs\n</h4>\n<p>\n Driver developers who need to create their own GUIDs can use the\n <strong>\n  guidgen\n </strong>\n utility, which is provided with\n <strong>\n  Visual C++\n </strong>\n . This tool employs an algorithm that minimizes the chance of generating identical GUIDs, ensuring their uniqueness across different systems.\n</p>\n<h4>\n Device Setup GUIDs\n</h4>\n<p>\n A\n <strong>\n  device setup GUID\n </strong>\n identifies a group of devices that Windows configures in the same way. Devices within the same setup GUID category use the same installation process, including the same\n <strong>\n  class installer\n </strong>\n and\n <strong>\n  co-installers\n </strong>\n . These GUIDs are defined in the system file\n <strong>\n  devguid.h\n </strong>\n , which is part of the\n <strong>\n  Windows DDK\n </strong>\n (Driver Development Kit).\n</p>\n<p>\n Table 8-1 in the source document provides examples of\n <strong>\n  device setup classes\n </strong>\n applicable to USB devices. Devices should generally use a setup class that corresponds to their primary function (e.g.,\n <strong>\n  printer\n </strong>\n ,\n <strong>\n  disk drive\n </strong>\n ). Some common USB device classes are automatically matched to these setup GUIDs, but a single device can belong to more than one setup class. For example, a\n <strong>\n  mouse\n </strong>\n device might be both an\n <strong>\n  HID (Human Interface Device)\n </strong>\n and a\n <strong>\n  Mouse\n </strong>\n .\n</p>\n<ul>\n<li>\n<strong>\n   USB Class GUID\n  </strong>\n  : Used for devices like USB hosts, hubs, or any devices that have unique installation needs.\n </li>\n<li>\n<strong>\n   Vendor-Specific Class\n  </strong>\n  : Although available, Microsoft generally discourages the use of vendor-specific classes unless absolutely necessary.\n </li>\n</ul>\n<h4>\n Registry and Setup Functions\n</h4>\n<p>\n Each\n <strong>\n  device setup GUID\n </strong>\n corresponds to a\n <strong>\n  Class key\n </strong>\n in the system registry. Within this registry entry, there is a subkey for each device instance belonging to that class. The\n <strong>\n  devcon\n </strong>\n example in the Windows DDK illustrates how to use these GUIDs for tasks like detecting devices, managing installations, and retrieving device information.\n</p>\n<p>\n In summary, GUIDs play a crucial role in the USB device management process, helping Windows identify, install, and communicate with devices in a standardized manner.\n</p>\n"}, "Page 274": {"response": "<h3>\n Device Interface GUIDs and Setup Classes\n</h3>\n<p>\n In USB communication, GUIDs are also used to manage\n <strong>\n  device interfaces\n </strong>\n and facilitate the interaction between applications and drivers. Here\u2019s how device interface GUIDs and device setup classes work:\n</p>\n<h4>\n Device Interface GUIDs\n</h4>\n<p>\n A\n <strong>\n  device interface GUID\n </strong>\n identifies a specific device interface class, which allows a driver to register multiple interfaces that applications can use to interact with the device. When a class or device driver registers an interface class, it provides the GUID that corresponds to that interface. This enables applications to:\n</p>\n<ol>\n<li>\n  Discover all attached devices within a specific interface class.\n </li>\n<li>\n  Obtain a\n  <strong>\n   device path name\n  </strong>\n  associated with a device, which can be used with the\n  <code>\n   CreateFile\n  </code>\n  function to open communication with the device.\n </li>\n<li>\n  Register for notifications about device attachment or removal.\n </li>\n</ol>\n<p>\n By using\n <strong>\n  SetupDi_ functions\n </strong>\n and the\n <strong>\n  device interface GUID\n </strong>\n , applications can find and manage devices that belong to a particular class, making it easier to interface with various devices dynamically. For instance, after detecting a device, an application can use the device path to communicate with the device (e.g., for reading or writing data).\n</p>\n<h4>\n Device Setup Classes\n</h4>\n<p>\n A\n <strong>\n  device setup GUID\n </strong>\n helps categorize devices based on their installation and configuration requirements. Each device class in Windows corresponds to a specific setup class, and each class has a GUID that determines how Windows installs, configures, and manages the device. Below is a selection of\n <strong>\n  device setup classes\n </strong>\n supported by Windows, along with the associated\n <strong>\n  USB device classes\n </strong>\n :\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Device Setup Class\n    </strong>\n</th>\n<th>\n<strong>\n     USB Class\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n    Battery Devices\n   </td>\n<td>\n    HID\n   </td>\n</tr>\n<tr>\n<td>\n    CD-ROM Drives\n   </td>\n<td>\n    Mass storage\n   </td>\n</tr>\n<tr>\n<td>\n    Disk Drives\n   </td>\n<td>\n    Mass storage\n   </td>\n</tr>\n<tr>\n<td>\n    Human Interface Devices (HID)\n   </td>\n<td>\n    HID\n   </td>\n</tr>\n<tr>\n<td>\n    Imaging Device (still image)\n   </td>\n<td>\n    Still image capture\n   </td>\n</tr>\n<tr>\n<td>\n    Keyboard\n   </td>\n<td>\n    HID\n   </td>\n</tr>\n<tr>\n<td>\n    Modem\n   </td>\n<td>\n    Communications\n   </td>\n</tr>\n<tr>\n<td>\n    Mouse\n   </td>\n<td>\n    HID\n   </td>\n</tr>\n<tr>\n<td>\n    Printers\n   </td>\n<td>\n    Printer\n   </td>\n</tr>\n<tr>\n<td>\n    Smart Card Readers\n   </td>\n<td>\n    Chip/smart card interface\n   </td>\n</tr>\n<tr>\n<td>\n    Tape Drives\n   </td>\n<td>\n    Mass storage\n   </td>\n</tr>\n<tr>\n<td>\n    USB\n   </td>\n<td>\n    Host controllers, hubs, and vendor-specific functions\n   </td>\n</tr>\n</tbody>\n</table>\n<p>\n Each device setup class encompasses USB devices that belong to the corresponding class. For example, the\n <strong>\n  Disk Drives\n </strong>\n class includes all mass storage devices like USB drives, while\n <strong>\n  Human Interface Devices (HID)\n </strong>\n includes devices like keyboards, mice, and other input devices.\n</p>\n<h4>\n Summary\n</h4>\n<p>\n In summary,\n <strong>\n  device interface GUIDs\n </strong>\n and\n <strong>\n  device setup GUIDs\n </strong>\n are essential for managing and communicating with USB devices. The device setup GUIDs help in categorizing devices during installation and configuration, while the device interface GUIDs allow applications to interface directly with the drivers of connected devices. Using these GUIDs, applications can easily detect, manage, and interact with USB devices across various classes.\n</p>\n"}, "Page 275": {"response": "<h3>\n Device Interface GUIDs vs. Symbolic Links\n</h3>\n<p>\n In USB communication,\n <strong>\n  device interface GUIDs\n </strong>\n and\n <strong>\n  symbolic links\n </strong>\n are two methods that enable applications to interact with devices, but they function in different ways.\n</p>\n<h4>\n Device Interface GUIDs\n</h4>\n<p>\n Unlike\n <strong>\n  device setup GUIDs\n </strong>\n ,\n <strong>\n  device interface GUIDs\n </strong>\n are not stored in a single file. Instead, they are usually defined in a C header file or as a Visual Basic declaration within a driver package. These GUIDs are crucial for identifying and interacting with specific device interfaces that a driver supports.\n</p>\n<p>\n For example, for Human Interface Devices (HID), applications can retrieve the device interface GUID using the function\n <code>\n  HidD_GetHidGuid\n </code>\n . This GUID allows applications to interact with the HID device through its specific interface, facilitating communication like reading inputs from a keyboard or mouse.\n</p>\n<p>\n However,\n <strong>\n  not all devices\n </strong>\n need to use device interface GUIDs. Some devices, like mass-storage devices and printers, can be accessed by applications through the standard file system or printing functions. These devices do not require the use of GUIDs for basic interaction. Additionally, custom drivers can define their own application programming interfaces (APIs) for interacting with the devices, bypassing the need for GUIDs entirely.\n</p>\n<h4>\n Symbolic Links for Device Access\n</h4>\n<p>\n Older device drivers often use\n <strong>\n  symbolic links\n </strong>\n to represent each device they control. For instance, the first device connected may be referred to as\n <code>\n  \\\\.\\mydevice0\n </code>\n , the second as\n <code>\n  \\\\.\\mydevice1\n </code>\n , and so on, depending on how many devices are connected. Applications can access these devices using these symbolic links, rather than relying on device interface GUIDs.\n</p>\n<p>\n In summary, while\n <strong>\n  device interface GUIDs\n </strong>\n are necessary for identifying and communicating with certain devices, especially those with specific interfaces like HID devices, some devices can be accessed more simply using standard system methods or symbolic links without requiring a GUID.\n</p>\n"}, "Page 276": {"response": "<h3>\n Matching a Driver to a Device\n</h3>\n<p>\n When a new USB device is connected to a system, the operating system must determine the appropriate driver for that device. This process is managed by Windows, which uses\n <strong>\n  INF files\n </strong>\n to select the correct driver. Additionally, the\n <strong>\n  Device Manager\n </strong>\n and the\n <strong>\n  system registry\n </strong>\n play key roles in managing devices and their associated drivers.\n</p>\n<h4>\n Using the Device Manager\n</h4>\n<p>\n Windows'\n <strong>\n  Device Manager\n </strong>\n is a tool that shows all installed devices on the system. It allows users to interact with these devices, including options to enable or disable devices, uninstall them, or update/change their assigned drivers.\n</p>\n<p>\n For developers, the Device Manager is particularly useful for:\n</p>\n<ul>\n<li>\n  Verifying if the correct driver is assigned to a device.\n </li>\n<li>\n  Confirming that the driver is installed properly.\n </li>\n<li>\n  Forcing Windows to forget its knowledge about a device and allowing it to re-enumerate or start fresh in terms of device recognition and driver assignment.\n </li>\n</ul>\n<p>\n By using the Device Manager, developers can easily troubleshoot driver-related issues and ensure the correct driver is being used for each device.\n</p>\n"}, "Page 277": {"response": "<h3>\n Viewing Devices in Device Manager\n</h3>\n<p>\n To access the\n <strong>\n  Device Manager\n </strong>\n in\n <strong>\n  Windows XP\n </strong>\n , there are several methods:\n</p>\n<ol>\n<li>\n  Right-click\n  <strong>\n   My Computer\n  </strong>\n  , select\n  <strong>\n   Manage\n  </strong>\n  , and then choose\n  <strong>\n   Device Manager\n  </strong>\n  from the\n  <strong>\n   Computer Management\n  </strong>\n  pane.\n </li>\n<li>\n  Alternatively, go to\n  <strong>\n   Start &gt; Settings &gt; Control Panel &gt; System &gt; Hardware &gt; Device Manager\n  </strong>\n  .\n </li>\n<li>\n  For quicker access, you can create a shortcut to the\n  <strong>\n   devmgmt.msc\n  </strong>\n  file located in\n  <strong>\n   Windows\\System32\n  </strong>\n  .\n </li>\n</ol>\n<p>\n In\n <strong>\n  Device Manager\n </strong>\n , the\n <strong>\n  View\n </strong>\n menu offers four options to organize device information:\n</p>\n<ul>\n<li>\n  Devices by\n  <strong>\n   Type\n  </strong>\n</li>\n<li>\n  Devices by\n  <strong>\n   Connection\n  </strong>\n</li>\n<li>\n  Resources by\n  <strong>\n   Type\n  </strong>\n</li>\n<li>\n  Resources by\n  <strong>\n   Connection\n  </strong>\n</li>\n</ul>\n<p>\n<strong>\n  Viewing devices by connection\n </strong>\n is particularly useful because it visually maps out the physical connections from each host controller and root hub, through any additional hubs, and all the way to the attached devices. This view helps you quickly identify which devices are connected to which hubs and controllers, as shown in\n <strong>\n  Figure 9-1\n </strong>\n .\n</p>\n"}, "Page 278": {"response": "<h3>\n Viewing Devices by Type and Connection in Device Manager\n</h3>\n<p>\n To view detailed information about a device in\n <strong>\n  Device Manager\n </strong>\n , including its driver and any operating system issues, right-click the device's listing and select\n <strong>\n  Properties\n </strong>\n . This will bring up the device's\n <strong>\n  Properties screen\n </strong>\n , where you can see the assigned driver and any potential problems, as shown in\n <strong>\n  Figure 9-2\n </strong>\n .\n</p>\n<p>\n When viewing devices\n <strong>\n  by type\n </strong>\n , devices are grouped based on their function, with minimal consideration of the hardware interface. The device categories are determined by the\n <strong>\n  Class key(s)\n </strong>\n in the system registry. Many devices fit into standard categories like\n <strong>\n  Disk Drives\n </strong>\n ,\n <strong>\n  Keyboards\n </strong>\n , and\n <strong>\n  Modems\n </strong>\n . Some devices can appear in multiple categories. For example, a keyboard might show up both under\n <strong>\n  Human Interface Devices (HID)\n </strong>\n and\n <strong>\n  Keyboards\n </strong>\n .\n</p>\n<p>\n The\n <strong>\n  USB category\n </strong>\n includes\n <strong>\n  host controllers\n </strong>\n ,\n <strong>\n  hubs\n </strong>\n , and some other devices. Devices using a vendor-specific driver might have their own unique category or fall under the\n <strong>\n  USB\n </strong>\n category. This type of categorization can help you quickly understand which devices belong to which groups, as shown in\n <strong>\n  Figure 9-3\n </strong>\n .\n</p>\n"}, "Page 279": {"response": "<h3>\n Viewing Device Resources and Status in Device Manager\n</h3>\n<p>\n In\n <strong>\n  Device Manager\n </strong>\n , you can choose to view resources either by\n <strong>\n  connection\n </strong>\n or by\n <strong>\n  type\n </strong>\n . Viewing by connection will show the memory and I/O addresses, as well as interrupt request (IRQ) lines assigned to each\n <strong>\n  host controller\n </strong>\n . However, this level of detail is generally not necessary when developing\n <strong>\n  USB devices\n </strong>\n ,\n <strong>\n  drivers\n </strong>\n , or\n <strong>\n  applications\n </strong>\n .\n</p>\n<p>\n If there\u2019s an issue with a device, an\n <strong>\n  exclamation point\n </strong>\n over its icon indicates that the host had trouble communicating with the device or locating a suitable driver. An\n <strong>\n  X\n </strong>\n over the icon means the device is disabled, potentially by the user.\n</p>\n<p>\n By default, Device Manager only displays currently connected USB devices. If you want to view devices that have been removed but still have their drivers installed, you can enable this feature by setting a system environment variable:\n <br/>\n<code>\n  DEVMGR_SHOW_NONPRESENT_DEVICES=1\n </code>\n<br/>\n To set this, go to\n <strong>\n  Control Panel\n </strong>\n &gt;\n <strong>\n  System\n </strong>\n &gt;\n <strong>\n  Advanced\n </strong>\n &gt;\n <strong>\n  Environment Variables\n </strong>\n , and add the variable name and value.\n</p>\n"}, "Page 281": {"response": "<h3>\n Understanding the Windows Registry and USB Device Information\n</h3>\n<p>\n<strong>\n  Registry Overview and Importance\n </strong>\n<br/>\n The Windows registry is a crucial part of the system, storing information about hardware and software. It is organized in a tree structure, where each node represents a registry key. These keys can have values and additional subkeys, forming a hierarchical organization. The registry is so vital that Windows keeps backup copies to restore functionality if the current copy is damaged. While editing the registry is risky and should be avoided unless absolutely necessary, simply viewing the registry is safe. If changes do occur, the System Restore utility can revert the registry to a previous state.\n</p>\n<p>\n<strong>\n  Registry Structure and Keys\n </strong>\n<br/>\n The primary data for hardware and software is stored under the\n <code>\n  HKEY_LOCAL_MACHINE\n </code>\n key. USB device information, in particular, is found under several subkeys, which include:\n</p>\n<ul>\n<li>\n<strong>\n   Hardware Key\n  </strong>\n</li>\n<li>\n<strong>\n   Class Key\n  </strong>\n</li>\n<li>\n<strong>\n   Driver Key\n  </strong>\n</li>\n<li>\n<strong>\n   Service Key\n  </strong>\n</li>\n</ul>\n<p>\n Each of these keys plays a role in organizing information about connected devices, including USB devices.\n</p>\n<p>\n<strong>\n  The Hardware Key (Instance Key or Device Key)\n </strong>\n<br/>\n The hardware key stores data about individual instances of devices. This information is located under the\n <code>\n  Enum\n </code>\n key at the following path:\n <br/>\n<code>\n  HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Enum\n </code>\n</p>\n<p>\n Within the\n <code>\n  Enum\n </code>\n key, you will find a USB subkey. Each subkey under the USB key corresponds to a USB device and contains critical information, such as the device's Vendor ID and Product ID. These identifiers are essential for recognizing and managing USB devices within the system.\n</p>\n"}, "Page 280": {"response": "<h3>\n Matching a Driver to a Device\n</h3>\n<p>\n<strong>\n  Device Manager and Hidden Devices\n </strong>\n<br/>\n In Device Manager, you can view hidden devices by selecting \"Show Hidden Devices\" under the \"View\" menu. Occasionally, you may need to reboot your system after setting an environment variable for proper device detection.\n</p>\n<p>\n<strong>\n  Property Pages for Devices\n </strong>\n<br/>\n Each device listed in Device Manager has Property Pages that give additional details and allow you to control the device and its driver. Double-clicking a device\u2019s listing opens the Property Pages where you can:\n</p>\n<ul>\n<li>\n  Enable or disable the device.\n </li>\n<li>\n  View, update, roll back, or uninstall the driver.\nA \"Details\" page provides further specifics, such as system IDs, associated filter drivers, coinstallers, and power capabilities.\n </li>\n</ul>\n<p>\n<strong>\n  Device Information in the Registry\n </strong>\n<br/>\n The Windows system registry is a critical database storing essential information about both hardware and software. It maintains data about all devices, whether or not they are currently connected. When a new device is detected, Windows stores related information in the registry.\n</p>\n<p>\n For USB devices, registry data is derived from both the bus drivers (which get data directly from the devices) and the INF file chosen by the OS to assign a driver. You can view and edit the registry using the \u201cregedit\u201d utility, accessible through the \"Run\" menu. However, modifying the registry is generally not recommended unless necessary, as it can lead to system issues.\n</p>\n<p>\n<strong>\n  Backup and Importance of the Registry\n </strong>\n<br/>\n The Windows registry is so crucial that multiple backup copies are automatically maintained to protect the system in case of corruption or failure.\n</p>\n"}, "Page 282": {"response": "<h3>\n Understanding Hardware and Class Keys in the Registry\n</h3>\n<p>\n<strong>\n  Hardware Key and Device Instance\n </strong>\n<br/>\n Each USB device is assigned a hardware key that stores information about its specific instance, including its Vendor ID and Product ID. For example, a device with Vendor ID\n <code>\n  0925h\n </code>\n and Product ID\n <code>\n  1234h\n </code>\n would have its entry under the corresponding subkey in the registry. If a device does not have a USB serial number, it will receive a new hardware key each time it is connected to a different port. However, if a different device with identical descriptors is plugged into the same port, no new hardware key is created, as the system cannot differentiate between the two.\n</p>\n<p>\n For devices with USB serial numbers, the system generates a single hardware key for the physical device, regardless of which port it is connected to. Additionally, some USB devices may have multiple keys if they are associated with other enumerators like HID, USBPRINT, or USBSTOR. For instance, a UPS back-up device with an HID interface might have keys under both the\n <code>\n  Enum\\USB\n </code>\n branch (for the HidUsb service) and the\n <code>\n  Enum\\HID\n </code>\n branch (for the HidBatt service).\n</p>\n<p>\n<strong>\n  Class Key and Device Setup Class\n </strong>\n<br/>\n The class key in the registry holds information about the device setup class to which a device belongs. These keys are located under:\n <br/>\n<code>\n  HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Class\n </code>\n</p>\n<p>\n Each class key is named after the device setup GUID (Globally Unique Identifier), which also appears in the hardware key under the\n <code>\n  ClassGUID\n </code>\n entry. For example, the registry will store the class information for HID devices under a GUID-specific class key. The class key includes:\n</p>\n<ul>\n<li>\n  A friendly name for the device setup class.\n </li>\n<li>\n  The class name from the header file that defines the GUID.\n </li>\n<li>\n  An index value indicating which icon to display in Device Manager and other interfaces that show device setup information.\n </li>\n</ul>\n<p>\n Applications can access the mini-icon index for a class by using the\n <code>\n  SetupDiGetClassBitmapIndex\n </code>\n function. Additionally, a vendor-specific installer or co-installer can provide a unique icon for a particular device class.\n</p>\n"}, "Page 283": {"response": "<h3>\n Understanding Class and Driver Keys in the Registry\n</h3>\n<p>\n<strong>\n  Class Key Optional Entries\n </strong>\n<br/>\n The class key can contain optional entries that influence the device installation process and user experience:\n</p>\n<ul>\n<li>\n<strong>\n   NoInstallClass\n  </strong>\n  : If this entry is present and non-zero, the system will prevent manual installation of devices in that class.\n </li>\n<li>\n<strong>\n   SilentInstall\n  </strong>\n  : If non-zero, the Plug and Play manager automatically installs devices in the class without showing dialog boxes or requiring user input.\n </li>\n<li>\n<strong>\n   NoDisplayClass\n  </strong>\n  : If present and non-zero, devices in that class will not be shown in Device Manager.\n </li>\n<li>\n<strong>\n   UpperFilters and LowerFilters\n  </strong>\n  : These entries specify filter drivers that apply to all devices within the class, allowing for additional driver functionality.\n </li>\n</ul>\n<p>\n<strong>\n  Driver Key and Device Driver Information\n </strong>\n<br/>\n Each device within a class has a driver key, often referred to as the software key. The hardware key for a device includes a\n <strong>\n  Driver\n </strong>\n entry that points to the device\u2019s setup GUID, matching the class key and device instance number. The driver key contains:\n</p>\n<ul>\n<li>\n  The\n  <strong>\n   INF file name\n  </strong>\n  , which details the associated driver files for the device.\n </li>\n</ul>\n<p>\n This setup allows Windows to correctly link devices to their respective drivers during installation. The registry structure ensures efficient management of device and driver relationships.\n</p>\n"}, "Page 284": {"response": "<h3>\n USB Device Hardware Key Entries\n</h3>\n<p>\n<strong>\n  Table 9-1: Key Entries in a USB Device\u2019s Hardware Key\n </strong>\n<br/>\n Each USB device's hardware key in the registry contains various entries that store important details about the device. Here\u2019s a breakdown of these entries:\n</p>\n<ul>\n<li>\n<strong>\n   Class\n  </strong>\n  : The name of the device\u2019s setup class, found in the INF file (\n  <code>\n   devguid.h\n  </code>\n  ).\n </li>\n<li>\n<strong>\n   ClassGUID\n  </strong>\n  : The GUID (Globally Unique Identifier) of the device\u2019s setup class, also found in the INF file (\n  <code>\n   devguid.h\n  </code>\n  ).\n </li>\n<li>\n<strong>\n   DeviceDesc\n  </strong>\n  : A description of the device, taken from the INF file, specifically the \"Models\" section, where the device description is listed.\n </li>\n<li>\n<strong>\n   HardwareID\n  </strong>\n  : A string that identifies the device, including its Vendor ID and Product ID, derived from the device descriptor.\n </li>\n<li>\n<strong>\n   CompatibleIDs\n  </strong>\n  : A string (or strings) that define the device\u2019s class, subclass, and protocol, pulled from the device and interface descriptors.\n </li>\n<li>\n<strong>\n   Mfg\n  </strong>\n  : The device manufacturer\u2019s name, provided in the INF file under the \"Manufacturer\" section.\n </li>\n<li>\n<strong>\n   Driver\n  </strong>\n  : The name of the driver key for the device, found in the system registry under\n  <code>\n   CurrentControlSet\\Control\\Class\n  </code>\n  .\n </li>\n<li>\n<strong>\n   Location Information\n  </strong>\n  : A string descriptor or \"USB Device\" identifier, sourced from the bus driver or a string descriptor.\n </li>\n<li>\n<strong>\n   Service\n  </strong>\n  : The name of the device\u2019s Service key, found in the system registry under\n  <code>\n   HKLM\\System\\CurrentControlSet\\Services\n  </code>\n  .\n </li>\n</ul>\n<p>\n These entries collectively provide detailed information about the device, its setup class, identifiers, manufacturer, and driver assignments.\n</p>\n"}, "Page 285": {"response": "<h3>\n Service Key and INF Files for USB Devices\n</h3>\n<p>\n<strong>\n  Service Key\n </strong>\n<br/>\n The service key in the registry stores information about a device\u2019s driver files, including where they are located and how they should be loaded. These service keys are found in the following registry path:\n <br/>\n<code>\n  HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\n </code>\n</p>\n<p>\n Each host controller type, hub, and device class (e.g., storage, printers, HID devices) has its own service key. For example, the\n <code>\n  HidUsb\n </code>\n service key stores information specific to the USB HID devices. These keys help the system load the appropriate driver and manage device functionality.\n</p>\n<p>\n<strong>\n  Inside INF Files\n </strong>\n<br/>\n An INF (Information) file is a text file that provides details about devices in a device setup class, including which drivers to use and the registry information to store. INF files are essential for device installation, telling Windows how to configure and manage a device. Windows comes with default INF files for built-in drivers, stored in the\n <code>\n  %SystemRoot%\\inf\n </code>\n folder, and any new INF files for added devices are copied to this location as well. This folder is hidden by default, but you can view it by adjusting Folder Options in Windows Explorer.\n</p>\n<p>\n<strong>\n  Table 9-2: Driver Key Entries in INF Files\n </strong>\n<br/>\n The driver key contains several entries that specify important details about the driver assigned to a device:\n</p>\n<ul>\n<li>\n<strong>\n   DriverDate\n  </strong>\n  : The date of the driver file, listed in the INF file under the\n  <code>\n   DriverVer\n  </code>\n  directive.\n </li>\n<li>\n<strong>\n   DriverDesc\n  </strong>\n  : A description of the driver, found in the INF file.\n </li>\n<li>\n<strong>\n   DriverVer\n  </strong>\n  : The version of the driver, also listed under\n  <code>\n   DriverVer\n  </code>\n  in the INF file.\n </li>\n<li>\n<strong>\n   InfPath\n  </strong>\n  : The name of the INF file used for the driver.\n </li>\n<li>\n<strong>\n   InfSection\n  </strong>\n  : The name of the INF file\u2019s\n  <code>\n   DDInstall\n  </code>\n  section, specifying installation details.\n </li>\n<li>\n<strong>\n   InfSectionExt\n  </strong>\n  : A \u201cdecorated\u201d extension used in the INF file (e.g.,\n  <code>\n   .NT\n  </code>\n  ).\n </li>\n<li>\n<strong>\n   MatchingDeviceID\n  </strong>\n  : The hardware or compatible ID that is used to match the driver to the device, derived from the device descriptor and the INF file.\n </li>\n<li>\n<strong>\n   ProviderName\n  </strong>\n  : The name of the driver\u2019s provider, found in the INF file.\n </li>\n</ul>\n<p>\n These entries help the system identify and properly configure the correct driver for each device, ensuring seamless operation and compatibility.\n</p>\n"}, "Page 286": {"response": "<h3>\n INF Files and Driver Matching for USB Devices\n</h3>\n<p>\n<strong>\n  Viewing INF Files\n </strong>\n<br/>\n INF files are stored in the\n <code>\n  %SystemRoot%\\inf\n </code>\n folder, which is hidden by default. To view these files, go to Folder Options in Windows Explorer, select the \"View\" tab, and enable \"Show hidden files and folders.\" It's important not to check \"Hide file extensions for known file types\" to see the full file names.\n</p>\n<p>\n<strong>\n  Driver Matching Process\n </strong>\n<br/>\n When a USB device is first connected, Windows retrieves its descriptors and tries to match the information from these descriptors with data in the system\u2019s INF files. This process helps Windows determine which driver to load for the device.\n</p>\n<p>\n This section doesn't cover all the details of INF file creation but instead uses an example to illustrate the kind of information these files contain. For more in-depth information, the Windows DDK documentation provides comprehensive details. Additionally, reviewing the INF files included with Windows can give insight into their structure and contents.\n</p>\n<p>\n<strong>\n  Example INF File\n </strong>\n<br/>\n An example of an INF file for the Ellisys USB Explorer protocol analyzer is shown in Listing 9-1. This device uses a vendor-specific driver and interfaces with a PC running analyzer software. The INF file is compatible with Windows 98, Windows Me, Windows 2000, and Windows XP. This example demonstrates how INF files specify driver installation details and match the correct driver to a device based on its descriptors.\n</p>\n"}, "Page 287": {"response": "<h3>\n Example INF File for Ellisys USB Explorer 200 Protocol Analyzer\n</h3>\n<p>\n<strong>\n  INF File Structure\n </strong>\n<br/>\n The example INF file for the Ellisys USB Explorer 200 protocol analyzer outlines how the device\u2019s driver installation is handled. The file is formatted as follows:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    [Version] Section\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<code>\n     Signature=\"$CHICAGO$\"\n    </code>\n    : This defines the signature for the Windows operating system version.\n   </li>\n<li>\n<code>\n     DriverVer=01/29/2004,2.0.1600.0\n    </code>\n    : Specifies the driver version and date.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    [ClassInstall] Section\n   </strong>\n   :\n   <br/>\n   This section includes the\n   <code>\n    AddReg=ClassAddReg\n   </code>\n   directive, which adds registry entries related to the class installation.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    [ClassInstall32] Section\n   </strong>\n   :\n   <br/>\n   Similar to the\n   <code>\n    [ClassInstall]\n   </code>\n   section, but specifically for 32-bit systems, with\n   <code>\n    AddReg=ClassAddReg\n   </code>\n   to add relevant registry entries.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    [ClassAddReg] Section\n   </strong>\n   :\n   <br/>\n   Contains registry modifications that associate the class with a friendly name and icon:\n  </p>\n<ul>\n<li>\n<code>\n     HKR,,,,\"%ClassName%\"\n    </code>\n    : Adds the class name.\n   </li>\n<li>\n<code>\n     HKR,,Icon,,-20\n    </code>\n    : Sets the icon for the class.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    [Manufacturer] Section\n   </strong>\n   :\n   <br/>\n   Defines the manufacturer and links it to the\n   <code>\n    [Models]\n   </code>\n   section.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    [DestinationDirs] Section\n   </strong>\n   :\n   <br/>\n   Specifies where the driver files will be placed, in this case,\n   <code>\n    System32\\Drivers\n   </code>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    [SourceDisksNames] Section\n   </strong>\n   :\n   <br/>\n   Defines the source disk for the driver files with the variable\n   <code>\n    %SourceDisk%\n   </code>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    [SourceDisksFiles] Section\n   </strong>\n   :\n   <br/>\n   Lists the driver file (\n   <code>\n    ellex200.sys\n   </code>\n   ) and its location.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    [Models] Section\n   </strong>\n   :\n   <br/>\n   Describes the model of the device, including its device descriptor (\n   <code>\n    USB\\VID_0ABA&amp;PID_8002\n   </code>\n   ), and points to the\n   <code>\n    [Install]\n   </code>\n   section for installation details.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    [Install] Section\n   </strong>\n   :\n   <br/>\n   Directs the system to copy the necessary files and add registry entries for installation.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    [Install.CopyFiles] Section\n   </strong>\n   :\n   <br/>\n   Specifies the driver file (\n   <code>\n    ellex200.sys\n   </code>\n   ) to be copied to the destination directory.\n  </p>\n</li>\n</ul>\n<p>\n This INF file example demonstrates how a vendor-specific driver is configured and associated with a device. It covers driver versioning, class setup, file copying, and registry entries needed for the device to function correctly.\n</p>\n"}, "Page 288": {"response": "<h3>\n INF File Syntax and Structure\n</h3>\n<p>\n<strong>\n  INF File Syntax Rules\n </strong>\n<br/>\n INF files follow a specific syntax to ensure proper configuration and installation of device drivers. The syntax is organized into sections, each containing relevant items. Here are some key syntax guidelines:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Sections and Section Names\n   </strong>\n   :\n   <br/>\n   Each section is marked with square brackets\n   <code>\n    [ ]\n   </code>\n   . Common sections like\n   <code>\n    [Version]\n   </code>\n   and\n   <code>\n    [Manufacturer]\n   </code>\n   are standard and found in every INF file. Other sections correspond to values referenced within the file. For example, if the\n   <code>\n    [Manufacturer]\n   </code>\n   section lists \"Lakeview,\" there should be a corresponding\n   <code>\n    [Lakeview]\n   </code>\n   section detailing the manufacturer's specific device models.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Section Contents\n   </strong>\n   :\n   <br/>\n   Each section includes one or more items. These items define how the system handles the device installation, driver assignment, and configuration.\n  </p>\n</li>\n</ul>\n<p>\n<strong>\n  Example Sections in the INF File\n </strong>\n<br/>\n Here\u2019s a breakdown of some specific sections from the example INF file:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    [Install.AddReg] Section\n   </strong>\n   :\n   <br/>\n   This section adds registry keys to configure the device for installation:\n  </p>\n<ul>\n<li>\n<code>\n     HKR,,DevLoader,,*ntkern\n    </code>\n    : Specifies the device loader.\n   </li>\n<li>\n<code>\n     HKR,,NTMPDriver,,ellex200.sys\n    </code>\n    : Specifies the driver file for Windows.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    [Install.NT] Section\n   </strong>\n   :\n   <br/>\n   This section is used for the installation of the device on NT-based systems (Windows 2000, XP, etc.):\n  </p>\n<ul>\n<li>\n<code>\n     CopyFiles=Install.CopyFiles\n    </code>\n    : Directs the system to copy files as specified in the\n    <code>\n     [Install.CopyFiles]\n    </code>\n    section.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    [Install.NT.Services] Section\n   </strong>\n   :\n   <br/>\n   This section adds a service for the device:\n  </p>\n<ul>\n<li>\n<code>\n     AddService=ellex200,2,Install.NT.AddService\n    </code>\n    : Defines the service for the driver.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    [Install.NT.AddService] Section\n   </strong>\n   :\n   <br/>\n   Specifies details about the service, including:\n  </p>\n<ul>\n<li>\n<code>\n     DisplayName=%SvcDesc%\n    </code>\n    : The name of the service displayed in the system.\n   </li>\n<li>\n<code>\n     ServiceType=1\n    </code>\n    : Defines the service type.\n   </li>\n<li>\n<code>\n     StartType=3\n    </code>\n    : The service's startup type (manual).\n   </li>\n<li>\n<code>\n     ErrorControl=1\n    </code>\n    : Error control level.\n   </li>\n<li>\n<code>\n     ServiceBinary=%10%\\system32\\drivers\\ellex200.sys\n    </code>\n    : Path to the driver binary file.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    [Strings] Section\n   </strong>\n   :\n   <br/>\n   Contains string values used throughout the INF file. This section includes definitions for the class name, provider, manufacturer, and descriptions for both the device and the driver.\n  </p>\n</li>\n</ul>\n<p>\n This structure ensures the correct configuration of device drivers, adding services and files to the appropriate directories and registry entries during installation. Each section in the INF file has a specific purpose, from driver installation to system service configuration.\n</p>\n"}, "Page 289": {"response": "<h3>\n INF File Syntax and Structure (Continued)\n</h3>\n<p>\n<strong>\n  INF File Syntax Rules\n </strong>\n<br/>\n INF files follow specific syntax rules to ensure proper driver configuration and installation:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Section Organization\n   </strong>\n   :\n   <br/>\n   Sections in an INF file are enclosed in square brackets\n   <code>\n    [ ]\n   </code>\n   . While the order of sections can vary, the order of items within a section can be critical.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Comments\n   </strong>\n   :\n   <br/>\n   Lines starting with a semicolon (\n   <code>\n    ;\n   </code>\n   ) are comments and are ignored during processing.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Line Continuation\n   </strong>\n   :\n   <br/>\n   A backslash (\n   <code>\n    \\\n   </code>\n   ) at the end of a line allows that line to continue onto the next line. This is useful for breaking long lines of text into multiple lines for clarity, unless the backslash is enclosed in quotes.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    String References\n   </strong>\n   :\n   <br/>\n   Text enclosed in percent symbols (\n   <code>\n    %\n   </code>\n   ) refers to a string defined elsewhere in the INF file. For example:\n  </p>\n<ul>\n<li>\n<code>\n     Provider=%Provider%\n    </code>\n    : This uses a string value defined in the\n    <code>\n     [Strings]\n    </code>\n    section where\n    <code>\n     Provider=\"Ellisys\"\n    </code>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Setting Entry Values\n   </strong>\n   :\n   <br/>\n   Some items directly set the value of an entry, such as:\n  </p>\n<ul>\n<li>\n<code>\n     Class=EllisysProtocolAnalyzers\n    </code>\n    : This assigns the device to the\n    <code>\n     EllisysProtocolAnalyzers\n    </code>\n    class.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Registry Information\n   </strong>\n   :\n   <br/>\n   Some items store data in the system registry. For example:\n  </p>\n<ul>\n<li>\n<code>\n     HKR,,NTMPDriver,,ellex200.sys\n    </code>\n    : This stores the driver file name (\n    <code>\n     ellex200.sys\n    </code>\n    ) in the registry.\n   </li>\n</ul>\n</li>\n</ul>\n<h3>\n Sections in an INF File\n</h3>\n<p>\n Each section in an INF file has a specific role, such as helping Windows find a matching driver, load the driver, and store relevant device information in the registry. Below is a breakdown of the sections in the example INF file:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Copyright Comment\n   </strong>\n   :\n   <br/>\n   The INF file must contain a comment with the word \"copyright\" to pass validation tools like the\n   <code>\n    Chkinf\n   </code>\n   utility. An example copyright comment might look like this:\n  </p>\n<ul>\n<li>\n<code>\n     ; Copyright (C) 1999-2004 Ellisys. All rights reserved.\n    </code>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Version Section\n   </strong>\n   :\n   <br/>\n   The\n   <code>\n    [Version]\n   </code>\n   section is mandatory and serves as the header of the INF file. It contains essential metadata about the file, including the version of the driver. For example:\n  </p>\n<ul>\n<li>\n<code>\n     DriverVer=01/29/2004,2.0.1600.0\n    </code>\n    : Specifies the driver\u2019s version and release date.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n These rules and sections ensure that the INF file correctly associates a device with its driver, loads the appropriate files, and updates the system registry as needed.\n</p>\n"}, "Page 290": {"response": "<h3>\n [Version] Section in INF File\n</h3>\n<p>\n The\n <strong>\n  [Version]\n </strong>\n section defines important metadata about the driver and INF file. It helps Windows identify which operating systems the INF file supports and specifies key information about the driver.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Signature Directive\n   </strong>\n   :\n   <br/>\n   The\n   <code>\n    Signature\n   </code>\n   field specifies the intended operating system(s) for the INF file. Possible values include\n   <code>\n    $Chicago$\n   </code>\n   ,\n   <code>\n    $Windows 95$\n   </code>\n   , or\n   <code>\n    $Windows NT$\n   </code>\n   . The term \"Chicago\" refers to Windows 95 during its development, and it is still valid for later versions of Windows. The value is case-insensitive, meaning it can be written in any case.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    DriverVer Directive\n   </strong>\n   :\n   <br/>\n   The\n   <code>\n    DriverVer\n   </code>\n   field provides the version and date for the driver(s) specified in the INF file. For instance,\n   <code>\n    DriverVer=01/29/2004,2.0.1600.0\n   </code>\n   indicates that the driver version is 2.0.1600.0, released on January 29, 2004.\n  </p>\n<ul>\n<li>\n    Windows generally selects the most recent driver when multiple options are available.\n   </li>\n<li>\n    For Windows 2000 and Windows XP, the\n    <code>\n     DriverVer\n    </code>\n    directive must be present in the\n    <code>\n     [Version]\n    </code>\n    section. For Windows 98 and Windows Me, it must be placed in the\n    <code>\n     DDInstall\n    </code>\n    sections instead of the\n    <code>\n     [Version]\n    </code>\n    section.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Provider Directive\n   </strong>\n   :\n   <br/>\n   The\n   <code>\n    Provider\n   </code>\n   field specifies the creator or manufacturer of the INF file. In this example,\n   <code>\n    %Provider%\n   </code>\n   is a placeholder string that is defined later in the file.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Class Directive\n   </strong>\n   :\n   <br/>\n   The\n   <code>\n    Class\n   </code>\n   directive defines the class of devices that will be installed using this INF file. For example,\n   <code>\n    Class=EllisysProtocolAnalyzers\n   </code>\n   specifies that this INF file is for devices in the \"EllisysProtocolAnalyzers\" class, which is vendor-specific.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    ClassGUID Directive\n   </strong>\n   :\n   <br/>\n   The\n   <code>\n    ClassGUID\n   </code>\n   field stores the device setup GUID (Globally Unique Identifier) in the device's registry Class key. This GUID can be vendor-specific or use a standard GUID for USB devices. The example uses a vendor-specific GUID (\n   <code>\n    {D8854594-A4EF-480e-B8D8-CBDDADB4F3B4}\n   </code>\n   ) for the Ellisys protocol analyzers.\n  </p>\n</li>\n</ul>\n<h3>\n ClassInstall32 Section\n</h3>\n<p>\n The\n <strong>\n  ClassInstall32\n </strong>\n section is responsible for installing a new device class in the system\u2019s registry under the Class section. This section is processed only if the device\u2019s class hasn\u2019t already been installed.\n</p>\n<ul>\n<li>\n  The\n  <strong>\n   ClassInstall32\n  </strong>\n  section typically includes registry modifications that associate the device with its class in the system, allowing Windows to recognize and properly configure the device based on its class type.\n </li>\n</ul>\n<p>\n This section ensures that the class for the device is properly registered in the system's registry, helping the operating system identify and configure the device appropriately when it is connected.\n</p>\n"}, "Page 291": {"response": "<h3>\n ClassInstall32 and Manufacturer Sections in INF Files\n</h3>\n<h4>\n ClassInstall32 Section\n</h4>\n<p>\n The\n <strong>\n  ClassInstall32\n </strong>\n section is used to install a device class in the system registry, but only if the device's class hasn't already been registered. It is particularly relevant for INF files associated with vendor-specific device setup classes.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Purpose\n   </strong>\n   :\n   <br/>\n   This section ensures that Windows recognizes and associates a device with the appropriate device class in the registry.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Example\n   </strong>\n   :\n   <br/>\n   The example ClassInstall32 section in the INF file includes the directive:\n  </p>\n  plaintext\n  Copy code\n  <code class=\"!whitespace-pre hljs language-plaintext\">\n   [ClassInstall32]\nAddreg=Class.AddReg\n  </code>\n<p>\n   This tells Windows to add the class description in the registry under the\n   <code>\n    Class.AddReg\n   </code>\n   section. The\n   <code>\n    AddReg\n   </code>\n   directive is responsible for storing the class information and adding a class description in the registry.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Class.AddReg Section\n   </strong>\n   :\n   <br/>\n   The\n   <code>\n    Class.AddReg\n   </code>\n   section defines what is added to the registry. Specifically, it includes the following:\n  </p>\n  plaintext\n  Copy code\n  <code class=\"!whitespace-pre hljs language-plaintext\">\n   [ClassAddReg]\nHKR,,,,\"%ClassName%\"\nHKR,,Icon,,-20\n  </code>\n<ul>\n<li>\n<code>\n     HKR\n    </code>\n    refers to\n    <strong>\n     HKEY_ROOT\n    </strong>\n    , the base registry key under which the data is stored.\n   </li>\n<li>\n<code>\n     %ClassName%\n    </code>\n    is a string that provides the name of the device class.\n   </li>\n<li>\n    The\n    <code>\n     Icon\n    </code>\n    directive assigns an icon to the device class. A\n    <strong>\n     negative value\n    </strong>\n    for the icon refers to an icon in Windows'\n    <code>\n     setupapi.dll\n    </code>\n    , while a\n    <strong>\n     positive value\n    </strong>\n    indicates that the icon should be extracted from a class installer DLL or property page DLL.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Icon Value\n   </strong>\n   :\n   <br/>\n   A\n   <strong>\n    negative icon value (-20)\n   </strong>\n   typically links to an icon from Windows' system libraries. A\n   <strong>\n    positive value\n   </strong>\n   points to an icon defined by the class installer or a DLL related to the device.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Section for Older Windows Versions\n   </strong>\n   :\n   <br/>\n   An additional\n   <code>\n    [ClassInstall]\n   </code>\n   section exists for Windows 98 systems, although its details are not specified here.\n  </p>\n</li>\n</ul>\n<h4>\n Manufacturer Section\n</h4>\n<p>\n The\n <strong>\n  Manufacturer\n </strong>\n section identifies the manufacturers of the devices and associates them with specific installation instructions. Every INF file must include this section.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Purpose\n   </strong>\n   :\n   <br/>\n   This section specifies which devices belong to which manufacturers and links to an install section that handles the setup for these devices.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Example\n   </strong>\n   :\n  </p>\n  plaintext\n  Copy code\n  <code class=\"!whitespace-pre hljs language-plaintext\">\n   [Manufacturer]\n%Manufacturer%=Models\n  </code>\n<p>\n   In this example:\n  </p>\n<ul>\n<li>\n<code>\n     %Manufacturer%\n    </code>\n    is a string that defines the name of the manufacturer, which is specified later in the file.\n   </li>\n<li>\n<code>\n     Models\n    </code>\n    is a generic section name that identifies the manufacturer's devices. It is used to group devices under the same manufacturer for installation purposes.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Naming Flexibility\n   </strong>\n   :\n   <br/>\n   The name\n   <code>\n    Models\n   </code>\n   is a placeholder. In practice, it can be more specific (e.g.,\n   <code>\n    CypressMice\n   </code>\n   for a specific line of mice from Cypress). If there are multiple manufacturers or device groups, each will need a unique section name under the\n   <code>\n    Manufacturer\n   </code>\n   section.\n  </p>\n</li>\n</ul>\n<p>\n In summary, the\n <strong>\n  ClassInstall32\n </strong>\n section helps register and display the device class in the registry, while the\n <strong>\n  Manufacturer\n </strong>\n section organizes devices by their respective manufacturers and links them to the installation processes.\n</p>\n"}, "Page 292": {"response": "<h3>\n DestinationDirs, SourceDisksNames, and Models Sections in INF Files\n</h3>\n<h4>\n DestinationDirs Section\n</h4>\n<p>\n The\n <strong>\n  DestinationDirs\n </strong>\n section in an INF file defines the directories where files should be copied during installation. It is used in conjunction with directives like\n <strong>\n  CopyFiles\n </strong>\n ,\n <strong>\n  RenFiles\n </strong>\n , and\n <strong>\n  DelFiles\n </strong>\n to specify the destination paths for these operations.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Purpose\n   </strong>\n   :\n   <br/>\n   This section ensures that files are placed in the correct location within the system.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Example\n   </strong>\n   :\n  </p>\n  plaintext\n  Copy code\n  <code class=\"!whitespace-pre hljs language-plaintext\">\n   [DestinationDirs]\nDefaultDestDir=10,System32\\Drivers\n  </code>\n<ul>\n<li>\n    The value\n    <code>\n     10\n    </code>\n    specifies the\n    <strong>\n     Windows directory\n    </strong>\n    , specifically the\n    <code>\n     System32\\Drivers\n    </code>\n    folder where driver files will be copied.\n   </li>\n<li>\n    Additional\n    <strong>\n     dirid values\n    </strong>\n    for other locations can be found in Windows DDK documentation, while older Windows 98 documentation uses the term\n    <strong>\n     LDID\n    </strong>\n    (Logical Disk Identifier).\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n SourceDisksNames Section\n</h4>\n<p>\n The\n <strong>\n  SourceDisksNames\n </strong>\n section provides the description of the installation disk(s) where setup files are located. It associates a disk number with the name and optional additional disk identifiers, such as volume label and serial number.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Purpose\n   </strong>\n   :\n   <br/>\n   This section identifies the installation media that the system should use to retrieve files.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Example\n   </strong>\n   :\n  </p>\n  plaintext\n  Copy code\n  <code class=\"!whitespace-pre hljs language-plaintext\">\n   [SourceDisksNames]\n1=%SourceDisk%,,,.\n  </code>\n<ul>\n<li>\n    The\n    <code>\n     1\n    </code>\n    refers to the first source disk.\n   </li>\n<li>\n<code>\n     %SourceDisk%\n    </code>\n    is a string that will be defined later in the file, providing the name of the disk or media.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n SourceDisksFiles Section\n</h4>\n<p>\n The\n <strong>\n  SourceDisksFiles\n </strong>\n section lists the specific files that need to be copied from the installation disk. This section ensures that the required driver files and other components are correctly identified and located during installation.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Purpose\n   </strong>\n   :\n   <br/>\n   This section specifies which files should be copied from the source media and where they are located.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Example\n   </strong>\n   :\n  </p>\n  plaintext\n  Copy code\n  <code class=\"!whitespace-pre hljs language-plaintext\">\n   [SourceDisksFiles]\nellex200.sys=1\n  </code>\n<ul>\n<li>\n    The\n    <code>\n     ellex200.sys\n    </code>\n    file is specified as being on disk number\n    <code>\n     1\n    </code>\n    , which corresponds to the first disk in the\n    <strong>\n     SourceDisksNames\n    </strong>\n    section.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Models Section\n</h4>\n<p>\n The\n <strong>\n  Models\n </strong>\n section in the INF file ties specific devices to their installation instructions and hardware IDs. It is referenced in the\n <strong>\n  Manufacturer\n </strong>\n section to associate a group of devices with installation instructions.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Purpose\n   </strong>\n   :\n   <br/>\n   This section identifies which device descriptions correspond to which\n   <strong>\n    DDInstall\n   </strong>\n   section and defines the hardware ID(s) for those devices.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Example\n   </strong>\n   :\n  </p>\n  plaintext\n  Copy code\n  <code class=\"!whitespace-pre hljs language-plaintext\">\n   [Models]\n%DeviceDesc%=Install,USB\\VID_0ABA&amp;PID_8001\n  </code>\n<ul>\n<li>\n<code>\n     %DeviceDesc%\n    </code>\n    is a string that describes the device (e.g., the device name or description).\n   </li>\n<li>\n<code>\n     Install\n    </code>\n    refers to the\n    <strong>\n     DDInstall\n    </strong>\n    section, which contains the actual installation instructions for this device.\n   </li>\n<li>\n<code>\n     USB\\VID_0ABA&amp;PID_8001\n    </code>\n    is the hardware ID, a unique identifier for the device based on its\n    <strong>\n     Vendor ID\n    </strong>\n    and\n    <strong>\n     Product ID\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Compatible IDs\n   </strong>\n   :\n   <br/>\n   After the hardware ID, you can specify\n   <strong>\n    compatible IDs\n   </strong>\n   . These alternative identifiers help Windows match the device with an appropriate driver. For example, a device might share certain characteristics with others and can thus use the same or similar drivers.\n  </p>\n</li>\n</ul>\n<p>\n In summary:\n</p>\n<ul>\n<li>\n<strong>\n   DestinationDirs\n  </strong>\n  specifies where installation files should be placed on the system.\n </li>\n<li>\n<strong>\n   SourceDisksNames\n  </strong>\n  and\n  <strong>\n   SourceDisksFiles\n  </strong>\n  identify the installation media and the specific files to be copied.\n </li>\n<li>\n<strong>\n   Models\n  </strong>\n  links device descriptions to their respective installation instructions and hardware IDs.\n </li>\n</ul>\n"}, "Page 293": {"response": "<h3>\n Install Sections in INF Files\n</h3>\n<h4>\n General Overview\n</h4>\n<p>\n The\n <strong>\n  Models\n </strong>\n section identifies the hardware associated with the device by listing its\n <strong>\n  hardware IDs\n </strong>\n and linking them to specific installation instructions. This ensures that Windows knows which driver to install when a device is connected. The\n <strong>\n  Install\n </strong>\n sections define the actual steps that need to be performed during device installation.\n</p>\n<h4>\n Models Section\n</h4>\n<ul>\n<li>\n  The\n  <strong>\n   Models\n  </strong>\n  section associates each device with an\n  <strong>\n   Install\n  </strong>\n  section and the device's hardware ID.\n </li>\n<li>\n<strong>\n   Hardware IDs\n  </strong>\n  are used to match devices to the correct driver.\n </li>\n</ul>\n<p>\n<strong>\n  Example\n </strong>\n :\n</p>\nplaintext\nCopy code\n<code class=\"!whitespace-pre hljs language-plaintext\">\n [Models]\n%DeviceDesc%=Install,USB\\VID_0ABA&amp;PID_8001\n</code>\n<p>\n In this example:\n</p>\n<ul>\n<li>\n<code>\n   %DeviceDesc%\n  </code>\n  is a placeholder for the actual device description.\n </li>\n<li>\n<code>\n   Install\n  </code>\n  refers to the section containing installation instructions for the device.\n </li>\n<li>\n<code>\n   USB\\VID_0ABA&amp;PID_8001\n  </code>\n  is the\n  <strong>\n   hardware ID\n  </strong>\n  , identifying the specific device based on its Vendor ID and Product ID.\n </li>\n</ul>\n<h4>\n Install Sections\n</h4>\n<p>\n There are two types of\n <strong>\n  Install\n </strong>\n sections in the example INF file: one for Windows 98/Me and another for Windows 2000/XP. These are defined as \"decorated\" sections for NT-based systems (e.g., Windows 2000/XP) by appending\n <code>\n  .NT\n </code>\n to the section names.\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Install Section for Windows 98 and Me\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Specifies the files to copy and registry entries to add during installation.\n   </li>\n<li>\n    Example:\n    plaintext\n    Copy code\n    <code class=\"!whitespace-pre hljs language-plaintext\">\n     [Install]\nCopyFiles=Install.CopyFiles\nAddReg=Install.AddReg\n    </code>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Install Section for Windows 2000 and XP\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    For Windows 2000 and XP, there are additional sections such as\n    <strong>\n     Install.NT\n    </strong>\n    and\n    <strong>\n     Install.NT.Services\n    </strong>\n    to handle service-specific configurations (e.g., starting drivers as services).\n   </li>\n<li>\n    Example:\n    plaintext\n    Copy code\n    <code class=\"!whitespace-pre hljs language-plaintext\">\n     [Install.NT]\nCopyFiles=Install.CopyFiles\n[Install.NT.Services]\nAddService=ellex200,2,Install.NT.AddService\n    </code>\n</li>\n</ul>\n</li>\n</ol>\n<h4>\n CopyFiles and AddReg Directives\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    CopyFiles\n   </strong>\n   : Directs the INF file to copy specific files from the source to the destination. For instance:\n  </p>\n  plaintext\n  Copy code\n  <code class=\"!whitespace-pre hljs language-plaintext\">\n   [Install.CopyFiles]\nellex200.sys,,,2\n  </code>\n<ul>\n<li>\n    The\n    <code>\n     ellex200.sys\n    </code>\n    driver file is copied with a flag\n    <code>\n     2\n    </code>\n    , which prevents the user from skipping the file copy operation during installation.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    AddReg\n   </strong>\n   : Specifies registry keys to add during installation. These registry settings ensure that Windows knows how to interact with the device and its driver.\n  </p>\n  plaintext\n  Copy code\n  <code class=\"!whitespace-pre hljs language-plaintext\">\n   [Install.AddReg]\nHKR,,DevLoader,,*ntkern\nHKR,,NTMPDriver,,ellex200.sys\n  </code>\n</li>\n</ul>\n<h4>\n NT Sections for Windows 2000 and XP\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Install.NT\n   </strong>\n   : Handles installation for NT-based systems, like Windows 2000 and XP, with sections that copy files and add services.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Install.NT.Services\n   </strong>\n   : Configures services for the device, including the service name and binary location.\n  </p>\n  plaintext\n  Copy code\n  <code class=\"!whitespace-pre hljs language-plaintext\">\n   [Install.NT.Services]\nAddService=ellex200,2,Install.NT.AddService\n  </code>\n</li>\n<li>\n<p>\n<strong>\n    Install.NT.AddService\n   </strong>\n   : Contains the configuration for the service, such as the service display name, type, and binary file:\n  </p>\n  plaintext\n  Copy code\n  <code class=\"!whitespace-pre hljs language-plaintext\">\n   [Install.NT.AddService]\nDisplayName=%SvcDesc%\nServiceType=1\nStartType=3\nErrorControl=1\nServiceBinary=%10%\\system32\\drivers\\ellex200.sys\n  </code>\n</li>\n</ul>\n<h4>\n Key Points:\n</h4>\n<ul>\n<li>\n<strong>\n   Install sections\n  </strong>\n  define what happens during installation, including copying files, adding registry entries, and setting up services.\n </li>\n<li>\n<strong>\n   Windows 98/Me\n  </strong>\n  and\n  <strong>\n   Windows 2000/XP\n  </strong>\n  use different sets of sections to handle installation.\n </li>\n<li>\n<strong>\n   CopyFiles\n  </strong>\n  ensures driver files are copied during setup, and\n  <strong>\n   AddReg\n  </strong>\n  adds necessary registry entries.\n </li>\n<li>\n  For\n  <strong>\n   Windows 2000/XP\n  </strong>\n  , additional configurations for services are included in the\n  <strong>\n   Install.NT.Services\n  </strong>\n  section.\n </li>\n</ul>\n"}, "Page 294": {"response": "<h3>\n Detailed Breakdown of INF File Sections for Device Installation\n</h3>\n<h4>\n Install Sections for Windows 2000 and Windows XP\n</h4>\n<p>\n For\n <strong>\n  Windows 2000\n </strong>\n and\n <strong>\n  Windows XP\n </strong>\n , the installation process requires two additional sections compared to\n <strong>\n  Windows 98\n </strong>\n and\n <strong>\n  Windows Me\n </strong>\n :\n <strong>\n  Install.NT.Services\n </strong>\n and\n <strong>\n  Install.NT.AddService\n </strong>\n .\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Install.NT\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This section is the equivalent of\n    <strong>\n     DDInstall\n    </strong>\n    for Windows 2000 and Windows XP.\n   </li>\n<li>\n    It primarily includes the\n    <strong>\n     CopyFiles\n    </strong>\n    directive that tells the system where to find the driver files, which is the same\n    <strong>\n     Install.CopyFiles\n    </strong>\n    section used for earlier Windows versions.\n   </li>\n<li>\n    It does not require the\n    <strong>\n     DevLoader\n    </strong>\n    and\n    <strong>\n     NTMPDriver\n    </strong>\n    registry entries, which are used in earlier Windows versions.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Install.NT.Services\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This section is essential for defining services associated with the driver.\n   </li>\n<li>\n    It assigns a\n    <strong>\n     ServiceName\n    </strong>\n    (in this case,\n    <code>\n     ellex200\n    </code>\n    ) to the device and specifies flags to identify the driver as the Plug-and-Play function driver.\n   </li>\n<li>\n    It also links to the\n    <strong>\n     Install.NT.AddService\n    </strong>\n    section, which contains instructions on how and when the driver\u2019s services should be loaded.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Install.NT.AddService\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This section contains specific details for configuring the service that Windows will use for the device driver.\n   </li>\n<li>\n    Key entries in this section include:\n    <ul>\n<li>\n<strong>\n       DisplayName\n      </strong>\n      : Provides a user-friendly name for the service.\n     </li>\n<li>\n<strong>\n       ServiceType\n      </strong>\n      : Defines the service as a kernel-mode device driver (value\n      <code>\n       1\n      </code>\n      ).\n     </li>\n<li>\n<strong>\n       StartType\n      </strong>\n      : Set to\n      <code>\n       3\n      </code>\n      , indicating that the driver starts automatically during enumeration.\n     </li>\n<li>\n<strong>\n       ErrorControl\n      </strong>\n      : Set to\n      <code>\n       1\n      </code>\n      , so a warning is displayed if there is an error, but installation continues.\n     </li>\n<li>\n<strong>\n       ServiceBinary\n      </strong>\n      : Specifies the location of the driver binary (\n      <code>\n       ellex200.sys\n      </code>\n      ), which was copied earlier in the installation process.\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4>\n Strings Section\n</h4>\n<p>\n The\n <strong>\n  Strings\n </strong>\n section is a part of the INF file that defines all the strings used in other sections. It ensures that the various names and descriptions are consistent and easy to manage.\n</p>\n<p>\n Example from the INF file:\n</p>\nplaintext\nCopy code\n<code class=\"!whitespace-pre hljs language-plaintext\">\n [Strings]\nClassName=\"Ellisys protocol analyzers\"\nProvider=\"Ellisys\"\nManufacturer=\"Ellisys\"\nSourceDisk=\"USB Explorer 200 Installation Disk\"\nDeviceDesc=\"USB Explorer 200\"\nSvcDesc=\"USB Explorer 200 Driver (ellex200.sys)\"\n</code>\n<ul>\n<li>\n<strong>\n   ClassName\n  </strong>\n  : Specifies the name of the device class, in this case, \"Ellisys protocol analyzers.\"\n </li>\n<li>\n<strong>\n   Provider\n  </strong>\n  : Defines the name of the provider (i.e., the manufacturer or developer of the driver), set to \"Ellisys.\"\n </li>\n<li>\n<strong>\n   Manufacturer\n  </strong>\n  : Specifies the manufacturer's name, which is also \"Ellisys.\"\n </li>\n<li>\n<strong>\n   SourceDisk\n  </strong>\n  : A description of the disk used for installation, such as \"USB Explorer 200 Installation Disk.\"\n </li>\n<li>\n<strong>\n   DeviceDesc\n  </strong>\n  : Describes the device, in this case, \"USB Explorer 200.\"\n </li>\n<li>\n<strong>\n   SvcDesc\n  </strong>\n  : Describes the service for the driver, identified as \"USB Explorer 200 Driver (ellex200.sys).\"\n </li>\n</ul>\n<p>\n This section ensures that the INF file uses these string values wherever necessary, making it easier to maintain and update the driver\u2019s installation configuration.\n</p>\n<h4>\n Key Points:\n</h4>\n<ul>\n<li>\n<strong>\n   Install.NT.Services\n  </strong>\n  and\n  <strong>\n   Install.NT.AddService\n  </strong>\n  sections are specific to Windows 2000/XP and define how to load and manage services for the driver.\n </li>\n<li>\n  The\n  <strong>\n   AddService\n  </strong>\n  section contains crucial parameters such as\n  <strong>\n   ServiceName\n  </strong>\n  ,\n  <strong>\n   ServiceType\n  </strong>\n  ,\n  <strong>\n   StartType\n  </strong>\n  ,\n  <strong>\n   ErrorControl\n  </strong>\n  , and\n  <strong>\n   ServiceBinary\n  </strong>\n  for service management.\n </li>\n<li>\n  The\n  <strong>\n   Strings\n  </strong>\n  section stores all string values used in the INF file, making it easier to refer to consistent names and descriptions throughout the file.\n </li>\n</ul>\n"}, "Page 295": {"response": "<h3>\n Device Identification Strings for Driver Matching\n</h3>\n<p>\n Windows uses\n <strong>\n  device identification strings\n </strong>\n to match devices with their appropriate drivers. These strings are created from the device\u2019s descriptors and are essential in identifying the device for proper driver installation. There are three key categories of identification strings used:\n <strong>\n  device IDs\n </strong>\n ,\n <strong>\n  hardware IDs\n </strong>\n , and\n <strong>\n  compatible IDs\n </strong>\n .\n</p>\n<h4>\n Types of Device Identification Strings\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Device IDs\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Every USB device is assigned at least one\n    <strong>\n     device ID\n    </strong>\n    by the hub driver. This ID is formed using key information from the device's descriptor, including the\n    <strong>\n     Vendor ID (VID)\n    </strong>\n    ,\n    <strong>\n     Product ID (PID)\n    </strong>\n    , and\n    <strong>\n     revision number (bcdDevice)\n    </strong>\n    .\n   </li>\n<li>\n    The format for a\n    <strong>\n     device ID\n    </strong>\n    is typically:\n    <ul>\n<li>\n<code>\n       USB\\VID_xxxx&amp;PID_yyyy&amp;REV_zzzz\n      </code>\n</li>\n<li>\n<code>\n       USB\\VID_xxxx&amp;PID_yyyy\n      </code>\n</li>\n</ul>\n</li>\n<li>\n<strong>\n     xxxx\n    </strong>\n    ,\n    <strong>\n     yyyy\n    </strong>\n    , and\n    <strong>\n     zzzz\n    </strong>\n    represent four-character hexadecimal values:\n    <ul>\n<li>\n<strong>\n       xxxx\n      </strong>\n      is the\n      <strong>\n       idVendor\n      </strong>\n      value.\n     </li>\n<li>\n<strong>\n       yyyy\n      </strong>\n      is the\n      <strong>\n       idProduct\n      </strong>\n      value.\n     </li>\n<li>\n<strong>\n       zzzz\n      </strong>\n      is the\n      <strong>\n       bcdDevice\n      </strong>\n      value, which represents the device\u2019s revision number.\n     </li>\n</ul>\n</li>\n<li>\n    For example, for a device with\n    <strong>\n     VID = 0925h\n    </strong>\n    ,\n    <strong>\n     PID = 1234h\n    </strong>\n    , and\n    <strong>\n     bcdDevice = 0310\n    </strong>\n    , the device ID would be:\n    <ul>\n<li>\n<code>\n       USB\\VID_0925&amp;PID_1234&amp;REV_0310\n      </code>\n</li>\n</ul>\n</li>\n<li>\n    In some cases, devices have multiple interfaces and therefore multiple device IDs, one for each interface.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Interface-Specific Device IDs\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Devices with multiple interfaces (e.g., a device that functions as both a keyboard and a mouse) can specify a driver for each individual interface.\n   </li>\n<li>\n    The device ID for each interface has the following format:\n    <ul>\n<li>\n<code>\n       USB\\VID_xxxx&amp;PID_yyyy&amp;REV_zzzz&amp;MI_ww\n      </code>\n</li>\n<li>\n<code>\n       USB\\VID_xxxx&amp;PID_yyyy&amp;MI_ww\n      </code>\n</li>\n</ul>\n</li>\n<li>\n    In this format, the\n    <strong>\n     MI_ww\n    </strong>\n    portion refers to the\n    <strong>\n     bInterfaceNumber\n    </strong>\n    from the interface descriptor, which identifies the specific interface of the device.\n    <strong>\n     ww\n    </strong>\n    is a 2-character hexadecimal value representing the interface number.\n   </li>\n<li>\n    For example, a composite device that functions as both a keyboard and a mouse might have entries in separate\n    <strong>\n     Models\n    </strong>\n    sections, like:\n    <ul>\n<li>\n<strong>\n       Keyboard Interface (interface 00)\n      </strong>\n      :\n      <ul>\n<li>\n<code>\n         [LAKEVIEW_KEYBOARD]\n        </code>\n</li>\n<li>\n<code>\n         %USB\\VID_0925&amp;PID_0801&amp;MI_00.DeviceDesc%= HID_Inst,, USB\\VID_0925&amp;PID_0801&amp;MI_00\n        </code>\n</li>\n</ul>\n</li>\n<li>\n<strong>\n       Mouse Interface (interface 01)\n      </strong>\n      :\n      <ul>\n<li>\n        Similar entry for the mouse interface (interface 01).\n       </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4>\n Summary of Device ID Structure:\n</h4>\n<ul>\n<li>\n<strong>\n   Device ID Format\n  </strong>\n  :\n  <code>\n   USB\\VID_xxxx&amp;PID_yyyy&amp;REV_zzzz\n  </code>\n  or\n  <code>\n   USB\\VID_xxxx&amp;PID_yyyy&amp;MI_ww\n  </code>\n</li>\n<li>\n<strong>\n   VID\n  </strong>\n  : Vendor ID (unique identifier for the device\u2019s manufacturer).\n </li>\n<li>\n<strong>\n   PID\n  </strong>\n  : Product ID (unique identifier for the product).\n </li>\n<li>\n<strong>\n   REV\n  </strong>\n  : Device revision (optional, depending on the device).\n </li>\n<li>\n<strong>\n   MI_ww\n  </strong>\n  : Interface number (only for devices with multiple interfaces).\n </li>\n</ul>\n<p>\n These identification strings help Windows match a device to the correct driver based on the device's descriptors, ensuring the right driver is used for installation and operation.\n</p>\n"}, "Page 296": {"response": "<h3>\n Device Identification and Compatible IDs for Driver Matching\n</h3>\n<p>\n When Windows searches for a driver for a device, it matches the\n <strong>\n  device ID\n </strong>\n and\n <strong>\n  compatible ID\n </strong>\n strings to determine the correct driver. Devices with multiple interfaces or features can have additional device IDs or compatible IDs to ensure proper driver matching.\n</p>\n<h4>\n Device IDs for Multiple Interfaces and Collections\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Multiple Interface Device IDs\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Devices with multiple interfaces, such as a keyboard and a mouse on the same USB device, will have separate device IDs for each interface. These IDs are created by appending the\n    <strong>\n     MI_ww\n    </strong>\n    field, where\n    <strong>\n     ww\n    </strong>\n    refers to the interface number (bInterfaceNumber).\n   </li>\n<li>\n    For example:\n    <ul>\n<li>\n<strong>\n       Keyboard Interface (interface 00)\n      </strong>\n      :\n      <ul>\n<li>\n<code>\n         [LAKEVIEW_KEYBOARD]\n        </code>\n</li>\n<li>\n<code>\n         %USB\\VID_0925&amp;PID_0801&amp;MI_00.DeviceDesc%= HID_Inst,, USB\\VID_0925&amp;PID_0801&amp;MI_00\n        </code>\n</li>\n</ul>\n</li>\n<li>\n<strong>\n       Mouse Interface (interface 01)\n      </strong>\n      :\n      <ul>\n<li>\n<code>\n         [LAKEVIEW_MOUSE]\n        </code>\n</li>\n<li>\n<code>\n         %USB\\VID_0925&amp;PID_0801&amp;MI_01.DeviceDesc%= HID_Inst,, USB\\VID_0925&amp;PID_0801&amp;MI_01\n        </code>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Device IDs for HID Class with Multiple Collections\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    HID-class devices with more than one top-level collection in their report descriptor will have a separate device ID for each collection. These IDs follow a similar format as interface-specific IDs but include the\n    <strong>\n     Colbb\n    </strong>\n    field (where\n    <strong>\n     bb\n    </strong>\n    indicates the collection number).\n   </li>\n<li>\n    The possible formats for collection-specific device IDs are:\n    <ul>\n<li>\n<code>\n       USB\\VID_xxxx&amp;PID_yyyy&amp;REV_zzzz&amp;Colbb\n      </code>\n</li>\n<li>\n<code>\n       USB\\VID_xxxx&amp;PID_yyyy&amp;Colbb\n      </code>\n</li>\n<li>\n<code>\n       USB\\VID_xxxx&amp;PID_yyyy&amp;REV_zzzz&amp;MI_ww&amp;Colbb\n      </code>\n</li>\n<li>\n<code>\n       USB\\VID_xxxx&amp;PID_yyyy&amp;MI_ww&amp;Colbb\n      </code>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4>\n Compatible IDs for Driver Matching\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Definition of Compatible IDs\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    In addition to the\n    <strong>\n     device ID\n    </strong>\n    , some drivers create\n    <strong>\n     compatible IDs\n    </strong>\n    to broaden the matching criteria. A\n    <strong>\n     compatible ID\n    </strong>\n    may not provide a perfect match but indicates a viable option for the driver installation.\n   </li>\n<li>\n    Compatible IDs are based on the device's\n    <strong>\n     class code\n    </strong>\n    ,\n    <strong>\n     subclass code\n    </strong>\n    , and\n    <strong>\n     protocol code\n    </strong>\n    , which are found in the device descriptor. These values are typically expressed in\n    <strong>\n     hexadecimal\n    </strong>\n    (except for Windows Me, which uses\n    <strong>\n     decimal\n    </strong>\n    ).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Compatible ID Formats\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The general format for compatible IDs is:\n    <ul>\n<li>\n<code>\n       USB\\CLASS_aa&amp;SUBCLASS_bb&amp;PROT_cc\n      </code>\n</li>\n<li>\n<code>\n       USB\\CLASS_aa&amp;SUBCLASS_bb\n      </code>\n</li>\n<li>\n<code>\n       USB\\CLASS_aa\n      </code>\n</li>\n</ul>\n</li>\n<li>\n<strong>\n     aa\n    </strong>\n    represents the\n    <strong>\n     bDeviceClass\n    </strong>\n    value,\n    <strong>\n     bb\n    </strong>\n    is the\n    <strong>\n     bDeviceSubclass\n    </strong>\n    value, and\n    <strong>\n     cc\n    </strong>\n    is the\n    <strong>\n     bDeviceProtocol\n    </strong>\n    value, all of which are two-character hexadecimal numbers.\n   </li>\n<li>\n    For example, the\n    <strong>\n     class code for HID\n    </strong>\n    devices is\n    <code>\n     03h\n    </code>\n    , so the compatible ID for HID-class devices would be:\n    <ul>\n<li>\n<code>\n       USB\\Class_03\n      </code>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Descriptive Names for Compatible IDs\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Some compatible IDs have predefined descriptive names such as:\n    <ul>\n<li>\n<code>\n       USBSTOR_BULK\n      </code>\n      for bulk storage devices.\n     </li>\n<li>\n<code>\n       GENERIC_USB_PRINTER\n      </code>\n      for generic USB printers.\n     </li>\n</ul>\n</li>\n<li>\n    These names help Windows identify the correct driver more easily.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Use of Compatible IDs\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    A compatible ID allows Windows to load a driver even if a perfect match (device ID) is not found in the INF file.\n   </li>\n<li>\n    However, vendors should avoid including\n    <strong>\n     compatible IDs\n    </strong>\n    in their INF files, as they represent a fallback option and are less specific than device IDs.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Summary of Key Points:\n</h4>\n<ul>\n<li>\n<strong>\n   Device IDs\n  </strong>\n  are created based on the\n  <strong>\n   Vendor ID (VID)\n  </strong>\n  ,\n  <strong>\n   Product ID (PID)\n  </strong>\n  , and\n  <strong>\n   revision number (bcdDevice)\n  </strong>\n  . Devices with multiple interfaces or collections will have multiple device IDs.\n </li>\n<li>\n<strong>\n   Compatible IDs\n  </strong>\n  are used when a device\u2019s exact match is not found and provide a broader way of identifying devices, typically based on class, subclass, and protocol values.\n </li>\n<li>\n<strong>\n   HID-class devices\n  </strong>\n  may have device IDs for each interface or collection, and compatible IDs allow Windows to find a driver if an exact match is not found.\n </li>\n</ul>\n"}, "Page 297": {"response": "<h3>\n Obtaining Identification Strings and Finding Driver Matches\n</h3>\n<p>\n When Windows searches for drivers for a device, it matches the device's identification strings with the information provided in INF files. These matches are ranked, with the best match receiving the highest priority. This process includes comparing\n <strong>\n  hardware IDs\n </strong>\n and\n <strong>\n  compatible IDs\n </strong>\n from both the device and the INF file.\n</p>\n<h4>\n Identification Strings in INF Files\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Hardware IDs\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    In the\n    <strong>\n     Models\n    </strong>\n    section of an INF file, each entry starts with a\n    <strong>\n     hardware ID\n    </strong>\n    , followed by any\n    <strong>\n     compatible IDs\n    </strong>\n    . These IDs are typically separated by commas.\n   </li>\n<li>\n    The\n    <strong>\n     hardware ID\n    </strong>\n    can take various forms, such as:\n    <ul>\n<li>\n      Device ID for a device\n     </li>\n<li>\n      Interface ID for a specific interface of a multi-interface device\n     </li>\n<li>\n      Collection ID for HID-class devices with multiple collections\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Compatible IDs\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Compatible IDs\n    </strong>\n    help to identify a device by its class code or other general attributes. These IDs broaden the matching criteria when an exact\n    <strong>\n     hardware ID\n    </strong>\n    isn\u2019t available.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Matching Process: How Windows Finds the Best Driver\n</h4>\n<p>\n When Windows attempts to find the best match for a device, it ranks the potential drivers based on how well the\n <strong>\n  hardware ID\n </strong>\n or\n <strong>\n  compatible ID\n </strong>\n from the device matches the entries in the INF files. This matching process involves several steps, with lower ranks representing better matches.\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Ranked Matching\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The matching process assigns ranks to different types of matches:\n    <ul>\n<li>\n<strong>\n       Best Match\n      </strong>\n      : A\n      <strong>\n       device ID\n      </strong>\n      from the device matches exactly with a\n      <strong>\n       hardware ID\n      </strong>\n      in a trusted INF file.\n     </li>\n<li>\n<strong>\n       Second Best Match\n      </strong>\n      : A\n      <strong>\n       device ID\n      </strong>\n      matches a\n      <strong>\n       compatible ID\n      </strong>\n      in a trusted INF file.\n     </li>\n<li>\n<strong>\n       Next Match\n      </strong>\n      : A\n      <strong>\n       compatible ID\n      </strong>\n      from the device matches a\n      <strong>\n       hardware ID\n      </strong>\n      in a trusted INF file.\n     </li>\n<li>\n<strong>\n       Lower Match\n      </strong>\n      : A\n      <strong>\n       compatible ID\n      </strong>\n      from the device matches a\n      <strong>\n       compatible ID\n      </strong>\n      in a trusted INF file.\n     </li>\n<li>\n<strong>\n       Untrusted Match\n      </strong>\n      : If no match is found with a trusted INF file, Windows will consider untrusted INF files.\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Trusted Drivers\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    NT-based systems, such as\n    <strong>\n     Windows 2000\n    </strong>\n    and\n    <strong>\n     Windows XP\n    </strong>\n    , assign a\n    <strong>\n     much lower rank\n    </strong>\n    to\n    <strong>\n     trusted drivers\n    </strong>\n    . Trusted drivers are those that are\n    <strong>\n     digitally signed\n    </strong>\n    and have passed\n    <strong>\n     Windows Hardware Quality Labs (WHQL)\n    </strong>\n    testing. This ensures higher reliability and compatibility.\n   </li>\n<li>\n<strong>\n     Windows 98\n    </strong>\n    does not check for trusted drivers, so the system doesn't prioritize digitally signed drivers.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Driver Selection in Case of No Match\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    If Windows cannot find any matching driver in the INF files, it launches the\n    <strong>\n     Found New Hardware wizard\n    </strong>\n    , prompting the user to specify a location (e.g., a CD drive or network share) where the driver can be located.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Special Considerations for Composite Devices\n</h4>\n<p>\n<strong>\n  Composite devices\n </strong>\n \u2014devices that contain multiple interfaces (such as a combination of a keyboard and mouse)\u2014pose a special challenge in driver selection. Since each interface may require its own driver, Windows may need to select a separate driver for each interface within the composite device.\n</p>\n<h4>\n Summary of Key Points:\n</h4>\n<ul>\n<li>\n<strong>\n   INF files\n  </strong>\n  contain hardware IDs and compatible IDs that help Windows match a device to the appropriate driver.\n </li>\n<li>\n<strong>\n   Hardware IDs\n  </strong>\n  are ranked higher when they exactly match, while\n  <strong>\n   compatible IDs\n  </strong>\n  offer broader matching possibilities.\n </li>\n<li>\n<strong>\n   NT-based operating systems\n  </strong>\n  give higher priority to\n  <strong>\n   trusted drivers\n  </strong>\n  (those that are digitally signed and WHQL-tested).\n </li>\n<li>\n  If no match is found, Windows prompts the user to locate the appropriate driver.\n </li>\n<li>\n<strong>\n   Composite devices\n  </strong>\n  with multiple interfaces require special handling to assign the correct driver to each interface.\n </li>\n</ul>\n"}, "Page 298": {"response": "<h3>\n Driver Matching Process in Windows\n</h3>\n<p>\n When Windows assigns a driver to a device, simply matching the\n <strong>\n  Vendor ID (VID)\n </strong>\n and\n <strong>\n  Product ID (PID)\n </strong>\n is not always enough, especially for more complex devices. To handle such cases, Windows employs a more comprehensive approach that may involve using compatible IDs and generic drivers.\n</p>\n<h4>\n Handling Composite Devices\n</h4>\n<p>\n For\n <strong>\n  composite devices\n </strong>\n , which include multiple interfaces (such as a USB device that acts as both a keyboard and a mouse),\n <strong>\n  Windows XP\n </strong>\n typically uses the\n <strong>\n  compatible ID\n </strong>\n<code>\n  USB\\COMPOSITE\n </code>\n . This action triggers the loading of a\n <strong>\n  generic parent driver\n </strong>\n called the\n <strong>\n  USB common class driver\n </strong>\n . This driver then creates device and compatible IDs for each interface, allowing Windows to assign a specific driver to each interface within the composite device. In earlier versions of Windows, this task was handled by the\n <strong>\n  bus\n </strong>\n or\n <strong>\n  hub driver\n </strong>\n .\n</p>\n<h4>\n Speeding Up Device Driver Search\n</h4>\n<p>\n Windows maintains an extensive collection of\n <strong>\n  INF files\n </strong>\n to aid in matching drivers with devices. To optimize this process, especially when a new device is installed, Windows generates a\n <strong>\n  PNF (precompiled INF) file\n </strong>\n . This PNF file is stored alongside the device\u2019s INF file and contains much of the same information but in a format that allows for faster searching during driver installation.\n</p>\n<h4>\n Ranking the Matches\n</h4>\n<p>\n Windows ranks matches based on how well the device\u2019s identification strings (device IDs or compatible IDs) match the entries in the INF files. The lower the rank, the better the match. Below is a table showing how these matches are ranked:\n</p>\n<table>\n<thead>\n<tr>\n<th>\n    Rank (Hex)\n   </th>\n<th>\n    ID from Descriptors\n   </th>\n<th>\n    ID from INF file\n   </th>\n<th>\n    Trusted Driver?\n   </th>\n<th>\n    \"Decorated\" INF Section?\n   </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n    0000\u20130FFF\n   </td>\n<td>\n    Device\n   </td>\n<td>\n    Hardware\n   </td>\n<td>\n    Yes\n   </td>\n<td>\n    Yes (required for NT-based OSs)\n   </td>\n</tr>\n<tr>\n<td>\n    1000\u20131FFF\n   </td>\n<td>\n    Device\n   </td>\n<td>\n    Compatible\n   </td>\n<td>\n    Yes\n   </td>\n<td>\n</td>\n</tr>\n<tr>\n<td>\n    2000\u20132FFF\n   </td>\n<td>\n    Compatible\n   </td>\n<td>\n    Hardware\n   </td>\n<td>\n    Yes\n   </td>\n<td>\n</td>\n</tr>\n<tr>\n<td>\n    3000\u20133FFF\n   </td>\n<td>\n    Compatible\n   </td>\n<td>\n    Compatible\n   </td>\n<td>\n    Yes\n   </td>\n<td>\n</td>\n</tr>\n<tr>\n<td>\n    8000\u20138FFF\n   </td>\n<td>\n    Device\n   </td>\n<td>\n    Hardware\n   </td>\n<td>\n    No\n   </td>\n<td>\n    Yes*\n   </td>\n</tr>\n<tr>\n<td>\n    9000\u2013BFFF\n   </td>\n<td>\n    Compatible\n   </td>\n<td>\n    Compatible\n   </td>\n<td>\n    No\n   </td>\n<td>\n    Yes*\n   </td>\n</tr>\n<tr>\n<td>\n    C000\u2013CFFF\n   </td>\n<td>\n    Device\n   </td>\n<td>\n    Hardware\n   </td>\n<td>\n    No\n   </td>\n<td>\n    No\n   </td>\n</tr>\n<tr>\n<td>\n    D000\u2013FFFE\n   </td>\n<td>\n    Compatible\n   </td>\n<td>\n    Compatible\n   </td>\n<td>\n    No\n   </td>\n<td>\n    No\n   </td>\n</tr>\n<tr>\n<td>\n    FFFF\n   </td>\n<td>\n    Worst-case match\n   </td>\n<td>\n</td>\n<td>\n</td>\n<td>\n</td>\n</tr>\n</tbody>\n</table>\n<h4>\n Explanation of Ranking Criteria:\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Trusted Driver?\n   </strong>\n   : Drivers signed with a digital signature (i.e.,\n   <strong>\n    trusted drivers\n   </strong>\n   ) are ranked higher (given a lower rank number) compared to unsigned or untrusted drivers.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    \u201cDecorated\u201d INF Section?\n   </strong>\n   : INF sections for\n   <strong>\n    NT-based OSs\n   </strong>\n   (Windows 2000, Windows XP) are considered \"decorated,\" meaning they include additional information that makes them suitable for modern operating systems. If an INF file is decorated, it is ranked more favorably.\n  </p>\n<ul>\n<li>\n<em>\n     Note\n    </em>\n    : The\n    <strong>\n     trusted driver\n    </strong>\n    designation applies only to\n    <strong>\n     NT-based operating systems\n    </strong>\n    (Windows 2000 and later). Windows 98 does not prioritize signed drivers.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n   The\n   <strong>\n    rank number\n   </strong>\n   (in hex) indicates the priority level:\n  </p>\n<ul>\n<li>\n    Lower hex values (e.g., 0000\u20130FFF) represent the best matches.\n   </li>\n<li>\n    Higher hex values (e.g., D000\u2013FFFE) represent worse or less ideal matches, typically used for fallback options like co-installers.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Summary:\n</h4>\n<ul>\n<li>\n<strong>\n   Composite devices\n  </strong>\n  may rely on a\n  <strong>\n   generic parent driver\n  </strong>\n  (USB\\COMPOSITE) to assign drivers to individual interfaces.\n </li>\n<li>\n  Windows speeds up driver installation by using\n  <strong>\n   PNF files\n  </strong>\n  .\n </li>\n<li>\n  Driver matches are ranked based on how closely they match the device\u2019s\n  <strong>\n   IDs\n  </strong>\n  with those in the INF files.\n </li>\n<li>\n<strong>\n   Trusted drivers\n  </strong>\n  and\n  <strong>\n   decorated INF sections\n  </strong>\n  are given higher priority.\n </li>\n<li>\n  If no good match is found, Windows proceeds with less ideal options or prompts the user to locate a driver manually.\n </li>\n</ul>\n"}, "Page 299": {"response": "<h3>\n Do You Need to Provide an INF File?\n</h3>\n<p>\n Not all USB devices require a custom INF file. Many devices that rely on the system\u2019s class drivers can use the default INF file provided by Windows. This is often the case for devices that belong to specific USB classes.\n</p>\n<h4>\n Default INF Files in Windows XP:\n</h4>\n<p>\n Windows XP and later versions favor trusted drivers. If you provide an untrusted driver for a device in a recognized class, Windows will not use your driver. Instead, it will select a compatible driver from the class's default INF file. INF files are considered part of the driver package. If you modify a trusted INF file or try to assign a trusted driver to your device, Windows will prefer the default INF file, rendering your custom INF file untrusted.\n</p>\n<h4>\n Trusted vs. Untrusted INF Files:\n</h4>\n<p>\n Modifying an INF file in a way that alters its trusted status means Windows will no longer trust it. If you try to add your device to an existing INF file, it will cause the INF to become untrusted. The operating system\u2019s settings will control how unsigned drivers are handled, allowing you to choose whether Windows blocks, warns, or allows installation. This setting can be adjusted via\n <strong>\n  Control Panel &gt; System &gt; Hardware &gt; Driver Signing\n </strong>\n .\n</p>\n<h4>\n Custom INF Files:\n</h4>\n<p>\n For devices that use class drivers, you can create a custom INF file with vendor-specific strings for display in the Device Manager. For example, an HID device could display \u201cMy Marvelous HID\u201d instead of the default \u201cUSB Human Interface Device.\u201d However, to use a custom INF file in Windows XP or later, your device and INF file must pass WHQL tests.\n</p>\n<h4>\n Example INF Files for Common USB Classes:\n</h4>\n<ul>\n<li>\n<strong>\n   Audio\n  </strong>\n  : wdmaudio.inf\n </li>\n<li>\n<strong>\n   Human Interface Device (HID)\n  </strong>\n  : input.inf (hiddev.inf in Windows 98)\n </li>\n<li>\n<strong>\n   Hub\n  </strong>\n  : usb.inf\n </li>\n<li>\n<strong>\n   Mass Storage\n  </strong>\n  : usbstor.inf\n </li>\n<li>\n<strong>\n   Printer\n  </strong>\n  : usbprint.inf\n </li>\n<li>\n<strong>\n   Smart Card\n  </strong>\n  : smartcrd.inf\n </li>\n<li>\n<strong>\n   Still Image\n  </strong>\n  : sti.inf\n </li>\n</ul>\n"}, "Page 300": {"response": "<h3>\n Matching a Driver to a Device\n</h3>\n<p>\n INF files provided by Windows often contain sections with manufacturer-specific information. When a device passes WHQL (Windows Hardware Quality Labs) tests, Microsoft may add the device's information to an existing INF file or include a manufacturer-specific INF file in the Windows distribution.\n</p>\n<h4>\n Devices Requiring Their Own INF Files:\n</h4>\n<p>\n Certain devices, such as modems or those with vendor-specific drivers, must have their own INF files. For these devices, the Windows DDK (Device Driver Kit) offers examples. A device that requires a custom driver also needs a unique INF file.\n</p>\n<h3>\n Tools and Diagnostic Aids\n</h3>\n<p>\n Microsoft provides several tools to assist with creating and testing INF files:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    GenInf\n   </strong>\n   : A wizard that generates INF files by asking questions about the device. However, the files it creates are basic and may require revisions. Specifically, these generated INF files don\u2019t support older versions of Windows and do not create multi-platform INF files.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    ChkInf\n   </strong>\n   : A Perl script used to check the structure and syntax of INF files. It requires a Perl interpreter, which can be downloaded from sources like\n   <a rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n    www\n    .activeware\n    .com\n   </a>\n   . When run, ChkInf generates an HTML page that highlights errors and warnings in the INF file.\n  </p>\n</li>\n</ul>\n<h4>\n Logging and Debugging Installation Issues:\n</h4>\n<p>\n When a device is detected, Windows uses the\n <strong>\n  Setup\n </strong>\n and device-installation functions to select and install the correct INF file and driver. These functions log events and errors in a file stored at\n <strong>\n  %SystemRoot%\\setupapi.log\n </strong>\n . This log is helpful for diagnosing installation issues. The Windows DDK documentation provides further details on using this logging capability.\n</p>\n<h3>\n Tips for Using INF Files\n</h3>\n<p>\n Here are some practical tips for working with INF files effectively:\n</p>\n"}, "Page 301": {"response": "<h3>\n Use a Valid Vendor ID\n</h3>\n<p>\n When distributing firmware outside a controlled environment, it is essential to use a Vendor ID (VID) assigned by the USB Implementers Forum (USB-IF). For example, the Vendor ID used in the sample code is 0925h, which is assigned to the company Lakeview Research. It is the responsibility of the Vendor ID owner to ensure that each product and version has a unique combination of Vendor ID and Product ID (PID). Using someone else\u2019s Vendor ID can create conflicts if that ID is already assigned to another device, leading to potential issues with identification.\n</p>\n<h3>\n Finding INF Files\n</h3>\n<p>\n When you install a device with a new INF file, Windows copies this INF file to the\n <strong>\n  %SystemRoot%\\inf\n </strong>\n folder, renaming it to\n <em>\n<em>\n   oem\n  </em>\n  .inf\n </em>\n *. Alongside, a\n <strong>\n  .PNF\n </strong>\n file is created with the name\n <strong>\n  oem*pnf\n </strong>\n . To locate INF files containing a specific Vendor ID and Product ID, use Windows' search function:\n</p>\n<ol>\n<li>\n  Go to\n  <strong>\n   Start Menu &gt; Search &gt; For Files or Folders\n  </strong>\n  .\n </li>\n<li>\n  Navigate to the\n  <strong>\n   %SystemRoot%\\inf\n  </strong>\n  folder.\n </li>\n<li>\n  Search for the text\n  <strong>\n   VID_xxxx&amp;PID_yyyy\n  </strong>\n  , replacing\n  <em>\n   xxxx\n  </em>\n  with the device\u2019s Vendor ID and\n  <em>\n   yyyy\n  </em>\n  with the Product ID.\n </li>\n</ol>\n<h3>\n Removing Device Information\n</h3>\n<p>\n When working with different versions of an INF file, you might find that Windows uses data stored in the system registry from a previous installation of the INF file. To ensure that Windows uses a different or updated INF file, follow these steps:\n</p>\n<ol>\n<li>\n  In\n  <strong>\n   Device Manager\n  </strong>\n  , right-click on the device listing and select\n  <strong>\n   Uninstall\n  </strong>\n  .\n </li>\n<li>\n  Delete any INF and PNF files containing the device\u2019s Vendor ID and Product ID from the\n  <strong>\n   %SystemRoot%\\inf\n  </strong>\n  folder.\n </li>\n<li>\n  Afterward, remove and reconnect the device. Windows will attempt to find and install the appropriate driver from scratch.\n </li>\n</ol>\n<p>\n If this method doesn\u2019t work, you may need to manually delete the unwanted INF and PNF files and any related registry keys.\n</p>\n<p>\n For Windows 98, if the above steps do not work, you can force Windows to forget device information by renaming two system files:\n</p>\n<ol>\n<li>\n  In the\n  <strong>\n   %SystemRoot%\\inf\n  </strong>\n  folder, rename\n  <strong>\n   drvdata.bin\n  </strong>\n  to\n  <strong>\n   drvdata.xxx\n  </strong>\n  .\n </li>\n<li>\n  Rename\n  <strong>\n   drvidx.bin\n  </strong>\n  to\n  <strong>\n   drvidx.xxx\n  </strong>\n  .\n </li>\n</ol>\n"}, "Page 302": {"response": "<h3>\n INF File Names and Driver Installation\n</h3>\n<h4>\n INF File Naming Convention\n</h4>\n<p>\n INF files that come with Windows typically have file names consisting of eight characters, plus a three-character extension. Microsoft explains that this naming limitation is due to \u201ctechnical issues with product installation.\u201d However, INF files added after Windows installation can use longer file names.\n</p>\n<h4>\n User Experience During Device Attachment\n</h4>\n<p>\n The user\u2019s experience when connecting a USB device can vary based on several factors, including:\n</p>\n<ul>\n<li>\n  The version of Windows being used.\n </li>\n<li>\n  The contents of the device's INF file.\n </li>\n<li>\n  The location of the driver.\n </li>\n<li>\n  Whether the driver includes a co-installer and is digitally signed.\n </li>\n<li>\n  Whether the device has been previously connected, enumerated, or has a serial number.\n </li>\n</ul>\n<h4>\n Device and Class Installers\n</h4>\n<p>\n Device and class installers are DLL files (dynamic link libraries) that assist in device installation. Windows provides default installers for devices in supported setup classes. Device vendors can supply a\n <strong>\n  co-installer\n </strong>\n that works alongside the class installer to handle device-specific tasks. A co-installer can:\n</p>\n<ul>\n<li>\n  Add information to the registry.\n </li>\n<li>\n  Prompt the user for additional configuration.\n </li>\n<li>\n  Provide custom properties pages for the Device Manager.\n </li>\n<li>\n  Perform other installation-related tasks.\n </li>\n</ul>\n<p>\n A custom device setup class may have its own class installer. For more details on writing installers and co-installers, refer to the Windows DDK documentation.\n</p>\n<h4>\n Searching for a Driver\n</h4>\n<p>\n Upon device attachment or system startup, after the device\u2019s descriptors are retrieved, Windows searches for a matching hardware key. If the key exists, the system has all the information needed to assign the correct driver. The hardware key\u2019s\n <strong>\n  Driver\n </strong>\n entry points to the\n <strong>\n  driver key\n </strong>\n , which specifies the associated INF file for installation.\n</p>\n"}, "Page 303": {"response": "<h3>\n Driver Matching and Installation Process\n</h3>\n<h4>\n The Role of the Hardware Key\n</h4>\n<p>\n The\n <strong>\n  hardware key\n </strong>\n in the registry contains a\n <strong>\n  Service\n </strong>\n entry, which points to the\n <strong>\n  service key\n </strong>\n . This service key provides details about the driver files associated with the device.\n</p>\n<h4>\n First Device Attachment\n</h4>\n<p>\n When a device is attached for the first time, Windows does not yet have a matching hardware key. It searches through its INF files for a compatible match. If the device uses a vendor-specific driver and Windows cannot find an appropriate INF file, it will trigger the\n <strong>\n  New Device Wizard\n </strong>\n . The user can either allow Windows to search for the driver or manually specify a directory for it.\n</p>\n<p>\n If you want to avoid users having to manually locate your driver, and if your driver is signed, you can create an installation program that uses the\n <strong>\n  SetupCopyOEMInf\n </strong>\n API function. This function will copy your INF file into the\n <strong>\n  %SystemRoot%\\inf\n </strong>\n directory, automating the process.\n</p>\n<h4>\n INF File Matching\n</h4>\n<p>\n When Windows finds a matching INF file, it will:\n</p>\n<ol>\n<li>\n  Copy the INF file to\n  <strong>\n   %SystemRoot%\\inf\n  </strong>\n  (if it's not already there).\n </li>\n<li>\n  Load the necessary drivers specified in the INF file.\n </li>\n<li>\n  Add the appropriate registry keys, which also adds the device to the\n  <strong>\n   Device Manager\n  </strong>\n  .\n </li>\n<li>\n  Optionally display a message confirming that the device has been installed.\n </li>\n</ol>\n<h4>\n Re-attachment of Identical Devices\n</h4>\n<p>\n For additional devices that are identical except for their serial number, Windows' behavior differs based on whether the driver is digitally signed:\n</p>\n<ul>\n<li>\n  If the driver is\n  <strong>\n   digitally signed\n  </strong>\n  , Windows uses\n  <strong>\n   administrative privileges\n  </strong>\n  to install the driver for any additional devices, even if the current user lacks these privileges.\n </li>\n<li>\n  If the driver is\n  <strong>\n   unsigned\n  </strong>\n  , Windows installs the driver based on the current user\u2019s privileges.\n </li>\n</ul>\n<h4>\n Re-attachment and Serial Number Impact\n</h4>\n<p>\n When a previously attached device is reconnected, the presence of a\n <strong>\n  USB serial number\n </strong>\n can affect how Windows finds the correct driver:\n</p>\n<ul>\n<li>\n  If the device\n  <strong>\n   does not have a serial number\n  </strong>\n  , the hardware key will only be found if the device is reconnected to the same port where it was originally attached.\n </li>\n<li>\n  If the device\n  <strong>\n   has a serial number\n  </strong>\n  , the hardware key can be found regardless of which port the device is connected to.\n </li>\n</ul>\n"}, "Page 304": {"response": "<h3>\n Detecting Devices\n</h3>\n<p>\n This chapter explains how applications can interact with attached devices, obtain information about them, request communication handles, and detect when devices are attached or removed. These tasks involve using Windows API functions and device interface GUIDs, which were introduced in Chapter 8. For those less familiar with API functions, this chapter starts with a brief tutorial to help understand their usage.\n</p>\n<h4>\n A Brief Guide to Calling API Functions\n</h4>\n<p>\n While you can accomplish many programming tasks without directly calling API functions, understanding them is essential for interacting with low-level system features.\n</p>\n<p>\n Microsoft\u2019s\n <strong>\n  .NET Framework\n </strong>\n offers classes for common tasks, such as:\n</p>\n<ul>\n<li>\n  Creating user interfaces.\n </li>\n<li>\n  Accessing files and manipulating text and graphics.\n </li>\n<li>\n  Interacting with peripheral devices.\n </li>\n<li>\n  Networking, security functions, and exception handling.\n </li>\n</ul>\n<p>\n Though these .NET classes internally use API functions, they provide a safer, more secure, and modular way to perform these tasks. These classes simplify complex operations by abstracting direct API calls, allowing developers to focus on higher-level functionality.\n</p>\n"}, "Page 305": {"response": "<h3>\n Working with API Functions and Managed/Unmanaged Code\n</h3>\n<h4>\n The .NET Framework and API Calls\n</h4>\n<p>\n The\n <strong>\n  .NET Framework\n </strong>\n includes languages like Visual Basic .NET, Visual C# .NET, and Visual C++ .NET, which offer classes to simplify common tasks such as user interface creation, file handling, and network operations. While these classes abstract much of the complexity, there are still tasks that require direct interaction with Windows API functions. In such cases, applications can combine the .NET Framework for standard tasks with API function calls when needed. For older languages like\n <strong>\n  Visual Basic 6\n </strong>\n , direct API calls are often necessary as well.\n</p>\n<p>\n The examples in this chapter focus on using Visual Basic .NET and Visual C++ .NET to call API functions.\n</p>\n<h4>\n Managed vs. Unmanaged Code\n</h4>\n<p>\n To effectively call Windows API functions in a Visual Basic .NET application, it\u2019s crucial to understand the difference between\n <strong>\n  managed\n </strong>\n and\n <strong>\n  unmanaged\n </strong>\n code.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Unmanaged code\n   </strong>\n   refers to the compiled machine code used in Windows API functions. These functions are executed directly on the CPU through dynamic link libraries (DLLs).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Managed code\n   </strong>\n   is used in languages like Visual Basic .NET and Visual C# .NET. This code is compiled into\n   <strong>\n    Microsoft Intermediate Language (MSIL)\n   </strong>\n   , which is executed by the\n   <strong>\n    Common Language Runtime (CLR)\n   </strong>\n   . The CLR provides key benefits, such as memory management via garbage collection and ease of interoperability across different .NET languages. For example, a Visual Basic .NET application can easily call a function written in Visual C# .NET without worrying about different calling conventions.\n  </p>\n</li>\n</ul>\n<h4>\n Calling Unmanaged Code from Managed Code\n</h4>\n<p>\n While .NET applications primarily use managed code, they can call functions written in unmanaged code, such as Windows API functions. However, this requires special handling to ensure that data passed between managed and unmanaged code survives the transition. Proper care must be taken when transferring data from one environment to the other to avoid errors or data loss.\n</p>\n"}, "Page 306": {"response": "<h3>\n Marshaling Data and Calling API Functions\n</h3>\n<h4>\n Marshaling Data Between Managed and Unmanaged Code\n</h4>\n<p>\n When using data returned by an API function in a\n <strong>\n  Visual Basic .NET\n </strong>\n or\n <strong>\n  Visual C# .NET\n </strong>\n application, the data often needs to be\n <strong>\n  marshaled\n </strong>\n . Marshaling involves transferring data between managed and unmanaged code, which typically requires copying data into managed memory or converting it between different types or formats.\n</p>\n<p>\n The\n <strong>\n  Marshal\n </strong>\n class in the .NET Framework provides methods to handle these tasks. It can:\n</p>\n<ul>\n<li>\n  Allocate memory for unmanaged code.\n </li>\n<li>\n  Copy data from unmanaged memory to managed memory.\n </li>\n<li>\n  Convert between managed and unmanaged data types.\n </li>\n</ul>\n<p>\n For example, to retrieve a string from unmanaged memory, you can use the\n <strong>\n  PtrToStringAuto\n </strong>\n method. The following Visual Basic code demonstrates how to retrieve a string from a pointer (\n <strong>\n  IntPtr pdevicePathName\n </strong>\n ) returned by an API function:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Dim\n DevicePathName\n as\n String\n DevicePathName = Marshal.PtrToStringAuto(pdevicePathName)\n</code>\n<h4>\n Working with Arrays and Structs\n</h4>\n<p>\n When dealing with arrays that will hold data copied from unmanaged code, the\n <strong>\n  MarshalAs\n </strong>\n attribute is used to define the array\u2019s size and data type. For instance, this Visual Basic code shows how to declare a 16-byte array that will hold a\n <strong>\n  GUID\n </strong>\n (Globally Unique Identifier) returned by an API function:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;MarshalAs(UnmanagedType.ByValArray, _\n  ArraySubType:=UnmanagedType.U1, SizeConst:=\n 16\n )&gt; _\n Public\n dbcc_classguid()\n As\n Byte\n</code>\n<p>\n Here, the\n <strong>\n  UnmanagedType.ByValArray\n </strong>\n marshals the\n <strong>\n  GUID\n </strong>\n into a byte array. The\n <strong>\n  ArraySubType\n </strong>\n field defines the array elements as unsigned, 1-byte (U1) values, and\n <strong>\n  SizeConst\n </strong>\n specifies the array size as 16 bytes.\n</p>\n<h4>\n Visual C++ .NET and Marshaling\n</h4>\n<p>\n In\n <strong>\n  Visual C++ .NET\n </strong>\n , the language can compile code into managed, unmanaged, or a mix of both types. One key advantage of Visual C++ .NET is its ability to use\n <strong>\n  \u201cIt Just Works\u201d\n </strong>\n technology, allowing managed code to call API functions in the same way unmanaged code does. This eliminates the need for marshaling, making Visual C++ .NET particularly versatile for calling API functions without extra overhead.\n</p>\n"}, "Page 307": {"response": "<h3>\n Using API Functions in Visual C++ .NET\n</h3>\n<h4>\n Simplicity of Visual C++ .NET for API Calls\n</h4>\n<p>\n When compared to\n <strong>\n  Visual Basic .NET\n </strong>\n or\n <strong>\n  Visual C# .NET\n </strong>\n , using\n <strong>\n  Visual C++ .NET\n </strong>\n for calling API functions is often simpler and more concise. This is because Visual C++ .NET has native support for unmanaged code and does not require the same marshaling steps as other .NET languages.\n</p>\n<h4>\n Documentation and Resources\n</h4>\n<p>\n Windows API functions are spread across various\n <strong>\n  DLLs\n </strong>\n and\n <strong>\n  libraries\n </strong>\n , with documentation in the\n <strong>\n  Windows DDK\n </strong>\n (Device Driver Kit) and\n <strong>\n  Platform SDK\n </strong>\n (Software Development Kit).\n</p>\n<ul>\n<li>\n<strong>\n   Functions for detecting devices\n  </strong>\n  are found in\n  <strong>\n   setupapi.dll\n  </strong>\n  , with documentation under\n  <strong>\n   Device Installation\n  </strong>\n  in the Windows DDK and\n  <strong>\n   Device Management\n  </strong>\n  in the Platform SDK.\n </li>\n<li>\n<strong>\n   Functions for communication with devices\n  </strong>\n  are located in\n  <strong>\n   kernel32.dll\n  </strong>\n  , documented under\n  <strong>\n   File Management\n  </strong>\n  and\n  <strong>\n   Device Input and Output Control\n  </strong>\n  in the Platform SDK.\n </li>\n<li>\n<strong>\n   Device notification functions\n  </strong>\n  are available in\n  <strong>\n   user32.dll\n  </strong>\n  , documented under\n  <strong>\n   Device Management\n  </strong>\n  in the Platform SDK.\n </li>\n</ul>\n<p>\n Additionally, header files for these DLLs often include helpful comments and details. If the documentation doesn't specify the header file, you can search for it using the\n <strong>\n  Windows Search\n </strong>\n tool. Simply search for\n <strong>\n  .h\n </strong>\n files containing the function name you need.\n</p>\n<h4>\n Using Visual C++ .NET to Call API Functions\n</h4>\n<p>\n To call an API function in a\n <strong>\n  Visual C++ .NET\n </strong>\n application, you need three essential components:\n</p>\n<ol>\n<li>\n  The ability to locate the file containing the function's compiled code.\n </li>\n<li>\n  A\n  <strong>\n   function declaration\n  </strong>\n  (also called a\n  <strong>\n   prototype\n  </strong>\n  ) to define how the function should be called.\n </li>\n<li>\n  A\n  <strong>\n   function call\n  </strong>\n  that triggers the execution of the function.\n </li>\n</ol>\n<p>\n Each\n <strong>\n  DLL\n </strong>\n has:\n</p>\n<ul>\n<li>\n  A\n  <strong>\n   library file\n  </strong>\n  (e.g.,\n  <strong>\n   setupapi.lib\n  </strong>\n  ,\n  <strong>\n   kernel32.lib\n  </strong>\n  ,\n  <strong>\n   user32.lib\n  </strong>\n  ) that helps the application locate and link the function without needing to manually point to the DLL.\n </li>\n<li>\n  One or more\n  <strong>\n   header files\n  </strong>\n  (e.g.,\n  <strong>\n   setupapi.h\n  </strong>\n  ,\n  <strong>\n   kernel32.h\n  </strong>\n  ,\n  <strong>\n   user32.h\n  </strong>\n  ) that define the function prototypes, structures, and symbols for easy use within the application.\n </li>\n</ul>\n<p>\n In summary, a\n <strong>\n  DLL\n </strong>\n contains compiled code for functions that are made available to applications. The library file associated with the DLL simplifies the process of finding and calling these functions, while the header file defines the necessary structures and prototypes.\n</p>\n"}, "Page 308": {"response": "<h3>\n Adding API Functions to a Visual C++ Project\n</h3>\n<h4>\n Linking to the Correct Library and Header Files\n</h4>\n<p>\n To use an API function in a\n <strong>\n  Visual C++\n </strong>\n application, you need to link the correct\n <strong>\n  library files\n </strong>\n and include the necessary\n <strong>\n  header files\n </strong>\n . Here's how to properly link and include these resources:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Add Library Files to the Project\n   </strong>\n   :\nIn\n   <strong>\n    Visual Studio\n   </strong>\n   , go to:\n  </p>\n<ul>\n<li>\n<code>\n     Project\n    </code>\n    &gt;\n    <code>\n     Properties\n    </code>\n    &gt;\n    <code>\n     Linker\n    </code>\n    &gt;\n    <code>\n     Input\n    </code>\n    .\n   </li>\n<li>\n    In the\n    <strong>\n     Additional Dependencies\n    </strong>\n    box, enter the names of the\n    <code>\n     .lib\n    </code>\n    files (such as\n    <strong>\n     setupapi.lib\n    </strong>\n    ).\n   </li>\n<li>\n    If the library files are located in a custom directory, enter the path to the libraries under\n    <strong>\n     Linker\n    </strong>\n    &gt;\n    <strong>\n     General\n    </strong>\n    &gt;\n    <strong>\n     Additional Library Directories\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Include the Header Files\n   </strong>\n   :\nIn the source file of the application, use the\n   <code>\n    #include\n   </code>\n   directive to include the necessary header files. For example:\n  </p>\n  cpp\n  Copy code\n  <code class=\"!whitespace-pre hljs language-cpp\">\n   extern\n   \"C\"\n   {\n   #\n   include\n   \"hidsdi.h\"\n   #\n   include\n   &lt;setupapi.h&gt;\n   }\n  </code>\n<p>\n   The\n   <code>\n    #include\n   </code>\n   directive essentially copies the contents of the specified file into the source file. The\n   <code>\n    extern \"C\"\n   </code>\n   modifier allows a C++ application to use header files that follow C naming conventions, avoiding name mangling in C++.\n  </p>\n</li>\n</ol>\n<h4>\n Understanding Library and Header Files\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Library Files\n   </strong>\n   : A\n   <strong>\n    .lib\n   </strong>\n   file contains\n   <strong>\n    stub functions\n   </strong>\n   that match the names and arguments of the corresponding functions in the\n   <strong>\n    DLL\n   </strong>\n   (e.g.,\n   <strong>\n    setupapi.dll\n   </strong>\n   ). During the compile process, the\n   <strong>\n    linker\n   </strong>\n   adds the necessary code from the library into the application's executable. When the application calls the function, the corresponding function in the\n   <strong>\n    DLL\n   </strong>\n   executes.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Header Files\n   </strong>\n   : These files define function prototypes, structures, and constants for the functions in the linked libraries. You must include the correct header files to use the API functions in your application.\n  </p>\n</li>\n</ul>\n<h4>\n Paths and Search Order\n</h4>\n<p>\n If you have multiple versions of a file in different locations, the order in which the compiler searches for files is determined by the punctuation used around the file name:\n</p>\n<ul>\n<li>\n<strong>\n   Angle brackets\n  </strong>\n  (\n  <code>\n   &lt; &gt;\n  </code>\n  ) indicate system directories.\n </li>\n<li>\n<strong>\n   Quotation marks\n  </strong>\n  (\n  <code>\n   \" \"\n  </code>\n  ) indicate the compiler should search the directories specified in the include path.\n </li>\n</ul>\n<p>\n To specify include directories in\n <strong>\n  Visual Studio\n </strong>\n , go to:\n</p>\n<ul>\n<li>\n<code>\n   Project\n  </code>\n  &gt;\n  <code>\n   Properties\n  </code>\n  &gt;\n  <code>\n   Resources\n  </code>\n  &gt;\n  <code>\n   General\n  </code>\n  .\n </li>\n<li>\n  Enter the path(s) in\n  <strong>\n   Additional Include Directories\n  </strong>\n  .\n </li>\n</ul>\n<p>\n This ensures that the compiler can locate and include the correct files from the specified paths during the build process.\n</p>\n"}, "Page 309": {"response": "<h3>\n Using API Functions in Visual Basic .NET\n</h3>\n<h4>\n Key Steps for Calling API Functions\n</h4>\n<p>\n To use an API function in a\n <strong>\n  Visual Basic .NET\n </strong>\n application, you need three things:\n</p>\n<ol>\n<li>\n<strong>\n   The DLL containing the function\n  </strong>\n  : You must know which DLL holds the function you want to use.\n </li>\n<li>\n<strong>\n   A declaration to enable access to the function\n  </strong>\n  : This declaration allows your application to locate the function in the DLL.\n </li>\n<li>\n<strong>\n   A call to execute the function\n  </strong>\n  : This invokes the function in the DLL.\n </li>\n</ol>\n<h4>\n Differences from Visual C++ .NET\n</h4>\n<p>\n Visual Basic .NET has extra considerations compared to\n <strong>\n  Visual C++ .NET\n </strong>\n when calling API functions:\n</p>\n<ul>\n<li>\n<strong>\n   C include files\n  </strong>\n  : Visual Basic requires you to translate the C-based structures and functions into Visual Basic syntax and data types.\n </li>\n<li>\n<strong>\n   Marshaling\n  </strong>\n  : Managed\n  <strong>\n   .NET code\n  </strong>\n  may require marshaling to handle unmanaged data (such as data returned from an API function). Marshaling ensures the data is passed correctly between managed and unmanaged code.\n </li>\n</ul>\n<h4>\n Declaring API Functions in Visual Basic .NET\n</h4>\n<p>\n Unlike\n <strong>\n  Visual C++\n </strong>\n , which uses C include files,\n <strong>\n  Visual Basic .NET\n </strong>\n needs specific declarations for each DLL function it calls. You do not need to reference the\n <strong>\n  .lib\n </strong>\n files (as in C++), but rather, you directly reference the\n <strong>\n  DLLs\n </strong>\n . The function declaration in Visual Basic .NET matches the function in the DLL, with the appropriate data types translated into Visual Basic syntax.\n</p>\n<h4>\n Example of Calling an API Function in Visual Basic .NET\n</h4>\n<p>\n Here\u2019s an example where the\n <code>\n  HidD_GetHidGuid\n </code>\n function from\n <strong>\n  hid.dll\n </strong>\n is called in Visual Basic .NET:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Dim\n HidGuid\n As\n Guid\nHidD_GetHidGuid(HidGuid)\n</code>\n<p>\n This code declares a\n <code>\n  Guid\n </code>\n variable, passes it to the function\n <code>\n  HidD_GetHidGuid\n </code>\n , and retrieves the value from the function.\n</p>\n<h4>\n Differences in Syntax for Visual Basic .NET\n</h4>\n<ul>\n<li>\n<strong>\n   DLL References\n  </strong>\n  : In Visual Basic .NET, you reference the DLL directly and use declarations in Visual Basic syntax. These declarations describe how data is passed to and from the function, including the data types and method signature.\n </li>\n<li>\n<strong>\n   Managed Code Handling\n  </strong>\n  : The application running in\n  <strong>\n   managed code\n  </strong>\n  in .NET requires special handling for unmanaged data. This is often achieved using\n  <strong>\n   marshaling\n  </strong>\n  techniques to convert and safely handle the data between the .NET environment and unmanaged API calls.\n </li>\n</ul>\n<p>\n This approach allows Visual Basic .NET applications to successfully call Windows API functions while handling the nuances of data types and memory management.\n</p>\n"}, "Page 310": {"response": "<h3>\n Calling API Functions in Visual Basic .NET\n</h3>\n<h4>\n Translating C Syntax to Visual Basic .NET\n</h4>\n<p>\n To call\n <strong>\n  Windows API functions\n </strong>\n in\n <strong>\n  Visual Basic .NET\n </strong>\n , you must translate C-style declarations and function calls into Visual Basic syntax. This process is not just about changing syntax but also about matching types and structures, as many C data types don't have direct equivalents in Visual Basic.\n</p>\n<h4>\n Example: Registering for Device Notifications\n</h4>\n<p>\n A common API function in device management is\n <code>\n  RegisterDeviceNotification\n </code>\n , which allows an application to be notified when a device is attached or removed. Here's how you'd declare and call this function in\n <strong>\n  Visual Basic .NET\n </strong>\n :\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;DllImport(\n \"user32.dll\"\n , CharSet:=CharSet.\n Auto\n )&gt; _\n Function\n RegisterDeviceNotification _\n   (\n ByVal\n hRecipient\n As\n IntPtr, _\n ByVal\n NotificationFilter\n As\n IntPtr, _\n ByVal\n Flags\n As\n Int32) _\n As\n IntPtr\n End\n Function\n</code>\n<h4>\n Breakdown of the Declaration\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    DllImport Attribute\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Specifies the DLL (\n    <code>\n     user32.dll\n    </code>\n    ) where the function resides.\n   </li>\n<li>\n    The\n    <code>\n     CharSet.Auto\n    </code>\n    setting allows Windows to automatically choose between ANSI (for older versions like Windows 98) or Unicode (for newer versions like Windows 2000 and XP).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Function Name\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The function name is\n    <code>\n     RegisterDeviceNotification\n    </code>\n    , as it is in the API.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Parameters\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<code>\n     hRecipient\n    </code>\n    ,\n    <code>\n     NotificationFilter\n    </code>\n    , and\n    <code>\n     Flags\n    </code>\n    are the parameters passed to the function. Each one must be defined with a specific data type:\n    <ul>\n<li>\n<code>\n       hRecipient\n      </code>\n      and\n      <code>\n       NotificationFilter\n      </code>\n      are of type\n      <code>\n       IntPtr\n      </code>\n      .\n     </li>\n<li>\n<code>\n       Flags\n      </code>\n      is an\n      <code>\n       Int32\n      </code>\n      .\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Passing Parameters\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The parameters are passed by value (\n    <code>\n     ByVal\n    </code>\n    ), meaning the function will receive a copy of the values.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Key Points in the Declaration:\n</h4>\n<ul>\n<li>\n<strong>\n   DllImport\n  </strong>\n  : Used to load the DLL and make the function available in your application.\n </li>\n<li>\n<strong>\n   CharSet.Auto\n  </strong>\n  : Ensures that the appropriate character set (ANSI or Unicode) is used based on the system's configuration.\n </li>\n<li>\n<strong>\n   Data Types\n  </strong>\n  : You need to specify the correct data types in\n  <strong>\n   Visual Basic .NET\n  </strong>\n  that match the expected input for the function, such as\n  <code>\n   IntPtr\n  </code>\n  and\n  <code>\n   Int32\n  </code>\n  .\n </li>\n</ul>\n<p>\n This setup enables the application to call the\n <strong>\n  RegisterDeviceNotification\n </strong>\n function and handle device events effectively.\n</p>\n"}, "Page 311": {"response": "<h3>\n Declaring and Using API Functions in Visual Basic .NET\n</h3>\n<h4>\n The Structure of the Declaration\n</h4>\n<p>\n When calling API functions in\n <strong>\n  Visual Basic .NET\n </strong>\n , the declaration must include several key details. Here's a summary of the essential components:\n</p>\n<ol>\n<li>\n<strong>\n   Data Type of the Return Value\n  </strong>\n  :\n  <ul>\n<li>\n    Most functions return a value, such as a pointer, represented as\n    <code>\n     IntPtr\n    </code>\n    . If a function has no return value, it may be declared as a\n    <strong>\n     Sub\n    </strong>\n    instead of a\n    <strong>\n     Function\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   DllImport Attribute\n  </strong>\n  :\n  <ul>\n<li>\n    This attribute specifies the DLL that contains the executable code for the function. It allows the application to use the function as if it were a local method. If the DLL is in a standard location, Windows will load it automatically. For example,\n    <code>\n     kernel32.dll\n    </code>\n    does not require specifying the\n    <code>\n     .dll\n    </code>\n    extension.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n DLL Location and File Name\n</h4>\n<p>\n The\n <strong>\n  DLL\u2019s name\n </strong>\n must be included in the declaration. When an application runs, Windows loads the required DLL into memory (unless it's already loaded). Usually, the\n <strong>\n  file name\n </strong>\n is all that\u2019s needed, as Windows already knows where to search for system DLLs (e.g.,\n <code>\n  %SystemRoot%\\system32\n </code>\n ).\n</p>\n<h4>\n Data Types in Visual Basic .NET\n</h4>\n<p>\n While\n <strong>\n  Visual Basic .NET\n </strong>\n provides its own set of data types (like\n <code>\n  Integer\n </code>\n ,\n <code>\n  String\n </code>\n , etc.), API functions often use types defined in the\n <strong>\n  Platform SDK\n </strong>\n that don't directly map to Visual Basic types.\n</p>\n<p>\n To handle this, you typically translate the C data types into\n <strong>\n  Visual Basic equivalents\n </strong>\n . Here's how some common C types map to Visual Basic .NET:\n</p>\n<ul>\n<li>\n<strong>\n   DWORD\n  </strong>\n  : A 32-bit integer, which can be represented as\n  <code>\n   Integer\n  </code>\n  in Visual Basic.\n </li>\n<li>\n<strong>\n   LPDWORD\n  </strong>\n  : A pointer to a\n  <code>\n   DWORD\n  </code>\n  , declared as an\n  <code>\n   Integer\n  </code>\n  passed by reference.\n </li>\n<li>\n<strong>\n   HANDLE\n  </strong>\n  : A platform-specific pointer, which maps to\n  <code>\n   System.IntPtr\n  </code>\n  .\n </li>\n<li>\n<strong>\n   GUID\n  </strong>\n  : A globally unique identifier, which translates to\n  <code>\n   System.Guid\n  </code>\n  .\n </li>\n</ul>\n<p>\n By understanding these mappings, you can translate C-style data types into ones that Visual Basic can use in its API declarations.\n</p>\n"}, "Page 312": {"response": "<h3>\n Understanding ByRef and ByVal in API Function Calls\n</h3>\n<h4>\n The Basics of ByRef and ByVal\n</h4>\n<p>\n In\n <strong>\n  Visual Basic .NET\n </strong>\n , when calling an API function, parameters can be passed either\n <strong>\n  by reference (ByRef)\n </strong>\n or\n <strong>\n  by value (ByVal)\n </strong>\n . While both approaches might seem similar, they serve different purposes depending on whether the function needs to modify the value of the parameter.\n</p>\n<ul>\n<li>\n<strong>\n   ByRef\n  </strong>\n  : When passing a variable by reference, the function receives the\n  <strong>\n   address\n  </strong>\n  of the variable, meaning any changes made to the variable inside the function will reflect back in the calling application. The function operates on the\n  <strong>\n   memory location\n  </strong>\n  where the value is stored.\n </li>\n<li>\n<strong>\n   ByVal\n  </strong>\n  : When passing a variable by value, the function receives a\n  <strong>\n   copy\n  </strong>\n  of the variable\u2019s value. The original value remains unchanged, and any modifications inside the function do not affect the calling application.\n </li>\n</ul>\n<h4>\n How ByRef and ByVal Work\n</h4>\n<p>\n When calling a function, the\n <strong>\n  stack\n </strong>\n temporarily holds the parameter value:\n</p>\n<ul>\n<li>\n<strong>\n   ByRef\n  </strong>\n  : The address of the variable (its\n  <strong>\n   pointer\n  </strong>\n  ) is passed. If the function modifies the variable\u2019s value, the calling program can access the updated value since it's directly linked to the variable\u2019s memory location.\n </li>\n<li>\n<strong>\n   ByVal\n  </strong>\n  : Only a\n  <strong>\n   copy\n  </strong>\n  of the variable\u2019s value is passed. If the function alters this value, the original value in memory remains unaffected, as the function doesn\u2019t have access to the variable\u2019s address.\n </li>\n</ul>\n<h4>\n When to Use ByRef or ByVal\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    ByVal (default)\n   </strong>\n   : In\n   <strong>\n    Visual Basic .NET\n   </strong>\n   , parameters are passed by value unless otherwise specified. This means that, by default, the function receives a copy of the variable\u2019s value and cannot change the original value.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    ByRef\n   </strong>\n   : If the function modifies the variable and the calling program needs to use the new value, you must pass the variable\n   <strong>\n    ByRef\n   </strong>\n   . This is especially necessary when the function needs to change values that should be accessible to the caller.\n  </p>\n<ul>\n<li>\n    Example: If you want a function to modify a number and reflect that change in the calling code, the number must be passed ByRef.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Special Case: Strings\n</h4>\n<p>\n Strings are an exception in\n <strong>\n  Visual Basic\n </strong>\n . Even though they are typically passed\n <strong>\n  ByVal\n </strong>\n to API functions,\n <strong>\n  Visual Basic\n </strong>\n actually passes a pointer to the string, which makes it behave like a ByRef parameter. This allows the function to modify the string\u2019s content.\n</p>\n<ul>\n<li>\n<strong>\n   Important\n  </strong>\n  : If an API function will modify the string, you should initialize it to be large enough to hold the largest expected string returned by the function. This prevents truncation or errors from occurring during the function call.\n </li>\n</ul>\n"}, "Page 313": {"response": "<h3>\n Passing Structures in API Calls\n</h3>\n<h4>\n Structure Data Types and API Functions\n</h4>\n<p>\n In some cases, API functions pass or return\n <strong>\n  structures\n </strong>\n , which are collections of multiple data items of different types. These structures are described in the API function documentation, and the header files for the API contain the structure declarations in\n <strong>\n  C syntax\n </strong>\n .\n</p>\n<p>\n In\n <strong>\n  Visual Basic .NET\n </strong>\n , equivalent structures can typically be declared using\n <strong>\n  structures\n </strong>\n or\n <strong>\n  classes\n </strong>\n . To ensure compatibility between managed and unmanaged code when passing structures, the\n <strong>\n  StructLayout\n </strong>\n attribute is used. This ensures the layout and alignment of structure members are consistent.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    StructLayout Attribute\n   </strong>\n   : The\n   <strong>\n    LayoutKind.Sequential\n   </strong>\n   setting ensures that the structure\u2019s members are laid out in memory sequentially, as they would be in unmanaged code.\n  </p>\n<p>\n   Example:\n  </p>\n  vb\n  Copy code\n  <code class=\"!whitespace-pre hljs language-vb\">\n   &lt;StructLayout(LayoutKind.Sequential)&gt;\n   Public\n   Structure\n   MyStructure\n   ' Structure members here\n   End\n   Structure\n  </code>\n</li>\n<li>\n<p>\n<strong>\n    CharSet Attribute\n   </strong>\n   : Similar to function declarations, the\n   <strong>\n    CharSet\n   </strong>\n   attribute ensures that string data is properly converted to\n   <strong>\n    ANSI\n   </strong>\n   or\n   <strong>\n    Unicode\n   </strong>\n   before passing it to unmanaged code.\n  </p>\n<p>\n   Example:\n  </p>\n  vb\n  Copy code\n  <code class=\"!whitespace-pre hljs language-vb\">\n   &lt;CharSet:=CharSet.\n   Auto\n   &gt;\n  </code>\n</li>\n</ul>\n<h4>\n Passing Structures ByVal or ByRef\n</h4>\n<p>\n A structure can be passed to an API function either:\n</p>\n<ul>\n<li>\n<strong>\n   ByVal\n  </strong>\n  : A copy of the structure is passed.\n </li>\n<li>\n<strong>\n   ByRef\n  </strong>\n  : A pointer to the structure is passed, which allows the API function to modify the structure\u2019s contents.\n </li>\n</ul>\n<h4>\n Handling Complex Structures\n</h4>\n<p>\n Some structures may be difficult or impractical to replicate directly in\n <strong>\n  Visual Basic\n </strong>\n . In such cases, a common approach is to use a\n <strong>\n  generic buffer\n </strong>\n of the expected size. The application can populate the buffer with data before passing it to the API function and then extract the returned data from the buffer as needed.\n</p>\n<h4>\n Example: Calling an API Function\n</h4>\n<p>\n Once the function and any required structures or classes are declared, the application can call the function. Here\u2019s an example of calling the\n <strong>\n  RegisterDeviceNotification\n </strong>\n function from earlier:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Public\n Const\n DEVICE_NOTIFY_WINDOW_HANDLE\n As\n Integer\n =\n 0\n deviceNotificationHandle = RegisterDeviceNotification _\n  (formHandle, DevBroadcastDeviceInterfaceBuffer, DEVICE_NOTIFY_WINDOW_HANDLE)\n</code>\n<p>\n This function registers for device notifications and requires parameters like the window handle and a pointer to a device interface structure, which is passed in the call.\n</p>\n"}, "Page 314": {"response": "<h3>\n Finding and Accessing Devices\n</h3>\n<h4>\n Overview of SetupDi_ API Functions\n</h4>\n<p>\n The\n <strong>\n  Windows API\n </strong>\n provides a set of\n <strong>\n  SetupDi_\n </strong>\n functions that allow applications to locate devices within a specific device interface class and retrieve the device path name for each device. Once the device path name is obtained, it can be used with the\n <strong>\n  CreateFile\n </strong>\n function to get a handle for communicating with the device.\n</p>\n<h4>\n Steps to Obtain a Device Path Name\n</h4>\n<p>\n To obtain a device path name, an application needs to follow these steps:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Obtain the Device Interface GUID\n   </strong>\n   : The first step is to get the\n   <strong>\n    device interface GUID\n   </strong>\n   , which uniquely identifies the class of devices.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Request a Pointer to the Device Information Set\n   </strong>\n   : The application should request a pointer to a device information set, which contains details about all the installed and present devices in the specified device interface class.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Request a Pointer to a Device Interface Structure\n   </strong>\n   : From the device information set, request a pointer to a structure that holds details about a specific device interface.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Request a Structure Containing the Device Path Name\n   </strong>\n   : Next, request a structure that includes the\n   <strong>\n    device path name\n   </strong>\n   for the device interface.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Extract the Device Path Name\n   </strong>\n   : Finally, extract the device path name from the structure, which is required to interact with the device.\n  </p>\n</li>\n</ol>\n<h4>\n Using the Device Path Name\n</h4>\n<p>\n Once the device path name is obtained, it can be passed to the\n <strong>\n  CreateFile\n </strong>\n function, which allows the application to open a handle for communication with the device.\n</p>\n<h4>\n Relevant API Functions\n</h4>\n<p>\n A series of\n <strong>\n  SetupDi_ API functions\n </strong>\n are available for performing the above actions. These functions are useful for finding devices that use specific, vendor-defined drivers or\n <strong>\n  HID-class devices\n </strong>\n that perform specialized functions.\n</p>\n<p>\n For devices performing\n <strong>\n  standard functions\n </strong>\n , there are alternative ways to access them. For example, to access storage devices (e.g., drives), the\n <strong>\n  .NET Framework\u2019s Directory class\n </strong>\n offers the\n <strong>\n  GetLogicalDrives\n </strong>\n method, which helps identify all logical drives on a system, regardless of whether they are USB devices. From there, you can use the\n <strong>\n  Directory\n </strong>\n and\n <strong>\n  File\n </strong>\n classes to access files on those drives.\n</p>\n"}, "Page 315": {"response": "<h3>\n Obtaining the Device Path Name using API Functions\n</h3>\n<h4>\n Overview\n</h4>\n<p>\n To interact with a device, an application must first locate it and obtain a device path name. This can be done using a set of API functions provided by Windows. These functions help identify devices and obtain the necessary path to communicate with them.\n</p>\n<h4>\n Steps to Obtain the Device Interface GUID\n</h4>\n<p>\n As mentioned in Chapter 8, applications can obtain the\n <strong>\n  device interface GUID\n </strong>\n from a\n <strong>\n  C header file\n </strong>\n or\n <strong>\n  Visual Basic declaration\n </strong>\n provided with the driver for many devices. Specifically for the\n <strong>\n  HID class\n </strong>\n , Windows provides a dedicated API function to retrieve the GUID, which is defined in\n <strong>\n  hidclass.h\n </strong>\n .\n</p>\n<h4>\n Visual C++ Code Example\n</h4>\n<p>\n To call the\n <strong>\n  HidD_GetHidGuid\n </strong>\n function in\n <strong>\n  Visual C++\n </strong>\n , the declaration and code are as follows:\n</p>\n<p>\n<strong>\n  Function Declaration:\n </strong>\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n VOID\n HidD_GetHidGuid\n (OUT LPGUID HidGuid)\n ;\n</code>\n<p>\n<strong>\n  Function Call:\n </strong>\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n HidD_GetHidGuid\n (&amp;HidGuid);\n</code>\n<h4>\n API Functions for Finding Devices and Getting Device Path Names\n</h4>\n<p>\n The following\n <strong>\n  API functions\n </strong>\n can be used to locate devices and obtain their device path names:\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     API Function\n    </strong>\n</th>\n<th>\n<strong>\n     DLL\n    </strong>\n</th>\n<th>\n<strong>\n     Purpose\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     HidD_GetHidGuid\n    </strong>\n</td>\n<td>\n<strong>\n     hid\n    </strong>\n</td>\n<td>\n    Retrieve the device interface GUID for the HID class\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     SetupDiDestroyDeviceInfoList\n    </strong>\n</td>\n<td>\n<strong>\n     setupapi\n    </strong>\n</td>\n<td>\n    Free resources used by\n    <strong>\n     SetupDiGetClassDevs\n    </strong>\n</td>\n</tr>\n<tr>\n<td>\n<strong>\n     SetupDiGetClassDevs\n    </strong>\n</td>\n<td>\n<strong>\n     setupapi\n    </strong>\n</td>\n<td>\n    Retrieve a device information set for devices in a specified class\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     SetupDiGetDeviceInterfaceDetail\n    </strong>\n</td>\n<td>\n<strong>\n     setupapi\n    </strong>\n</td>\n<td>\n    Retrieve a device path name\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     SetupDiEnumDeviceInterfaces\n    </strong>\n</td>\n<td>\n<strong>\n     setupapi\n    </strong>\n</td>\n<td>\n    Retrieve information about a device in a device information set\n   </td>\n</tr>\n</tbody>\n</table>\n<p>\n These functions are essential for accessing devices, including those using specialized drivers, and are useful in various programming scenarios. For a full example of how to use these functions in\n <strong>\n  Visual C++ .NET\n </strong>\n or\n <strong>\n  Visual Basic .NET\n </strong>\n , visit\n <strong>\n<a rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n   www\n   .Lvr\n   .com\n  </a>\n</strong>\n .\n</p>\n"}, "Page 316": {"response": "<h3>\n Requesting Device Information with SetupDiGetClassDevs\n</h3>\n<h4>\n Overview\n</h4>\n<p>\n To gather information about all devices in a specific device interface class, applications use the\n <strong>\n  SetupDiGetClassDevs\n </strong>\n function. This function returns a pointer to an array of structures that contain details about the devices associated with a given\n <strong>\n  GUID\n </strong>\n (Global Unique Identifier).\n</p>\n<h4>\n Visual Basic Code Example\n</h4>\n<p>\n For\n <strong>\n  Visual Basic .NET\n </strong>\n , the\n <strong>\n  HidD_GetHidGuid\n </strong>\n function is declared as a\n <strong>\n  Sub\n </strong>\n (since it has no return value) and called as follows:\n</p>\n<p>\n<strong>\n  Function Declaration:\n </strong>\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;DllImport(\n \"hid.dll\"\n )&gt;\n Sub\n HidD_GetHidGuid _\n    (\n ByRef\n HidGuid\n As\n System.Guid)\n End\n Sub\n</code>\n<p>\n<strong>\n  Function Call:\n </strong>\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Dim\n HidGuid\n As\n System.Guid\nHidD_GetHidGuid(HidGuid)\n</code>\n<h4>\n Visual C++ Code Example\n</h4>\n<p>\n For\n <strong>\n  Visual C++\n </strong>\n , the\n <strong>\n  SetupDiGetClassDevs\n </strong>\n function is declared as follows:\n</p>\n<p>\n<strong>\n  Function Declaration:\n </strong>\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n HDEVINFO\n SetupDiGetClassDevs\n (\n    IN LPGUID  ClassGuid,  \n    OPTIONAL IN PCTSTR  Enumerator,  \n    OPTIONAL IN HWND  hwndParent,  \n    IN DWORD  Flags\n)\n ;\n</code>\n<p>\n<strong>\n  Function Call:\n </strong>\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n HANDLE DeviceInfoSet;\nDeviceInfoSet =\n SetupDiGetClassDevs\n (\n  &amp;HidGuid,\n NULL\n ,\n NULL\n , \n  DIGCF_PRESENT | DIGCF_INTERFACEDEVICE\n);\n</code>\n<p>\n Here,\n <code>\n  HidGuid\n </code>\n refers to the device interface GUID (which was obtained earlier), and the\n <strong>\n  DIGCF_PRESENT\n </strong>\n and\n <strong>\n  DIGCF_INTERFACEDEVICE\n </strong>\n flags specify that only devices currently present and of the interface device type should be included in the results.\n</p>\n"}, "Page 317": {"response": "<h3>\n Requesting a Device Information Set in Visual Basic\n</h3>\n<h4>\n Overview\n</h4>\n<p>\n To retrieve information about devices in a specific device interface class, Visual Basic .NET applications use the\n <strong>\n  SetupDiGetClassDevs\n </strong>\n function. This function returns a pointer to a set of device information, which includes details about all devices currently connected and recognized by the system.\n</p>\n<h4>\n Function Declaration\n</h4>\n<p>\n The\n <strong>\n  SetupDiGetClassDevs\n </strong>\n function is declared in Visual Basic as follows:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;DllImport(\n \"setupapi.dll\"\n , CharSet:=CharSet.\n Auto\n )&gt; _\n Function\n SetupDiGetClassDevs _\n    (\n ByRef\n ClassGuid\n As\n System.Guid, _\n ByVal\n Enumerator\n As\n String\n , _\n ByVal\n hwndParent\n As\n Integer\n , _\n ByVal\n Flags\n As\n Integer\n ) _\n As\n IntPtr\n End\n Function\n</code>\n<h4>\n Function Call\n</h4>\n<p>\n The code to call the function looks like this:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Public\n Const\n DIGCF_PRESENT\n As\n Short\n =\n &amp;H2S\n Public\n Const\n DIGCF_DEVICEINTERFACE\n As\n Short\n =\n &amp;H10S\n Dim\n DeviceInfoSet\n As\n IntPtr\nDeviceInfoSet = SetupDiGetClassDevs _\n    (HidGuid, _\n    vbNullString, _\n 0\n , _\n    DIGCF_PRESENT\n Or\n DIGCF_DEVICEINTERFACE)\n</code>\n<h4>\n Explanation\n</h4>\n<ul>\n<li>\n<strong>\n   ClassGuid:\n  </strong>\n  This is the GUID for the device interface class, which, in the case of HID-class devices, is returned by the\n  <strong>\n   HidD_GetHidGuid\n  </strong>\n  function. For other drivers, you would pass the appropriate GUID.\n </li>\n<li>\n<strong>\n   Enumerator and hwndParent:\n  </strong>\n  In this case, these parameters are not used and can be set to\n  <strong>\n   vbNullString\n  </strong>\n  and\n  <strong>\n   0\n  </strong>\n  , respectively.\n </li>\n<li>\n<strong>\n   Flags:\n  </strong>\n  These system constants control the behavior of the function. In this example:\n  <ul>\n<li>\n<strong>\n     DIGCF_PRESENT\n    </strong>\n    ensures the function only looks for devices that are currently attached.\n   </li>\n<li>\n<strong>\n     DIGCF_DEVICEINTERFACE\n    </strong>\n    ensures it only searches for devices that support interfaces.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n The returned value,\n <strong>\n  DeviceInfoSet\n </strong>\n , is a pointer to the device information set. This set contains details about each device currently recognized and connected in the specified device interface class. Each device in the set has an associated device information element that holds data like the device's path and other configuration information.\n</p>\n"}, "Page 318": {"response": "<h3>\n Identifying a Device Interface\n</h3>\n<h4>\n Overview\n</h4>\n<p>\n To identify and retrieve information about a specific device interface, applications use the\n <strong>\n  SetupDiEnumDeviceInterfaces\n </strong>\n function. This function allows the application to loop through the device interface array and find the device it\u2019s looking for, based on various criteria. When an application calls this function, it specifies a device interface by passing an array index. If there are multiple interfaces for a device, the application must investigate each one until it finds the desired interface or determines that the device isn\u2019t present.\n</p>\n<h4>\n Functionality\n</h4>\n<p>\n The device information set returned by the\n <strong>\n  SetupDiGetClassDevs\n </strong>\n function contains a handle to a device\u2019s devnode. This devnode is a structure representing the device. The information set also contains a linked list of device interfaces associated with the device.\n</p>\n<p>\n After retrieving the device information set, the application can loop through the array of device interfaces using\n <strong>\n  SetupDiEnumDeviceInterfaces\n </strong>\n , incrementing the array index to get each device interface. The loop continues until the function returns zero, indicating no more interfaces are available. When this happens, the\n <strong>\n  GetLastError\n </strong>\n function will return\n <strong>\n  No more data is available\n </strong>\n , signaling the end of the list.\n</p>\n<p>\n If the application detects multiple interfaces for a device, it can further investigate each interface to identify the correct one. This is done by examining additional information or attributes about the interfaces, such as the GUID of the interface class.\n</p>\n<h4>\n Visual C++ Declaration\n</h4>\n<p>\n Here is the declaration of the\n <strong>\n  SP_DEVICE_INTERFACE_DATA\n </strong>\n structure, which is used to store information about a device interface:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n typedef\n struct\n _SP_DEVICE_INTERFACE_DATA\n {\n    DWORD cbSize;\n    GUID InterfaceClassGuid;\n    DWORD Flags;\n    ULONG_PTR Reserved;\n} SP_DEVICE_INTERFACE_DATA, *PSP_DEVICE_INTERFACE_DATA;\n</code>\n<ul>\n<li>\n<strong>\n   cbSize:\n  </strong>\n  The size of the structure, which helps the function know how much memory to work with.\n </li>\n<li>\n<strong>\n   InterfaceClassGuid:\n  </strong>\n  A GUID that identifies the device interface class associated with this device interface.\n </li>\n<li>\n<strong>\n   Flags:\n  </strong>\n  Contains flags that provide additional information about the interface.\n </li>\n<li>\n<strong>\n   Reserved:\n  </strong>\n  Reserved for future use and should typically be set to zero.\n </li>\n</ul>\n<h4>\n Next Steps\n</h4>\n<p>\n After identifying a device interface, the application can request more details about the interface, such as its device path name, which can be used to open the device for communication. The function helps applications effectively handle multiple device interfaces and identify the right one for their purpose.\n</p>\n"}, "Page 319": {"response": "<h3>\n Calling\n <code>\n  SetupDiEnumDeviceInterfaces\n </code>\n to Identify Device Interfaces\n</h3>\n<h4>\n Function Overview\n</h4>\n<p>\n The\n <strong>\n  SetupDiEnumDeviceInterfaces\n </strong>\n function is used to retrieve information about a specific device interface from a device information set. It allows an application to loop through the interfaces associated with a device, by specifying an index to access each interface. The function helps identify and access the interfaces for devices connected to the system, allowing the application to determine the appropriate interface to interact with.\n</p>\n<h4>\n Function Declaration and Parameters\n</h4>\n<p>\n Here is the declaration of the\n <strong>\n  SetupDiEnumDeviceInterfaces\n </strong>\n function in C/C++:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n BOOLEAN\n SetupDiEnumDeviceInterfaces\n (\n    IN HDEVINFO DeviceInfoSet,\n    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL\n    IN LPGUID InterfaceClassGuid,\n    IN DWORD MemberIndex,\n    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData\n)\n ;\n</code>\n<ul>\n<li>\n<strong>\n   DeviceInfoSet:\n  </strong>\n  A pointer to a device information set that contains information about all devices in a specified device interface class.\n </li>\n<li>\n<strong>\n   DeviceInfoData:\n  </strong>\n  Optional parameter. It is used to retrieve specific device information, but is typically not needed when enumerating device interfaces.\n </li>\n<li>\n<strong>\n   InterfaceClassGuid:\n  </strong>\n  A GUID that specifies the device interface class. It identifies the type of device interfaces to be enumerated.\n </li>\n<li>\n<strong>\n   MemberIndex:\n  </strong>\n  The index of the device interface to enumerate within the set. The application can increment this index to loop through all device interfaces.\n </li>\n<li>\n<strong>\n   DeviceInterfaceData:\n  </strong>\n  A pointer to a structure (\n  <strong>\n   SP_DEVICE_INTERFACE_DATA\n  </strong>\n  ) that will be filled with information about the retrieved device interface.\n </li>\n</ul>\n<h4>\n Example Code in C++\n</h4>\n<p>\n The following is a C++ example showing how to call\n <strong>\n  SetupDiEnumDeviceInterfaces\n </strong>\n to enumerate a device interface:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n BOOLEAN Result;\nSP_DEVICE_INTERFACE_DATA MyDeviceInterfaceData;\nMyDeviceInterfaceData.cbSize =\n sizeof\n (MyDeviceInterfaceData);\nMemberIndex =\n 0\n ;\nResult =\n SetupDiEnumDeviceInterfaces\n (\n    DeviceInfoSet,\n 0\n ,\n    &amp;HidGuid,\n    MemberIndex,\n    &amp;MyDeviceInterfaceData\n);\n</code>\n<ul>\n<li>\n<strong>\n   MyDeviceInterfaceData.cbSize:\n  </strong>\n  Initializes the size of the structure to ensure it is correctly interpreted by the function.\n </li>\n<li>\n<strong>\n   MemberIndex:\n  </strong>\n  The index used to specify which device interface to retrieve. The loop can increment this value to get additional interfaces.\n </li>\n</ul>\n<h4>\n Visual Basic Declaration\n</h4>\n<p>\n In Visual Basic, you can define the\n <strong>\n  SP_DEVICE_INTERFACE_DATA\n </strong>\n structure like this:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;StructLayout(LayoutKind.Sequential)&gt; _\n Public\n Structure\n SP_DEVICE_INTERFACE_DATA\n Dim\n cbSize\n As\n Integer\n Dim\n InterfaceClassGuid\n As\n System.Guid\n Dim\n Flags\n As\n Integer\n Dim\n Reserved\n As\n Integer\n End\n Structure\n</code>\n<ul>\n<li>\n<strong>\n   cbSize:\n  </strong>\n  The size of the structure, which is used for memory management.\n </li>\n<li>\n<strong>\n   InterfaceClassGuid:\n  </strong>\n  The GUID that identifies the device interface class for this interface.\n </li>\n<li>\n<strong>\n   Flags and Reserved:\n  </strong>\n  Other data fields that provide additional information about the device interface.\n </li>\n</ul>\n<h4>\n Summary\n</h4>\n<p>\n Using\n <strong>\n  SetupDiEnumDeviceInterfaces\n </strong>\n , applications can efficiently enumerate device interfaces within a device information set, examining each interface to find the correct one. By looping through the array of interfaces and checking the relevant details, an application can select the appropriate interface for communication with a device.\n</p>\n"}, "Page 320": {"response": "<h3>\n Calling\n <code>\n  SetupDiEnumDeviceInterfaces\n </code>\n in Visual Basic\n</h3>\n<h4>\n Function Declaration\n</h4>\n<p>\n The\n <strong>\n  SetupDiEnumDeviceInterfaces\n </strong>\n function can be called from Visual Basic using the following declaration:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;DllImport(\n \"setupapi.dll\"\n )&gt; _\n Function\n SetupDiEnumDeviceInterfaces _\n    (\n ByVal\n DeviceInfoSet\n As\n IntPtr, _\n ByVal\n DeviceInfoData\n As\n Integer\n , _\n ByRef\n InterfaceClassGuid\n As\n System.Guid, _\n ByVal\n MemberIndex\n As\n Integer\n , _\n ByRef\n DeviceInterfaceData\n As\n SP_DEVICE_INTERFACE_DATA) _\n As\n Boolean\n End\n Function\n</code>\n<ul>\n<li>\n<strong>\n   DeviceInfoSet:\n  </strong>\n  A pointer to the device information set containing all devices in a specified device interface class.\n </li>\n<li>\n<strong>\n   DeviceInfoData:\n  </strong>\n  An optional pointer to a structure used to narrow the search to a specific device.\n </li>\n<li>\n<strong>\n   InterfaceClassGuid:\n  </strong>\n  A reference to the GUID that identifies the class of device interfaces.\n </li>\n<li>\n<strong>\n   MemberIndex:\n  </strong>\n  The index in the array of device interfaces to retrieve. The index increments as you loop through available interfaces.\n </li>\n<li>\n<strong>\n   DeviceInterfaceData:\n  </strong>\n  A reference to the structure that will receive the details of the device interface.\n </li>\n</ul>\n<h4>\n Example Code in Visual Basic\n</h4>\n<p>\n Here's how to use\n <strong>\n  SetupDiEnumDeviceInterfaces\n </strong>\n in Visual Basic:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Dim\n MemberIndex\n As\n Integer\n Dim\n MyDeviceInterfaceData\n As\n SP_DEVICE_INTERFACE_DATA\n Dim\n Result\n As\n Boolean\n MyDeviceInterfaceData.cbSize = Marshal.SizeOf(MyDeviceInterfaceData)\nMemberIndex =\n 0\n Result = SetupDiEnumDeviceInterfaces _\n    (DeviceInfoSet, _\n 0\n , _\n    HidGuid, _\n    MemberIndex, _\n    MyDeviceInterfaceData)\n</code>\n<ul>\n<li>\n<strong>\n   MyDeviceInterfaceData.cbSize:\n  </strong>\n  The\n  <strong>\n   cbSize\n  </strong>\n  field of the\n  <strong>\n   SP_DEVICE_INTERFACE_DATA\n  </strong>\n  structure must be initialized to the size of the structure. In Visual Basic,\n  <strong>\n   Marshal.SizeOf\n  </strong>\n  retrieves this size.\n </li>\n<li>\n<strong>\n   MemberIndex:\n  </strong>\n  The index is initially set to 0 to start from the first device interface in the device information set.\n </li>\n<li>\n<strong>\n   Result:\n  </strong>\n  Stores the Boolean return value indicating whether the function succeeded.\n </li>\n</ul>\n<h4>\n Key Details and Structure Setup\n</h4>\n<ul>\n<li>\n<strong>\n   cbSize:\n  </strong>\n  This field in the\n  <strong>\n   SP_DEVICE_INTERFACE_DATA\n  </strong>\n  structure indicates the size of the structure in bytes. This must be set before calling\n  <strong>\n   SetupDiEnumDeviceInterfaces\n  </strong>\n  . In Visual Basic,\n  <strong>\n   Marshal.SizeOf\n  </strong>\n  is used to fetch the size of the structure.\n </li>\n<li>\n<strong>\n   HidGuid and DeviceInfoSet:\n  </strong>\n  These parameters should be values retrieved earlier in the process, such as the\n  <strong>\n   HidGuid\n  </strong>\n  from the\n  <strong>\n   HidD_GetHidGuid\n  </strong>\n  function and the\n  <strong>\n   DeviceInfoSet\n  </strong>\n  from\n  <strong>\n   SetupDiGetClassDevs\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   DeviceInfoData:\n  </strong>\n  This parameter is optional and can be used to filter the search to a specific device. If it's not needed, it can be passed as\n  <strong>\n   0\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   MemberIndex:\n  </strong>\n  The index used to identify the current device interface in the device information set. It is incremented to move through the set of interfaces.\n </li>\n<li>\n<strong>\n   DeviceInterfaceData:\n  </strong>\n  This structure will be filled with data about the device interface, including its GUID and flags.\n </li>\n</ul>\n<h4>\n Summary\n</h4>\n<p>\n The\n <strong>\n  SetupDiEnumDeviceInterfaces\n </strong>\n function allows an application to iterate through all device interfaces in a set. Each interface is identified by an index, and the function fills a structure with details about the interface, such as its GUID. The\n <strong>\n  cbSize\n </strong>\n field must be set to the size of the structure before calling the function. By looping through the device interfaces, an application can find the desired interface for communication with the connected device.\n</p>\n"}, "Page 321": {"response": "<h3>\n Requesting a Device Path Name\n</h3>\n<p>\n The\n <code>\n  SetupDiGetDeviceInterfaceDetail\n </code>\n function retrieves detailed information about a device interface, specifically the device path name, which can be used to access and communicate with the device.\n</p>\n<h4>\n The Issue with DeviceInterfaceDetailDataSize\n</h4>\n<p>\n When calling\n <code>\n  SetupDiGetDeviceInterfaceDetail\n </code>\n for the first time, you cannot know the required size of the\n <code>\n  DeviceInterfaceDetailData\n </code>\n structure, which is a parameter in the function. The function needs this size to allocate enough memory to store the device information.\n</p>\n<p>\n To address this issue, the function is called twice:\n</p>\n<ol>\n<li>\n  On the first call, you provide an initial buffer size. The function will return an error:\n  <strong>\n   \"The data area passed to a system call is too small.\"\n  </strong>\n  However, it also returns the correct size needed for the buffer in the\n  <code>\n   RequiredSize\n  </code>\n  parameter.\n </li>\n<li>\n  On the second call, you pass the correct buffer size as indicated by\n  <code>\n   RequiredSize\n  </code>\n  , and the function then successfully returns the full structure with the device path name.\n </li>\n</ol>\n<h4>\n Visual C++ Example\n</h4>\n<p>\n In C++, you declare the structure\n <code>\n  SP_DEVICE_INTERFACE_DETAIL_DATA\n </code>\n and use the\n <code>\n  SetupDiGetDeviceInterfaceDetail\n </code>\n function as follows:\n</p>\n<ul>\n<li>\n<strong>\n   SP_DEVICE_INTERFACE_DETAIL_DATA Structure Declaration:\n  </strong>\n</li>\n</ul>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n typedef\n struct\n _SP_DEVICE_INTERFACE_DETAIL_DATA\n {\n    DWORD cbSize;\n    TCHAR DevicePath[ANYSIZE_ARRAY];\n} SP_DEVICE_INTERFACE_DETAIL_DATA, *PSP_DEVICE_INTERFACE_DETAIL_DATA;\n</code>\n<ul>\n<li>\n<strong>\n   Function Declaration:\n  </strong>\n</li>\n</ul>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n BOOLEAN\n SetupDiGetDeviceInterfaceDetail\n (\n    IN HDEVINFO DeviceInfoSet,\n    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,\n    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA DeviceInterfaceDetailData, OPTIONAL\n    IN DWORD DeviceInterfaceDetailDataSize,\n    OUT PDWORD RequiredSize, OPTIONAL\n    OUT PSP_DEVINFO_DATA DeviceInfoData OPTIONAL\n)\n ;\n</code>\n<ul>\n<li>\n<strong>\n   Function Call Example:\n  </strong>\n</li>\n</ul>\n<p>\n The following code demonstrates how to call\n <code>\n  SetupDiGetDeviceInterfaceDetail\n </code>\n to obtain the device path name:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n BOOLEAN Result;\nSP_DEVICE_INTERFACE_DETAIL_DATA MyDeviceInterfaceDetailData;\nDWORD RequiredSize =\n 0\n ;\n // First call with a buffer size of 0\n MyDeviceInterfaceDetailData.cbSize =\n sizeof\n (MyDeviceInterfaceDetailData);\nResult =\n SetupDiGetDeviceInterfaceDetail\n (\n    DeviceInfoSet,\n    &amp;MyDeviceInterfaceData,\n    &amp;MyDeviceInterfaceDetailData,\n 0\n ,\n // size is 0 for the first call\n &amp;RequiredSize,\n NULL\n );\n // If the call was successful, RequiredSize will contain the correct size\n if\n (Result == FALSE &amp;&amp;\n GetLastError\n () == ERROR_INSUFFICIENT_BUFFER) {\n // Second call with the correct buffer size\n MyDeviceInterfaceDetailData.cbSize =\n sizeof\n (MyDeviceInterfaceDetailData);\n    Result =\n SetupDiGetDeviceInterfaceDetail\n (\n        DeviceInfoSet,\n        &amp;MyDeviceInterfaceData,\n        &amp;MyDeviceInterfaceDetailData,\n        RequiredSize,\n NULL\n ,\n NULL\n );\n}\n</code>\n<h4>\n Structure Breakdown\n</h4>\n<ul>\n<li>\n<strong>\n   cbSize:\n  </strong>\n  This field in the\n  <code>\n   SP_DEVICE_INTERFACE_DETAIL_DATA\n  </code>\n  structure must be set to the size of the structure before calling\n  <code>\n   SetupDiGetDeviceInterfaceDetail\n  </code>\n  .\n </li>\n<li>\n<strong>\n   DevicePath:\n  </strong>\n  This is an array where the device path name is stored. It\u2019s a string that represents the path to the device and can be used later to open the device handle.\n </li>\n</ul>\n<h4>\n Conclusion\n</h4>\n<p>\n To retrieve the device path name from\n <code>\n  SetupDiGetDeviceInterfaceDetail\n </code>\n , the function must be called twice. The first call returns an error but provides the correct size required for the structure, and the second call uses this size to successfully retrieve the device path. This process is essential for identifying the specific path to a device interface, enabling further communication and interaction with the device.\n</p>\n"}, "Page 322": {"response": "<h3>\n Calling\n <code>\n  SetupDiGetDeviceInterfaceDetail\n </code>\n to Retrieve Device Path\n</h3>\n<p>\n To retrieve the device path using\n <code>\n  SetupDiGetDeviceInterfaceDetail\n </code>\n , the function needs to be called twice. Here's a breakdown of the process:\n</p>\n<h4>\n Step 1: First Call to\n <code>\n  SetupDiGetDeviceInterfaceDetail\n </code>\n</h4>\n<p>\n In the first call, you don't know the required buffer size for the structure. Therefore, you call the function with a buffer size of\n <code>\n  0\n </code>\n . The system will return the required buffer size in the\n <code>\n  Length\n </code>\n parameter.\n</p>\n<p>\n Here\u2019s the code for the first call:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n BOOLEAN Result;\nPSP_DEVICE_INTERFACE_DETAIL_DATA DetailData;\nULONG Length;\n\nResult =\n SetupDiGetDeviceInterfaceDetail\n (\n    DeviceInfoSet, \n    &amp;MyDeviceInterfaceData,\n NULL\n ,\n 0\n , \n    &amp;Length,\n NULL\n );\n</code>\n<ul>\n<li>\n<strong>\n   Parameters:\n  </strong>\n<ul>\n<li>\n<code>\n     DeviceInfoSet\n    </code>\n    : Contains information about devices.\n   </li>\n<li>\n<code>\n     &amp;MyDeviceInterfaceData\n    </code>\n    : Points to a structure that describes the device interface.\n   </li>\n<li>\n<code>\n     NULL\n    </code>\n    : Since we\u2019re only retrieving the required buffer size, no structure for device details is provided yet.\n   </li>\n<li>\n<code>\n     0\n    </code>\n    : Indicates no buffer size is provided initially.\n   </li>\n<li>\n<code>\n     &amp;Length\n    </code>\n    : Will store the required buffer size that the function returns.\n   </li>\n<li>\n<code>\n     NULL\n    </code>\n    : Optional pointer to\n    <code>\n     SP_DEVINFO_DATA\n    </code>\n    , not needed in this case.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Step 2: Allocating Memory and Making the Second Call\n</h4>\n<p>\n Once the required buffer size is obtained in the first call, you can allocate memory for the\n <code>\n  DetailData\n </code>\n structure. Then, in the second call, you provide the allocated buffer, pass the required length, and retrieve the device path information.\n</p>\n<p>\n Here\u2019s the code for the second call:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n DetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)\n malloc\n (Length);\nDetailData-&gt;cbSize =\n sizeof\n (SP_DEVICE_INTERFACE_DETAIL_DATA);\n\nResult =\n SetupDiGetDeviceInterfaceDetail\n (\n    DeviceInfoSet, \n    &amp;MyDeviceInterfaceData, \n    DetailData, \n    Length, \n    &amp;Length,\n NULL\n );\n</code>\n<ul>\n<li>\n<strong>\n   Steps:\n  </strong>\n<ol>\n<li>\n<strong>\n     Allocate Memory\n    </strong>\n    :\n    <code>\n     malloc(Length)\n    </code>\n    allocates memory for the\n    <code>\n     DetailData\n    </code>\n    structure based on the required size returned by the first call.\n   </li>\n<li>\n<strong>\n     Set\n     <code>\n      cbSize\n     </code>\n</strong>\n    : The\n    <code>\n     cbSize\n    </code>\n    field of\n    <code>\n     DetailData\n    </code>\n    is set to the size of the\n    <code>\n     SP_DEVICE_INTERFACE_DETAIL_DATA\n    </code>\n    structure to ensure proper memory alignment.\n   </li>\n<li>\n<strong>\n     Second Call\n    </strong>\n    : The function is called again, this time with a valid buffer, to fill in the details, including the device path.\n   </li>\n</ol>\n</li>\n</ul>\n<h4>\n Result\n</h4>\n<p>\n The second call successfully fills the\n <code>\n  DetailData\n </code>\n structure with the device path information. This path can then be used to open the device and interact with it programmatically.\n</p>\n<h4>\n Summary\n</h4>\n<p>\n To retrieve a device path using\n <code>\n  SetupDiGetDeviceInterfaceDetail\n </code>\n , you must first call the function to determine the required buffer size. Then, allocate the necessary memory and make a second call to actually retrieve the device details, including the path. This two-step process ensures that you have enough memory to hold the device path data returned by the function.\n</p>\n"}, "Page 323": {"response": "<h3>\n Visual Basic Approach to\n <code>\n  SetupDiGetDeviceInterfaceDetail\n </code>\n</h3>\n<p>\n In Visual Basic, the process for retrieving the device path using\n <code>\n  SetupDiGetDeviceInterfaceDetail\n </code>\n differs slightly from other languages like C++. Instead of declaring a specific structure for the device path, Visual Basic reserves a generic buffer to store the device path information. Here's how it works in detail:\n</p>\n<h4>\n Structure for Device Path Information\n</h4>\n<p>\n While Visual Basic doesn't explicitly declare an\n <code>\n  SP_DEVICE_INTERFACE_DETAIL_DATA\n </code>\n structure in the code, we can still understand what this structure would contain. Here\u2019s how it would look if declared:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;StructLayout(LayoutKind.Sequential)&gt; _\n Public\n Structure\n SP_DEVICE_INTERFACE_DETAIL_DATA\n Dim\n cbSize\n As\n Integer\n Dim\n DevicePath\n As\n String\n End\n Structure\n</code>\n<ul>\n<li>\n<strong>\n<code>\n    cbSize\n   </code>\n</strong>\n  : This is the size of the structure.\n </li>\n<li>\n<strong>\n<code>\n    DevicePath\n   </code>\n</strong>\n  : This is the actual path to the device.\n </li>\n</ul>\n<p>\n However, in the Visual Basic code, we won't directly use this structure. Instead, a generic buffer is used, and the device path is extracted from it.\n</p>\n<h4>\n Declaring the Function\n</h4>\n<p>\n In Visual Basic, the declaration for the\n <code>\n  SetupDiGetDeviceInterfaceDetail\n </code>\n function is as follows:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;DllImport(\n \"setupapi.dll\"\n , CharSet:=CharSet.\n Auto\n )&gt; _\n Function\n SetupDiGetDeviceInterfaceDetail _\n    (\n ByVal\n DeviceInfoSet\n As\n IntPtr, _\n ByRef\n DeviceInterfaceData\n As\n SP_DEVICE_INTERFACE_DATA, _\n ByVal\n DeviceInterfaceDetailData\n As\n IntPtr, _\n ByVal\n DeviceInterfaceDetailDataSize\n As\n Integer\n , _\n ByRef\n RequiredSize\n As\n Integer\n , _\n ByVal\n DeviceInfoData\n As\n IntPtr) _\n As\n Boolean\n End\n Function\n</code>\n<p>\n This function allows us to retrieve detailed information about a device interface, including the device path.\n</p>\n<h4>\n First Call to\n <code>\n  SetupDiGetDeviceInterfaceDetail\n </code>\n</h4>\n<p>\n In the first call, Visual Basic makes use of a generic buffer and passes its size to the function. The buffer size is determined dynamically, and the system will return the required size in\n <code>\n  BufferSize\n </code>\n . Here\u2019s the code for this first call:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Dim\n BufferSize\n As\n Integer\n Dim\n Success\n As\n Boolean\n Success = SetupDiGetDeviceInterfaceDetail _\n    (DeviceInfoSet, _\n    MyDeviceInterfaceData, _\n    IntPtr.Zero, _\n 0\n , _\n    BufferSize, _\n    IntPtr.Zero)\n</code>\n<ul>\n<li>\n<strong>\n   Parameters:\n  </strong>\n<ul>\n<li>\n<code>\n     DeviceInfoSet\n    </code>\n    : Contains the information about the available devices.\n   </li>\n<li>\n<code>\n     MyDeviceInterfaceData\n    </code>\n    : Contains information about the specific device interface.\n   </li>\n<li>\n<code>\n     IntPtr.Zero\n    </code>\n    : A placeholder for the buffer, indicating that we\u2019re only interested in getting the required buffer size initially.\n   </li>\n<li>\n<code>\n     0\n    </code>\n    : The size of the buffer, which is initially zero since we don\u2019t have the buffer size yet.\n   </li>\n<li>\n<code>\n     BufferSize\n    </code>\n    : Will store the required buffer size, which the system will fill in during the call.\n   </li>\n<li>\n<code>\n     IntPtr.Zero\n    </code>\n    : A placeholder for optional data that isn\u2019t needed in this call.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n After the call,\n <code>\n  BufferSize\n </code>\n will contain the required size for the next call.\n</p>\n<h4>\n Next Steps\n</h4>\n<p>\n After obtaining the\n <code>\n  BufferSize\n </code>\n , you can proceed with allocating the appropriate memory and make a second call to\n <code>\n  SetupDiGetDeviceInterfaceDetail\n </code>\n to retrieve the actual device path.\n</p>\n<h4>\n Summary\n</h4>\n<p>\n In Visual Basic, instead of defining the structure explicitly, you pass a generic buffer and use\n <code>\n  SetupDiGetDeviceInterfaceDetail\n </code>\n to first get the required buffer size. Once you have the size, you can allocate memory and make another call to get the detailed information, such as the device path, which can then be used to interact with the device.\n</p>\n"}, "Page 324": {"response": "<h3>\n Extracting the Device Path Using\n <code>\n  SetupDiGetDeviceInterfaceDetail\n </code>\n in Visual Basic\n</h3>\n<p>\n When working with the\n <code>\n  SetupDiGetDeviceInterfaceDetail\n </code>\n function in Visual Basic, there are a few important steps to follow after obtaining the required buffer size. This process helps retrieve detailed information, including the device path, for the specified device interface.\n</p>\n<h4>\n Preparing for the Next Call\n</h4>\n<p>\n After determining the required buffer size, the next step is to allocate memory for the structure that will hold the device path. This is done using the\n <code>\n  Marshal.AllocHGlobal\n </code>\n method. The\n <code>\n  BufferSize\n </code>\n value, obtained from the first function call, is used to reserve the necessary amount of memory for the structure.\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Dim\n DetailDataBuffer\n As\n IntPtr\nDetailDataBuffer = Marshal.AllocHGlobal(BufferSize)\n</code>\n<p>\n This code allocates memory in unmanaged space for the structure that will store the device details.\n</p>\n<h4>\n Setting Up the Structure\n</h4>\n<p>\n The\n <code>\n  SP_DEVICE_INTERFACE_DETAIL_DATA\n </code>\n structure requires the\n <code>\n  cbSize\n </code>\n field to be set, which is the size of the structure. The\n <code>\n  cbSize\n </code>\n field must account for both the size of the integer (4 bytes) and the length of the device path. When passed to the function, the device path is initially empty.\n</p>\n<p>\n The\n <code>\n  Marshal.WriteInt32\n </code>\n method writes the\n <code>\n  cbSize\n </code>\n value into the first member of the\n <code>\n  DetailDataBuffer\n </code>\n , ensuring it includes the 4 bytes for the integer plus the length of one character for the device path.\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Marshal.WriteInt32(DetailDataBuffer,\n 4\n + Marshal.SystemDefaultCharSize)\n</code>\n<h4>\n Calling\n <code>\n  SetupDiGetDeviceInterfaceDetail\n </code>\n Again\n</h4>\n<p>\n After setting up the buffer, the second call to\n <code>\n  SetupDiGetDeviceInterfaceDetail\n </code>\n can be made. This time, you pass the\n <code>\n  DetailDataBuffer\n </code>\n pointer to the function, along with the\n <code>\n  BufferSize\n </code>\n to retrieve the full device details:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Success = SetupDiGetDeviceInterfaceDetail _\n    (deviceInfoSet, _\n    MyDeviceInterfaceData, _\n    DetailDataBuffer, _\n    BufferSize, _\n    BufferSize, _\n    IntPtr.Zero)\n</code>\n<p>\n This call will populate the\n <code>\n  DetailDataBuffer\n </code>\n with a structure that contains the device path name.\n</p>\n<h4>\n Extracting the Device Path Name\n</h4>\n<p>\n Once the function returns successfully, the device path name will be located in the\n <code>\n  DevicePath\n </code>\n member of the\n <code>\n  SP_DEVICE_INTERFACE_DETAIL_DATA\n </code>\n structure, which is stored in\n <code>\n  DetailDataBuffer\n </code>\n . The application can now access this path to communicate with the device.\n</p>\n<h3>\n Summary\n</h3>\n<p>\n To retrieve a device's path using\n <code>\n  SetupDiGetDeviceInterfaceDetail\n </code>\n , the process involves two calls to the function. The first call determines the required buffer size, and the second call retrieves the device path into the allocated buffer. The device path can then be extracted from the structure returned in the buffer, allowing the application to access the device directly.\n</p>\n"}, "Page 325": {"response": "<h3>\n Retrieving and Handling the Device Path Name\n</h3>\n<p>\n After calling the\n <code>\n  SetupDiGetDeviceInterfaceDetail\n </code>\n function, you can retrieve the device path name, which allows communication with the device. This process varies slightly between Visual C++ and Visual Basic, but the general flow is the same.\n</p>\n<h4>\n In Visual C++\n</h4>\n<p>\n Once the\n <code>\n  SetupDiGetDeviceInterfaceDetail\n </code>\n function has populated the\n <code>\n  DetailData\n </code>\n structure, you can access the device path name directly from the\n <code>\n  DevicePath\n </code>\n member:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n DevicePathName = DetailData-&gt;DevicePath;\n</code>\n<h4>\n In Visual Basic\n</h4>\n<p>\n In Visual Basic, the device path name is located starting at byte 5 of the\n <code>\n  DetailDataBuffer\n </code>\n , with the first four bytes reserved for the\n <code>\n  cbSize\n </code>\n member. You need to use an\n <code>\n  IntPtr\n </code>\n to point to the beginning of the device path name and then retrieve the string from the buffer:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Dim\n DevicePathName(\n 127\n )\n As\n String\n Dim\n pDevicePathName\n As\n IntPtr =\n New\n IntPtr(DetailDataBuffer.ToInt32 +\n 4\n )\nDevicePathName = Marshal.PtrToStringAuto(pDevicePathName)\n</code>\n<p>\n After extracting the device path name, it's important to free the memory allocated for\n <code>\n  DetailDataBuffer\n </code>\n to prevent memory leaks:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Marshal.FreeHGlobal(DetailDataBuffer)\n</code>\n<h4>\n Closing Communications\n</h4>\n<p>\n Once the device information set (\n <code>\n  DeviceInfoSet\n </code>\n ) returned by\n <code>\n  SetupDiGetClassDevs\n </code>\n is no longer needed, it is crucial to free the associated resources by calling\n <code>\n  SetupDiDestroyDeviceInfoList\n </code>\n . This ensures that the application does not hold on to unnecessary memory or resources.\n</p>\n<h5>\n In Visual C++\n</h5>\n<p>\n To destroy the device information list in Visual C++, use the following function declaration and call:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n BOOL\n SetupDiDestroyDeviceInfoList\n (HDEVINFO DeviceInfoSet)\n ;\n</code>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n SetupDiDestroyDeviceInfoList\n (DeviceInfoSet);\n</code>\n<p>\n This properly cleans up the resources used to store device information.\n</p>\n"}, "Page 326": {"response": "<h3>\n Closing the Device Information Set and Obtaining a Handle\n</h3>\n<h4>\n Freeing Resources in Visual Basic\n</h4>\n<p>\n In Visual Basic, once you're finished with the\n <code>\n  DeviceInfoSet\n </code>\n (which contains the list of devices), you must clean up by calling the\n <code>\n  SetupDiDestroyDeviceInfoList\n </code>\n function. This ensures that all resources allocated to the device information list are properly freed.\n</p>\n<p>\n Here\u2019s the function declaration and the code to call it:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;DllImport(\n \"setupapi.dll\"\n )&gt;\n Function\n SetupDiDestroyDeviceInfoList _\n    (\n ByVal\n DeviceInfoSet\n As\n IntPtr)\n As\n Integer\n End\n Function\n</code>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n SetupDiDestroyDeviceInfoList(deviceInfoSet)\n</code>\n<h4>\n Opening Communications with the Device\n</h4>\n<p>\n After obtaining a device path name, the next step is to establish communication with the device. This is done by obtaining a handle that allows you to interact with the device through handle-based operations.\n</p>\n<h4>\n Requesting a Handle with\n <code>\n  CreateFile\n </code>\n</h4>\n<p>\n To obtain a handle, the\n <code>\n  CreateFile\n </code>\n function is used. This function opens an existing file or device, providing access to the requested resource. It works by passing a device path name, and it is commonly used for communicating with devices, such as exchanging reports with HID (Human Interface Device) class devices.\n</p>\n<h5>\n Visual C++ Declaration for\n <code>\n  CreateFile\n </code>\n</h5>\n<p>\n Here\u2019s the declaration of the\n <code>\n  CreateFile\n </code>\n function in Visual C++:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n HANDLE\n CreateFile\n (\n  LPCTSTR lpFileName,\n // Device path name\n DWORD dwDesiredAccess,\n // Access mode\n DWORD dwShareMode,\n // Sharing mode\n LPSECURITY_ATTRIBUTES lpSecurityAttributes,\n // Security attributes\n DWORD dwCreationDisposition,\n // Action to take on file creation\n DWORD dwFlagsAndAttributes,\n // File or device attributes\n HANDLE hTemplateFile\n // Template file (optional)\n )\n ;\n</code>\n<p>\n Once the\n <code>\n  CreateFile\n </code>\n function is called with the appropriate parameters, it returns a handle that you can use to interact with the device.\n</p>\n"}, "Page 327": {"response": "<h3>\n Requesting and Closing Device Handles\n</h3>\n<h4>\n Opening Communications with the Device in Visual C++\n</h4>\n<p>\n Once you have a device path name, you can use the\n <code>\n  CreateFile\n </code>\n function to obtain a handle for communication with the device. This handle allows you to send and receive data from the device, such as reports for HID-class devices.\n</p>\n<h5>\n Visual C++ Code for Opening a Device Handle\n</h5>\n<p>\n Here\u2019s how you use the\n <code>\n  CreateFile\n </code>\n function in Visual C++:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n HANDLE DeviceHandle;\nDeviceHandle =\n CreateFile\n (\n  DetailData-&gt;DevicePath,\n // Device path from SetupDiGetDeviceInterfaceDetail\n GENERIC_READ | GENERIC_WRITE,\n // Desired access: Read and Write\n FILE_SHARE_READ | FILE_SHARE_WRITE,\n // Allow sharing of file for reading and writing\n (LPSECURITY_ATTRIBUTES)\n NULL\n ,\n // No security attributes\n OPEN_EXISTING,\n // Open existing file/device\n 0\n ,\n // No special flags or attributes\n NULL\n // No template file\n );\n</code>\n<p>\n This code opens the device located at\n <code>\n  DetailData-&gt;DevicePath\n </code>\n with read and write access. The file sharing mode allows other processes to read or write to the file simultaneously. The\n <code>\n  OPEN_EXISTING\n </code>\n flag ensures that the function opens the device only if it already exists. The\n <code>\n  NULL\n </code>\n values for security attributes and the template file indicate no special options.\n</p>\n<h4>\n Closing the Handle\n</h4>\n<p>\n After you're done using the handle, it\u2019s important to free up the resources associated with it using the\n <code>\n  CloseHandle\n </code>\n function.\n</p>\n<h5>\n Visual Basic Code for Creating a Handle\n</h5>\n<p>\n In Visual Basic, the process is similar, but you may need to define the\n <code>\n  SECURITY_ATTRIBUTES\n </code>\n structure for use with\n <code>\n  CreateFile\n </code>\n .\n</p>\n<h5>\n Declaring the\n <code>\n  SECURITY_ATTRIBUTES\n </code>\n Structure in Visual Basic\n</h5>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;StructLayout(LayoutKind.Sequential)&gt; _\n Public\n Structure\n SECURITY_ATTRIBUTES\n Dim\n nLength\n As\n Integer\n Dim\n lpSecurityDescriptor\n As\n Integer\n Dim\n bInheritHandle\n As\n Integer\n End\n Structure\n</code>\n<p>\n This structure contains the security attributes for the handle, including its length, a security descriptor, and an inheritance flag.\n</p>\n<h4>\n Functions for Handle Management\n</h4>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     API Function\n    </strong>\n</th>\n<th>\n<strong>\n     DLL\n    </strong>\n</th>\n<th>\n<strong>\n     Purpose\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<code>\n     CloseHandle\n    </code>\n</td>\n<td>\n<code>\n     kernel32\n    </code>\n</td>\n<td>\n    Frees the resources used by a handle.\n   </td>\n</tr>\n<tr>\n<td>\n<code>\n     CreateFile\n    </code>\n</td>\n<td>\n<code>\n     kernel32\n    </code>\n</td>\n<td>\n    Retrieves a handle for communicating with a device.\n   </td>\n</tr>\n</tbody>\n</table>\n"}, "Page 328": {"response": "<h3>\n Using CreateFile to Open a Device Handle in Visual Basic\n</h3>\n<p>\n In Visual Basic, the\n <code>\n  CreateFile\n </code>\n function allows an application to open a device and retrieve a handle for communication with it. This handle can be used to read from or write to the device, such as sending or receiving HID reports. Below is the structure and usage of this function.\n</p>\n<h4>\n Function Declaration in Visual Basic\n</h4>\n<p>\n The declaration for\n <code>\n  CreateFile\n </code>\n in Visual Basic looks like this:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;DllImport(\n \"kernel32.dll\"\n , CharSet:=CharSet.\n Auto\n )&gt;\n Function\n CreateFile _\n    (\n ByVal\n lpFileName\n As\n String\n , _\n ByVal\n dwDesiredAccess\n As\n Integer\n , _\n ByVal\n dwShareMode\n As\n Integer\n , _\n ByRef\n lpSecurityAttributes\n As\n SECURITY_ATTRIBUTES, _\n ByVal\n dwCreationDisposition\n As\n Integer\n , _\n ByVal\n dwFlagsAndAttributes\n As\n Integer\n , _\n ByVal\n hTemplateFile\n As\n Integer\n ) _\n As\n Integer\n End\n Function\n</code>\n<h4>\n Calling CreateFile in Visual Basic\n</h4>\n<p>\n To call this function, define constants for the flags that specify access and sharing modes, and then call\n <code>\n  CreateFile\n </code>\n with the appropriate parameters:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Public\n Const\n GENERIC_READ =\n &amp;H80000000\n Public\n Const\n GENERIC_WRITE =\n &amp;H40000000\n Public\n Const\n FILE_SHARE_READ =\n &amp;H1\n Public\n Const\n FILE_SHARE_WRITE =\n &amp;H2\n Public\n Const\n OPEN_EXISTING =\n 3\n Dim\n DeviceHandle\n As\n Integer\n Dim\n Security\n As\n SECURITY_ATTRIBUTES\nSecurity.lpSecurityDescriptor =\n 0\n Security.bInheritHandle =\n CInt\n (\n True\n )\nSecurity.nLength = Len(Security)\n\nDeviceHandle = CreateFile _\n    (DevicePathName, _\n    GENERIC_READ\n Or\n GENERIC_WRITE, _\n    FILE_SHARE_READ\n Or\n FILE_SHARE_WRITE, _\n    Security, _\n    OPEN_EXISTING, _\n 0\n , _\n 0\n )\n</code>\n<h4>\n Parameters of the CreateFile Function\n</h4>\n<ul>\n<li>\n<strong>\n<code>\n    lpFileName\n   </code>\n</strong>\n  : The device path name (from the earlier steps using\n  <code>\n   SetupDiGetDeviceInterfaceDetail\n  </code>\n  ).\n </li>\n<li>\n<strong>\n<code>\n    dwDesiredAccess\n   </code>\n</strong>\n  : This specifies the type of access required. Here,\n  <code>\n   GENERIC_READ\n  </code>\n  and\n  <code>\n   GENERIC_WRITE\n  </code>\n  request both read and write access.\n </li>\n<li>\n<strong>\n<code>\n    dwShareMode\n   </code>\n</strong>\n  : This defines the sharing mode. By setting it to\n  <code>\n   FILE_SHARE_READ\n  </code>\n  and\n  <code>\n   FILE_SHARE_WRITE\n  </code>\n  , other processes can also read from or write to the device while the handle is open.\n </li>\n<li>\n<strong>\n<code>\n    lpSecurityAttributes\n   </code>\n</strong>\n  : This refers to a\n  <code>\n   SECURITY_ATTRIBUTES\n  </code>\n  structure, which specifies the security settings for the handle (in this case, using default settings).\n </li>\n<li>\n<strong>\n<code>\n    dwCreationDisposition\n   </code>\n</strong>\n  : Set to\n  <code>\n   OPEN_EXISTING\n  </code>\n  to open the device if it exists.\n </li>\n<li>\n<strong>\n<code>\n    dwFlagsAndAttributes\n   </code>\n</strong>\n  : These flags control the file's attributes, set to 0 here for default behavior.\n </li>\n<li>\n<strong>\n<code>\n    hTemplateFile\n   </code>\n</strong>\n  : This parameter is unused, so it's set to 0.\n </li>\n</ul>\n<h4>\n How it Works\n</h4>\n<p>\n The\n <code>\n  CreateFile\n </code>\n function requires the device path name, which is obtained from\n <code>\n  SetupDiGetDeviceInterfaceDetail\n </code>\n . The\n <code>\n  dwDesiredAccess\n </code>\n parameter specifies the access permissions for reading and writing to the device. The\n <code>\n  dwShareMode\n </code>\n allows other processes to access the device while the handle is open, ensuring that multiple applications can interact with the device concurrently.\n</p>\n<p>\n After calling\n <code>\n  CreateFile\n </code>\n , the function returns a handle (\n <code>\n  DeviceHandle\n </code>\n ), which is used for communication with the device.\n</p>\n"}, "Page 329": {"response": "<h3>\n Chapter 10: Device Handle Management and Detection\n</h3>\n<h4>\n Closing the Handle\n</h4>\n<p>\n When you interact with a device, particularly in contexts like HID-class devices, you'll need to manage resources effectively by closing device handles once communication is complete. This is crucial to prevent memory leaks or other issues that might arise from leaving open handles.\n</p>\n<p>\n The\n <code>\n  CloseHandle\n </code>\n function is used to close a handle after communication is finished. This function releases any resources allocated by the device handle, ensuring proper cleanup.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Function Declaration in Visual C++\n   </strong>\n   :\n  </p>\n  cpp\n  Copy code\n  <code class=\"!whitespace-pre hljs language-cpp\">\n   BOOL\n   CloseHandle\n   (HANDLE hObject)\n   ;\n  </code>\n</li>\n<li>\n<p>\n<strong>\n    Function Call in Visual C++\n   </strong>\n   :\n   <br/>\n   To close a device handle, simply call the function with the appropriate handle:\n  </p>\n  cpp\n  Copy code\n  <code class=\"!whitespace-pre hljs language-cpp\">\n   CloseHandle\n   (DeviceHandle);\n  </code>\n</li>\n<li>\n<p>\n<strong>\n    Function Declaration in Visual Basic\n   </strong>\n   :\n   <br/>\n   In Visual Basic, the declaration is as follows:\n  </p>\n  vb\n  Copy code\n  <code class=\"!whitespace-pre hljs language-vb\">\n   &lt;DllImport(\n   \"kernel32.dll\"\n   )&gt;\n   Function\n   CloseHandle _\n    (\n   ByVal\n   hObject\n   As\n   Integer\n   ) _\n   As\n   Integer\n   End\n   Function\n  </code>\n</li>\n<li>\n<p>\n<strong>\n    Function Call in Visual Basic\n   </strong>\n   :\n   <br/>\n   The call to close the handle looks like this:\n  </p>\n  vb\n  Copy code\n  <code class=\"!whitespace-pre hljs language-vb\">\n   CloseHandle(DeviceHandle)\n  </code>\n</li>\n</ul>\n<h4>\n Detecting Device Attachment and Removal\n</h4>\n<p>\n Detecting when a device is attached or removed is often a necessary feature for applications. By knowing when a device is connected or disconnected, you can automate interactions, such as beginning communication upon attachment or stopping communication when the device is removed.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Device Attachment\n   </strong>\n   :\n   <br/>\n   Applications can monitor device attachment events, allowing them to automatically start communication once a device is connected.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Device Removal\n   </strong>\n   :\n   <br/>\n   Similarly, detecting when a device is removed helps ensure the application can stop communication and clean up resources as needed.\n  </p>\n</li>\n</ul>\n<p>\n The details of detecting these events will depend on the specific device driver, but handling attachment and removal is a key part of managing device communication in many applications.\n</p>\n"}, "Page 330": {"response": "<h3>\n Detecting Devices and Device Notifications\n</h3>\n<h4>\n Overview of Device Notifications\n</h4>\n<p>\n Applications often need to be informed when a device is attached or removed, especially in systems that rely on USB devices. Windows provides a mechanism for this through device notifications. When a device is connected or disconnected, the operating system sends notification messages to an application, allowing it to respond appropriately (e.g., notifying the user or pausing operations). These notifications are typically WM_DEVICECHANGE messages, which are passed to the window's message processing method (WindowProc in C++ or WndProc in Visual Basic).\n</p>\n<p>\n An application can override the default message handling function (WindowProc or WndProc) to process the device notification messages. Each message contains a device path that can be used to identify the device associated with the notification.\n</p>\n<h4>\n Registering for Device Notifications\n</h4>\n<p>\n To receive device attachment or removal notifications, an application must register for device notifications using the\n <code>\n  RegisterDeviceNotification\n </code>\n function. This function requires three parameters:\n</p>\n<ol>\n<li>\n<strong>\n   Window or Service Handle\n  </strong>\n  : A pointer to a handle for the window or service that will receive the notifications.\n </li>\n<li>\n<strong>\n   DEV_BROADCAST_DEVICEINTERFACE Structure\n  </strong>\n  : This structure contains details about the device interface class the application wants to be notified about. The\n  <code>\n   dbcc_devicetype\n  </code>\n  member should be set to\n  <code>\n   DBT_DEVTYP_DEVICEINTERFACE\n  </code>\n  to specify that notifications for device interfaces are desired. The\n  <code>\n   classguid\n  </code>\n  field should contain the GUID for the device interface class (e.g.,\n  <code>\n   HidGuid\n  </code>\n  for HID devices).\n </li>\n<li>\n<strong>\n   Flags\n  </strong>\n  : These flags indicate whether the handle is for a window or a service, which helps the system understand the type of notifications expected.\n </li>\n</ol>\n<p>\n The\n <code>\n  RegisterDeviceNotification\n </code>\n function tells Windows to send WM_DEVICECHANGE messages to the application when a device of the specified type is added or removed.\n</p>\n<h4>\n Unregistering from Device Notifications\n</h4>\n<p>\n When the application no longer needs to receive device notifications, it should unregister by calling the\n <code>\n  UnregisterDeviceNotification\n </code>\n function. This ensures that the application stops receiving unnecessary notifications and frees up system resources.\n</p>\n<p>\n The key takeaway is that device notifications allow applications to automatically respond to hardware changes, improving usability and efficiency when managing devices like USB peripherals.\n</p>\n"}, "Page 331": {"response": "<h3>\n Registering and Using Device Notifications in Visual C++\n</h3>\n<h4>\n DEV_BROADCAST_DEVICEINTERFACE Structure\n</h4>\n<p>\n To register for device notifications in Visual C++, an application uses the\n <code>\n  DEV_BROADCAST_DEVICEINTERFACE\n </code>\n structure. This structure contains details about the type of device the application wants to be notified about.\n</p>\n<p>\n The structure is defined as follows:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n typedef\n struct\n _DEV_BROADCAST_DEVICEINTERFACE\n {\n    DWORD dbcc_size;\n // Size of the structure\n DWORD dbcc_devicetype;\n // Type of device (e.g., device interface)\n DWORD dbcc_reserved;\n // Reserved, must be zero\n GUID dbcc_classguid;\n // GUID for the device interface class\n TCHAR dbcc_name[\n 1\n ];\n // Device name (not used in this case)\n } DEV_BROADCAST_DEVICEINTERFACE, *PDEV_BROADCAST_DEVICEINTERFACE;\n</code>\n<ul>\n<li>\n<strong>\n   dbcc_size\n  </strong>\n  : Specifies the size of the structure.\n </li>\n<li>\n<strong>\n   dbcc_devicetype\n  </strong>\n  : Defines the type of device the application is interested in (e.g.,\n  <code>\n   DBT_DEVTYP_DEVICEINTERFACE\n  </code>\n  for device interfaces).\n </li>\n<li>\n<strong>\n   dbcc_classguid\n  </strong>\n  : A GUID that identifies the device interface class, such as\n  <code>\n   HidGuid\n  </code>\n  for HID devices.\n </li>\n<li>\n<strong>\n   dbcc_name\n  </strong>\n  : This is a placeholder for the device's name, though it's not typically used for device interface notifications.\n </li>\n</ul>\n<h4>\n Registering for Device Notifications\n</h4>\n<p>\n To request device notifications, you use the\n <code>\n  RegisterDeviceNotification\n </code>\n function. It requires three parameters:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n HDEVNOTIFY\n RegisterDeviceNotification\n (\n  HANDLE hRecipient,\n // Handle for the window or service receiving notifications\n LPVOID NotificationFilter,\n // Pointer to the filter structure (e.g., DEV_BROADCAST_DEVICEINTERFACE)\n DWORD Flags\n // Flags that indicate whether the recipient is a window or service\n )\n ;\n</code>\n<p>\n Here's an example of how to use it in code:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n HDEVNOTIFY DeviceNotificationHandle;\nDEV_BROADCAST_DEVICEINTERFACE DevBroadcastDeviceInterface;\n\nDevBroadcastDeviceInterface.dbcc_size =\n sizeof\n (DevBroadcastDeviceInterface);\nDevBroadcastDeviceInterface.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;\nDevBroadcastDeviceInterface.dbcc_classguid = HidGuid;\n</code>\n<ul>\n<li>\n<strong>\n   DeviceNotificationHandle\n  </strong>\n  : A handle returned by the\n  <code>\n   RegisterDeviceNotification\n  </code>\n  function that can be used to manage the notification subscription.\n </li>\n<li>\n<strong>\n   DevBroadcastDeviceInterface\n  </strong>\n  : This structure is populated with details about the device interface class you want to receive notifications for, including the class GUID (\n  <code>\n   HidGuid\n  </code>\n  for HID devices).\n </li>\n</ul>\n<h4>\n API Functions for Device Notification\n</h4>\n<p>\n The following API functions are used to manage device notifications:\n</p>\n<ul>\n<li>\n<strong>\n   RegisterDeviceNotification (user32.dll)\n  </strong>\n  : This function is used to request that the application receive notifications when a device is attached or removed.\n </li>\n<li>\n<strong>\n   UnregisterDeviceNotification (user32.dll)\n  </strong>\n  : When the application no longer needs to receive notifications, this function is called to stop receiving them.\n </li>\n</ul>\n<p>\n These functions allow the application to manage when and how it receives updates about device changes, enabling efficient and responsive handling of USB or other connected devices.\n</p>\n"}, "Page 332": {"response": "<h3>\n Detecting Devices in Visual Basic\n</h3>\n<h4>\n Registering for Device Notifications\n</h4>\n<p>\n In Visual Basic, device notifications are set up using constants and structures defined in the\n <code>\n  dbt.h\n </code>\n and\n <code>\n  setupapi.h\n </code>\n header files. These constants help the application specify how to receive device-related notifications, such as when a device is attached or removed.\n</p>\n<p>\n To register for device notifications, the\n <code>\n  RegisterDeviceNotification\n </code>\n function is used. It requires three key parameters:\n</p>\n<ol>\n<li>\n<strong>\n   Recipient Handle (\n   <code>\n    hRecipient\n   </code>\n   )\n  </strong>\n  : This is the window handle (\n  <code>\n   m_hWnd\n  </code>\n  in the example) that will receive the notifications.\n </li>\n<li>\n<strong>\n   Notification Filter (\n   <code>\n    NotificationFilter\n   </code>\n   )\n  </strong>\n  : This is a pointer to a structure, typically\n  <code>\n   DEV_BROADCAST_DEVICEINTERFACE\n  </code>\n  , that specifies the type of device and the conditions for notification.\n </li>\n<li>\n<strong>\n   Flags (\n   <code>\n    Flags\n   </code>\n   )\n  </strong>\n  : This indicates how the notification will be delivered. For example,\n  <code>\n   DEVICE_NOTIFY_WINDOW_HANDLE\n  </code>\n  specifies that notifications should be sent to a window handle.\n </li>\n</ol>\n<p>\n In Visual Basic, the code to register for device notifications is as follows:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n DeviceNotificationHandle = RegisterDeviceNotification( _\n    m_hWnd, _\n    &amp;DevBroadcastDeviceInterface, _\n    DEVICE_NOTIFY_WINDOW_HANDLE)\n</code>\n<h4>\n Key Constants for Device Notifications\n</h4>\n<p>\n The following constants are used to define and manage device notifications in Visual Basic:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    From\n    <code>\n     dbt.h\n    </code>\n</strong>\n   :\n  </p>\n<ul>\n<li>\n<code>\n     DBT_DEVTYP_DEVICEINTERFACE\n    </code>\n    = 5: Specifies that notifications are for a device interface.\n   </li>\n<li>\n<code>\n     DEVICE_NOTIFY_WINDOW_HANDLE\n    </code>\n    = 0: Indicates that notifications will be sent to a window handle.\n   </li>\n<li>\n<code>\n     WM_DEVICECHANGE\n    </code>\n    = &amp;H219: The Windows message that indicates a device has been added or removed.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    From\n    <code>\n     setupapi.h\n    </code>\n</strong>\n   :\n  </p>\n<ul>\n<li>\n<code>\n     DIGCF_PRESENT\n    </code>\n    = &amp;H2S: Requests devices that are currently present.\n   </li>\n<li>\n<code>\n     DIGCF_DEVICEINTERFACE\n    </code>\n    = &amp;H10S: Requests devices that have an interface.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n DEV_BROADCAST_DEVICEINTERFACE Structure in Visual Basic\n</h4>\n<p>\n The structure\n <code>\n  DEV_BROADCAST_DEVICEINTERFACE\n </code>\n is used to specify the device interface class that the application wants to monitor. In Visual Basic, the structure is defined as a class with the following properties:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;StructLayout(LayoutKind.Sequential)&gt; _\n Public\n Class\n DEV_BROADCAST_DEVICEINTERFACE\n Public\n dbcc_size\n As\n Integer\n Public\n dbcc_devicetype\n As\n Integer\n Public\n dbcc_reserved\n As\n Integer\n Public\n dbcc_classguid\n As\n Guid\n Public\n dbcc_name\n As\n Short\n End\n Class\n</code>\n<ul>\n<li>\n<strong>\n   dbcc_size\n  </strong>\n  : Specifies the size of the structure.\n </li>\n<li>\n<strong>\n   dbcc_devicetype\n  </strong>\n  : Indicates the type of device to monitor (e.g.,\n  <code>\n   DBT_DEVTYP_DEVICEINTERFACE\n  </code>\n  ).\n </li>\n<li>\n<strong>\n   dbcc_classguid\n  </strong>\n  : The GUID for the device interface class to be monitored (such as\n  <code>\n   HidGuid\n  </code>\n  for HID devices).\n </li>\n<li>\n<strong>\n   dbcc_name\n  </strong>\n  : A short value used for the device name (typically unused for device interface notifications).\n </li>\n</ul>\n<h4>\n RegisterDeviceNotification Function in Visual Basic\n</h4>\n<p>\n The declaration for the\n <code>\n  RegisterDeviceNotification\n </code>\n function in Visual Basic is as follows:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;DllImport(\n \"user32.dll\"\n , CharSet:=CharSet.\n Auto\n )&gt; _\n Function\n RegisterDeviceNotification( _\n ByVal\n hRecipient\n As\n IntPtr, _\n ByVal\n NotificationFilter\n As\n IntPtr, _\n ByVal\n Flags\n As\n Int32)\n As\n IntPtr\n End\n Function\n</code>\n<p>\n This function is called to register the application to receive notifications about device changes, such as when a device is attached or removed. The function takes three parameters:\n</p>\n<ol>\n<li>\n<strong>\n   hRecipient\n  </strong>\n  : The window handle (\n  <code>\n   IntPtr\n  </code>\n  ) where notifications will be sent.\n </li>\n<li>\n<strong>\n   NotificationFilter\n  </strong>\n  : A pointer to a structure that specifies the type of devices to monitor (e.g.,\n  <code>\n   DEV_BROADCAST_DEVICEINTERFACE\n  </code>\n  ).\n </li>\n<li>\n<strong>\n   Flags\n  </strong>\n  : A set of flags that define how the notifications will be delivered (e.g.,\n  <code>\n   DEVICE_NOTIFY_WINDOW_HANDLE\n  </code>\n  ).\n </li>\n</ol>\n<p>\n By setting up these elements correctly, your application can detect when a device is attached or removed and respond accordingly.\n</p>\n"}, "Page 333": {"response": "<h3>\n Registering for Device Notifications in Visual Basic (Code Example)\n</h3>\n<h4>\n Setting Up for Device Notifications\n</h4>\n<p>\n To register for device notifications in Visual Basic, the\n <code>\n  DEV_BROADCAST_DEVICEINTERFACE\n </code>\n structure is first created and populated with necessary information about the device type and class. The process involves using the\n <code>\n  Marshal\n </code>\n class to work with unmanaged memory and ensure that the structure is correctly passed to the\n <code>\n  RegisterDeviceNotification\n </code>\n function.\n</p>\n<p>\n Here's the breakdown of the code:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Define and Initialize the Structure\n   </strong>\n   :\nThe\n   <code>\n    DEV_BROADCAST_DEVICEINTERFACE\n   </code>\n   structure is instantiated and the size of the structure is determined using\n   <code>\n    Marshal.SizeOf\n   </code>\n   . This size is stored in the structure's\n   <code>\n    dbcc_size\n   </code>\n   member.\n  </p>\n  vb\n  Copy code\n  <code class=\"!whitespace-pre hljs language-vb\">\n   Dim\n   DevBroadcastDeviceInterface\n   As\n   DEV_BROADCAST_DEVICEINTERFACE = _\n   New\n   DEV_BROADCAST_DEVICEINTERFACE()\n   Dim\n   Size\n   As\n   Integer\n   Size = Marshal.SizeOf(DevBroadcastDeviceInterface)\nDevBroadcastDeviceInterface.dbcc_size = Size\nDevBroadcastDeviceInterface.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE\nDevBroadcastDeviceInterface.dbcc_reserved =\n   0\n   DevBroadcastDeviceInterface.dbcc_classguid = HidGuid\n  </code>\n<ul>\n<li>\n<strong>\n     dbcc_size\n    </strong>\n    : Stores the size of the structure, which is needed by\n    <code>\n     RegisterDeviceNotification\n    </code>\n    .\n   </li>\n<li>\n<strong>\n     dbcc_devicetype\n    </strong>\n    : Set to\n    <code>\n     DBT_DEVTYP_DEVICEINTERFACE\n    </code>\n    to indicate the application is monitoring a device interface.\n   </li>\n<li>\n<strong>\n     dbcc_reserved\n    </strong>\n    : Set to 0, as it is reserved for future use.\n   </li>\n<li>\n<strong>\n     dbcc_classguid\n    </strong>\n    : The GUID for the device class the application is interested in (e.g.,\n    <code>\n     HidGuid\n    </code>\n    for HID devices).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Reserve Memory for the Structure\n   </strong>\n   :\nNext,\n   <code>\n    Marshal.AllocHGlobal\n   </code>\n   is used to allocate unmanaged memory for a buffer that will hold the\n   <code>\n    DEV_BROADCAST_DEVICEINTERFACE\n   </code>\n   structure.\n  </p>\n  vb\n  Copy code\n  <code class=\"!whitespace-pre hljs language-vb\">\n   Dim\n   DevBroadcastDeviceInterfaceBuffer\n   As\n   IntPtr\nDevBroadcastDeviceInterfaceBuffer = Marshal.AllocHGlobal(Size)\n  </code>\n<ul>\n<li>\n<strong>\n     DevBroadcastDeviceInterfaceBuffer\n    </strong>\n    : A pointer to the unmanaged memory buffer that will hold the structure.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Copy the Structure to Unmanaged Memory\n   </strong>\n   :\nThe\n   <code>\n    Marshal.StructureToPtr\n   </code>\n   method is then called to copy the populated structure into the allocated memory buffer.\n  </p>\n  vb\n  Copy code\n  <code class=\"!whitespace-pre hljs language-vb\">\n   Marshal.StructureToPtr(DevBroadcastDeviceInterface, _\n    DevBroadcastDeviceInterfaceBuffer, _\n   True\n   )\n  </code>\n<ul>\n<li>\n<strong>\n     True\n    </strong>\n    : This flag indicates that the original structure should be cleaned up once it is copied.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Call RegisterDeviceNotification\n   </strong>\n   :\nWith the structure copied to unmanaged memory, the\n   <code>\n    RegisterDeviceNotification\n   </code>\n   function is called to register for notifications. The application is now set up to receive notifications about device changes (e.g., device attachment or removal).\n  </p>\n  vb\n  Copy code\n  <code class=\"!whitespace-pre hljs language-vb\">\n   Dim\n   DeviceNotificationHandle\n   As\n   IntPtr\nDeviceNotificationHandle = RegisterDeviceNotification( _\n    frmMy.Handle, _\n    DevBroadcastDeviceInterfaceBuffer, _\n    DEVICE_NOTIFY_WINDOW_HANDLE)\n  </code>\n<ul>\n<li>\n<strong>\n     frmMy.Handle\n    </strong>\n    : The handle of the window (e.g.,\n    <code>\n     frmMain\n    </code>\n    ), which will receive the device notifications.\n   </li>\n<li>\n<strong>\n     DEVICE_NOTIFY_WINDOW_HANDLE\n    </strong>\n    : This flag indicates that the notifications will be sent to a window handle.\n   </li>\n<li>\n<strong>\n     DeviceNotificationHandle\n    </strong>\n    : The handle returned by\n    <code>\n     RegisterDeviceNotification\n    </code>\n    that can be used to manage the device notifications.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Summary\n</h4>\n<p>\n This code example shows how to register for device notifications in a Visual Basic application. It involves creating and populating the\n <code>\n  DEV_BROADCAST_DEVICEINTERFACE\n </code>\n structure, allocating unmanaged memory for it, copying the structure into the allocated memory, and then calling\n <code>\n  RegisterDeviceNotification\n </code>\n to start receiving notifications. This process enables the application to be alerted when devices are attached or removed.\n</p>\n"}, "Page 334": {"response": "<h3>\n Handling Device Change Messages\n</h3>\n<h4>\n Freeing Allocated Memory\n</h4>\n<p>\n Once the\n <code>\n  DEV_BROADCAST_DEVICEINTERFACE\n </code>\n buffer (allocated with\n <code>\n  Marshal.AllocHGlobal\n </code>\n ) is no longer needed, it is important to free the memory to prevent memory leaks. This is done using the\n <code>\n  Marshal.FreeHGlobal\n </code>\n method.\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Marshal.FreeHGlobal(DevBroadcastDeviceInterfaceBuffer)\n</code>\n<p>\n This releases the unmanaged memory used for the buffer, ensuring that system resources are properly cleaned up.\n</p>\n<h4>\n Capturing Device Change Messages\n</h4>\n<p>\n To capture device change messages (\n <code>\n  WM_DEVICECHANGE\n </code>\n ), the application must handle these messages in its message processing function. These messages are sent by the operating system whenever a device is attached or removed.\n</p>\n<h5>\n Visual C++ (Message Map)\n</h5>\n<p>\n In Visual C++, the message map for a dialog box must be configured to handle\n <code>\n  WM_DEVICECHANGE\n </code>\n messages. This is done by adding an entry in the message map for the\n <code>\n  ON_WM_DEVICECHANGE()\n </code>\n function.\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n BEGIN_MESSAGE_MAP\n (MyApplicationDlg, CDialog)\n //{{AFX_MSG_MAP(MyApplicationDlg)\n .\n    .\n    .\n //}}AFX_MSG_MAP\n ON_WM_DEVICECHANGE\n ()\n END_MESSAGE_MAP\n ()\n</code>\n<p>\n This entry ensures that when a\n <code>\n  WM_DEVICECHANGE\n </code>\n message is received, the application will handle it appropriately.\n</p>\n<h5>\n Visual Basic (WndProc Override)\n</h5>\n<p>\n In Visual Basic, the message processing function\n <code>\n  WndProc\n </code>\n can be overridden to handle the\n <code>\n  WM_DEVICECHANGE\n </code>\n message. The\n <code>\n  WndProc\n </code>\n method processes all messages sent to a window, and by overriding it, you can customize how the application responds to different messages.\n</p>\n<p>\n Here is the code for overriding the\n <code>\n  WndProc\n </code>\n method:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Protected\n Overrides\n Sub\n WndProc(\n ByRef\n m\n As\n Message)\n If\n m.Msg = WM_DEVICECHANGE\n Then\n OnDeviceChange(m)\n End\n If\n MyBase\n .WndProc(m)\n End\n Sub\n</code>\n<ul>\n<li>\n<strong>\n   OnDeviceChange\n  </strong>\n  : When the\n  <code>\n   WM_DEVICECHANGE\n  </code>\n  message is detected, the method calls\n  <code>\n   OnDeviceChange\n  </code>\n  to handle the event.\n </li>\n<li>\n<strong>\n   MyBase.WndProc(m)\n  </strong>\n  : After handling the device change message, the message is passed to the base class\u2019s\n  <code>\n   WndProc\n  </code>\n  method for default processing.\n </li>\n</ul>\n<h4>\n Summary\n</h4>\n<p>\n In both Visual C++ and Visual Basic, device change messages (\n <code>\n  WM_DEVICECHANGE\n </code>\n ) can be captured by overriding the default message handling function (\n <code>\n  WindowProc\n </code>\n in C++ or\n <code>\n  WndProc\n </code>\n in Visual Basic). The application can then respond to these messages (indicating that a device has been added or removed) by implementing custom logic in the\n <code>\n  OnDeviceChange\n </code>\n method. Additionally, any memory allocated for device notification buffers should be properly freed to avoid memory leaks.\n</p>\n"}, "Page 335": {"response": "<h3>\n Reading Device Change Messages\n</h3>\n<p>\n When a window receives a\n <code>\n  WM_DEVICECHANGE\n </code>\n message, it triggers the execution of the\n <code>\n  OnDeviceChange\n </code>\n method. This method can then examine the details of the message and take appropriate action based on the information contained in the message. The\n <code>\n  WM_DEVICECHANGE\n </code>\n message includes two important properties:\n <code>\n  wParam\n </code>\n and\n <code>\n  lParam\n </code>\n .\n</p>\n<h4>\n Understanding the\n <code>\n  wParam\n </code>\n and\n <code>\n  lParam\n </code>\n Properties\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    wParam\n   </strong>\n   : This is a code that indicates the type of device event that occurred, such as whether a device has been added, removed, or if another event has occurred.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    lParam\n   </strong>\n   : This is a pointer to a device management structure that provides more detailed information about the event. There are various types of device management structures, but they all share the same header. The header is defined by the\n   <code>\n    DEV_BROADCAST_HDR\n   </code>\n   structure.\n  </p>\n</li>\n</ul>\n<h4>\n The DEV_BROADCAST_HDR Structure\n</h4>\n<p>\n The\n <code>\n  DEV_BROADCAST_HDR\n </code>\n structure is the common header for all device management structures and includes the following members:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n typedef\n struct\n _DEV_BROADCAST_HDR\n {\n    DWORD dbch_size;\n // Size of the entire structure\n DWORD dbch_devicetype;\n // Type of the device-management structure\n DWORD dbch_reserved;\n // Reserved for future use\n } DEV_BROADCAST_HDR, *PDEV_BROADCAST_HDR;\n</code>\n<ul>\n<li>\n<strong>\n   dbch_size\n  </strong>\n  : Specifies the size of the structure, which is used to ensure that the correct version of the structure is being processed.\n </li>\n<li>\n<strong>\n   dbch_devicetype\n  </strong>\n  : Indicates the type of device management structure that\n  <code>\n   lParam\n  </code>\n  points to. This is critical for determining how to interpret the contents of the structure.\n </li>\n<li>\n<strong>\n   dbch_reserved\n  </strong>\n  : Reserved for future use and must be set to zero.\n </li>\n</ul>\n<h4>\n Handling DEV_BROADCAST_INTERFACE\n</h4>\n<p>\n When\n <code>\n  dbch_devicetype\n </code>\n is set to\n <code>\n  DBT_DEVTYP_DEVICEINTERFACE\n </code>\n , the\n <code>\n  lParam\n </code>\n points to a\n <code>\n  DEV_BROADCAST_DEVICEINTERFACE\n </code>\n structure. This structure provides specific details about the device, including the device's path name. The application can retrieve the complete structure from\n <code>\n  lParam\n </code>\n and then check the\n <code>\n  dbcc_name\n </code>\n member to get the device path name.\n</p>\n<p>\n By comparing the device path name in\n <code>\n  dbcc_name\n </code>\n with the path name of the device the application is interested in, it can determine whether the event pertains to that specific device.\n</p>\n<h4>\n Visual C++ Code Example\n</h4>\n<p>\n Here\u2019s the declaration of the\n <code>\n  DEV_BROADCAST_HDR\n </code>\n structure in Visual C++:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n typedef\n struct\n _DEV_BROADCAST_HDR\n {\n    DWORD dbch_size;\n // Size of the structure\n DWORD dbch_devicetype;\n // Type of device-management structure\n DWORD dbch_reserved;\n // Reserved for future use\n } DEV_BROADCAST_HDR, *PDEV_BROADCAST_HDR;\n</code>\n<p>\n This structure serves as the header for device management structures and is used to identify the type of device event and the specific structure pointed to by\n <code>\n  lParam\n </code>\n .\n</p>\n<h4>\n Summary\n</h4>\n<p>\n When handling a\n <code>\n  WM_DEVICECHANGE\n </code>\n message, the\n <code>\n  OnDeviceChange\n </code>\n method can access both the\n <code>\n  wParam\n </code>\n and\n <code>\n  lParam\n </code>\n properties to gather information about the event. The\n <code>\n  wParam\n </code>\n provides the event code (e.g., device arrival or removal), and the\n <code>\n  lParam\n </code>\n contains a pointer to a device management structure, such as\n <code>\n  DEV_BROADCAST_DEVICEINTERFACE\n </code>\n . By examining the\n <code>\n  DEV_BROADCAST_HDR\n </code>\n structure, the application can determine the type of device event and respond accordingly.\n</p>\n"}, "Page 336": {"response": "<h3>\n Handling Device Change Events in C++ and Visual Basic\n</h3>\n<h4>\n C++ Code for OnDeviceChange Function\n</h4>\n<p>\n In C++, the\n <code>\n  OnDeviceChange\n </code>\n function is responsible for handling device events, such as when a device is added or removed. This function is triggered by receiving a\n <code>\n  WM_DEVICECHANGE\n </code>\n message. It checks the\n <code>\n  wParam\n </code>\n parameter to determine the type of device event and then performs actions based on the event. Here's how the function works:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n BOOL\n CUsbhidiocDlg::OnDeviceChange\n (WPARAM wParam, LPARAM lParam)\n {\n switch\n (wParam) \n  {\n case\n DBT_DEVICEARRIVAL:\n // Check if the device path name matches the event\n // If it does, perform necessary tasks when a device is attached.\n return\n TRUE;\n case\n DBT_DEVICEREMOVECOMPLETE:\n // Check if the device path name matches the event\n // If it does, perform necessary tasks when a device is removed.\n return\n TRUE;\n default\n :\n return\n TRUE; \n  } \n}\n</code>\n<ul>\n<li>\n<strong>\n   wParam\n  </strong>\n  : This parameter indicates the type of event. In this case, it can be\n  <code>\n   DBT_DEVICEARRIVAL\n  </code>\n  (device arrival) or\n  <code>\n   DBT_DEVICEREMOVECOMPLETE\n  </code>\n  (device removal).\n </li>\n<li>\n<strong>\n   lParam\n  </strong>\n  : This contains a pointer to a structure with device-specific information, which can be used to retrieve the device path name.\n </li>\n</ul>\n<p>\n The function checks\n <code>\n  wParam\n </code>\n to determine whether the event is a device arrival or removal. If the device path name matches the one the application is monitoring, the corresponding task (such as handling device attachment or removal) is performed.\n</p>\n<h4>\n Constants for Device Events in Visual Basic\n</h4>\n<p>\n In Visual Basic, the constants for the device events\n <code>\n  DBT_DEVICEARRIVAL\n </code>\n and\n <code>\n  DBT_DEVICEREMOVECOMPLETE\n </code>\n are defined in the\n <code>\n  dbt.h\n </code>\n header file. These constants are used to identify the type of device change event in the\n <code>\n  OnDeviceChange\n </code>\n method:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Public\n Const\n DBT_DEVICEARRIVAL\n As\n Integer\n =\n &amp;H8000\n Public\n Const\n DBT_DEVICEREMOVECOMPLETE\n As\n Integer\n =\n &amp;H8004\n</code>\n<ul>\n<li>\n<strong>\n   DBT_DEVICEARRIVAL\n  </strong>\n  : This constant represents the event when a device is added (device arrival).\n </li>\n<li>\n<strong>\n   DBT_DEVICEREMOVECOMPLETE\n  </strong>\n  : This constant represents the event when a device is removed (device removal).\n </li>\n</ul>\n<p>\n These constants are used in the same way as the\n <code>\n  wParam\n </code>\n values in C++, helping the application detect whether a device was attached or removed.\n</p>\n<h4>\n Summary\n</h4>\n<p>\n The\n <code>\n  OnDeviceChange\n </code>\n function in both C++ and Visual Basic processes device change events, such as when a device is attached or removed. The\n <code>\n  wParam\n </code>\n value indicates the type of event (e.g.,\n <code>\n  DBT_DEVICEARRIVAL\n </code>\n for a new device or\n <code>\n  DBT_DEVICEREMOVECOMPLETE\n </code>\n for a removed device). The application can use this information to perform the appropriate tasks, such as updating the UI or performing cleanup when a device is removed.\n</p>\n"}, "Page 337": {"response": "<h3>\n Handling Device Arrival and Removal Events in Visual Basic\n</h3>\n<h4>\n DEV_BROADCAST_HDR Structure in Visual Basic\n</h4>\n<p>\n In Visual Basic, the\n <code>\n  DEV_BROADCAST_HDR\n </code>\n structure is used to handle the information in device change messages. This structure serves as a header for the device management structure, which holds details about the device event. The structure includes the following members:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;StructLayout(LayoutKind.Sequential)&gt; _\n Public\n Class\n DEV_BROADCAST_HDR\n Public\n dbch_size\n As\n Integer\n ' Size of the structure\n Public\n dbch_devicetype\n As\n Integer\n ' Type of the device-management structure\n Public\n dbch_reserved\n As\n Integer\n ' Reserved for future use\n End\n Class\n</code>\n<ul>\n<li>\n<strong>\n   dbch_size\n  </strong>\n  : The size of the structure, which ensures the application handles the correct version of the structure.\n </li>\n<li>\n<strong>\n   dbch_devicetype\n  </strong>\n  : Specifies the type of device-management structure, such as a device interface.\n </li>\n<li>\n<strong>\n   dbch_reserved\n  </strong>\n  : Reserved for future use; it is set to zero.\n </li>\n</ul>\n<h4>\n Checking for Device Arrival and Removal Events\n</h4>\n<p>\n To handle device arrival and removal messages in Visual Basic, you can check the\n <code>\n  wParam\n </code>\n property of the message in the\n <code>\n  OnDeviceChange\n </code>\n method. If\n <code>\n  wParam\n </code>\n corresponds to a device arrival (\n <code>\n  DBT_DEVICEARRIVAL\n </code>\n ) or device removal (\n <code>\n  DBT_DEVICEREMOVECOMPLETE\n </code>\n ), the application performs specific tasks related to these events.\n</p>\n<p>\n Here\u2019s how to structure the code:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Friend\n Sub\n OnDeviceChange(\n ByVal\n m\n As\n Message)\n If\n (m.WParam.ToInt32 = DBT_DEVICEARRIVAL)\n Then\n ' Check if the device path name matches.\n ' Perform any tasks required for device arrival.\n ElseIf\n (m.WParam.ToInt32 = DBT_DEVICEREMOVECOMPLETE)\n Then\n ' Check if the device path name matches.\n ' Perform any tasks required for device removal.\n End\n If\n End\n Sub\n</code>\n<ul>\n<li>\n<strong>\n   DBT_DEVICEARRIVAL\n  </strong>\n  : This constant corresponds to the event when a device is attached.\n </li>\n<li>\n<strong>\n   DBT_DEVICEREMOVECOMPLETE\n  </strong>\n  : This constant corresponds to the event when a device is removed.\n </li>\n</ul>\n<p>\n In both cases, the application can compare the device path name to see if the event is related to the device of interest, and then perform the necessary actions (e.g., updating the UI or cleaning up resources).\n</p>\n<h4>\n Retrieving the Device Path Name\n</h4>\n<p>\n When a\n <code>\n  WM_DEVICECHANGE\n </code>\n message indicates that a device has been added or removed, the application can gather more information by examining the structure pointed to by\n <code>\n  lParam\n </code>\n .\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    lParam\n   </strong>\n   : Points to a device management structure that contains information about the event. If the\n   <code>\n    dbch_devicetype\n   </code>\n   is set to\n   <code>\n    DBT_DEVTYP_DEVICEINTERFACE\n   </code>\n   , it means the event relates to a device interface. In this case, the structure pointed to by\n   <code>\n    lParam\n   </code>\n   is a\n   <code>\n    DEV_BROADCAST_DEVICEINTERFACE\n   </code>\n   structure, which begins with a\n   <code>\n    DEV_BROADCAST_HDR\n   </code>\n   structure.\n  </p>\n</li>\n<li>\n<p>\n   The\n   <code>\n    dbcc_name\n   </code>\n   member in this structure contains the device path name of the device that the event applies to. The application can retrieve this path name to identify the device involved in the event.\n  </p>\n</li>\n</ul>\n<h4>\n Summary\n</h4>\n<p>\n In Visual Basic, handling device arrival and removal events involves checking the\n <code>\n  wParam\n </code>\n value in the\n <code>\n  OnDeviceChange\n </code>\n method. When a device event occurs, the application can retrieve detailed information, such as the device path name, from the structure pointed to by\n <code>\n  lParam\n </code>\n . If the event is related to a device interface, the\n <code>\n  DEV_BROADCAST_DEVICEINTERFACE\n </code>\n structure provides the device path name, allowing the application to respond appropriately to the event.\n</p>\n"}, "Page 338": {"response": "<h3>\n Comparing Device Path Names in Visual C++\n</h3>\n<p>\n To determine if a device event is related to a specific device, the application can compare the device path name from the\n <code>\n  lParam\n </code>\n structure to the device path name it is interested in. If the names match, the application can take action accordingly.\n</p>\n<h4>\n Retrieving the Device Path Name\n</h4>\n<p>\n In Visual C++, the device path name can be retrieved from the\n <code>\n  DEV_BROADCAST_DEVICEINTERFACE\n </code>\n structure, which is pointed to by\n <code>\n  lParam\n </code>\n . The process of checking the device path name for a match is outlined in the following code:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n PDEV_BROADCAST_HDR lpdb = (PDEV_BROADCAST_HDR)lParam;\n if\n (lpdb-&gt;dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE) \n{\n  PDEV_BROADCAST_DEVICEINTERFACE lpdbi = (PDEV_BROADCAST_DEVICEINTERFACE)lParam;\n  CString DeviceNameString;\n  DeviceNameString = lpdbi-&gt;dbcc_name;\n if\n ((DeviceNameString.\n CompareNoCase\n (DetailData-&gt;DevicePath)) ==\n 0\n )\n  {\n // The names match. Perform actions for the matching device.\n }\n else\n {\n // It\u2019s a different device. Handle as needed.\n }\n}\n</code>\n<ul>\n<li>\n<strong>\n   lpdb\n  </strong>\n  : This is a pointer to the\n  <code>\n   DEV_BROADCAST_HDR\n  </code>\n  structure, which contains general information about the event.\n </li>\n<li>\n<strong>\n   lpdbi\n  </strong>\n  : If the\n  <code>\n   dbch_devicetype\n  </code>\n  is\n  <code>\n   DBT_DEVTYP_DEVICEINTERFACE\n  </code>\n  , this pointer is cast to a\n  <code>\n   DEV_BROADCAST_DEVICEINTERFACE\n  </code>\n  structure, which contains detailed information about the device.\n </li>\n<li>\n<strong>\n   DeviceNameString\n  </strong>\n  : This variable holds the device path name from the\n  <code>\n   dbcc_name\n  </code>\n  member of\n  <code>\n   DEV_BROADCAST_DEVICEINTERFACE\n  </code>\n  .\n </li>\n<li>\n<strong>\n   DetailData-&gt;DevicePath\n  </strong>\n  : This is the device path name the application is interested in. It is compared with the device path name from the message.\n </li>\n</ul>\n<p>\n The comparison uses the\n <code>\n  CompareNoCase\n </code>\n method to check if the device path names match, ignoring case differences. If the names match, the application can perform the desired actions for the specific device. If they do not match, the application can disregard the event or handle it differently.\n</p>\n<h4>\n Summary\n</h4>\n<p>\n In Visual C++, the application can retrieve the device path name from the\n <code>\n  lParam\n </code>\n structure when handling device events. By comparing this path name with the device path name of interest, the application can determine if the event is relevant to a specific device and take appropriate action based on the result.\n</p>\n"}, "Page 339": {"response": "<h3>\n Retrieving and Comparing Device Path Names in Visual Basic\n</h3>\n<p>\n In Visual Basic, the application uses two versions of the\n <code>\n  DEV_BROADCAST_DEVICEINTERFACE\n </code>\n structure. The first is used when calling\n <code>\n  RegisterDeviceNotification\n </code>\n , and the second (\n <code>\n  DEV_BROADCAST_DEVICEINTERFACE_1\n </code>\n ) is used for marshaling the data, including the\n <code>\n  dbcc_name\n </code>\n and\n <code>\n  dbcc_classguid\n </code>\n members, to handle the device path name more efficiently.\n</p>\n<h4>\n Declaration of DEV_BROADCAST_DEVICEINTERFACE_1 Structure\n</h4>\n<p>\n The\n <code>\n  DEV_BROADCAST_DEVICEINTERFACE_1\n </code>\n structure is defined to marshal data related to device events, such as device arrival and removal, and contains the device path name and class GUID:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;StructLayout(LayoutKind.Sequential, CharSet:=CharSet.\n Unicode\n )&gt; _\n Public\n Class\n DEV_BROADCAST_DEVICEINTERFACE_1\n Public\n dbcc_size\n As\n Integer\n ' Size of the structure\n Public\n dbcc_devicetype\n As\n Integer\n ' Type of the device-management structure\n Public\n dbcc_reserved\n As\n Integer\n ' Reserved for future use\n &lt;MarshalAs(UnmanagedType.ByValArray, ArraySubType:=UnmanagedType.U1, SizeConst:=\n 16\n )&gt; _\n Public\n dbcc_classguid()\n As\n Byte\n ' Device class GUID\n &lt;MarshalAs(UnmanagedType.ByValArray, SizeConst:=\n 255\n )&gt; _\n Public\n dbcc_name()\n As\n Char\n ' Device path name\n End\n Class\n</code>\n<ul>\n<li>\n<strong>\n   dbcc_classguid\n  </strong>\n  : This array holds the device class GUID, which is used to identify the type of device (e.g., HID).\n </li>\n<li>\n<strong>\n   dbcc_name\n  </strong>\n  : This array stores the device path name (such as\n  <code>\n   \\\\?\\HID#VID_1234&amp;PID_5678...\n  </code>\n  ) that the application can compare to identify the device of interest.\n </li>\n</ul>\n<h4>\n Retrieving and Comparing the Device Path Name\n</h4>\n<p>\n To retrieve the device path name and compare it to the path name of interest, you need to first marshal the data from\n <code>\n  lParam\n </code>\n into the relevant structure. Here's how this is done in Visual Basic:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Dim\n DevBroadcastDeviceInterface\n As\n New\n DEV_BROADCAST_DEVICEINTERFACE_1()\n Dim\n DevBroadcastHeader\n As\n New\n DEV_BROADCAST_HDR()\nMarshal.PtrToStructure(m.LParam, DevBroadcastHeader)\n If\n (DevBroadcastHeader.dbch_devicetype = DBT_DEVTYP_DEVICEINTERFACE)\n Then\n ' Calculate the size of the device name string\n Dim\n StringSize\n As\n Integer\n =\n CInt\n ((DevBroadcastHeader.dbch_size -\n 32\n ) /\n 2\n )\n ' Redimension the dbcc_name array to hold the correct size\n ReDim\n DevBroadcastDeviceInterface.dbcc_name(StringSize)\n ' Marshal the data from the lParam pointer into the structure\n Marshal.PtrToStructure(m.LParam, DevBroadcastDeviceInterface)\n End\n If\n</code>\n<ul>\n<li>\n<strong>\n   Marshal.PtrToStructure\n  </strong>\n  : This function is used to copy data from a pointer (\n  <code>\n   m.LParam\n  </code>\n  ) into the\n  <code>\n   DevBroadcastHeader\n  </code>\n  and\n  <code>\n   DevBroadcastDeviceInterface\n  </code>\n  structures.\n </li>\n<li>\n<strong>\n   StringSize\n  </strong>\n  : This calculates the size of the device name string by subtracting 32 (the size of the\n  <code>\n   DEV_BROADCAST_HDR\n  </code>\n  structure) and dividing by 2 (since\n  <code>\n   dbcc_name\n  </code>\n  is an array of characters).\n </li>\n</ul>\n<p>\n Once the data is marshaled into the\n <code>\n  DEV_BROADCAST_DEVICEINTERFACE_1\n </code>\n structure, you can access the\n <code>\n  dbcc_name\n </code>\n member, which contains the device path name.\n</p>\n<h4>\n Summary\n</h4>\n<p>\n In Visual Basic, to retrieve and compare the device path name when handling device events, you use the\n <code>\n  DEV_BROADCAST_DEVICEINTERFACE_1\n </code>\n structure. This structure allows you to marshal the device data, including the device path name and class GUID, from the message's\n <code>\n  lParam\n </code>\n pointer. After marshaling the data, you can compare the device path name to the one you are interested in and take appropriate actions based on whether they match.\n</p>\n"}, "Page 340": {"response": "<h3>\n Retrieving and Comparing the Device Path Name in Visual Basic\n</h3>\n<p>\n In Visual Basic, after marshaling the device data, the device path name can be retrieved and compared to check if it matches a specific device of interest.\n</p>\n<h4>\n Retrieving the Device Path Name\n</h4>\n<p>\n When handling a\n <code>\n  WM_DEVICECHANGE\n </code>\n message, the application processes the\n <code>\n  lParam\n </code>\n property, which contains the information about the device event. If the event relates to a device interface, the application can retrieve the device path name.\n</p>\n<p>\n Here\u2019s how the application retrieves and compares the device path name:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Dim\n DeviceNameString\n As\n New\n String\n (DevBroadcastDeviceInterface.dbcc_name,\n 0\n , StringSize)\n If\n (\n String\n .\n Compare\n (DeviceNameString, DevicePathName,\n True\n ) =\n 0\n )\n Then\n ' The names match. Perform the necessary actions.\n Else\n ' It's a different device. Handle accordingly.\n End\n If\n</code>\n<ul>\n<li>\n<strong>\n   DeviceNameString\n  </strong>\n  : This converts the\n  <code>\n   dbcc_name\n  </code>\n  character array (which contains the device path name) into a\n  <code>\n   String\n  </code>\n  . The\n  <code>\n   StringSize\n  </code>\n  variable is used to determine the length of the name.\n </li>\n<li>\n<strong>\n   String.Compare\n  </strong>\n  : This method compares the device path name retrieved from\n  <code>\n   dbcc_name\n  </code>\n  with the\n  <code>\n   DevicePathName\n  </code>\n  you are interested in. The third parameter (\n  <code>\n   True\n  </code>\n  ) makes the comparison case-insensitive.\n </li>\n<li>\n  If the names match, the application can perform the required tasks for that device. If they don\u2019t match, it can handle the event differently.\n </li>\n</ul>\n<h4>\n How the Device Path Name is Retrieved\n</h4>\n<p>\n The\n <code>\n  lParam\n </code>\n property points to a\n <code>\n  DEV_BROADCAST_HDR\n </code>\n structure, which contains metadata about the event. If the event relates to a device interface, the structure is cast to a\n <code>\n  DEV_BROADCAST_DEVICEINTERFACE_1\n </code>\n structure, which includes the device path name (\n <code>\n  dbcc_name\n </code>\n ) and other details.\n</p>\n<ul>\n<li>\n<strong>\n   dbcc_name\n  </strong>\n  : This is a character array in unmanaged memory containing the device path name.\n </li>\n<li>\n<strong>\n   dbch_size\n  </strong>\n  : This field in\n  <code>\n   DEV_BROADCAST_HDR\n  </code>\n  indicates the total size of the complete structure, which includes the header and the device-specific data.\n </li>\n<li>\n  To determine the length of the device path name, the application subtracts the 32 bytes used by the header and divides the result by 2, since each character in the path name is 2 bytes.\n </li>\n</ul>\n<h4>\n Stopping Device Notifications\n</h4>\n<p>\n When the application no longer needs to receive device notifications, it should unregister from receiving further notifications by calling the\n <code>\n  UnregisterDeviceNotification\n </code>\n function. This call should be made before the application is closed to free resources and stop receiving unnecessary device notifications.\n</p>\n<h3>\n Summary\n</h3>\n<p>\n In Visual Basic, to retrieve and compare the device path name in response to device events, the application marshals data from the\n <code>\n  lParam\n </code>\n pointer into a structure. It extracts the device path name, converts it into a string, and compares it to the path name of interest. If a match is found, the application can proceed with specific actions for that device. Additionally, when device notifications are no longer needed, the application should call\n <code>\n  UnregisterDeviceNotification\n </code>\n to stop receiving them.\n</p>\n"}, "Page 341": {"response": "<h3>\n Stopping Device Notifications\n</h3>\n<p>\n To stop receiving device notifications, an application must call the\n <code>\n  UnregisterDeviceNotification\n </code>\n function. This function unregisters a previously registered notification handle, ensuring that the application no longer receives device change messages.\n</p>\n<h4>\n UnregisterDeviceNotification in Visual C++\n</h4>\n<p>\n In Visual C++, the\n <code>\n  UnregisterDeviceNotification\n </code>\n function is declared as follows:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n BOOL\n UnregisterDeviceNotification\n (\n  HDEVNOTIFY Handle\n)\n ;\n</code>\n<ul>\n<li>\n<strong>\n   Handle\n  </strong>\n  : This is the handle returned by\n  <code>\n   RegisterDeviceNotification\n  </code>\n  , which identifies the registered notification.\n </li>\n<li>\n<strong>\n   Return Value\n  </strong>\n  : The function returns a\n  <code>\n   BOOL\n  </code>\n  indicating whether the unregistration was successful.\n </li>\n</ul>\n<p>\n To call this function, the code would look like this:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n UnregisterDeviceNotification\n (DeviceNotificationHandle);\n</code>\n<p>\n Here,\n <code>\n  DeviceNotificationHandle\n </code>\n is the handle that was used to register for device notifications.\n</p>\n<h4>\n UnregisterDeviceNotification in Visual Basic\n</h4>\n<p>\n In Visual Basic, the declaration of\n <code>\n  UnregisterDeviceNotification\n </code>\n is made through a\n <code>\n  DllImport\n </code>\n attribute to call the function from the\n <code>\n  user32.dll\n </code>\n library:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;DllImport(\n \"user32.dll\"\n )&gt; _\n Function\n UnregisterDeviceNotification _\n    (\n ByVal\n Handle\n As\n IntPtr) _\n As\n Boolean\n End\n Function\n</code>\n<ul>\n<li>\n<strong>\n   Handle\n  </strong>\n  : This is the notification handle passed as an\n  <code>\n   IntPtr\n  </code>\n  type, representing the handle that was used to register the notification.\n </li>\n<li>\n<strong>\n   Return Value\n  </strong>\n  : The function returns a\n  <code>\n   Boolean\n  </code>\n  indicating whether the unregistration was successful.\n </li>\n</ul>\n<p>\n To call the function in Visual Basic, the code is:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n UnregisterDeviceNotification(DeviceNotificationHandle)\n</code>\n<p>\n Where\n <code>\n  DeviceNotificationHandle\n </code>\n is the handle used to register for device notifications.\n</p>\n<h3>\n Summary\n</h3>\n<p>\n In both Visual C++ and Visual Basic, the\n <code>\n  UnregisterDeviceNotification\n </code>\n function is used to stop receiving device notifications by unregistering the notification handle. This function is crucial for cleaning up and freeing resources when the application no longer needs to listen for device events.\n</p>\n"}, "Page 342": {"response": "<h3>\n Human Interface Devices: Using Control and Interrupt Transfers\n</h3>\n<p>\n The Human Interface Device (HID) class was one of the first USB classes supported by Windows. From Windows 98 onwards, the operating system includes built-in drivers for HIDs, allowing applications to easily communicate with these devices. As a result, many vendor-specific USB devices utilize the HID class.\n</p>\n<h4>\n Overview of HID Class and Communication\n</h4>\n<p>\n Chapter 7 introduced the HID class, and this chapter expands on it by covering several important topics related to HID communication:\n</p>\n<ul>\n<li>\n<strong>\n   Determining HID Compatibility\n  </strong>\n  : This section will explain how to identify if a particular device can be classified as an HID.\n </li>\n<li>\n<strong>\n   Firmware Requirements\n  </strong>\n  : It discusses the firmware that must be implemented in a device to define it as an HID and enable proper data exchange with its host system.\n </li>\n<li>\n<strong>\n   HID-Specific Control Requests\n  </strong>\n  : The chapter will also cover the six control requests that are specific to the HID class, essential for managing the communication between the host and the device.\n </li>\n<li>\n<strong>\n   Example of HID Firmware\n  </strong>\n  : A practical example will be provided to show how HID firmware works in action.\n </li>\n</ul>\n<p>\n The subsequent Chapter 12 will go into further detail on advanced topics related to HID devices.\n</p>\n"}, "Page 343": {"response": "<h3>\n What is a HID (Human Interface Device)?\n</h3>\n<p>\n HID (Human Interface Devices) are a class of devices designed to interact with humans, though not all HIDs directly involve human interaction. Common examples include keyboards, mice, joysticks, game controllers, and even more specialized devices like data gloves or steering wheels. The term \"human interface\" in the name refers to devices that enable direct human interaction, but technically, any device that complies with the HID class specification can be considered an HID.\n</p>\n<h4>\n Key Characteristics and Limitations of HID Devices\n</h4>\n<p>\n Here are the main features and restrictions that define HID-class devices:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Reports for Data Exchange\n   </strong>\n   :\nHIDs exchange data through structures called \"reports.\" These reports are sent back and forth using control or interrupt transfers. The format of these reports is flexible, which allows for various types of data to be handled. However, each report has a fixed size once defined.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Interrupt IN Endpoint Requirement\n   </strong>\n   :\nA HID interface must have at least one interrupt IN endpoint to send Input reports from the device to the host. This endpoint allows the device to send data at unpredictable times (e.g., when a user presses a key or moves a mouse).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Endpoint Limitations\n   </strong>\n   :\nA HID interface can have a maximum of one interrupt IN endpoint and one interrupt OUT endpoint. If a device requires more interrupt endpoints, it must be designed as a composite device containing multiple HIDs. Each HID in the composite device will require a separate handle for communication.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Unpredictable Data Timing\n   </strong>\n   :\nThe interrupt IN endpoint allows the HID to send information to the host at irregular intervals. For example, a keyboard doesn't know when a user will press a key, so the host's driver uses periodic polling to check for new data.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Data Exchange Rate Limitations\n   </strong>\n   :\nThe rate at which data can be exchanged depends on the device's speed. At low and full USB speeds, the data transfer rate is constrained. Specifically, a low-speed interrupt endpoint can transfer no more than 800 bytes per second, while a full-speed endpoint has a higher rate limit.\n  </p>\n</li>\n</ul>\n<h4>\n Conclusion\n</h4>\n<p>\n The HID class encompasses a wide range of devices, from everyday input devices like keyboards and mice to more specialized interfaces like game controllers or custom panels. While these devices interact with humans in many ways, they all follow the same general specifications that allow them to communicate via structured reports over control or interrupt transfers. However, limitations like the number of interrupt endpoints and data rate restrictions apply, especially at lower USB speeds.\n</p>\n"}, "Page 344": {"response": "<h3>\n Human Interface Devices: Control and Interrupt Transfers\n</h3>\n<p>\n HID devices are designed to communicate with a host through control and interrupt transfers, both of which have specific characteristics, limitations, and requirements. This section explores the data exchange rates, supported transfer types, and hardware requirements for HID devices.\n</p>\n<h4>\n Data Exchange Rates and Limitations\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Low-Speed and Full-Speed Transfers\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    At\n    <strong>\n     low-speed\n    </strong>\n    (1.5 Mbps) and\n    <strong>\n     full-speed\n    </strong>\n    (12 Mbps) USB, the data exchange rates are limited. For example:\n    <ul>\n<li>\n      Low-speed interrupt endpoints can transfer up to\n      <strong>\n       800 bytes per second\n      </strong>\n      .\n     </li>\n<li>\n      Full-speed interrupt endpoints have a maximum transfer rate of\n      <strong>\n       64 KB per second\n      </strong>\n      .\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    High-Speed Transfers\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     High-speed USB\n    </strong>\n    (480 Mbps) endpoints can support much higher rates:\n    <ul>\n<li>\n<strong>\n       Up to 24 MB per second\n      </strong>\n      for high-speed endpoints if the host supports high-bandwidth transfers.\n     </li>\n<li>\n      If the host does not support high-bandwidth endpoints, the rate is reduced to\n      <strong>\n       about 8 MB per second\n      </strong>\n      .\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Control Transfers\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Unlike interrupt transfers,\n    <strong>\n     control transfers\n    </strong>\n    don\u2019t have guaranteed bandwidth except for the portion reserved for control traffic on the bus.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Compatibility with Older USB Versions\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Windows 98 Gold\n    </strong>\n    (the first version) only supports\n    <strong>\n     USB 1.0\n    </strong>\n    , so\n    <strong>\n     interrupt OUT transfers\n    </strong>\n    are not supported. All host-to-device communication must occur via\n    <strong>\n     control transfers\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n HID Devices Beyond Human Interfaces\n</h4>\n<p>\n While many HID devices interact directly with humans (e.g., keyboards, mice, and game controllers), the HID class can also accommodate devices that don\u2019t have a traditional human interface. Examples include:\n</p>\n<ul>\n<li>\n<strong>\n   Bar-code readers\n  </strong>\n</li>\n<li>\n<strong>\n   Thermometers\n  </strong>\n</li>\n<li>\n<strong>\n   Voltmeters\n  </strong>\n  These devices send data to the host and may receive configuration requests. In addition, there are devices that primarily receive data, such as:\n </li>\n<li>\n<strong>\n   Remote displays\n  </strong>\n</li>\n<li>\n<strong>\n   Control panels for remote devices\n  </strong>\n</li>\n<li>\n<strong>\n   Robots\n  </strong>\n  These devices can receive occasional or periodic commands from the host.\n </li>\n</ul>\n<h4>\n HID Interface in Multi-Interface Devices\n</h4>\n<p>\n A device may contain multiple interfaces, and the HID interface could be just one of them. For example:\n</p>\n<ul>\n<li>\n  A\n  <strong>\n   USB speaker\n  </strong>\n  may use\n  <strong>\n   isochronous transfers\n  </strong>\n  for audio and have an HID interface for controlling the volume, balance, treble, and bass. The HID interface allows for simpler, less costly controls compared to traditional physical interfaces.\n </li>\n</ul>\n<h4>\n Hardware Requirements for HID Devices\n</h4>\n<p>\n For a device to comply with the HID specification, its\n <strong>\n  endpoints\n </strong>\n and\n <strong>\n  descriptors\n </strong>\n must meet specific requirements.\n</p>\n<ul>\n<li>\n<strong>\n   Endpoints\n  </strong>\n  :\n  <ul>\n<li>\n    HID devices can use either\n    <strong>\n     control endpoints\n    </strong>\n    or\n    <strong>\n     interrupt endpoints\n    </strong>\n    for data transfer.\n   </li>\n<li>\n    Every HID must have at least one\n    <strong>\n     interrupt IN endpoint\n    </strong>\n    to send data to the host.\n   </li>\n<li>\n    The\n    <strong>\n     interrupt OUT endpoint\n    </strong>\n    is optional, depending on the device\u2019s functionality.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Transfer Types and Typical Uses in HIDs\n</h4>\n<p>\n Table 11-1 (which is not provided here) would list the various transfer types (control and interrupt) and their typical uses in HID devices, such as input reports (IN) and output reports (OUT).\n</p>\n<h3>\n Conclusion\n</h3>\n<p>\n HID devices can range from traditional human-interface devices, such as keyboards and mice, to non-traditional devices like bar-code readers or remote displays. The key characteristic of all HID devices is their use of\n <strong>\n  reports\n </strong>\n for data exchange, either through\n <strong>\n  control\n </strong>\n or\n <strong>\n  interrupt transfers\n </strong>\n . Understanding the hardware and transfer requirements is crucial for ensuring that the device meets the HID specification and functions as intended within the USB system.\n</p>\n"}, "Page 345": {"response": "<h3>\n Reports and Transfers in HID Devices\n</h3>\n<p>\n Human Interface Devices (HIDs) rely on a combination of\n <strong>\n  reports\n </strong>\n ,\n <strong>\n  control transfers\n </strong>\n , and\n <strong>\n  interrupt transfers\n </strong>\n for data exchange. These mechanisms allow HIDs to function effectively, especially for devices that require quick or periodic data communication.\n</p>\n<h4>\n Reports in HID Devices\n</h4>\n<p>\n Each HID device must define\n <strong>\n  Input Reports\n </strong>\n within its\n <strong>\n  report descriptor\n </strong>\n . These reports are used for transferring data from the device to the host, often via\n <strong>\n  interrupt IN endpoints\n </strong>\n .\n</p>\n<ul>\n<li>\n<strong>\n   Input Reports\n  </strong>\n  : Required for every HID, these reports allow the device to send data to the host.\n </li>\n<li>\n<strong>\n   Output and Feature Reports\n  </strong>\n  : These are optional and depend on the specific needs of the device. Output reports send data from the host to the device, while Feature reports can be used for configuration or other device-specific purposes.\n </li>\n</ul>\n<h4>\n Control Transfers\n</h4>\n<p>\n The\n <strong>\n  HID specification\n </strong>\n defines six class-specific requests, two of which are specifically for transferring reports:\n</p>\n<ol>\n<li>\n<strong>\n   Set_Report\n  </strong>\n  : Used by the host to send reports to the device.\n </li>\n<li>\n<strong>\n   Get_Report\n  </strong>\n  : Used by the host to receive reports from the device.\n </li>\n</ol>\n<p>\n In addition to these, there are four other requests related to configuring the device:\n</p>\n<ul>\n<li>\n<strong>\n   Set_Idle\n  </strong>\n  and\n  <strong>\n   Get_Idle\n  </strong>\n  : These requests control the idle rate. The idle rate determines whether the device will resend data even if it hasn\u2019t changed since the last time it was polled.\n </li>\n<li>\n<strong>\n   Set_Protocol\n  </strong>\n  and\n  <strong>\n   Get_Protocol\n  </strong>\n  : These requests manage the protocol the device uses. This is especially useful during boot-up when full HID drivers may not yet be loaded on the host, allowing the device to function with a simplified protocol.\n </li>\n</ul>\n<h4>\n Interrupt Transfers\n</h4>\n<p>\n<strong>\n  Interrupt transfers\n </strong>\n provide an alternative method of data exchange when quick or periodic data transmission is needed. These transfers are often used for time-sensitive data exchanges, such as key presses on a keyboard or mouse movements. Interrupt transfers operate on interrupt endpoints and offer a lower latency compared to control transfers.\n</p>\n<p>\n Interrupt transfers come in two directions:\n</p>\n<ul>\n<li>\n<strong>\n   Device to Host (IN transfer)\n  </strong>\n  : Used for periodic or low-latency data from the device to the host.\n </li>\n<li>\n<strong>\n   Host to Device (OUT transfer)\n  </strong>\n  : Used for sending periodic or low-latency data from the host to the device, though this is not supported on all devices.\n </li>\n</ul>\n<h4>\n Table 11-1: Transfer Types Used in HID Transfers\n</h4>\n<p>\n The type of transfer used for HID communication depends on the specific data requirements and the capabilities of the device\u2019s chip. Here\u2019s a summary:\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Transfer Type\n    </strong>\n</th>\n<th>\n<strong>\n     Source of Data\n    </strong>\n</th>\n<th>\n<strong>\n     Typical Data\n    </strong>\n</th>\n<th>\n<strong>\n     Required Pipe?\n    </strong>\n</th>\n<th>\n<strong>\n     Windows Support\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     Control\n    </strong>\n</td>\n<td>\n    Device (IN transfer)\n   </td>\n<td>\n    Data without critical timing requirements\n   </td>\n<td>\n    Yes\n   </td>\n<td>\n    Windows 98 and later\n   </td>\n</tr>\n<tr>\n<td>\n</td>\n<td>\n    Host (OUT transfer)\n   </td>\n<td>\n    Data without critical timing, or any data if no OUT interrupt pipe is available\n   </td>\n<td>\n    Yes\n   </td>\n<td>\n    Windows 98 and later\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Interrupt\n    </strong>\n</td>\n<td>\n    Device (IN transfer)\n   </td>\n<td>\n    Periodic or low-latency data\n   </td>\n<td>\n    Yes\n   </td>\n<td>\n    Windows 98 SE and later\n   </td>\n</tr>\n<tr>\n<td>\n</td>\n<td>\n    Host (OUT transfer)\n   </td>\n<td>\n    Periodic or low-latency data\n   </td>\n<td>\n    No\n   </td>\n<td>\n    Windows 98 SE and later\n   </td>\n</tr>\n</tbody>\n</table>\n<h3>\n Conclusion\n</h3>\n<p>\n HID devices communicate with their host using\n <strong>\n  reports\n </strong>\n transferred through\n <strong>\n  control\n </strong>\n and\n <strong>\n  interrupt transfers\n </strong>\n . The control transfers are used for device configuration and reporting, while interrupt transfers allow for the quick exchange of periodic or time-sensitive data. These transfers are essential for ensuring that HID devices, ranging from keyboards and mice to remote controls and sensors, function efficiently in a USB environment.\n</p>\n"}, "Page 346": {"response": "<h3>\n Firmware and Descriptors for HID Devices\n</h3>\n<p>\n Human Interface Devices (HIDs) must adhere to specific firmware and descriptor requirements to function properly within the USB ecosystem. These requirements ensure the device can communicate effectively with the host using control and interrupt transfers.\n</p>\n<h4>\n Firmware Requirements\n</h4>\n<p>\n The firmware of a HID must support various descriptors to enable proper communication between the device and the host. These include:\n</p>\n<ul>\n<li>\n<strong>\n   Interface Descriptor\n  </strong>\n  : Specifies that the device is of the HID class.\n </li>\n<li>\n<strong>\n   HID Descriptor\n  </strong>\n  : Defines the HID-specific properties of the device.\n </li>\n<li>\n<strong>\n   Interrupt IN Endpoint Descriptor\n  </strong>\n  : Required for sending data to the host.\n </li>\n<li>\n<strong>\n   Interrupt OUT Endpoint Descriptor\n  </strong>\n  : Optional, added in USB 1.1 and HID 1.1, allowing data to be sent from the host to the device.\n </li>\n<li>\n<strong>\n   Report Descriptor\n  </strong>\n  : Describes the contents of the HID reports, including their size and data structure. This descriptor is crucial for determining how data should be exchanged.\n </li>\n</ul>\n<p>\n Each HID must include a\n <strong>\n  Report Descriptor\n </strong>\n , which details how reports are structured. The descriptor can define the following types of reports:\n</p>\n<ul>\n<li>\n<strong>\n   Input Reports\n  </strong>\n  : Data sent from the device to the host.\n </li>\n<li>\n<strong>\n   Output Reports\n  </strong>\n  : Data sent from the host to the device (optional).\n </li>\n<li>\n<strong>\n   Feature Reports\n  </strong>\n  : Can be sent in either direction and provide additional configuration information (optional).\n </li>\n</ul>\n<h4>\n Interrupt Transfers vs. Control Transfers\n</h4>\n<p>\n While\n <strong>\n  interrupt transfers\n </strong>\n guarantee bandwidth for sending time-sensitive data (such as key presses),\n <strong>\n  control transfers\n </strong>\n handle other types of communication, like configuration requests. Devices that use\n <strong>\n  Output Reports\n </strong>\n should use control transfers to maintain compatibility with\n <strong>\n  Windows 98 Gold\n </strong>\n . Interrupt transfers for\n <strong>\n  Output Reports\n </strong>\n are optional.\n</p>\n<p>\n<strong>\n  Feature Reports\n </strong>\n , on the other hand, always use control transfers. These reports typically provide device settings or status updates.\n</p>\n<h4>\n HID Descriptors in Device Enumeration\n</h4>\n<p>\n During the enumeration process, the host discovers the HID interface by inspecting the\n <strong>\n  device descriptors\n </strong>\n . The descriptors help the host understand how to interact with the device. The following descriptors are essential during enumeration:\n</p>\n<ol>\n<li>\n<strong>\n   Device Descriptor\n  </strong>\n</li>\n<li>\n<strong>\n   Configuration Descriptor\n  </strong>\n</li>\n<li>\n<strong>\n   Interface Descriptor\n  </strong>\n</li>\n<li>\n<strong>\n   Class Descriptor\n  </strong>\n</li>\n<li>\n<strong>\n   Endpoint Descriptor\n  </strong>\n</li>\n</ol>\n<p>\n These descriptors allow the host to learn about the device\u2019s capabilities and initiate proper communication.\n</p>\n<h4>\n Example of HID Descriptors\n</h4>\n<p>\n When the device is enumerated, the descriptors inform the host of the device's interface and how it will interact with the system. For example, the device descriptor might specify that the device is an HID and that it supports certain endpoints (such as interrupt IN and optional interrupt OUT). The interface and class descriptors further define the communication protocol, while the endpoint descriptors provide the details about the data transfer mechanisms used by the device.\n</p>\n<h3>\n Conclusion\n</h3>\n<p>\n For a device to function as a HID, it must meet both\n <strong>\n  firmware\n </strong>\n and\n <strong>\n  descriptor\n </strong>\n requirements. These include having the proper HID, interrupt IN endpoint descriptors, and report descriptors. Additionally, the use of control and interrupt transfers allows HIDs to exchange data efficiently, with interrupt transfers ensuring low-latency communication, especially for time-sensitive data. Proper enumeration and descriptor handling are essential for the host to recognize and interact with the HID device.\n</p>\n"}, "Page 347": {"response": "<h3>\n Example Descriptors for a Vendor-Specific HID Device\n</h3>\n<p>\n In this section, we look at an example of the device, configuration, and interface descriptors used by a vendor-specific Human Interface Device (HID). These descriptors provide essential information for the host to communicate effectively with the device.\n</p>\n<h4>\n Device Descriptor\n</h4>\n<p>\n The device descriptor provides basic information about the USB device. The fields in this descriptor include:\n</p>\n<ul>\n<li>\n<strong>\n   Descriptor Size (0x12)\n  </strong>\n  : The size of the descriptor, in bytes.\n </li>\n<li>\n<strong>\n   Descriptor Type (0x01)\n  </strong>\n  : Indicates this is a device descriptor.\n </li>\n<li>\n<strong>\n   USB Specification Release Number (0x0200)\n  </strong>\n  : Specifies the USB version (2.0) the device supports.\n </li>\n<li>\n<strong>\n   Class Code (0x00)\n  </strong>\n  : No specific class code (this is a vendor-specific device).\n </li>\n<li>\n<strong>\n   Subclass Code (0x00)\n  </strong>\n  : No subclass code.\n </li>\n<li>\n<strong>\n   Protocol Code (0x00)\n  </strong>\n  : No specific protocol.\n </li>\n<li>\n<strong>\n   Endpoint 0 Maximum Packet Size (0x08)\n  </strong>\n  : The maximum packet size for endpoint 0 (8 bytes).\n </li>\n<li>\n<strong>\n   Vendor ID (0x0925)\n  </strong>\n  : The ID for the manufacturer (Lakeview Research).\n </li>\n<li>\n<strong>\n   Product ID (0x1234)\n  </strong>\n  : The specific product ID.\n </li>\n<li>\n<strong>\n   Device Release Number (0x0100)\n  </strong>\n  : Version of the device (1.00).\n </li>\n<li>\n<strong>\n   Manufacturer String Index (0x01)\n  </strong>\n  : The index for the manufacturer string.\n </li>\n<li>\n<strong>\n   Product String Index (0x02)\n  </strong>\n  : The index for the product string.\n </li>\n<li>\n<strong>\n   Device Serial Number String Index (0x00)\n  </strong>\n  : No serial number string.\n </li>\n<li>\n<strong>\n   Number of Configurations (0x01)\n  </strong>\n  : The number of configurations the device supports (1 configuration).\n </li>\n</ul>\n<h4>\n Configuration Descriptor\n</h4>\n<p>\n The configuration descriptor provides details about the device\u2019s configuration, which includes information about the interface(s) and endpoints.\n</p>\n<ul>\n<li>\n<strong>\n   Descriptor Size (0x09)\n  </strong>\n  : The size of the descriptor (9 bytes).\n </li>\n<li>\n<strong>\n   Descriptor Type (0x02)\n  </strong>\n  : Indicates this is a configuration descriptor.\n </li>\n<li>\n<strong>\n   Total Length (0x0029)\n  </strong>\n  : The total length of this descriptor and any subordinate descriptors (41 bytes).\n </li>\n<li>\n<strong>\n   Number of Interfaces (0x01)\n  </strong>\n  : The configuration includes one interface.\n </li>\n<li>\n<strong>\n   Configuration Index (0x01)\n  </strong>\n  : The index for this configuration.\n </li>\n<li>\n<strong>\n   Configuration String Index (0x00)\n  </strong>\n  : No string index for the configuration.\n </li>\n<li>\n<strong>\n   Attributes (0xA0)\n  </strong>\n  : This device is bus-powered and supports remote wakeup.\n </li>\n<li>\n<strong>\n   Maximum Power Consumption (0x50)\n  </strong>\n  : The device consumes 100 mA of power.\n </li>\n</ul>\n<h4>\n Interface Descriptor\n</h4>\n<p>\n The interface descriptor provides details about the interface used by the device.\n</p>\n<ul>\n<li>\n<strong>\n   Descriptor Size (0x09)\n  </strong>\n  : The size of the interface descriptor (9 bytes).\n </li>\n<li>\n<strong>\n   Descriptor Type (0x04)\n  </strong>\n  : Indicates this is an interface descriptor.\n </li>\n<li>\n<strong>\n   Interface Number (0x00)\n  </strong>\n  : The index of this interface.\n </li>\n<li>\n<strong>\n   Alternate Setting Number (0x00)\n  </strong>\n  : No alternate setting for the interface.\n </li>\n<li>\n<strong>\n   Number of Endpoints (0x02)\n  </strong>\n  : This interface has two endpoints.\n </li>\n<li>\n<strong>\n   Interface Class (0x03)\n  </strong>\n  : This is an HID class interface.\n </li>\n<li>\n<strong>\n   Interface Subclass (0x00)\n  </strong>\n  : No subclass code.\n </li>\n<li>\n<strong>\n   Interface Protocol (0x00)\n  </strong>\n  : No specific protocol.\n </li>\n<li>\n<strong>\n   Interface String Index (0x00)\n  </strong>\n  : No string index for the interface.\n </li>\n</ul>\n<h4>\n Summary\n</h4>\n<p>\n These descriptors are essential for the host to understand how to communicate with the HID device. The\n <strong>\n  device descriptor\n </strong>\n provides overall information about the device, the\n <strong>\n  configuration descriptor\n </strong>\n details the power requirements and configuration setup, and the\n <strong>\n  interface descriptor\n </strong>\n defines how the device's interface is structured, including its endpoints and the HID class protocol. These descriptors allow the host to correctly configure and interact with the HID device.\n</p>\n"}, "Page 348": {"response": "<h3>\n Descriptors for a Vendor-Specific HID (Continued)\n</h3>\n<p>\n This section continues to describe the descriptors needed for a vendor-specific HID, specifically the HID descriptor and interrupt endpoint descriptors. These descriptors are critical for ensuring proper communication between the host and the HID device.\n</p>\n<h4>\n HID Descriptor\n</h4>\n<p>\n The\n <strong>\n  HID descriptor\n </strong>\n provides information about the device's HID capabilities, such as the HID specification version and the report descriptor details.\n</p>\n<ul>\n<li>\n<strong>\n   Descriptor Size (0x09)\n  </strong>\n  : The size of the HID descriptor (9 bytes).\n </li>\n<li>\n<strong>\n   Descriptor Type (0x21)\n  </strong>\n  : Indicates this is an HID descriptor.\n </li>\n<li>\n<strong>\n   HID Specification Release Number (0x0110)\n  </strong>\n  : Specifies the HID specification version (1.1).\n </li>\n<li>\n<strong>\n   Country Code (0x00)\n  </strong>\n  : No country-specific code.\n </li>\n<li>\n<strong>\n   Number of Subordinate Class Descriptors (0x01)\n  </strong>\n  : This descriptor includes one subordinate class descriptor (the report descriptor).\n </li>\n<li>\n<strong>\n   Descriptor Type (0x22)\n  </strong>\n  : Specifies the type of subordinate descriptor (report descriptor).\n </li>\n<li>\n<strong>\n   Report Descriptor Size (0x002F)\n  </strong>\n  : The size of the report descriptor (47 bytes).\n </li>\n</ul>\n<h4>\n IN Interrupt Endpoint Descriptor\n</h4>\n<p>\n This descriptor defines an\n <strong>\n  IN interrupt endpoint\n </strong>\n , used for sending data from the HID device to the host. Interrupt endpoints allow the device to send data at periodic intervals.\n</p>\n<ul>\n<li>\n<strong>\n   Descriptor Size (0x07)\n  </strong>\n  : The size of the endpoint descriptor (7 bytes).\n </li>\n<li>\n<strong>\n   Descriptor Type (0x05)\n  </strong>\n  : Indicates this is an endpoint descriptor.\n </li>\n<li>\n<strong>\n   Endpoint Number and Direction (0x81)\n  </strong>\n  : The endpoint number is 1, and the direction is IN (from the device to the host).\n </li>\n<li>\n<strong>\n   Transfer Type (0x03)\n  </strong>\n  : Specifies that this is an interrupt transfer type.\n </li>\n<li>\n<strong>\n   Maximum Packet Size (0x40)\n  </strong>\n  : The maximum packet size for this endpoint is 64 bytes.\n </li>\n<li>\n<strong>\n   Polling Interval (0x0A)\n  </strong>\n  : The polling interval is set to 10 milliseconds, which determines how often the host polls the endpoint.\n </li>\n</ul>\n<h4>\n OUT Interrupt Endpoint Descriptor\n</h4>\n<p>\n This descriptor defines an\n <strong>\n  OUT interrupt endpoint\n </strong>\n , used for sending data from the host to the HID device.\n</p>\n<ul>\n<li>\n<strong>\n   Descriptor Size (0x07)\n  </strong>\n  : The size of the endpoint descriptor (7 bytes).\n </li>\n<li>\n<strong>\n   Descriptor Type (0x05)\n  </strong>\n  : Indicates this is an endpoint descriptor.\n </li>\n<li>\n<strong>\n   Endpoint Number and Direction (0x01)\n  </strong>\n  : The endpoint number is 1, and the direction is OUT (from the host to the device).\n </li>\n<li>\n<strong>\n   Transfer Type (0x03)\n  </strong>\n  : Specifies that this is an interrupt transfer type.\n </li>\n<li>\n<strong>\n   Maximum Packet Size (0x40)\n  </strong>\n  : The maximum packet size for this endpoint is 64 bytes.\n </li>\n<li>\n<strong>\n   Polling Interval (0x0A)\n  </strong>\n  : The polling interval is set to 10 milliseconds.\n </li>\n</ul>\n<h3>\n Summary\n</h3>\n<p>\n These descriptors are part of the HID device's setup. The\n <strong>\n  HID descriptor\n </strong>\n provides essential details about the HID device, including the HID specification version, the number of report descriptors, and the size of the report descriptor. The\n <strong>\n  IN interrupt endpoint descriptor\n </strong>\n enables data transfer from the device to the host at regular intervals, while the\n <strong>\n  OUT interrupt endpoint descriptor\n </strong>\n allows data to be sent from the host to the device. These descriptors allow the host to correctly configure the device and facilitate communication.\n</p>\n"}, "Page 349": {"response": "<h3>\n The HID Interface\n</h3>\n<p>\n The HID interface is defined by the interface descriptor, which helps the host recognize and interact with HID-class devices. One of the key identifiers in this descriptor is the\n <code>\n  bInterfaceClass\n </code>\n , which is set to\n <strong>\n  3\n </strong>\n to indicate the device is a Human Interface Device (HID).\n</p>\n<h4>\n Boot Interface Support\n</h4>\n<p>\n A\n <strong>\n  boot interface\n </strong>\n is a special type of HID interface that allows the device to function with minimal support from the host\u2019s operating system. This is particularly useful when the host's HID drivers are not yet loaded, such as during:\n</p>\n<ul>\n<li>\n  Computer boot-up before the operating system is loaded (e.g., DOS mode).\n </li>\n<li>\n  Accessing system setup screens in BIOS.\n </li>\n<li>\n  Using Windows Safe Mode for troubleshooting.\n </li>\n</ul>\n<p>\n Devices like keyboards and mice often include a boot interface, which uses a simplified protocol that can be understood directly by the\n <strong>\n  BIOS\n </strong>\n (Basic Input/Output System) during startup. If a device supports a boot interface, it uses a special protocol defined in the\n <strong>\n  HID Usage Tables\n </strong>\n for keyboards and mice.\n</p>\n<p>\n When a device with a boot interface is connected, the BIOS automatically detects and uses this protocol, and there's no need to read the device\u2019s report descriptor. The\n <strong>\n  Set_Report\n </strong>\n request can be used by the BIOS to interact with the device using this simplified protocol. Later, when the operating system\u2019s full HID drivers are loaded, it can use the\n <strong>\n  Set_Protocol\n </strong>\n request to switch the device to a more detailed communication protocol.\n</p>\n<p>\n The\n <code>\n  bInterfaceProtocol\n </code>\n field in the interface descriptor specifies whether the boot interface is for a\n <strong>\n  keyboard (1)\n </strong>\n or\n <strong>\n  mouse (2)\n </strong>\n .\n</p>\n<p>\n If a device does\n <strong>\n  not\n </strong>\n support a boot interface, the\n <code>\n  bInterfaceSubclass\n </code>\n field will be set to\n <strong>\n  0\n </strong>\n .\n</p>\n<hr/>\n<h3>\n HID Class Descriptor\n</h3>\n<p>\n The\n <strong>\n  HID class descriptor\n </strong>\n provides additional information about the HID device's capabilities and the communication method it uses. It helps the host identify other descriptors related to the HID and sets up the necessary communication with the device.\n</p>\n<p>\n The class descriptor contains several fields, and depending on the number of additional descriptors, it could have seven or more fields. These fields allow the host to learn about the reports and other related descriptors for communication with the HID device.\n</p>\n<hr/>\n<h3>\n Summary\n</h3>\n<p>\n The HID interface allows devices like keyboards and mice to function even without full OS-level support by using a simplified boot protocol. The\n <code>\n  bInterfaceClass\n </code>\n and\n <code>\n  bInterfaceSubclass\n </code>\n fields help identify whether the device supports such a boot protocol. When the operating system loads, the device can switch to the full HID report protocol using specific HID control requests. The HID class descriptor further assists the host in recognizing and interacting with the device, particularly for devices that include additional communication descriptors.\n</p>\n"}, "Page 350": {"response": "<h3>\n HID Class Descriptor\n</h3>\n<p>\n The\n <strong>\n  HID Class Descriptor\n </strong>\n provides detailed information about the device's HID interface and describes its communication characteristics. It contains several fields that help the host properly identify and interact with the HID device. Here\u2019s a breakdown of the key components in this descriptor:\n</p>\n<h4>\n Descriptor Fields\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    bLength\n   </strong>\n   (1 byte): Specifies the size of the descriptor in bytes.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bDescriptorType\n   </strong>\n   (1 byte): This value is set to\n   <strong>\n    21h\n   </strong>\n   to identify this as an HID descriptor.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bcdHID\n   </strong>\n   (2 bytes): Indicates the version of the HID specification the device complies with, in\n   <strong>\n    BCD (Binary-Coded Decimal)\n   </strong>\n   format. For example,\n   <strong>\n    0100h\n   </strong>\n   refers to\n   <strong>\n    version 1.0\n   </strong>\n   , and\n   <strong>\n    0110h\n   </strong>\n   refers to\n   <strong>\n    version 1.1\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bCountryCode\n   </strong>\n   (1 byte): If the device is localized for a specific country, this field contains a code identifying the country. If it\u2019s not localized, it is set to\n   <strong>\n    00h\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bNumDescriptors\n   </strong>\n   (1 byte): Specifies how many subordinate descriptors follow. These descriptors provide further details about the device\u2019s capabilities, such as report and physical descriptors.\n  </p>\n</li>\n</ul>\n<h4>\n Subordinate Descriptors\n</h4>\n<p>\n The descriptor can also include subordinate descriptors, which provide additional information about the device. These descriptors are identified by the\n <strong>\n  bDescriptorType\n </strong>\n field and can vary depending on the device\u2019s configuration:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    bDescriptorType (Report Descriptor)\n   </strong>\n   (1 byte): This field identifies the type of a class-specific descriptor that follows. A\n   <strong>\n    report descriptor\n   </strong>\n   is essential and has a type of\n   <strong>\n    22h\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    wDescriptorLength\n   </strong>\n   (2 bytes): Specifies the total length of the descriptor following the\n   <strong>\n    bDescriptorType\n   </strong>\n   field.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bDescriptorType (Physical Descriptor)\n   </strong>\n   (1 byte): This field is optional and, if present, indicates a\n   <strong>\n    physical descriptor\n   </strong>\n   . Its type is\n   <strong>\n    23h\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    wDescriptorLength\n   </strong>\n   (2 bytes): This field specifies the length of the\n   <strong>\n    physical descriptor\n   </strong>\n   . It appears only if a\n   <strong>\n    bDescriptorType\n   </strong>\n   field is present for the physical descriptor. Additional physical descriptors may follow, and they will be identified with their respective\n   <strong>\n    bDescriptorType\n   </strong>\n   and\n   <strong>\n    wDescriptorLength\n   </strong>\n   fields.\n  </p>\n</li>\n</ul>\n<hr/>\n<h3>\n Table of HID Class Descriptor Fields\n</h3>\n<table>\n<thead>\n<tr>\n<th>\n    Offset (decimal)\n   </th>\n<th>\n    Field\n   </th>\n<th>\n    Size (bytes)\n   </th>\n<th>\n    Description\n   </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n    0\n   </td>\n<td>\n    bLength\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Descriptor size in bytes\n   </td>\n</tr>\n<tr>\n<td>\n    1\n   </td>\n<td>\n    bDescriptorType\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Descriptor type:\n    <strong>\n     21h\n    </strong>\n    for HID\n   </td>\n</tr>\n<tr>\n<td>\n    2\n   </td>\n<td>\n    bcdHID\n   </td>\n<td>\n    2\n   </td>\n<td>\n    HID specification release number (BCD)\n   </td>\n</tr>\n<tr>\n<td>\n    4\n   </td>\n<td>\n    bCountryCode\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Country code for localized hardware, or\n    <strong>\n     00h\n    </strong>\n    if not localized\n   </td>\n</tr>\n<tr>\n<td>\n    5\n   </td>\n<td>\n    bNumDescriptors\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Number of subordinate descriptors\n   </td>\n</tr>\n<tr>\n<td>\n    6\n   </td>\n<td>\n    bDescriptorType\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Type of class-specific descriptor (e.g.,\n    <strong>\n     22h\n    </strong>\n    for report descriptor)\n   </td>\n</tr>\n<tr>\n<td>\n    7\n   </td>\n<td>\n    wDescriptorLength\n   </td>\n<td>\n    2\n   </td>\n<td>\n    Length of the descriptor identified by the previous field\n   </td>\n</tr>\n<tr>\n<td>\n    9\n   </td>\n<td>\n    bDescriptorType\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Optional: Type of a physical descriptor (\n    <strong>\n     23h\n    </strong>\n    )\n   </td>\n</tr>\n<tr>\n<td>\n    10\n   </td>\n<td>\n    wDescriptorLength\n   </td>\n<td>\n    2\n   </td>\n<td>\n    Length of the physical descriptor (if present)\n   </td>\n</tr>\n</tbody>\n</table>\n<hr/>\n<h3>\n Summary\n</h3>\n<p>\n The HID class descriptor provides vital details about an HID device, including the HID version, country localization, and the number and types of subordinate descriptors. These descriptors allow the host to properly identify and manage the device, especially when it comes to defining how the device exchanges data through report and physical descriptors. Understanding these fields is crucial for ensuring proper communication and functionality of HID devices.\n</p>\n"}, "Page 351": {"response": "<h3>\n Understanding HID Report Descriptors\n</h3>\n<p>\n The\n <strong>\n  Report Descriptor\n </strong>\n in an HID (Human Interface Device) specifies the format and structure of the data exchanged between the device and the host. It defines how data is organized within reports, which are the primary way that data is transferred between a HID device and the host.\n</p>\n<h4>\n Key Points about Report Descriptors:\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Purpose of Report Descriptors\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The report descriptor defines the type of data and how it is used in a device's reports. For example:\n    <ul>\n<li>\n      A\n      <strong>\n       mouse\n      </strong>\n      report descriptor specifies mouse movements and button clicks.\n     </li>\n<li>\n      A\n      <strong>\n       relay controller\n      </strong>\n      report descriptor specifies which relays should be opened or closed.\n     </li>\n</ul>\n</li>\n<li>\n    The report descriptor must be flexible enough to support a wide variety of HID devices with different functions.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Compact Data Format\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The descriptor format is designed to be compact to save both storage space on the device and bus time when transferring data. This means the format is more complex and less human-readable compared to simpler formats.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Class-Specific Descriptor\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     report descriptor\n    </strong>\n    is a class-specific descriptor, meaning it is specific to HID devices. It is retrieved by the host using a\n    <strong>\n     Get_Descriptor\n    </strong>\n    request, where the\n    <code>\n     wValue\n    </code>\n    field is set to\n    <code>\n     22h\n    </code>\n    in the high byte to request the report descriptor.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Types of Reports\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    There are three main types of reports described in a typical HID report descriptor:\n    <ul>\n<li>\n<strong>\n       Input Report\n      </strong>\n      : Contains data sent from the device to the host.\n     </li>\n<li>\n<strong>\n       Output Report\n      </strong>\n      : Contains data sent from the host to the device.\n     </li>\n<li>\n<strong>\n       Feature Report\n      </strong>\n      : Contains configuration or control data, which can be sent from the host to the device or retrieved from the device.\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Structure of the Report Descriptor\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The descriptor consists of items, where each item includes a byte that identifies the item and additional bytes that provide the details for the item.\n   </li>\n<li>\n    The format and structure of these items are defined by the HID class specification.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Example: Basic Report Descriptor\n</h4>\n<p>\n Listing 11-2 would typically show a simple report descriptor consisting of the following:\n</p>\n<ul>\n<li>\n<strong>\n   Input Report\n  </strong>\n  : Defines the data that the device sends to the host, in this case, two bytes of data.\n </li>\n<li>\n<strong>\n   Output Report\n  </strong>\n  : Defines the data that the host sends to the device, also consisting of two bytes of data.\n </li>\n<li>\n<strong>\n   Feature Report\n  </strong>\n  : A two-byte report that can be sent to the device or retrieved from it, used for controlling or configuring the device.\n </li>\n</ul>\n<hr/>\n<h3>\n Descriptor Fields\n</h3>\n<ul>\n<li>\n<p>\n<strong>\n    bNumDescriptors\n   </strong>\n   : This field specifies how many class-specific descriptors follow the HID class descriptor.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bDescriptorType\n   </strong>\n   : Identifies the type of the next descriptor. For instance,\n   <strong>\n    22h\n   </strong>\n   is for report descriptors. Physical descriptors, if present, will be identified by\n   <strong>\n    23h\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    wDescriptorLength\n   </strong>\n   : The length of the descriptor identified in the previous field.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Optional Fields\n   </strong>\n   : If there are physical descriptors, additional\n   <code>\n    bDescriptorType\n   </code>\n   and\n   <code>\n    wDescriptorLength\n   </code>\n   fields are used to specify their type and length.\n  </p>\n</li>\n</ul>\n<hr/>\n<h3>\n Summary\n</h3>\n<p>\n HID report descriptors are crucial for defining how data is structured and exchanged between a device and its host. By using a concise format, they allow efficient data transfer, which is important for devices with varying purposes, like mice, keyboards, or control systems. Understanding how these descriptors are organized helps ensure proper device communication and configuration.\n</p>\n"}, "Page 352": {"response": "<h3>\n Understanding Report Descriptor Items\n</h3>\n<p>\n In HID (Human Interface Device) communication, a\n <strong>\n  Report Descriptor\n </strong>\n defines the format of data exchanged between the device and the host. The example descriptor in Listing 11-2 describes three types of reports: Input, Output, and Feature. Each report in the descriptor defines how the data is structured and specifies how the device and host should handle it.\n</p>\n<p>\n Here\u2019s a breakdown of the key items in the descriptor and what each one means:\n</p>\n<h4>\n Key Items in a Report Descriptor\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Usage Page (0x06)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This item specifies the general category or function of the device, such as game controls, alphanumeric displays, or other vendor-specific functions.\n   </li>\n<li>\n    Example: In this descriptor, the\n    <strong>\n     Usage Page\n    </strong>\n    is defined as a vendor-specific value\n    <code>\n     0xFFA0\n    </code>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Usage (0x09)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     Usage\n    </strong>\n    item identifies the specific function of a report within the defined\n    <strong>\n     Usage Page\n    </strong>\n    . It specifies what the device does in terms of its functionality.\n   </li>\n<li>\n    Example: The\n    <strong>\n     Usage\n    </strong>\n    here is\n    <code>\n     0x01\n    </code>\n    , which is vendor-specific.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Collection (0xA1)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     Collection\n    </strong>\n    item defines a logical grouping of items that share a common function or purpose, like a group of controls or sensors.\n   </li>\n<li>\n    Example: This descriptor defines a\n    <strong>\n     Collection\n    </strong>\n    of type \"Application\" (0x01).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Logical Minimum (0x15)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     Logical Minimum\n    </strong>\n    sets the smallest possible value that the report item can have. This is often used to define the range of data values in reports.\n   </li>\n<li>\n    Example: The\n    <strong>\n     Logical Minimum\n    </strong>\n    here is\n    <code>\n     0x00\n    </code>\n    , which means the value in this report will start at 0.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Logical Maximum (0x26)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     Logical Maximum\n    </strong>\n    sets the largest possible value for the item in the report, defining the upper limit for the data.\n   </li>\n<li>\n    Example: The\n    <strong>\n     Logical Maximum\n    </strong>\n    is\n    <code>\n     0x00FF\n    </code>\n    , which means the maximum value for this report is 255.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Report Count (0x95)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This item specifies how many times the report item is repeated in the report. It indicates the number of fields or bytes that the host and device will send or receive for this report.\n   </li>\n<li>\n    Example:\n    <strong>\n     Report Count\n    </strong>\n    here is\n    <code>\n     0x02\n    </code>\n    , meaning there are two bytes of data in this report.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Report Size (0x75)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     Report Size\n    </strong>\n    defines how many bits each report item occupies. In this case, each item is 8 bits (1 byte).\n   </li>\n<li>\n    Example:\n    <strong>\n     Report Size\n    </strong>\n    here is\n    <code>\n     0x08\n    </code>\n    , indicating that each item is 8 bits wide.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Input (0x81)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     Input\n    </strong>\n    item specifies that the report is being sent from the device to the host. The parameters that follow define how the input data is structured.\n   </li>\n<li>\n    Example:\n    <strong>\n     Input\n    </strong>\n    here is marked as\n    <strong>\n     Data, Variable, Absolute\n    </strong>\n    , indicating the data is dynamic, variable in size, and absolute (not relative).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Output (0x91)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     Output\n    </strong>\n    item specifies that the report is being sent from the host to the device, with similar parameters to the\n    <strong>\n     Input\n    </strong>\n    item.\n   </li>\n<li>\n    Example:\n    <strong>\n     Output\n    </strong>\n    here is defined as\n    <strong>\n     Data, Variable, Absolute\n    </strong>\n    , just like the Input.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Feature (0xB1)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     Feature\n    </strong>\n    item defines a report that can be sent in either direction (host to device or device to host), used for configuration or control.\n   </li>\n<li>\n    Example:\n    <strong>\n     Feature\n    </strong>\n    is defined as\n    <strong>\n     Data, Variable, Absolute\n    </strong>\n    here, allowing the device to either send or receive configuration data.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    End Collection (0xC0)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     End Collection\n    </strong>\n    item marks the end of the logical collection started earlier. It indicates that no more related report items will follow.\n   </li>\n</ul>\n</li>\n</ol>\n<hr/>\n<h3>\n Example of a Report Descriptor\n</h3>\n<p>\n Here is a summary of the example in\n <strong>\n  Listing 11-2\n </strong>\n :\n</p>\n<ul>\n<li>\n  The descriptor defines three reports:\n  <ul>\n<li>\n<strong>\n     Input Report\n    </strong>\n    : The device sends 2 vendor-defined bytes to the host.\n   </li>\n<li>\n<strong>\n     Output Report\n    </strong>\n    : The host sends 2 vendor-defined bytes to the device.\n   </li>\n<li>\n<strong>\n     Feature Report\n    </strong>\n    : The host can either send or request 2 vendor-defined bytes.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n Each report consists of a series of items that define how the data is structured and handled. The device uses the\n <strong>\n  Usage Page\n </strong>\n and\n <strong>\n  Usage\n </strong>\n to specify what kind of data is being transferred, while the\n <strong>\n  Logical Minimum\n </strong>\n and\n <strong>\n  Logical Maximum\n </strong>\n define the valid range of data. The\n <strong>\n  Report Count\n </strong>\n and\n <strong>\n  Report Size\n </strong>\n define how much data is included in each report.\n</p>\n<p>\n These descriptors allow the HID device and the host to understand the format of the data, ensuring that they can communicate effectively.\n</p>\n"}, "Page 353": {"response": "<h3>\n Understanding the Structure of Report Descriptors and HID-Specific Requests\n</h3>\n<h4>\n Report Descriptor Structure\n</h4>\n<p>\n A\n <strong>\n  Report Descriptor\n </strong>\n defines the format and organization of data exchanged between a Human Interface Device (HID) and its host. Here\u2019s an in-depth look at how these descriptors are structured:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Usage Page and Usage\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     Usage Page\n    </strong>\n    identifies the general function of the device (e.g., mouse, keyboard, joystick). In this case, the example descriptor uses a\n    <strong>\n     vendor-defined Usage Page\n    </strong>\n    (\n    <code>\n     0xFFA0\n    </code>\n    ).\n   </li>\n<li>\n    The\n    <strong>\n     Usage\n    </strong>\n    identifies a specific function within the Usage Page. For example, in the descriptor,\n    <code>\n     0x01\n    </code>\n    represents a vendor-specific function.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Collection (Application)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     Collection\n    </strong>\n    groups related report items that together perform a single function. Each report descriptor must include at least one\n    <strong>\n     Application Collection\n    </strong>\n    to group related report items. This could be a group of controls like a keyboard or mouse.\n   </li>\n<li>\n    The\n    <strong>\n     Collection\n    </strong>\n    is opened with\n    <code>\n     0xA1\n    </code>\n    and contains the following items: a\n    <strong>\n     Usage\n    </strong>\n    ,\n    <strong>\n     Logical Minimum/Maximum\n    </strong>\n    ,\n    <strong>\n     Report Count/Size\n    </strong>\n    , and the type of report (Input, Output, or Feature).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Items in Each Report\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Usage\n    </strong>\n    : Each report data item has a\n    <strong>\n     vendor-defined Usage\n    </strong>\n    , which specifies what the data represents.\n   </li>\n<li>\n<strong>\n     Logical Minimum and Maximum\n    </strong>\n    : These define the valid range of values for the report. For instance, a device might have a minimum value of\n    <code>\n     0x00\n    </code>\n    and a maximum value of\n    <code>\n     0xFF\n    </code>\n    (255).\n   </li>\n<li>\n<strong>\n     Report Count and Size\n    </strong>\n    : The\n    <strong>\n     Report Count\n    </strong>\n    specifies how many data items are included in the report, and the\n    <strong>\n     Report Size\n    </strong>\n    defines the number of bits each item takes up (typically 8 bits, or 1 byte, in the example).\n   </li>\n<li>\n<strong>\n     Report Type\n    </strong>\n    : Each report can be marked as an\n    <strong>\n     Input\n    </strong>\n    (data from the device to the host),\n    <strong>\n     Output\n    </strong>\n    (data from the host to the device), or\n    <strong>\n     Feature\n    </strong>\n    report (optional, used for configuration data).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    End Collection\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     End Collection\n    </strong>\n    item (\n    <code>\n     0xC0\n    </code>\n    ) marks the end of the Application Collection, signifying that all report items belonging to this collection have been defined.\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n These items together allow the host and device to understand how to handle and interpret the data sent and received during communication.\n</p>\n<h4>\n HID-Specific Requests\n</h4>\n<p>\n The\n <strong>\n  HID specification\n </strong>\n defines several HID-specific requests that enable communication between the host and the device. These requests control the flow of data and the behavior of the device. Below is a breakdown of these requests:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Get_Report\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    All HIDs must support this request. It allows the host to retrieve data from the device.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Set_Report\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This request is used by the host to send data to the device. It is optional for most devices, but if the device does not have an\n    <strong>\n     Interrupt OUT endpoint\n    </strong>\n    (or is communicating with an older host, like Windows 98 Gold), it must support\n    <code>\n     Set_Report\n    </code>\n    to receive reports from the host.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Get_Idle\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This request retrieves the idle rate of the device, which determines whether or not the device will resend unchanged data during polling.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Set_Idle\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This request sets the idle rate, allowing the device to adjust its behavior and stop sending unchanged data.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Get_Protocol\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This request is used to retrieve the current protocol in use by the device (either boot or report protocol). Boot devices must support this request.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Set_Protocol\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This request sets the protocol type used by the device. Boot devices must support this request to switch from the boot protocol to the report protocol once the full HID drivers are loaded on the host.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Key Points:\n</h4>\n<ul>\n<li>\n<strong>\n   Mandatory Requests\n  </strong>\n  : All HIDs must support\n  <code>\n   Get_Report\n  </code>\n  . Devices that support the boot protocol must also support\n  <code>\n   Get_Protocol\n  </code>\n  and\n  <code>\n   Set_Protocol\n  </code>\n  .\n </li>\n<li>\n<strong>\n   Optional Requests\n  </strong>\n  :\n  <code>\n   Set_Report\n  </code>\n  ,\n  <code>\n   Get_Idle\n  </code>\n  , and\n  <code>\n   Set_Idle\n  </code>\n  are optional, except for keyboards using the boot protocol, which must support\n  <code>\n   Set_Idle\n  </code>\n  .\n </li>\n</ul>\n<p>\n Understanding these requests is crucial for ensuring proper communication between the HID and the host, allowing for configuration and data transfer as needed.\n</p>\n"}, "Page 354": {"response": "<h3>\n Overview of HID-Specific Requests\n</h3>\n<p>\n The\n <strong>\n  Human Interface Device (HID) specification\n </strong>\n defines six HID-specific requests that enable communication between the device and the host. These requests facilitate the transfer of reports, set idle durations, and manage protocols, among other things. Below is a detailed explanation of each request, along with its required data and functionality.\n</p>\n<h4>\n HID-Specific Requests Breakdown\n</h4>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Request Number\n    </strong>\n</th>\n<th>\n<strong>\n     Request\n    </strong>\n</th>\n<th>\n<strong>\n     Data Source (Data Stage)\n    </strong>\n</th>\n<th>\n<strong>\n     wValue\n    </strong>\n    (high byte, low byte)\n   </th>\n<th>\n<strong>\n     wIndex\n    </strong>\n</th>\n<th>\n<strong>\n     Data Length (wLength)\n    </strong>\n</th>\n<th>\n<strong>\n     Data Stage Contents\n    </strong>\n</th>\n<th>\n<strong>\n     Required?\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n    01h\n   </td>\n<td>\n<strong>\n     Get_Report\n    </strong>\n</td>\n<td>\n    Device\n   </td>\n<td>\n    Report type, Report ID\n   </td>\n<td>\n    Interface\n   </td>\n<td>\n    Report length\n   </td>\n<td>\n    Report data\n   </td>\n<td>\n    Yes\n   </td>\n</tr>\n<tr>\n<td>\n    02h\n   </td>\n<td>\n<strong>\n     Get_Idle\n    </strong>\n</td>\n<td>\n    Device\n   </td>\n<td>\n    0, Report ID\n   </td>\n<td>\n    Interface\n   </td>\n<td>\n    1 byte\n   </td>\n<td>\n    Idle duration\n   </td>\n<td>\n    No\n   </td>\n</tr>\n<tr>\n<td>\n    03h\n   </td>\n<td>\n<strong>\n     Get_Protocol\n    </strong>\n</td>\n<td>\n    Device\n   </td>\n<td>\n    0\n   </td>\n<td>\n    Interface\n   </td>\n<td>\n    1 byte\n   </td>\n<td>\n    Protocol in use (e.g., boot or report)\n   </td>\n<td>\n    Required for devices with boot protocol support\n   </td>\n</tr>\n<tr>\n<td>\n    09h\n   </td>\n<td>\n<strong>\n     Set_Report\n    </strong>\n</td>\n<td>\n    Host\n   </td>\n<td>\n    Report type, Report ID\n   </td>\n<td>\n    Interface\n   </td>\n<td>\n    Report length\n   </td>\n<td>\n    Report data to send\n   </td>\n<td>\n    No\n   </td>\n</tr>\n<tr>\n<td>\n    0Ah\n   </td>\n<td>\n<strong>\n     Set_Idle\n    </strong>\n</td>\n<td>\n    No data stage\n   </td>\n<td>\n    Idle duration, Report ID\n   </td>\n<td>\n    Interface\n   </td>\n<td>\n    None\n   </td>\n<td>\n    Idle duration and report ID\n   </td>\n<td>\n    No, except for keyboards with boot protocol\n   </td>\n</tr>\n<tr>\n<td>\n    0Bh\n   </td>\n<td>\n<strong>\n     Set_Protocol\n    </strong>\n</td>\n<td>\n    No data stage\n   </td>\n<td>\n    0, Protocol\n   </td>\n<td>\n    Interface\n   </td>\n<td>\n    None\n   </td>\n<td>\n    Protocol to switch to (e.g., boot or report)\n   </td>\n<td>\n    Required for devices with boot protocol support\n   </td>\n</tr>\n</tbody>\n</table>\n<h4>\n Explanation of Each Request:\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Get_Report (01h)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Purpose\n    </strong>\n    : Retrieves data from the device in the form of a report.\n   </li>\n<li>\n<strong>\n     Data Source\n    </strong>\n    : The device.\n   </li>\n<li>\n<strong>\n     Parameters\n    </strong>\n    :\n    <ul>\n<li>\n<code>\n       wValue\n      </code>\n      : Specifies the type of report and the report ID.\n     </li>\n<li>\n<code>\n       wIndex\n      </code>\n      : Refers to the interface the request is targeting.\n     </li>\n<li>\n<code>\n       wLength\n      </code>\n      : The length of the report.\n     </li>\n</ul>\n</li>\n<li>\n<strong>\n     Required?\n    </strong>\n    : Yes. This is a mandatory request for all HIDs.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Get_Idle (02h)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Purpose\n    </strong>\n    : Retrieves the idle duration, which controls how long the device waits before resending unchanged data.\n   </li>\n<li>\n<strong>\n     Data Source\n    </strong>\n    : The device.\n   </li>\n<li>\n<strong>\n     Parameters\n    </strong>\n    :\n    <ul>\n<li>\n<code>\n       wValue\n      </code>\n      : Always 0, along with the report ID.\n     </li>\n<li>\n<code>\n       wIndex\n      </code>\n      : Refers to the interface.\n     </li>\n<li>\n<code>\n       wLength\n      </code>\n      : The size of the idle duration data.\n     </li>\n</ul>\n</li>\n<li>\n<strong>\n     Required?\n    </strong>\n    : No. This request is optional, but may be used for fine-tuning idle behaviors.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Get_Protocol (03h)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Purpose\n    </strong>\n    : Retrieves the current protocol in use, either a simplified boot protocol or the full report protocol.\n   </li>\n<li>\n<strong>\n     Data Source\n    </strong>\n    : The device.\n   </li>\n<li>\n<strong>\n     Parameters\n    </strong>\n    :\n    <ul>\n<li>\n<code>\n       wValue\n      </code>\n      : Always 0.\n     </li>\n<li>\n<code>\n       wIndex\n      </code>\n      : Refers to the interface.\n     </li>\n<li>\n<code>\n       wLength\n      </code>\n      : Size of the protocol data.\n     </li>\n</ul>\n</li>\n<li>\n<strong>\n     Required?\n    </strong>\n    : Yes, for devices that support the boot protocol. This request allows the host to determine which protocol the device is currently using.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Set_Report (09h)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Purpose\n    </strong>\n    : Sends data to the device in the form of a report.\n   </li>\n<li>\n<strong>\n     Data Source\n    </strong>\n    : The host.\n   </li>\n<li>\n<strong>\n     Parameters\n    </strong>\n    :\n    <ul>\n<li>\n<code>\n       wValue\n      </code>\n      : Specifies the type of report and the report ID.\n     </li>\n<li>\n<code>\n       wIndex\n      </code>\n      : Refers to the interface the request is targeting.\n     </li>\n<li>\n<code>\n       wLength\n      </code>\n      : The length of the report being sent.\n     </li>\n</ul>\n</li>\n<li>\n<strong>\n     Required?\n    </strong>\n    : No. This is an optional request, but it is necessary for certain communication situations, such as when a device lacks an interrupt OUT endpoint.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Set_Idle (0Ah)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Purpose\n    </strong>\n    : Sets the idle duration for the device, determining how long it waits before resending unchanged data.\n   </li>\n<li>\n<strong>\n     Data Source\n    </strong>\n    : No data stage.\n   </li>\n<li>\n<strong>\n     Parameters\n    </strong>\n    :\n    <ul>\n<li>\n<code>\n       wValue\n      </code>\n      : Specifies the idle duration and the report ID.\n     </li>\n<li>\n<code>\n       wIndex\n      </code>\n      : Refers to the interface.\n     </li>\n</ul>\n</li>\n<li>\n<strong>\n     Required?\n    </strong>\n    : No, except for keyboards that use the boot protocol, which must support this request.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Set_Protocol (0Bh)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Purpose\n    </strong>\n    : Allows the host to switch the device's protocol from the boot protocol to the report protocol or vice versa.\n   </li>\n<li>\n<strong>\n     Data Source\n    </strong>\n    : No data stage.\n   </li>\n<li>\n<strong>\n     Parameters\n    </strong>\n    :\n    <ul>\n<li>\n<code>\n       wValue\n      </code>\n      : Specifies the protocol type (0 for boot, 1 for report).\n     </li>\n<li>\n<code>\n       wIndex\n      </code>\n      : Refers to the interface.\n     </li>\n</ul>\n</li>\n<li>\n<strong>\n     Required?\n    </strong>\n    : Yes, for devices that support the boot protocol. This request is crucial for transitioning between protocols, especially when HID drivers are not yet fully loaded on the host.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Summary:\n</h4>\n<p>\n These HID-specific requests define how data is exchanged between the host and the device, allowing the host to retrieve data, configure idle behaviors, and switch protocols. Understanding these requests is key to ensuring proper communication and functionality for HID devices. Some of these requests, like\n <strong>\n  Get_Report\n </strong>\n and\n <strong>\n  Set_Report\n </strong>\n , are mandatory, while others, like\n <strong>\n  Set_Idle\n </strong>\n , are only required for certain devices (e.g., keyboards using the boot protocol).\n</p>\n"}, "Page 355": {"response": "<h3>\n Get_Report Request\n</h3>\n<p>\n The\n <strong>\n  Get_Report\n </strong>\n request allows the host to retrieve either an Input or Feature report from a HID device using a control transfer. This request is a vital part of HID communication and is mandatory for all HIDs.\n</p>\n<h4>\n Key Details:\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Purpose\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The host sends a request to retrieve an Input or Feature report from the device.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Request Number (bRequest)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    01h, which identifies this request as the \"Get_Report\" request.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Source of Data\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The data is provided by the device.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Data Length (wLength)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Specifies the length of the report being returned by the device.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Contents of wValue Field\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     high byte\n    </strong>\n    contains the\n    <strong>\n     report type\n    </strong>\n    (1 for Input, 3 for Feature).\n   </li>\n<li>\n    The\n    <strong>\n     low byte\n    </strong>\n    contains the\n    <strong>\n     report ID\n    </strong>\n    . The default report ID is\n    <strong>\n     0\n    </strong>\n    if not specified.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Contents of wIndex Field\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Refers to the\n    <strong>\n     interface number\n    </strong>\n    that the request is targeting.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Contents of Data Packet (Data Stage)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The device sends the requested report in the data stage. This report will be based on the report type and ID specified in the wValue field.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Comments\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    All HIDs are required to support this request to ensure that the host can retrieve data from the device. The request is typically followed by a\n    <strong>\n     Set_Report\n    </strong>\n    request for sending data back to the device.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n This request is essential for communication between the host and the HID, particularly in cases where the host needs to fetch data from the device's reports, such as input data from a keyboard or mouse.\n</p>\n"}, "Page 356": {"response": "<h3>\n Get_Idle Request\n</h3>\n<p>\n The\n <strong>\n  Get_Idle\n </strong>\n request allows the host to retrieve the current idle rate from a HID device. This rate indicates how often the device should resend its data if no changes occur. It's typically used for power management and efficient communication.\n</p>\n<h4>\n Key Details:\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Purpose\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The host queries the HID to read its current Idle rate.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Request Number (bRequest)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    02h, identifying the request as \"Get_Idle.\"\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Source of Data\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The device provides the data.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Data Length (wLength)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The data length is\n    <strong>\n     1 byte\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Contents of wValue Field\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     high byte\n    </strong>\n    is set to\n    <strong>\n     0\n    </strong>\n    .\n   </li>\n<li>\n    The\n    <strong>\n     low byte\n    </strong>\n    contains the\n    <strong>\n     report ID\n    </strong>\n    the request applies to. If the low byte is\n    <strong>\n     0\n    </strong>\n    , the request applies to all Input reports of the HID.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Contents of wIndex Field\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     interface number\n    </strong>\n    that supports this request.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Contents of Data Packet (Data Stage)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The device returns the\n    <strong>\n     Idle rate\n    </strong>\n    in the data stage, expressed in units of\n    <strong>\n     4 milliseconds\n    </strong>\n    . This rate represents the duration a report must remain unchanged before the device sends it again.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Comments\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This request is optional for HIDs to support. For HIDs that implement it, it can be useful for controlling the behavior of the device during periods of inactivity. Refer to\n    <strong>\n     Set_Idle\n    </strong>\n    for more context on how the Idle rate works.\n   </li>\n</ul>\n</li>\n</ul>\n"}, "Page 357": {"response": "<h3>\n Get_Protocol Request\n</h3>\n<p>\n The\n <strong>\n  Get_Protocol\n </strong>\n request allows the host to determine whether a HID device is currently using the\n <strong>\n  boot protocol\n </strong>\n or the\n <strong>\n  report protocol\n </strong>\n . This helps the host identify which protocol the device is operating under, particularly during system startup or in safe mode when the full HID drivers may not be loaded.\n</p>\n<h4>\n Key Details:\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Purpose\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The host uses this request to check if the HID device is using the\n    <strong>\n     boot protocol\n    </strong>\n    or the\n    <strong>\n     report protocol\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Request Number (bRequest)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     03h\n    </strong>\n    , identifying this as the \"Get_Protocol\" request.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Source of Data\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The device responds with the data.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Data Length (wLength)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The data length is\n    <strong>\n     1 byte\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Contents of wValue Field\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Set to\n    <strong>\n     0\n    </strong>\n    , as this field is not used in this request.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Contents of wIndex Field\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     interface number\n    </strong>\n    that supports the request.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Contents of Data Packet (Data Stage)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The data returned in the\n    <strong>\n     Data stage\n    </strong>\n    indicates the current protocol:\n    <ul>\n<li>\n<strong>\n       0\n      </strong>\n      = boot protocol\n     </li>\n<li>\n<strong>\n       1\n      </strong>\n      = report protocol\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Comments\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Boot devices\n    </strong>\n    (such as keyboards and mice) are required to support this request. This is essential for proper operation during boot or when operating in environments with limited driver support.\n   </li>\n<li>\n    For more details on switching between protocols, refer to\n    <strong>\n     Set_Protocol\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n</ul>\n"}, "Page 358": {"response": "<h3>\n Set_Report Request\n</h3>\n<p>\n The\n <strong>\n  Set_Report\n </strong>\n request is used by the host to send an\n <strong>\n  Output\n </strong>\n or\n <strong>\n  Feature\n </strong>\n report to a Human Interface Device (HID) through a control transfer. This request allows the host to communicate with the HID by sending data.\n</p>\n<h4>\n Key Details:\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Purpose\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The host sends either an\n    <strong>\n     Output\n    </strong>\n    or\n    <strong>\n     Feature\n    </strong>\n    report to the HID.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Request Number (bRequest)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     09h\n    </strong>\n    , which identifies this as the \"Set_Report\" request.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Source of Data\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     host\n    </strong>\n    provides the data for the report.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Data Length (wLength)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The length of the report being sent.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Contents of wValue Field\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     high byte\n    </strong>\n    indicates the type of report:\n    <ul>\n<li>\n<strong>\n       2\n      </strong>\n      for\n      <strong>\n       Output\n      </strong>\n      reports\n     </li>\n<li>\n<strong>\n       3\n      </strong>\n      for\n      <strong>\n       Feature\n      </strong>\n      reports\n     </li>\n</ul>\n</li>\n<li>\n    The\n    <strong>\n     low byte\n    </strong>\n    contains the\n    <strong>\n     report ID\n    </strong>\n    (default is zero).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Contents of wIndex Field\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     interface number\n    </strong>\n    to which the request is directed.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Contents of Data Packet (Data Stage)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The actual\n    <strong>\n     report\n    </strong>\n    data sent by the host.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Comments\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    If the HID interface does not have an\n    <strong>\n     Interrupt OUT\n    </strong>\n    endpoint or if the host is using HID specification version\n    <strong>\n     1.0\n    </strong>\n    , the\n    <strong>\n     Set_Report\n    </strong>\n    request is the only way for the host to send data to the HID.\n   </li>\n<li>\n<strong>\n     HIDs\n    </strong>\n    are not required to support this request, but it is an important method of communication between the host and the device when interrupt endpoints are not available.\n   </li>\n<li>\n    See\n    <strong>\n     Get_Report\n    </strong>\n    for more details about retrieving reports from the HID.\n   </li>\n</ul>\n</li>\n</ul>\n"}, "Page 359": {"response": "<h3>\n Set_Idle Request\n</h3>\n<p>\n The\n <strong>\n  Set_Idle\n </strong>\n request is used to manage the frequency at which a Human Interface Device (HID) sends reports through an interrupt\n <strong>\n  IN\n </strong>\n endpoint. It helps reduce bandwidth usage by limiting reports when the data hasn't changed since the last report.\n</p>\n<h4>\n Key Details:\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Purpose\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This request controls the interval at which the HID sends reports, effectively reducing bandwidth by sending reports only when necessary. If the data hasn't changed, the HID may delay the report.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Request Number (bRequest)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     0Ah\n    </strong>\n    , which identifies this as the \"Set_Idle\" request.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Source of Data\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    No data is sent in the\n    <strong>\n     Data stage\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Data Length (wLength)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    No data is sent in the\n    <strong>\n     Data stage\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Contents of wValue Field\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     High byte\n    </strong>\n    : Sets the duration (maximum time between reports).\n    <ul>\n<li>\n      A value of\n      <strong>\n       0\n      </strong>\n      means the HID will send a report only when the data changes.\n     </li>\n</ul>\n</li>\n<li>\n<strong>\n     Low byte\n    </strong>\n    : Indicates the report ID.\n    <ul>\n<li>\n      If it\u2019s zero, the request applies to all\n      <strong>\n       Input reports\n      </strong>\n      from the HID.\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Contents of wIndex Field\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Specifies the\n    <strong>\n     interface number\n    </strong>\n    the request is directed to.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Contents of Data Packet (Data Stage)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    There is\n    <strong>\n     no Data stage\n    </strong>\n    for this request.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Comments\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The duration is in\n    <strong>\n     4 millisecond units\n    </strong>\n    , providing a range from 4 to 1,020 milliseconds.\n   </li>\n<li>\n    If the data has changed since the last report, the HID will send a report regardless of the duration setting.\n   </li>\n<li>\n    If the data hasn\u2019t changed and the duration hasn't expired, the HID will return a\n    <strong>\n     NAK\n    </strong>\n    (Negative Acknowledgment).\n   </li>\n<li>\n    If the duration expires, even with unchanged data, the HID will send the report.\n   </li>\n<li>\n    A\n    <strong>\n     duration value of 0\n    </strong>\n    indicates an infinite duration, where the HID will send a report only if the data has changed and will return\n    <strong>\n     NAK\n    </strong>\n    otherwise.\n   </li>\n<li>\n    If the HID responds with a\n    <strong>\n     STALL\n    </strong>\n    , it can send reports regardless of whether the data has changed.\n   </li>\n<li>\n    During enumeration, the\n    <strong>\n     Windows HID driver\n    </strong>\n    attempts to set the idle rate to zero. The HID should\n    <strong>\n     STALL\n    </strong>\n    the request if it does not want an infinite idle duration.\n   </li>\n<li>\n<strong>\n     HIDs\n    </strong>\n    are not required to support this request, except for\n    <strong>\n     keyboards\n    </strong>\n    using the\n    <strong>\n     boot protocol\n    </strong>\n    .\n   </li>\n<li>\n    See also\n    <strong>\n     Get_Idle\n    </strong>\n    for more details on managing idle behavior.\n   </li>\n</ul>\n</li>\n</ul>\n"}, "Page 360": {"response": "<h3>\n Set_Protocol Request\n</h3>\n<p>\n The\n <strong>\n  Set_Protocol\n </strong>\n request allows the host to specify whether the HID device should use the\n <strong>\n  boot protocol\n </strong>\n or the\n <strong>\n  report protocol\n </strong>\n for communication.\n</p>\n<h4>\n Key Details:\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Purpose\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This request is used to set the protocol mode for the HID. The host decides whether the HID should operate in the\n    <strong>\n     boot protocol\n    </strong>\n    (simpler and supported during boot-up) or in the\n    <strong>\n     report protocol\n    </strong>\n    (more complex and used after the OS loads full HID drivers).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Request Number (bRequest)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     0Bh\n    </strong>\n    , identifying this as the \"Set_Protocol\" request.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Source of Data\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    No data is transferred during the\n    <strong>\n     Data stage\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Data Length (wLength)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    There is no data in the\n    <strong>\n     Data stage\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Contents of wValue Field\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     High byte\n    </strong>\n    : Specifies the protocol type.\n    <ul>\n<li>\n<strong>\n       0\n      </strong>\n      indicates the\n      <strong>\n       boot protocol\n      </strong>\n      .\n     </li>\n<li>\n<strong>\n       1\n      </strong>\n      indicates the\n      <strong>\n       report protocol\n      </strong>\n      .\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Contents of wIndex Field\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Specifies the\n    <strong>\n     interface number\n    </strong>\n    that this request is directed to.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Contents of Data Packet (Data Stage)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    No data is sent during the\n    <strong>\n     Data stage\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Comments\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Boot devices\n    </strong>\n    (such as keyboards and mice in basic operating modes) must support this request.\n   </li>\n<li>\n    The\n    <strong>\n     Get_Protocol\n    </strong>\n    request can be used to check which protocol the HID is currently using.\n   </li>\n<li>\n    This request is important for toggling between simpler boot protocol communication and more advanced report-based communication.\n   </li>\n</ul>\n</li>\n</ul>\n"}, "Page 361": {"response": "<h3>\n Transferring Data\n</h3>\n<p>\n Once USB enumeration is completed, the host has successfully identified the device as a\n <strong>\n  Human Interface Device (HID)\n </strong>\n , established communication pipes with the device's endpoints, and understands the necessary report formats for sending and receiving data.\n</p>\n<h4>\n Data Transfer Mechanisms:\n</h4>\n<ul>\n<li>\n<strong>\n   Host to Device Communication\n  </strong>\n  :\n  <ul>\n<li>\n    The host can request reports from the HID device using\n    <strong>\n     interrupt IN transfers\n    </strong>\n    or\n    <strong>\n     control transfers\n    </strong>\n    with\n    <strong>\n     Get_Report\n    </strong>\n    requests.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Device to Host Communication\n  </strong>\n  :\n  <ul>\n<li>\n    The HID device may also receive reports from the host using\n    <strong>\n     interrupt OUT transfers\n    </strong>\n    or\n    <strong>\n     control transfers\n    </strong>\n    with\n    <strong>\n     Set_Report\n    </strong>\n    requests.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n Both\n <strong>\n  Get_Report\n </strong>\n (control read transfer) and\n <strong>\n  Set_Report\n </strong>\n (control write transfer) requests involve transferring HID reports. These control transfers are similar to the\n <strong>\n  Get_Descriptor\n </strong>\n request but differ in that they deal with reports instead of descriptors.\n</p>\n<h3>\n Example Firmware and Code Structure\n</h3>\n<p>\n The example code provided is specifically for the\n <strong>\n  Microchip PIC18F4550\n </strong>\n microcontroller, introduced earlier in Chapter 6, and utilizes the\n <strong>\n  Microchip USB Firmware Framework\n </strong>\n . Although tailored for the PIC18 family, the principles and structure can apply to other microcontrollers as well.\n</p>\n<ul>\n<li>\n<strong>\n   Example Code Purpose\n  </strong>\n  :\n  <ul>\n<li>\n    It demonstrates the operation of a generic HID device, focusing on both sending and receiving HID reports. The code is derived from Microchip's mouse code and adapts it to a broader, more flexible HID implementation.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Utility for Non-HID Devices\n  </strong>\n  :\n  <ul>\n<li>\n    Even if your device is not an HID, this example code may still be useful. The sections dealing with\n    <strong>\n     control transfers\n    </strong>\n    can act as templates for responding to\n    <strong>\n     class-specific\n    </strong>\n    or\n    <strong>\n     vendor-specific requests\n    </strong>\n    .\n   </li>\n<li>\n    Additionally, since\n    <strong>\n     bulk\n    </strong>\n    and\n    <strong>\n     interrupt transfers\n    </strong>\n    are handled similarly in the firmware, the\n    <strong>\n     interrupt transfer\n    </strong>\n    code can be applied to firmware that uses these transfer types.\n   </li>\n</ul>\n</li>\n</ul>\n<h3>\n System Files in the Framework\n</h3>\n<p>\n The firmware framework includes several system files that manage both general USB functions and tasks specific to the HID class. These system files generally require minimal or no modification and serve as a base for specific applications.\n</p>\n"}, "Page 362": {"response": "<h3>\n USB Firmware Structure for HID Devices\n</h3>\n<p>\n The USB firmware code is structured into several source files, each handling specific tasks essential for the operation of the USB communication and HID device. Here\u2019s an overview of these files and their purposes:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    usbmmap.c\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This file is responsible for allocating memory to store variables, endpoints, and buffers that are needed for USB communications.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    usbdrv.c\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Contains functions to handle the detection of device attachment and removal.\n   </li>\n<li>\n    Manages USB hardware interrupts, and controls the entry and exit of the\n    <strong>\n     Suspend state\n    </strong>\n    .\n   </li>\n<li>\n    Responds to\n    <strong>\n     bus resets\n    </strong>\n    during the operation of the device.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    usbctrltrf.c\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Contains functions for managing\n    <strong>\n     control transfers\n    </strong>\n    .\n   </li>\n<li>\n    These functions decode incoming\n    <strong>\n     Setup packets\n    </strong>\n    , handle data transfer in the\n    <strong>\n     Data stage\n    </strong>\n    , and manage the\n    <strong>\n     Status stage\n    </strong>\n    for completion signals.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    usb9.c\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This file contains functions that handle requests defined in\n    <strong>\n     Chapter 9\n    </strong>\n    of the USB specification.\n   </li>\n<li>\n    It decodes incoming requests, provides data for descriptors, and executes actions like selecting a configuration or setting an address.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    hid.c\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Manages tasks specific to the\n    <strong>\n     HID class\n    </strong>\n    .\n   </li>\n<li>\n    Functions in this file decode incoming\n    <strong>\n     Setup data\n    </strong>\n    directed to the HID interface and provide pointers for both sending and receiving data during\n    <strong>\n     control\n    </strong>\n    and\n    <strong>\n     interrupt transfers\n    </strong>\n    .\n   </li>\n<li>\n    It also handles HID-specific requests, such as\n    <strong>\n     Get_Idle\n    </strong>\n    and\n    <strong>\n     Set_Idle\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    usbdesc.c\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Contains structures that hold various\n    <strong>\n     device descriptors\n    </strong>\n    (e.g., device descriptor, configuration descriptors, string descriptors, and the report descriptor).\n   </li>\n<li>\n    These descriptors are crucial for device enumeration and communication and will vary depending on the device.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    user_generic_hid.c\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This file holds the majority of the code specific to the HID application.\n   </li>\n<li>\n    It contains functions that obtain data to be sent in reports and process the data received in reports.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    main.c\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <code>\n     main.c\n    </code>\n    file initializes the system and enters a loop to check the\n    <strong>\n     bus status\n    </strong>\n    .\n   </li>\n<li>\n    It then calls functions from\n    <code>\n     user_generic_hid.c\n    </code>\n    to perform the device\u2019s core functionality.\n   </li>\n</ul>\n</li>\n</ol>\n<h3>\n Key Points on Code Structure:\n</h3>\n<ul>\n<li>\n<strong>\n   Application-specific code\n  </strong>\n  is primarily found in\n  <strong>\n   user_generic_hid.c\n  </strong>\n  , which handles how data is exchanged in HID reports.\n </li>\n<li>\n  The code from\n  <strong>\n   usbdesc.c\n  </strong>\n  ,\n  <strong>\n   usbdrv.c\n  </strong>\n  ,\n  <strong>\n   usbctrltrf.c\n  </strong>\n  , and\n  <strong>\n   hid.c\n  </strong>\n  are general-purpose, designed to handle basic USB and HID communication tasks.\n </li>\n<li>\n  The following sections of the document will focus on\n  <strong>\n   application-specific code\n  </strong>\n  related to sending and receiving HID reports.\n </li>\n</ul>\n<p>\n This modular approach helps in organizing the USB firmware and ensures that each aspect of the HID functionality is managed independently, making it easier to modify and extend as needed.\n</p>\n"}, "Page 363": {"response": "<h3>\n Sending Reports via Interrupt Transfers\n</h3>\n<p>\n Once the HID driver is loaded on the host, the host controller begins sending periodic\n <strong>\n  IN token packets\n </strong>\n to the HID\u2019s\n <strong>\n  interrupt IN endpoint\n </strong>\n . The endpoint should respond by\n <strong>\n  NAKing\n </strong>\n these packets until the HID has an\n <strong>\n  Input report\n </strong>\n to send. When the HID is ready to send data via an interrupt transfer, the device firmware typically places the data into the endpoint\u2019s buffer and configures the endpoint to send it to the host upon receiving an IN token packet.\n</p>\n<h4>\n Code Example for Configuring the Interrupt IN Endpoint:\n</h4>\n<p>\n In the\n <code>\n  usbmmap.c\n </code>\n file, the\n <code>\n  hid_report_in\n </code>\n array is declared to hold the report data, with its length matching the endpoint\u2019s\n <code>\n  wMaxPacketSize\n </code>\n :\n</p>\nc\nCopy code\n<code class=\"!whitespace-pre hljs language-c\">\n extern\n volatile\n far\n unsigned\n char\n hid_report_in[HID_INT_IN_EP_SIZE];\n</code>\n<p>\n To initialize the\n <strong>\n  interrupt IN endpoint\n </strong>\n , the firmware sets values in the\n <strong>\n  endpoint\u2019s buffer descriptor\n </strong>\n (\n <code>\n  HID_BD_IN\n </code>\n ). Here's how this is done:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Set the address register\n   </strong>\n   :\nThe endpoint's address register is set to point to the\n   <code>\n    hid_report_in\n   </code>\n   buffer:\n  </p>\n  c\n  Copy code\n  <code class=\"!whitespace-pre hljs language-c\">\n   HID_BD_IN.ADR = (byte*)&amp;hid_report_in;\n  </code>\n</li>\n<li>\n<p>\n<strong>\n    Set the status register\n   </strong>\n   :\nThe status register is configured with the following bits:\n  </p>\n<ul>\n<li>\n<strong>\n     _UCPU\n    </strong>\n    : Indicates that the\n    <strong>\n     CPU owns the buffer\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     _DAT1\n    </strong>\n    : Specifies that the\n    <strong>\n     next data toggle\n    </strong>\n    expected is\n    <strong>\n     DATA1\n    </strong>\n    .\n   </li>\n</ul>\n<p>\n   Before sending data, the\n   <strong>\n    mUSBBufferReady macro\n   </strong>\n   is called to toggle the data toggle bit:\n  </p>\n  c\n  Copy code\n  <code class=\"!whitespace-pre hljs language-c\">\n   HID_BD_IN.Stat._byte = _UCPU | _DAT1;\n  </code>\n</li>\n</ol>\n<h4>\n Function to Send Data:\n</h4>\n<p>\n The following function handles the process of making the data available in the endpoint\u2019s buffer. It accepts two parameters:\n</p>\n<ul>\n<li>\n  A pointer to the buffer containing the report data (\n  <code>\n   *buffer\n  </code>\n  ).\n </li>\n<li>\n  The number of bytes to send (\n  <code>\n   len\n  </code>\n  ).\n </li>\n</ul>\n<p>\n This function sets up the interrupt IN endpoint to send the provided data when the appropriate\n <strong>\n  IN token packet\n </strong>\n is received from the host.\n</p>\n<h3>\n Summary:\n</h3>\n<ul>\n<li>\n<strong>\n   Interrupt IN transfers\n  </strong>\n  are initiated when the host periodically requests data from the HID device. The device responds by sending reports when it has data ready.\n </li>\n<li>\n  The device firmware prepares the data by placing it into a buffer (\n  <code>\n   hid_report_in\n  </code>\n  ) and configures the endpoint descriptor (\n  <code>\n   HID_BD_IN\n  </code>\n  ) to send the data when requested by the host.\n </li>\n<li>\n  The\n  <strong>\n   status register\n  </strong>\n  is configured to ensure correct data transmission using the\n  <strong>\n   DATA toggle\n  </strong>\n  mechanism, and the\n  <strong>\n   mUSBBufferReady macro\n  </strong>\n  helps manage this toggle.\n </li>\n</ul>\n<p>\n This approach allows the HID device to communicate efficiently with the host by sending data only when needed, saving bandwidth and reducing unnecessary data traffic.\n</p>\n"}, "Page 364": {"response": "<h3>\n HIDTxReport Function for Sending Data in Input Reports\n</h3>\n<p>\n The\n <strong>\n  HIDTxReport\n </strong>\n function is designed to send an Input report via the HID\u2019s\n <strong>\n  interrupt IN endpoint\n </strong>\n . It prepares the data for transfer and ensures the endpoint is ready to send the report when the host sends an IN token packet.\n</p>\n<h4>\n Function Overview:\n</h4>\n<ul>\n<li>\n<strong>\n   Parameters\n  </strong>\n  :\n  <ul>\n<li>\n<code>\n     char *buffer\n    </code>\n    : A pointer to the buffer containing the report data.\n   </li>\n<li>\n<code>\n     byte len\n    </code>\n    : The length of the report data to send.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Process\n  </strong>\n  :\n  <ol>\n<li>\n<p>\n<strong>\n      Length Validation\n     </strong>\n     :\n    </p>\n<ul>\n<li>\n      The length (\n      <code>\n       len\n      </code>\n      ) of the report cannot exceed the endpoint's maximum packet size, defined by\n      <code>\n       HID_INT_IN_EP_SIZE\n      </code>\n      . If the length is greater, it is truncated to the endpoint\u2019s maximum size.\n     </li>\n</ul>\n    c\n    Copy code\n    <code class=\"!whitespace-pre hljs language-c\">\n     if\n     (len &gt; HID_INT_IN_EP_SIZE)\n    len = HID_INT_IN_EP_SIZE;\n    </code>\n</li>\n<li>\n<p>\n<strong>\n      Copy Data\n     </strong>\n     :\n    </p>\n<ul>\n<li>\n      The function copies the data from the provided buffer (\n      <code>\n       buffer\n      </code>\n      ) into the endpoint's buffer (\n      <code>\n       hid_report_in\n      </code>\n      ) byte by byte. This prepares the data for transmission.\n     </li>\n</ul>\n    c\n    Copy code\n    <code class=\"!whitespace-pre hljs language-c\">\n     for\n     (i =\n     0\n     ; i &lt; len; i++)\n    hid_report_in[i] = buffer[i];\n    </code>\n</li>\n<li>\n<p>\n<strong>\n      Set the Buffer Descriptor's Count\n     </strong>\n     :\n    </p>\n<ul>\n<li>\n      The count register of the buffer descriptor (\n      <code>\n       HID_BD_IN.Cnt\n      </code>\n      ) is set to the length of the data (\n      <code>\n       len\n      </code>\n      ). This tells the system how many bytes to send.\n     </li>\n</ul>\n    c\n    Copy code\n    <code class=\"!whitespace-pre hljs language-c\">\n     HID_BD_IN.Cnt = len;\n    </code>\n</li>\n<li>\n<p>\n<strong>\n      Prepare the Endpoint for Data Transfer\n     </strong>\n     :\n    </p>\n<ul>\n<li>\n      The\n      <strong>\n       mUSBBufferReady macro\n      </strong>\n      is called, which toggles the data toggle and transfers the ownership of the buffer to the\n      <strong>\n       Serial Interface Engine (SIE)\n      </strong>\n      . The SIE will then send the data when the host requests it through an IN token packet.\n     </li>\n</ul>\n    c\n    Copy code\n    <code class=\"!whitespace-pre hljs language-c\">\n     mUSBBufferReady(HID_BD_IN);\n    </code>\n</li>\n</ol>\n</li>\n</ul>\n<h4>\n Summary:\n</h4>\n<p>\n The\n <code>\n  HIDTxReport\n </code>\n function ensures that the HID device is ready to send an Input report:\n</p>\n<ul>\n<li>\n  It validates and possibly truncates the length of the report to fit within the endpoint's size.\n </li>\n<li>\n  The report data is copied to the endpoint buffer.\n </li>\n<li>\n  The length of the report is updated in the buffer descriptor.\n </li>\n<li>\n  The function then signals the USB subsystem to send the data when the host requests it, ensuring smooth communication with the host.\n </li>\n</ul>\n<p>\n This function plays a critical role in preparing and sending data to the host in response to periodic IN token packets.\n</p>\n"}, "Page 365": {"response": "<h3>\n Process of Sending Reports Using Interrupt IN Transfers\n</h3>\n<p>\n This section describes the process of preparing and sending an Input report via the\n <strong>\n  interrupt IN endpoint\n </strong>\n . The report data is placed in a buffer and sent after ensuring the CPU owns the endpoint buffer.\n</p>\n<h4>\n Step-by-Step Process:\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Prepare the Report Data\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    First, the report data is placed in an array (\n    <code>\n     transmit_buffer\n    </code>\n    ).\n   </li>\n</ul>\n  c\n  Copy code\n  <code class=\"!whitespace-pre hljs language-c\">\n   char\n   transmit_buffer[\n   2\n   ];\ntransmit_buffer[\n   0\n   ] =\n   104\n   ;\n   // Report data\n   transmit_buffer[\n   1\n   ] =\n   105\n   ;\n   // Report data\n  </code>\n</li>\n<li>\n<p>\n<strong>\n    Wait for the Endpoint to Be Ready\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The firmware checks whether the CPU has control over the interrupt IN endpoint buffer. It uses the\n    <strong>\n     mHIDTxIsBusy\n    </strong>\n    macro to wait until the buffer is available for the CPU to use.\n   </li>\n<li>\n    While waiting, the\n    <strong>\n     USBDriverService\n    </strong>\n    function is called to handle any USB-related interrupts that may occur.\n   </li>\n</ul>\n  c\n  Copy code\n  <code class=\"!whitespace-pre hljs language-c\">\n   while\n   (mHIDTxIsBusy()) {\n    USBDriverService();\n   // Handle USB interrupts\n   }\n  </code>\n</li>\n<li>\n<p>\n<strong>\n    Call HIDTxReport\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Once the buffer is available, the\n    <strong>\n     HIDTxReport\n    </strong>\n    function is called to make the report data available for transmission. The buffer and the length of the report are passed as parameters to this function.\n   </li>\n</ul>\n  c\n  Copy code\n  <code class=\"!whitespace-pre hljs language-c\">\n   HIDTxReport(transmit_buffer,\n   2\n   );\n   // Send 2 bytes of report data\n  </code>\n</li>\n</ol>\n<h4>\n Inside the\n <code>\n  HIDTxReport\n </code>\n Function:\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Handling the Length\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The length (\n    <code>\n     len\n    </code>\n    ) is checked to ensure it does not exceed the endpoint\u2019s maximum packet size (\n    <code>\n     wMaxPacketSize\n    </code>\n    ). If the length is too large, it is reduced to the maximum size.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Copying Data to Endpoint Buffer\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The function copies the data from the provided\n    <code>\n     transmit_buffer\n    </code>\n    to the endpoint buffer (\n    <code>\n     hid_report_in\n    </code>\n    ).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Setting the Byte Count\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The byte count register (\n    <code>\n     HID_BD_IN.Cnt\n    </code>\n    ) is updated with the number of bytes to be sent, indicating how much data will be transferred in the next interrupt IN transaction.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Ownership and Data Transfer\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     mUSBBufferReady\n    </strong>\n    macro toggles the data-toggle bit and transfers the buffer ownership to the\n    <strong>\n     Serial Interface Engine (SIE)\n    </strong>\n    . This makes the buffer ready for transmission once the host sends an IN token packet.\n   </li>\n<li>\n    The\n    <strong>\n     SIE\n    </strong>\n    then sends the report data to the host and returns control of the buffer back to the CPU.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Summary:\n</h4>\n<p>\n In this process:\n</p>\n<ul>\n<li>\n  Data is prepared in a buffer and transferred to the interrupt IN endpoint's buffer.\n </li>\n<li>\n  The firmware ensures that the CPU controls the endpoint buffer before transferring the data.\n </li>\n<li>\n  The report data is then sent via an interrupt IN transaction when the host requests it.\n </li>\n<li>\n  The\n  <strong>\n   mUSBBufferReady\n  </strong>\n  macro facilitates the data transfer by signaling the SIE to send the data.\n </li>\n</ul>\n<p>\n This entire process ensures that the HID device sends the report data to the host when the appropriate conditions are met.\n</p>\n"}, "Page 366": {"response": "<h3>\n Receiving Reports via Interrupt Transfers\n</h3>\n<p>\n If the HID device has an\n <strong>\n  interrupt OUT endpoint\n </strong>\n and the system supports USB 1.1 or later, it is capable of receiving\n <strong>\n  Output reports\n </strong>\n from the host using interrupt transfers. The device firmware needs to configure the endpoint to receive data on an OUT token packet. Once data is received, the firmware will be notified by an interrupt or a polled register.\n</p>\n<h4>\n Step-by-Step Process:\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Configure the Interrupt OUT Endpoint\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The device firmware sets up the\n    <strong>\n     interrupt OUT endpoint\n    </strong>\n    to receive data. It configures the\n    <strong>\n     buffer descriptor\n    </strong>\n    and prepares the device to receive data from the host. Below is the initialization process:\n   </li>\n</ul>\n  c\n  Copy code\n  <code class=\"!whitespace-pre hljs language-c\">\n   extern\n   volatile\n   far\n   unsigned\n   char\n   hid_report_out[HID_INT_OUT_EP_SIZE];\n   // Set the byte-count register to the size of the expected output report\n   HID_BD_OUT.Cnt =\n   sizeof\n   (hid_report_out);\n   // Set the address register to the location of the hid_report_out buffer\n   HID_BD_OUT.ADR = (byte*)&amp;hid_report_out;\n   // Set status register bits:\n   // _USIE = SIE owns the buffer\n   // _DATA0 = DATA0 data toggle is expected next\n   // _DTSEN = Enable data-toggle synchronization\n   HID_BD_OUT.Stat._byte = _USIE | _DAT0 | _DTSEN;\n  </code>\n</li>\n<li>\n<p>\n<strong>\n    Receiving Data\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    After the endpoint is initialized and the device is ready, the host can send data to the interrupt OUT endpoint. The device firmware will be notified when the data is received, and it can retrieve the data.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Retrieving Received Data\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    A function is used to copy the data from the interrupt OUT endpoint to a buffer. This function typically takes a pointer to a buffer where the report data will be stored.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Code Example for Retrieving Data:\n</h4>\n<p>\n Here\u2019s a sample function that retrieves data once it has been received at the interrupt OUT endpoint:\n</p>\nc\nCopy code\n<code class=\"!whitespace-pre hljs language-c\">\n void\n HIDRxReport\n (\n char\n *buffer)\n {\n    byte i;\n // Copy received data from the endpoint\u2019s buffer to the provided buffer\n for\n (i =\n 0\n ; i &lt;\n sizeof\n (hid_report_out); i++) {\n        buffer[i] = hid_report_out[i];\n    }\n}\n</code>\n<p>\n This function copies the data from the\n <strong>\n  hid_report_out\n </strong>\n buffer, which holds the report data that was received via the interrupt OUT endpoint, into the provided buffer.\n</p>\n<h4>\n Summary:\n</h4>\n<ul>\n<li>\n  The HID device configures an interrupt OUT endpoint to receive reports from the host.\n </li>\n<li>\n  Upon receiving data, the firmware reads the data from the interrupt OUT endpoint's buffer into a local buffer.\n </li>\n<li>\n  The endpoint is configured using specific registers such as\n  <strong>\n   Cnt\n  </strong>\n  (byte-count register),\n  <strong>\n   ADR\n  </strong>\n  (address register), and\n  <strong>\n   Stat\n  </strong>\n  (status register).\n </li>\n</ul>\n<p>\n This process ensures that the HID device can receive\n <strong>\n  Output reports\n </strong>\n from the host in an efficient manner using interrupt transfers.\n</p>\n"}, "Page 367": {"response": "<h3>\n Receiving Data via Interrupt OUT Transfers: HIDRxReport Function\n</h3>\n<p>\n The\n <strong>\n  HIDRxReport\n </strong>\n function is responsible for retrieving data received at an\n <strong>\n  interrupt OUT endpoint\n </strong>\n . The function copies the received report data into a user-supplied buffer and prepares the endpoint for the next data transfer.\n</p>\n<h4>\n Function Details:\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Parameters\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     buffer\n    </strong>\n    : This is the destination buffer where the received report data will be copied.\n   </li>\n<li>\n<strong>\n     len\n    </strong>\n    : The length of the data expected to be received.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Process Overview\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The function first checks if the interrupt OUT endpoint is ready to receive data by calling\n    <code>\n     mHIDRxIsBusy()\n    </code>\n    .\n   </li>\n<li>\n    If the endpoint is not busy, the function continues by copying the data from the\n    <strong>\n     hid_report_out\n    </strong>\n    buffer (where the received data is stored) into the provided\n    <strong>\n     buffer\n    </strong>\n    .\n   </li>\n<li>\n    After copying the data, the function prepares the endpoint for the next transaction by resetting its count register and toggling the data toggle bit.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Code Walkthrough:\n</h4>\nc\nCopy code\n<code class=\"!whitespace-pre hljs language-c\">\n byte\n HIDRxReport\n (\n char\n *buffer, byte len)\n {\n // Reset the report reception length variable\n hid_rpt_rx_len =\n 0\n ;\n // Check if the interrupt OUT endpoint is not busy\n if\n (!mHIDRxIsBusy())\n    {\n // If necessary, adjust the length to match the actual bytes received\n if\n (len &gt; HID_BD_OUT.Cnt)\n            len = HID_BD_OUT.Cnt;\n // Copy the received report data from hid_report_out to the user buffer\n for\n (hid_rpt_rx_len =\n 0\n ; \n            hid_rpt_rx_len &lt; len; \n            hid_rpt_rx_len++)\n        {\n            buffer[hid_rpt_rx_len] = hid_report_out[hid_rpt_rx_len];\n        }\n // Prepare the endpoint buffer for the next OUT transaction\n HID_BD_OUT.Cnt =\n sizeof\n (hid_report_out);\n // Set the count to the report size\n mUSBBufferReady(HID_BD_OUT);\n // Toggle data toggle and transfer buffer ownership\n }\n // Return the length of the report received\n return\n hid_rpt_rx_len;\n}\n</code>\n<h4>\n Key Steps in the Function:\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Check if the Endpoint is Ready\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <code>\n     mHIDRxIsBusy()\n    </code>\n    function checks if the interrupt OUT endpoint is busy, meaning that it is still processing the previous data. If it is busy, the function will not proceed further.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Adjust the Length\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    If the received length (\n    <code>\n     len\n    </code>\n    ) exceeds the actual received bytes (which is stored in\n    <code>\n     HID_BD_OUT.Cnt\n    </code>\n    ), the function adjusts the length to match the actual amount of data received. This ensures that only the available data is processed.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Copy Data to User Buffer\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The data from the\n    <strong>\n     hid_report_out\n    </strong>\n    buffer (which stores the received data) is copied into the\n    <strong>\n     user-provided buffer\n    </strong>\n    (\n    <code>\n     buffer\n    </code>\n    ). This allows the system to access the data sent by the host.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Prepare for Next Transaction\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <code>\n     HID_BD_OUT.Cnt\n    </code>\n    register is set to the size of the\n    <strong>\n     hid_report_out\n    </strong>\n    buffer. This prepares the endpoint for the next OUT transfer.\n   </li>\n<li>\n    The\n    <code>\n     mUSBBufferReady()\n    </code>\n    macro toggles the data toggle bit and transfers ownership of the buffer back to the\n    <strong>\n     Serial Interface Engine (SIE)\n    </strong>\n    , so it can handle the next transaction.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Return Value:\n</h4>\n<ul>\n<li>\n  The function returns the number of bytes successfully copied from the\n  <strong>\n   hid_report_out\n  </strong>\n  buffer to the\n  <strong>\n   user-provided buffer\n  </strong>\n  . This is stored in\n  <code>\n   hid_rpt_rx_len\n  </code>\n  .\n </li>\n</ul>\n<h4>\n Summary:\n</h4>\n<ul>\n<li>\n  The\n  <strong>\n   HIDRxReport\n  </strong>\n  function efficiently retrieves data received at the interrupt OUT endpoint and prepares the endpoint for the next transaction.\n </li>\n<li>\n  It ensures that only the valid amount of data is copied and manages the endpoint's buffers for continuous data transfer.\n </li>\n</ul>\n"}, "Page 368": {"response": "<h3>\n Receiving Data via Control Transfers: HIDRxReport Function\n</h3>\n<p>\n The\n <strong>\n  HIDRxReport\n </strong>\n function handles the process of retrieving data from an interrupt OUT endpoint. It copies the received report data into a user-provided buffer and prepares the endpoint for the next data transfer.\n</p>\n<h4>\n Function Flow:\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Parameters\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     buffer\n    </strong>\n    : The destination where the received report data is copied.\n   </li>\n<li>\n<strong>\n     len\n    </strong>\n    : The length of the data that is expected to be received.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Steps\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The function checks if the interrupt OUT endpoint is ready to receive data using the\n    <code>\n     mHIDRxIsBusy()\n    </code>\n    macro. If the endpoint is busy, the function returns\n    <code>\n     0\n    </code>\n    to indicate no data is available.\n   </li>\n<li>\n    If the endpoint is ready, the function checks if the expected number of bytes (\n    <code>\n     len\n    </code>\n    ) matches the number of bytes received, as reported in\n    <code>\n     HID_BD_OUT.Cnt\n    </code>\n    . If necessary, the function adjusts\n    <code>\n     len\n    </code>\n    to reflect the actual received bytes.\n   </li>\n<li>\n    The data from\n    <strong>\n     hid_report_out\n    </strong>\n    (the buffer where the received data is stored) is copied into the provided buffer (\n    <code>\n     buffer\n    </code>\n    ).\n   </li>\n<li>\n    The function prepares the endpoint for the next transaction by resetting the byte-count register (\n    <code>\n     HID_BD_OUT.Cnt\n    </code>\n    ) and calling the\n    <code>\n     mUSBBufferReady\n    </code>\n    macro to toggle the data toggle and transfer ownership of the buffer to the SIE.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Return Value\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The function returns the number of bytes successfully copied to the user's buffer (\n    <code>\n     hid_rpt_rx_len\n    </code>\n    ). If no data is received, it returns\n    <code>\n     0\n    </code>\n    .\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Example Code:\n</h4>\nc\nCopy code\n<code class=\"!whitespace-pre hljs language-c\">\n byte number_of_bytes_read;\n char\n receive_buffer[\n 2\n ];\n // Call the function to read data into the buffer\n number_of_bytes_read = HIDRxReport(receive_buffer,\n 2\n );\n</code>\n<p>\n In this example, the function\n <code>\n  HIDRxReport\n </code>\n is called with the\n <code>\n  receive_buffer\n </code>\n and an expected byte length of 2. The function then retrieves the report data and stores it in\n <code>\n  receive_buffer\n </code>\n .\n</p>\n<hr/>\n<h3>\n Sending Reports via Control Transfers\n</h3>\n<p>\n To send an\n <strong>\n  Input\n </strong>\n or\n <strong>\n  Feature\n </strong>\n report using a\n <strong>\n  control transfer\n </strong>\n , device firmware must recognize the\n <code>\n  Get_Report\n </code>\n code in the\n <strong>\n  bRequest\n </strong>\n field of the Setup stage of the control request directed to the HID interface.\n</p>\n<h4>\n Process Overview:\n</h4>\n<ol>\n<li>\n<strong>\n   Detecting the Request\n  </strong>\n  :\n  <ul>\n<li>\n    The firmware must detect when a request with a\n    <strong>\n     Get_Report\n    </strong>\n    code is received in the\n    <strong>\n     Setup\n    </strong>\n    stage. The\n    <strong>\n     bRequest\n    </strong>\n    field will contain the value corresponding to this request.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Configuring Endpoint 0\n  </strong>\n  :\n  <ul>\n<li>\n    After detecting the\n    <code>\n     Get_Report\n    </code>\n    request, the firmware configures\n    <strong>\n     Endpoint 0\n    </strong>\n    to send the report during the\n    <strong>\n     Data\n    </strong>\n    stage of the control transfer. This involves placing the report data in the appropriate endpoint buffer.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Handling the Response\n  </strong>\n  :\n  <ul>\n<li>\n    The firmware also configures the endpoint to receive the host\u2019s response in the\n    <strong>\n     Status\n    </strong>\n    stage after sending the report.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Example Code (HIDGetReportHandler):\n</h4>\n<p>\n Microchip\u2019s\n <strong>\n  Framework HID example\n </strong>\n includes code for handling the\n <code>\n  Get_Report\n </code>\n request. This code checks the high byte of the\n <strong>\n  wValue\n </strong>\n field in the Setup stage\u2019s data packet (\n <code>\n  MSB(SetupPkt.W_Value)\n </code>\n ) to determine if the host is requesting an Input or Feature report.\n</p>\n<h3>\n Summary\n</h3>\n<ul>\n<li>\n  The\n  <strong>\n   HIDRxReport\n  </strong>\n  function handles receiving data at the interrupt OUT endpoint, copying the data into a buffer, and preparing the endpoint for the next data transfer.\n </li>\n<li>\n  The\n  <strong>\n   control transfer\n  </strong>\n  process for sending reports involves detecting requests and configuring Endpoint 0 to send the data during the Data stage and receive the host's response in the Status stage.\n </li>\n</ul>\n"}, "Page 369": {"response": "<h3>\n HIDGetReportHandler Function\n</h3>\n<p>\n The\n <strong>\n  HIDGetReportHandler\n </strong>\n function is responsible for handling\n <strong>\n  Get_Report\n </strong>\n requests in the USB HID interface. It processes these requests by identifying the type of report (either\n <strong>\n  Input\n </strong>\n or\n <strong>\n  Feature\n </strong>\n ) and the specific report ID requested by the host. Once the report type and ID are determined, the firmware takes the necessary actions to provide the requested report data.\n</p>\n<h4>\n Function Breakdown:\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Report Type Detection\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The function starts by checking the high byte of the\n    <strong>\n     wValue\n    </strong>\n    field in the Setup packet to determine the report type. The report type is identified as:\n    <ul>\n<li>\n<code>\n       1\n      </code>\n      for\n      <strong>\n       Input report\n      </strong>\n</li>\n<li>\n<code>\n       3\n      </code>\n      for\n      <strong>\n       Feature report\n      </strong>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Input Report Handling\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    If the report type is\n    <code>\n     1\n    </code>\n    (Input report), the function checks the low byte of the\n    <strong>\n     wValue\n    </strong>\n    field to identify the report ID.\n    <ul>\n<li>\n      For\n      <strong>\n       Report ID 0\n      </strong>\n      , the function calls\n      <code>\n       GetInputReport0()\n      </code>\n      to retrieve the data for the Input report.\n     </li>\n<li>\n      Additional case blocks can be added to handle other report IDs, such as\n      <strong>\n       Report ID 1\n      </strong>\n      .\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Feature Report Handling\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    If the report type is\n    <code>\n     3\n    </code>\n    (Feature report), the function can include code to handle\n    <strong>\n     Feature reports\n    </strong>\n    . Feature reports typically involve setting or retrieving device-specific settings.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Ownership and Control\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The function assigns ownership of the transfer session to the HID class code by setting\n    <code>\n     ctrl_trf_session_owner = MUID_HID\n    </code>\n    .\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Example Code:\n</h4>\nc\nCopy code\n<code class=\"!whitespace-pre hljs language-c\">\n void\n HIDGetReportHandler\n (\n void\n )\n {\n // The report type is in the high byte of the setup packet's wValue field.\n switch\n (MSB(SetupPkt.W_Value))\n    {\n        byte count;\n case\n 1\n :\n // Input report\n // Determine which report ID was specified.\n switch\n (LSB(SetupPkt.W_Value))\n            {\n case\n 0\n :\n // Report ID 0\n ctrl_trf_session_owner = MUID_HID;\n                    GetInputReport0();\n // Provide the data for Report ID 0.\n break\n ;\n case\n 1\n :\n // Report ID 1\n // Add code to handle Report ID 1 here.\n break\n ;\n            }\n break\n ;\n case\n 3\n :\n // Feature report\n // Add code to handle Feature reports here.\n break\n ;\n    }\n}\n</code>\n<h3>\n Summary:\n</h3>\n<ul>\n<li>\n  The\n  <strong>\n   HIDGetReportHandler\n  </strong>\n  function handles\n  <strong>\n   Get_Report\n  </strong>\n  requests by identifying the report type and report ID in the\n  <strong>\n   Setup\n  </strong>\n  packet.\n </li>\n<li>\n  Based on the\n  <strong>\n   Input report\n  </strong>\n  or\n  <strong>\n   Feature report\n  </strong>\n  , the appropriate actions are taken, such as retrieving the Input report data or preparing the device to respond with a Feature report.\n </li>\n</ul>\n"}, "Page 370": {"response": "<h3>\n Receiving and Sending Reports via Control Transfers\n</h3>\n<p>\n Control transfers are commonly used in USB communication to send and receive\n <strong>\n  Input\n </strong>\n and\n <strong>\n  Feature\n </strong>\n reports between the host and HID devices. The following sections describe how these reports are handled in both sending and receiving scenarios using control transfers.\n</p>\n<h4>\n Sending Reports via Control Transfers\n</h4>\n<p>\n When sending an\n <strong>\n  Input\n </strong>\n or\n <strong>\n  Feature\n </strong>\n report, the device must detect the appropriate\n <strong>\n  Get_Report\n </strong>\n request from the host. This request will contain the report type (Input or Feature) and the report ID. The\n <strong>\n  HIDGetReportHandler\n </strong>\n function (as discussed earlier) checks these values in the\n <strong>\n  wValue\n </strong>\n field of the Setup packet:\n</p>\n<ul>\n<li>\n  The\n  <strong>\n   high byte\n  </strong>\n  of the\n  <strong>\n   wValue\n  </strong>\n  field (MSB) identifies whether it's an\n  <strong>\n   Input\n  </strong>\n  or\n  <strong>\n   Feature\n  </strong>\n  report.\n </li>\n<li>\n  The\n  <strong>\n   low byte\n  </strong>\n  (LSB) specifies the report ID, which refers to a particular report.\n </li>\n</ul>\n<p>\n If the requested report is supported, the function sets the\n <strong>\n  ctrl_trf_session_owner\n </strong>\n variable to\n <strong>\n  MUID_HID\n </strong>\n , indicating that the HID firmware will handle the transfer.\n</p>\n<p>\n For example, to send\n <strong>\n  Input report 0\n </strong>\n , the function\n <strong>\n  GetInputReport0\n </strong>\n is called. This function sets\n <strong>\n  pSrc.bRam\n </strong>\n to point to the data location (in this case,\n <strong>\n  hid_report_in\n </strong>\n ). The firmware then prepares\n <strong>\n  Endpoint 0\n </strong>\n to send the report data upon receiving an\n <strong>\n  IN token packet\n </strong>\n and ensures the host sends a\n <strong>\n  zero-length packet\n </strong>\n in the\n <strong>\n  Status\n </strong>\n stage of the transfer.\n</p>\n<p>\n Similar processes occur for other reports. The only difference is the source of the report data, which varies depending on the report type or ID.\n</p>\n<h4>\n Receiving Reports via Control Transfers\n</h4>\n<p>\n To\n <strong>\n  receive\n </strong>\n an\n <strong>\n  Output\n </strong>\n or\n <strong>\n  Feature\n </strong>\n report via a control transfer, the firmware needs to detect a\n <strong>\n  Set_Report\n </strong>\n request in the\n <strong>\n  bRequest\n </strong>\n field. This request directs the HID interface to receive the report data in the\n <strong>\n  Data stage\n </strong>\n and return a\n <strong>\n  handshake\n </strong>\n in the\n <strong>\n  Status stage\n </strong>\n .\n</p>\n<p>\n The function responsible for handling this is\n <strong>\n  HIDSetReportHandler\n </strong>\n , which is called when the\n <strong>\n  Set_Report\n </strong>\n request is detected. Here's how it works:\n</p>\n<ul>\n<li>\n  The function examines the\n  <strong>\n   high byte\n  </strong>\n  of the\n  <strong>\n   wValue\n  </strong>\n  field to determine if the report is an\n  <strong>\n   Output\n  </strong>\n  or\n  <strong>\n   Feature\n  </strong>\n  report.\n </li>\n<li>\n  The\n  <strong>\n   low byte\n  </strong>\n  of the\n  <strong>\n   wValue\n  </strong>\n  field (LSB) indicates the report ID, which helps identify the specific report being sent.\n </li>\n</ul>\n<p>\n If the requested report is supported, the\n <strong>\n  ctrl_trf_session_owner\n </strong>\n variable is set to\n <strong>\n  MUID_HID\n </strong>\n , allowing the firmware to detect that the HID firmware is managing the transfer.\n</p>\n<p>\n For receiving data, the firmware prepares\n <strong>\n  Endpoint 0\n </strong>\n to accept the incoming report data upon receiving an\n <strong>\n  OUT token packet\n </strong>\n . The process for handling\n <strong>\n  Output\n </strong>\n and\n <strong>\n  Feature\n </strong>\n reports in the\n <strong>\n  Data stage\n </strong>\n is similar to handling\n <strong>\n  Input\n </strong>\n reports but in reverse (i.e., receiving data instead of sending it).\n</p>\n<h4>\n Summary:\n</h4>\n<ul>\n<li>\n<strong>\n   Sending Reports\n  </strong>\n  : The\n  <strong>\n   HIDGetReportHandler\n  </strong>\n  function checks the report type and ID, and if the report is supported, it prepares the\n  <strong>\n   Endpoint 0\n  </strong>\n  to send the data in an\n  <strong>\n   IN token packet\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Receiving Reports\n  </strong>\n  : The\n  <strong>\n   HIDSetReportHandler\n  </strong>\n  function detects a\n  <strong>\n   Set_Report\n  </strong>\n  request, examines the report type and ID, and prepares\n  <strong>\n   Endpoint 0\n  </strong>\n  to receive the report data in an\n  <strong>\n   OUT token packet\n  </strong>\n  .\n </li>\n</ul>\n"}, "Page 371": {"response": "<h3>\n Receiving and Handling Output Reports via Control Transfers\n</h3>\n<p>\n When the device receives an\n <strong>\n  Output report\n </strong>\n through a control transfer, the report data is provided in the\n <strong>\n  Data stage\n </strong>\n , and the transfer concludes with a\n <strong>\n  zero-length packet\n </strong>\n in the\n <strong>\n  Status stage\n </strong>\n . The following explains how the firmware handles this process.\n</p>\n<h4>\n Handling Output Reports\n</h4>\n<p>\n When\n <strong>\n  Output report 0\n </strong>\n is received, the data is stored at the location pointed to by\n <strong>\n  pDst.bRam\n </strong>\n . In this case,\n <strong>\n  pDst.bRam\n </strong>\n points to the\n <strong>\n  hid_report_out\n </strong>\n array in RAM. The firmware can then call a function to process the received report data.\n</p>\n<p>\n For example, the firmware checks if the\n <strong>\n  ctrl_trf_session_owner\n </strong>\n variable is set to\n <strong>\n  MUID_HID\n </strong>\n , indicating that the HID firmware is handling the transfer. If this is true, the firmware can call a function, such as\n <strong>\n  HandleControlOutReport()\n </strong>\n , to process the received report.\n</p>\nc\nCopy code\n<code class=\"!whitespace-pre hljs language-c\">\n if\n (ctrl_trf_session_owner == MUID_HID) {\n // Call a function that uses the report data.\n HandleControlOutReport();\n}\n</code>\n<p>\n This ensures that any Output report data received can be appropriately processed.\n</p>\n<h4>\n Sending Input Reports\n</h4>\n<p>\n For sending\n <strong>\n  Input reports\n </strong>\n , the firmware uses a function like\n <strong>\n  GetInputReport0\n </strong>\n (shown in Listing 11-6). This function prepares the data to be sent by setting\n <strong>\n  pSrc.bRam\n </strong>\n to point to the location where the report's data is stored\u2014in this case,\n <strong>\n  hid_report_in\n </strong>\n .\n</p>\nc\nCopy code\n<code class=\"!whitespace-pre hljs language-c\">\n void\n GetInputReport0\n (\n void\n )\n {\n    byte count;\n // Set pSrc.bRam to point to the report.\n pSrc.bRam = (byte*)&amp;hid_report_in;\n}\n</code>\n<p>\n This function handles the specific task of setting up the report data for transmission when a\n <strong>\n  Get_Report\n </strong>\n request is received.\n</p>\n"}, "Page 372": {"response": "<h3>\n Receiving Output and Feature Reports via Control Transfers\n</h3>\n<p>\n When the device receives\n <strong>\n  Output\n </strong>\n or\n <strong>\n  Feature\n </strong>\n reports via control transfers, the firmware processes the report according to the information contained in the Setup packet's\n <strong>\n  wValue\n </strong>\n field. The\n <strong>\n  HIDSetReportHandler\n </strong>\n function, shown in Listing 11-7, is responsible for handling these requests.\n</p>\n<h4>\n Function Overview: HIDSetReportHandler\n</h4>\n<p>\n The\n <strong>\n  HIDSetReportHandler\n </strong>\n function handles\n <strong>\n  Set_Report\n </strong>\n requests. It uses the\n <strong>\n  MSB (Most Significant Byte)\n </strong>\n and\n <strong>\n  LSB (Least Significant Byte)\n </strong>\n of the\n <strong>\n  wValue\n </strong>\n field to determine the report type and ID. Here's a breakdown of how the function operates:\n</p>\n<ol>\n<li>\n<strong>\n   Report Type Determination (MSB of wValue):\n  </strong>\n<ul>\n<li>\n    If the\n    <strong>\n     MSB\n    </strong>\n    of the\n    <strong>\n     wValue\n    </strong>\n    field is\n    <strong>\n     2\n    </strong>\n    , it indicates that the report is an\n    <strong>\n     Output report\n    </strong>\n    .\n   </li>\n<li>\n    If the\n    <strong>\n     MSB\n    </strong>\n    is\n    <strong>\n     3\n    </strong>\n    , it indicates that the report is a\n    <strong>\n     Feature report\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Output Report Handling (wValue = 2):\n  </strong>\n<ul>\n<li>\n    The\n    <strong>\n     LSB\n    </strong>\n    of the\n    <strong>\n     wValue\n    </strong>\n    field specifies the\n    <strong>\n     Report ID\n    </strong>\n    .\n   </li>\n<li>\n    In this example, the code handles\n    <strong>\n     Report ID 0\n    </strong>\n    . If a different report ID (e.g., Report ID 1) is used, the firmware can be extended to handle it.\n   </li>\n<li>\n    When\n    <strong>\n     Report ID 0\n    </strong>\n    is selected, the\n    <strong>\n     ctrl_trf_session_owner\n    </strong>\n    variable is set to\n    <strong>\n     MUID_HID\n    </strong>\n    , indicating that the HID firmware will manage the transfer.\n   </li>\n<li>\n    The\n    <strong>\n     pDst.bRam\n    </strong>\n    pointer is set to the\n    <strong>\n     hid_report_out\n    </strong>\n    array in RAM, which will store the data received in the\n    <strong>\n     Data stage\n    </strong>\n    of the transfer.\n   </li>\n</ul>\n</li>\n</ol>\nc\nCopy code\n<code class=\"!whitespace-pre hljs language-c\">\n void\n HIDSetReportHandler\n (\n void\n )\n {\n // The report type is in the high byte of the Setup packet's\n // wValue field. 2 = Output; 3 = Feature.\n switch\n (MSB(SetupPkt.W_Value))\n    {\n case\n 2\n :\n // Output report\n // The report ID is in the low byte of the Setup\n // packet's wValue field.\n switch\n (LSB(SetupPkt.W_Value))\n            {\n case\n 0\n :\n // Report ID 0\n ctrl_trf_session_owner = MUID_HID;\n // When the report arrives in the Data stage,\n // the report data will be available in\n // hid_report_out.\n pDst.bRam = (byte*)&amp;hid_report_out;\n break\n ;\n case\n 1\n :\n // Report ID 1\n // Place code to handle Report ID 1 here.\n break\n ;\n            }\n break\n ;\n case\n 3\n :\n // Feature report\n // Place code to handle Feature reports here.\n break\n ;\n    }\n}\n</code>\n<h3>\n Key Points:\n</h3>\n<ul>\n<li>\n<strong>\n   Output Report Handling:\n  </strong>\n  The\n  <strong>\n   pDst.bRam\n  </strong>\n  pointer is set to\n  <strong>\n   hid_report_out\n  </strong>\n  , which will hold the data from the\n  <strong>\n   Output report\n  </strong>\n  . This allows the device to process the data once it arrives in the\n  <strong>\n   Data stage\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Feature Report Handling:\n  </strong>\n  If the report type is\n  <strong>\n   Feature\n  </strong>\n  (MSB = 3), the firmware should include code to handle Feature reports, though the handling logic is not specified here.\n </li>\n</ul>\n"}, "Page 373": {"response": "<p>\n It seems that the content is missing. Could you please provide the specific section you would like me to explain or restate for you? I'll be happy to help!\n</p>\n"}, "Page 374": {"response": "<h3>\n Human Interface Devices: Reports\n</h3>\n<p>\n Chapter 11 covered the reports that Human Interface Devices (HIDs) use to send and receive data. A report can be a simple sequence of bytes or a more intricate structure with various elements, each assigned specific functions and units. This chapter will explain how to design a report for a specific application.\n</p>\n<h3>\n Report Structure\n</h3>\n<p>\n A report descriptor can include numerous items arranged in different ways. The benefit of a more detailed descriptor is that it allows the device to convey comprehensive information about the data it transmits and receives. The descriptor can define how the values should be interpreted and what units apply to the raw data. By analyzing a report descriptor, an application can determine if the device supports certain features, such as force feedback in a joystick.\n</p>\n"}, "Page 375": {"response": "<h3>\n Report Structure and Designing Reports\n</h3>\n<p>\n While the HID specification defines many potential items that can be used in a device's report descriptor, not every item needs to be used. For vendor-specific devices, especially those designed for a single application, the application typically already knows the report format in advance. In such cases, the application doesn\u2019t need to derive this information from the device itself. For example, when creating an application for a data-acquisition unit, the vendor understands the report's format, so the application may only need to check the device descriptor for things like the product ID and release number to determine whether specific settings or actions can be requested.\n</p>\n<h3>\n Simplifying Report Structure Details\n</h3>\n<p>\n In most cases, understanding every intricate detail of each item type within a report descriptor is unnecessary. You can skim through the more complex sections of this chapter and revisit them later if needed. The key concept is that a report descriptor typically contains controls and data items. A control refers to a physical element, such as a button or switch, that regulates some aspect of the device. Data items represent other types of information that the report transfers. Each control or data item in the descriptor has a defined scope. Some items are reusable and can be applied to multiple values, reducing redundancy.\n</p>\n<h3>\n Using the HID Descriptor Tool\n</h3>\n<p>\n The HID Descriptor Tool, available from the USB-IF, is a free utility that aids in creating and validating report descriptors. It can check the structure of your descriptor and identify errors. Rather than manually looking up values for each item in the descriptor, you can select an item from a list and specify the value you want, and the tool will automatically insert it into the descriptor. The tool also allows you to add items manually.\n</p>\n<p>\n One of the tool's features is the \"Parse Descriptor\" function, which shows the raw and interpreted values of your descriptor and flags any errors. Once your descriptor is free of errors, the tool can convert it into the correct syntax required for use in your firmware. However, it\u2019s important to note that the tool has limited support for vendor-specific items and may flag these as errors, even though they may be valid in your application.\n</p>\n"}, "Page 376": {"response": "<h3>\n The HID Descriptor Tool\n</h3>\n<p>\n The\n <strong>\n  HID Descriptor Tool\n </strong>\n (as shown in Figure 12-1) is a free utility provided by the USB-IF that assists in the creation and testing of HID report descriptors. This tool simplifies the process of constructing a report descriptor by allowing you to select items from a list and input the corresponding values. The tool then adds these items to the descriptor for you. Additionally, it helps identify and correct any structural errors in the descriptor by displaying both raw and interpreted values and offering error messages when issues are detected. Once the descriptor is error-free, the tool can convert it into the appropriate syntax required for your firmware.\n</p>\n"}, "Page 377": {"response": "<h3>\n Control and Data Item Values\n</h3>\n<p>\n The\n <strong>\n  HID Usage Tables document\n </strong>\n is the primary source for values that reports can contain. It defines values for a variety of controls, such as generic desktop controls, simulation controls, game controls, LEDs, buttons, and more. This document also provides references to other sources where additional values can be found. Some values are defined in the HID specification itself, while others can be found in the class specifications for specific devices, like monitors, power devices, or point-of-sale devices.\n</p>\n<h3>\n Item Types\n</h3>\n<p>\n The\n <strong>\n  HID specification\n </strong>\n categorizes report items into two types:\n <strong>\n  short items\n </strong>\n and\n <strong>\n  long items\n </strong>\n . As of HID 1.1, only\n <strong>\n  short items\n </strong>\n are defined, and the long item type is reserved for potential future use.\n</p>\n<h4>\n Short Items\n</h4>\n<p>\n A\n <strong>\n  short item\n </strong>\n is identified by a 1-byte prefix that indicates the item\u2019s type, scope, and size. This prefix byte is broken down into the following components:\n</p>\n<ul>\n<li>\n<strong>\n   Item Size\n  </strong>\n  (Bit 0): Indicates the number of bytes the item will occupy.\n </li>\n<li>\n<strong>\n   Item Type\n  </strong>\n  (Bits 1-2): Specifies the item\u2019s scope, such as Main, Global, or Local.\n </li>\n<li>\n<strong>\n   Item Tag\n  </strong>\n  (Bits 3-7): A numeric value that denotes the specific function or purpose of the item.\n </li>\n</ul>\n"}, "Page 378": {"response": "<h3>\n Item Types in HID Reports\n</h3>\n<p>\n HID reports are structured using two main item types:\n <strong>\n  short items\n </strong>\n and\n <strong>\n  long items\n </strong>\n . The size and type of these items are specified using a prefix byte.\n</p>\n<h4>\n Short Items\n</h4>\n<p>\n A\n <strong>\n  short item\n </strong>\n uses a 1-byte prefix to define the item\u2019s size, type, and function:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Item Size\n   </strong>\n   (Bits 0 and 1): Specifies how many data bytes the item will contain. The binary values for item size correspond to the following:\n  </p>\n<ul>\n<li>\n<code>\n     00\n    </code>\n    \u2192 0 bytes\n   </li>\n<li>\n<code>\n     01\n    </code>\n    \u2192 1 byte\n   </li>\n<li>\n<code>\n     10\n    </code>\n    \u2192 2 bytes\n   </li>\n<li>\n<code>\n     11\n    </code>\n    \u2192 4 bytes\n(For example, an item size of\n    <code>\n     11\n    </code>\n    in binary means 4 data bytes.)\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Item Type\n   </strong>\n   (Bits 2 and 3): Describes the scope of the item. There are three types:\n  </p>\n<ul>\n<li>\n<strong>\n     Main (00)\n    </strong>\n    : Defines or groups data fields in the descriptor.\n   </li>\n<li>\n<strong>\n     Global (01)\n    </strong>\n    : Describes data.\n   </li>\n<li>\n<strong>\n     Local (10)\n    </strong>\n    : Defines characteristics of specific controls or data items.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Item Tag\n   </strong>\n   (Bits 4\u20137): A numeric value that identifies the item\u2019s function or purpose within the report.\n  </p>\n</li>\n</ol>\n<h4>\n Long Items\n</h4>\n<p>\n A\n <strong>\n  long item\n </strong>\n stores the same information as a short item but uses multiple bytes. It is identified by the prefix byte\n <code>\n  FEh\n </code>\n . In addition to the 1-byte prefix, a long item includes:\n</p>\n<ul>\n<li>\n  A byte specifying the number of data bytes,\n </li>\n<li>\n  A byte containing the item tag,\n </li>\n<li>\n  Up to 255 bytes of data.\n </li>\n</ul>\n<h4>\n Main Item Type\n</h4>\n<p>\n The\n <strong>\n  Main item\n </strong>\n is used to define or group data items within a report descriptor. There are five main item types:\n</p>\n<ul>\n<li>\n<strong>\n   Input\n  </strong>\n  : Defines a field in an Input report.\n </li>\n<li>\n<strong>\n   Output\n  </strong>\n  : Defines a field in an Output report.\n </li>\n<li>\n<strong>\n   Feature\n  </strong>\n  : Defines a field in a Feature report.\n </li>\n<li>\n<strong>\n   Collection\n  </strong>\n  : Groups related items together within a report.\n </li>\n<li>\n<strong>\n   End Collection\n  </strong>\n  : Marks the end of a collection.\n </li>\n</ul>\n<p>\n The default value for all Main items is zero.\n</p>\n"}, "Page 379": {"response": "<h3>\n Chapter 12: Input, Output, and Feature Items\n</h3>\n<p>\n Table 12-1 outlines the supported values for Input, Output, and Feature items, providing details about the prefixes and the meaning of bits in the data following them.\n</p>\n<h4>\n Input Items\n</h4>\n<p>\n An\n <strong>\n  Input item\n </strong>\n refers to data that the device sends to the host. It is part of an\n <strong>\n  Input report\n </strong>\n , which can contain multiple Input items. The host requests Input reports using\n <strong>\n  interrupt IN transfers\n </strong>\n or\n <strong>\n  Get_Report requests\n </strong>\n .\n</p>\n<h4>\n Output Items\n</h4>\n<p>\n An\n <strong>\n  Output item\n </strong>\n pertains to information the host sends to the device. An\n <strong>\n  Output report\n </strong>\n includes one or more Output items. These reports convey control states, such as whether to activate or deactivate a switch or the level of intensity for an effect. If the HID has an interrupt OUT endpoint, a HID 1.1-compliant host can use\n <strong>\n  interrupt OUT transfers\n </strong>\n to send Output reports. Alternatively,\n <strong>\n  Set_Report requests\n </strong>\n can be used by all hosts to send Output reports.\n</p>\n<h4>\n Feature Items\n</h4>\n<p>\n A\n <strong>\n  Feature item\n </strong>\n generally refers to data the host sends to the device, though it\u2019s also possible for the host to read Feature items from the device. A\n <strong>\n  Feature report\n </strong>\n includes one or more Feature items and often holds configuration settings that influence the device\u2019s behavior or that of its components. These settings might be the same as those adjusted through a physical control panel. For instance, a virtual control panel on the host could allow users to select and manage the device's settings. The host uses\n <strong>\n  Set_Report\n </strong>\n and\n <strong>\n  Get_Report requests\n </strong>\n with\n <strong>\n  control transfers\n </strong>\n to send and receive Feature reports.\n</p>\n<h4>\n Data Representation\n</h4>\n<p>\n After each Input, Output, or Feature item prefix, there are up to 9 bits that describe the data associated with the item. Additionally, 23 bits are reserved. For instance, an Input item with a 9-bit data field would have a value of\n <strong>\n  82h\n </strong>\n . The high four bits (\n <strong>\n  08h\n </strong>\n ) represent the Input item, while the low four bits (\n <strong>\n  02h\n </strong>\n ) indicate that the data requires 2 bytes. Similarly, an Input item with an 8-bit data field would have the value\n <strong>\n  81h\n </strong>\n , where the high four bits (\n <strong>\n  08h\n </strong>\n ) still signify the Input item, and the low four bits (\n <strong>\n  01h\n </strong>\n ) show that the data fits in 1 byte. The device firmware and host software may choose to use or disregard the information in these items.\n</p>\n"}, "Page 380": {"response": "<h3>\n Human Interface Devices: Reports\n</h3>\n<p>\n Table 12-1 explains the bits following the prefixes for Input, Output, and Feature Items. These bits define the data characteristics in the reports.\n</p>\n<h4>\n Input Items\n</h4>\n<p>\n Input items start with the prefix\n <strong>\n  100000nn\n </strong>\n , where \"nn\" indicates the number of bytes in the data following the prefix. For example,\n <strong>\n  81h\n </strong>\n is used for 1 byte of item data, and\n <strong>\n  82h\n </strong>\n is used for 2 bytes.\n</p>\n<ul>\n<li>\n<strong>\n   Bit 0:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    Data\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    Constant\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 1:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    Array\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    Variable\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 2:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    Absolute\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    Relative\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 3:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    No wrap\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    Wrap\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 4:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    Linear\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    Non-linear\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 5:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    Preferred state\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    No preferred state\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 6:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    No null position\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    Null state\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 7:\n  </strong>\n<ul>\n<li>\n<strong>\n     Reserved\n    </strong>\n</li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 8:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    Bit field\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    Buffered bytes\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bits 9-31:\n  </strong>\n  Reserved\n </li>\n</ul>\n<h4>\n Output Items\n</h4>\n<p>\n Output items start with the prefix\n <strong>\n  100100nn\n </strong>\n , where \"nn\" again indicates the number of bytes in the data following the prefix. For example,\n <strong>\n  91h\n </strong>\n is used for 1 byte, and\n <strong>\n  92h\n </strong>\n is used for 2 bytes.\n</p>\n<ul>\n<li>\n<strong>\n   Bit 0:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    Data\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    Constant\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 1:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    Array\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    Variable\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 2:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    Absolute\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    Relative\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 3:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    No wrap\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    Wrap\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 4:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    Linear\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    Non-linear\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 5:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    Preferred state\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    No preferred state\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 6:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    No null position\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    Null state\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 7:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    Non-volatile\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    Volatile\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 8:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    Bit field\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    Buffered bytes\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bits 9-31:\n  </strong>\n  Reserved\n </li>\n</ul>\n<h4>\n Feature Items\n</h4>\n<p>\n Feature items start with the prefix\n <strong>\n  101100nn\n </strong>\n , where \"nn\" also indicates the number of bytes in the data following the prefix. For example,\n <strong>\n  B1h\n </strong>\n is used for 1 byte, and\n <strong>\n  B2h\n </strong>\n is used for 2 bytes.\n</p>\n<ul>\n<li>\n<strong>\n   Bit 0:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    Data\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    Constant\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 1:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    Array\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    Variable\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 2:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    Absolute\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    Relative\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 3:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    No wrap\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    Wrap\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 4:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    Linear\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    Non-linear\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 5:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    Preferred state\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    No preferred state\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 6:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    No null position\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    Null state\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 7:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    Non-volatile\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    Volatile\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bit 8:\n  </strong>\n<ul>\n<li>\n<strong>\n     0:\n    </strong>\n    Bit field\n   </li>\n<li>\n<strong>\n     1:\n    </strong>\n    Buffered bytes\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Bits 9-31:\n  </strong>\n  Reserved\n </li>\n</ul>\n<p>\n These bits define how the data in reports is structured, determining its type, behavior, and how it should be interpreted by the host or device.\n</p>\n"}, "Page 381": {"response": "<h3>\n Chapter 12: Bit Functions for Input, Output, and Feature Items\n</h3>\n<p>\n The bit functions for Input, Output, and Feature items are generally the same, except that\n <strong>\n  Input items\n </strong>\n do not support the\n <strong>\n  volatile/non-volatile\n </strong>\n bit. Here's an explanation of the uses for each bit:\n</p>\n<h4>\n Data | Constant\n</h4>\n<ul>\n<li>\n<strong>\n   Data:\n  </strong>\n  The item can be modified (read/write).\n </li>\n<li>\n<strong>\n   Constant:\n  </strong>\n  The item\u2019s content is fixed and cannot be modified (read-only).\n </li>\n</ul>\n<h4>\n Array | Variable\n</h4>\n<p>\n This bit determines how the data is reported:\n</p>\n<ul>\n<li>\n<strong>\n   Array:\n  </strong>\n  Only the state of the active or asserted controls is reported, making the report more compact. This is useful for devices like keyboards, where only a few keys are pressed at a time.\n </li>\n<li>\n<strong>\n   Variable:\n  </strong>\n  The report includes the state of every control, regardless of whether it\u2019s active or not.\n </li>\n</ul>\n<p>\n For example, on a keypad with eight keys:\n</p>\n<ul>\n<li>\n<strong>\n   Variable:\n  </strong>\n  The report contains a bit for each key. The report size would be 1 bit per key, and with eight keys, it would total 8 bits.\n </li>\n<li>\n<strong>\n   Array:\n  </strong>\n  The report would only list the indexes of the keys that are pressed. If only one key can be pressed at a time, the report size would be 3 bits (to represent keys 0-7), and the report count would be 1, totaling 3 bits of data. If multiple keys can be pressed, the report count would reflect the maximum simultaneous keypresses, e.g., 8 keys would require 24 bits of data.\n </li>\n</ul>\n<p>\n An\n <strong>\n  out-of-range value\n </strong>\n for an Array item means no controls are active.\n</p>\n<h4>\n Absolute | Relative\n</h4>\n<ul>\n<li>\n<strong>\n   Absolute:\n  </strong>\n  The value is based on a fixed starting point or origin. For example, a joystick typically reports absolute data (its current position).\n </li>\n<li>\n<strong>\n   Relative:\n  </strong>\n  The value represents the change since the last reading. A mouse usually reports relative data (movement since the previous position).\n </li>\n</ul>\n<h4>\n No Wrap | Wrap\n</h4>\n<ul>\n<li>\n<strong>\n   Wrap:\n  </strong>\n  When the value reaches its maximum or minimum, it rolls over to the opposite end. For example, if a counter reaches the maximum value, it returns to the minimum value, and vice versa.\n </li>\n<li>\n<strong>\n   No Wrap:\n  </strong>\n  If the value exceeds the specified range, it does not wrap around. Instead, it stays within the defined range or may be clipped.\n </li>\n</ul>\n<p>\n These bit functions define how data is reported and how it behaves, impacting the compactness and flexibility of the reports for different devices.\n</p>\n"}, "Page 382": {"response": "<h3>\n Human Interface Devices: Report Bit Functions (Continued)\n</h3>\n<p>\n Here\u2019s a breakdown of additional bit functions used in Input, Output, and Feature reports:\n</p>\n<h4>\n Linear | Non-linear\n</h4>\n<ul>\n<li>\n<strong>\n   Linear:\n  </strong>\n  The data has a direct, linear relationship with the property being measured. A graph of the data would show a straight line.\n </li>\n<li>\n<strong>\n   Non-linear:\n  </strong>\n  The data has a curved relationship with the property being measured. A graph of this data would show a curve instead of a straight line.\nNote: This bit does not apply to\n  <strong>\n   Array data\n  </strong>\n  .\n </li>\n</ul>\n<h4>\n Preferred State | No Preferred State\n</h4>\n<ul>\n<li>\n<strong>\n   Preferred State:\n  </strong>\n  The control will return to a specific state when not in use. For example, a momentary pushbutton would have a preferred state (out) when not being pressed. A toggle switch, however, has no preferred state, and it remains in the last state selected by the user.\nNote: This bit does not apply to\n  <strong>\n   Array data\n  </strong>\n  .\n </li>\n</ul>\n<h4>\n No Null Position | Null State\n</h4>\n<ul>\n<li>\n<strong>\n   Null State:\n  </strong>\n  The control supports a state where it isn\u2019t transmitting meaningful data. This is indicated by sending a value outside the defined range of its Logical Minimum and Logical Maximum.\n </li>\n<li>\n<strong>\n   No Null Position:\n  </strong>\n  Any data transmitted by the control is meaningful.\nExample: A hat switch on a joystick might send no data (null state) when not being pressed.\nNote: This bit does not apply to\n  <strong>\n   Array data\n  </strong>\n  .\n </li>\n</ul>\n<h4>\n Non-volatile | Volatile\n</h4>\n<p>\n This bit is used only for\n <strong>\n  Output\n </strong>\n and\n <strong>\n  Feature\n </strong>\n report data:\n</p>\n<ul>\n<li>\n<strong>\n   Volatile:\n  </strong>\n  The device can change its value without input from the host, either autonomously or when the host sends a report. For example, a control panel may allow the user to either press a physical button on the device or click on a virtual button to change the value.\n </li>\n<li>\n<strong>\n   Non-volatile:\n  </strong>\n  The device changes its value only when instructed by the host through a report.\n </li>\n</ul>\n<p>\n When sending reports to a volatile item:\n</p>\n<ul>\n<li>\n  If the item is defined as\n  <strong>\n   relative\n  </strong>\n  , assigning a value of 0 in the report results in no change.\n </li>\n<li>\n  If the item is defined as\n  <strong>\n   absolute\n  </strong>\n  , assigning an out-of-range value in the report results in no change.\n </li>\n</ul>\n<p>\n These bit functions help specify the behavior and interactions of controls, whether they are independent or require host input.\n</p>\n"}, "Page 383": {"response": "<h3>\n Chapter 12: Collection and End Collection Items\n</h3>\n<p>\n In addition to the bit functions,\n <strong>\n  Collection\n </strong>\n and\n <strong>\n  End Collection\n </strong>\n items are used to group related report items together.\n</p>\n<h4>\n Bit Field | Buffered Bytes\n</h4>\n<ul>\n<li>\n<strong>\n   Bit Field:\n  </strong>\n  Each bit or group of bits within a byte represents a separate piece of data. The byte itself does not represent a single value. The application is responsible for interpreting the data within the field.\n </li>\n<li>\n<strong>\n   Buffered Bytes:\n  </strong>\n  The data consists of one or more bytes, and the report size for Buffered Byte items must be eight.\nNote: This bit (Bit 8) requires two data bytes in the item and does not apply to\n  <strong>\n   Array data\n  </strong>\n  .\n </li>\n</ul>\n<h4>\n Collection Types\n</h4>\n<p>\n There are three predefined types of collections:\n <strong>\n  application\n </strong>\n ,\n <strong>\n  physical\n </strong>\n , and\n <strong>\n  logical\n </strong>\n . Additionally, vendors can define their own collection types. Collections can also be nested.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Application Collection:\n   </strong>\n   This collection contains items that serve a common purpose or perform a related function. For example, in a keyboard's boot descriptor, the keypress and LED data are grouped into an application collection. All report items must be part of an application collection.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Physical Collection:\n   </strong>\n   This collection contains items that represent data from a specific physical location. For example, a device collecting sensor readings from various locations might organize the data from each location into a physical collection. In a mouse's boot descriptor, button and position data are grouped into a physical collection.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Logical Collection:\n   </strong>\n   A logical collection links different types of items together into a data structure. For example, it could group the contents of a data buffer with a count of the bytes in that buffer.\n  </p>\n</li>\n</ul>\n<h4>\n Collection Structure\n</h4>\n<p>\n Each collection begins with a\n <strong>\n  Collection\n </strong>\n item and ends with an\n <strong>\n  End Collection\n </strong>\n item. All report items placed between these two markers are part of the collection. Additionally, each collection must have a\n <strong>\n  Usage tag\n </strong>\n , which provides additional context for the items within the collection.\n</p>\n<p>\n This structure helps organize and categorize data in a way that groups related items for efficient processing and interpretation.\n</p>\n"}, "Page 384": {"response": "<h3>\n Human Interface Devices: Reports (Continued)\n</h3>\n<h4>\n Top-Level Collections\n</h4>\n<p>\n A\n <strong>\n  top-level collection\n </strong>\n is a collection that isn\u2019t nested within another collection. A HID interface can have multiple top-level collections, with each representing a different HID. For example, a keyboard with an embedded pointing device might have a HID interface containing two top-level collections\u2014one for the keyboard\u2019s reports and one for the pointing device\u2019s reports. Unlike separate HIDs in different interfaces, these HIDs share interrupt endpoints.\n</p>\n<ul>\n<li>\n  If a report contains an\n  <strong>\n   unknown vendor-defined collection type\n  </strong>\n  , the host should ignore all main items within that collection.\n </li>\n<li>\n  If a known collection type has an\n  <strong>\n   unknown Usage\n  </strong>\n  , the host should ignore all items within that collection.\n </li>\n</ul>\n<h4>\n Global Item Type\n</h4>\n<p>\n<strong>\n  Global items\n </strong>\n provide information about the reports and describe their characteristics, such as the function of the data, its maximum and minimum values, and the size and number of report items. A\n <strong>\n  Global item tag\n </strong>\n applies to every item that follows it until the next Global tag. This allows the report descriptor to save storage space by not repeating values that remain the same across multiple items.\n</p>\n<p>\n There are 12 defined\n <strong>\n  Global items\n </strong>\n that help organize and define data across a report. These items ensure consistency and efficiency in the report structure.\n</p>\n<h4>\n Identifying the Report: Report ID\n</h4>\n<p>\n The\n <strong>\n  Report ID\n </strong>\n is a value that identifies a specific report within a HID. HID devices can support multiple reports of the same type, with each report having its own\n <strong>\n  Report ID\n </strong>\n . This enables the device to distinguish between different reports of the same category, allowing for more complex and flexible data reporting.\n</p>\n<h4>\n Table 12-2: Collection and End Collection Main Item Tags\n</h4>\n<p>\n This table shows the values for the\n <strong>\n  Collection\n </strong>\n and\n <strong>\n  End Collection\n </strong>\n main item tags:\n</p>\n<table>\n<thead>\n<tr>\n<th>\n    Main Item Type\n   </th>\n<th>\n    Value\n   </th>\n<th>\n    Description\n   </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     Collection (A1h)\n    </strong>\n</td>\n<td>\n</td>\n<td>\n</td>\n</tr>\n<tr>\n<td>\n    00h\n   </td>\n<td>\n    Physical\n   </td>\n<td>\n    Describes a physical collection\n   </td>\n</tr>\n<tr>\n<td>\n    01h\n   </td>\n<td>\n    Application\n   </td>\n<td>\n    Describes an application collection\n   </td>\n</tr>\n<tr>\n<td>\n    02h\n   </td>\n<td>\n    Logical\n   </td>\n<td>\n    Describes a logical collection\n   </td>\n</tr>\n<tr>\n<td>\n    03h-7Fh\n   </td>\n<td>\n    Reserved\n   </td>\n<td>\n    Reserved values\n   </td>\n</tr>\n<tr>\n<td>\n    80h-FFh\n   </td>\n<td>\n    Vendor-defined\n   </td>\n<td>\n    Vendor-specific collection types\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     End Collection (C0h)\n    </strong>\n</td>\n<td>\n    None\n   </td>\n<td>\n    Closes a collection\n   </td>\n</tr>\n</tbody>\n</table>\n<p>\n This table helps define the tags used to identify and close collections within the report descriptor, clarifying how items are grouped and structured for the host to process correctly.\n</p>\n"}, "Page 385": {"response": "<h3>\n Chapter 12: Global Items and Report IDs\n</h3>\n<h4>\n Report ID\n</h4>\n<p>\n A\n <strong>\n  Report ID\n </strong>\n is used to uniquely identify a specific report in a HID (Human Interface Device). This helps avoid the need to include all the data in every report transfer. While it\u2019s often more efficient to have a single report with all the information, sometimes it's more important to keep reports simple and minimize bandwidth.\n</p>\n<ul>\n<li>\n  In a\n  <strong>\n   report descriptor\n  </strong>\n  , the\n  <strong>\n   Report ID\n  </strong>\n  applies to all items that follow it until the next\n  <strong>\n   Report ID\n  </strong>\n  is declared.\n </li>\n<li>\n  If no\n  <strong>\n   Report ID\n  </strong>\n  is specified, the default\n  <strong>\n   ID of zero\n  </strong>\n  is assumed. However, it is recommended not to declare a\n  <strong>\n   Report ID\n  </strong>\n  of zero.\n </li>\n<li>\n  The\n  <strong>\n   Report IDs\n  </strong>\n  are specific to each report type. A device can have one report of each type with the default ID (zero). But if a device supports multiple Report IDs for any report type, then every report in the HID must declare its Report ID.\n </li>\n</ul>\n<p>\n For instance, if a device supports\n <strong>\n  Report ID 1\n </strong>\n and\n <strong>\n  Report ID 2\n </strong>\n for\n <strong>\n  Feature reports\n </strong>\n , then all\n <strong>\n  Input\n </strong>\n or\n <strong>\n  Output\n </strong>\n reports must also have Report IDs greater than zero. This ensures that the host can correctly distinguish between different reports.\n</p>\n<p>\n When a\n <strong>\n  Set_Report\n </strong>\n or\n <strong>\n  Get_Report\n </strong>\n request is made, the\n <strong>\n  Report ID\n </strong>\n is specified by the host in the\n <strong>\n  wValue\n </strong>\n field of the Setup transaction. The\n <strong>\n  low byte\n </strong>\n of the\n <strong>\n  wValue\n </strong>\n indicates the Report ID.\n</p>\n<h4>\n Global Items\n</h4>\n<p>\n Global items help identify and describe the characteristics of data in reports, such as the function of the data, its maximum and minimum values, and the number of items. These global items apply to all following items until the next Global item tag appears. This reduces redundancy and saves space in the report descriptor. There are\n <strong>\n  12 defined Global items\n </strong>\n that help define how the data is structured and used in the report.\n</p>\n<p>\n Here are the\n <strong>\n  12 defined Global items\n </strong>\n :\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Global Item Type\n    </strong>\n</th>\n<th>\n<strong>\n     Value\n    </strong>\n</th>\n<th>\n<strong>\n     Description\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     Usage Page\n    </strong>\n</td>\n<td>\n    000001nn\n   </td>\n<td>\n    Specifies the data's usage or function.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Logical Minimum\n    </strong>\n</td>\n<td>\n    000101nn\n   </td>\n<td>\n    Smallest value that an item will report.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Logical Maximum\n    </strong>\n</td>\n<td>\n    001001nn\n   </td>\n<td>\n    Largest value that an item will report.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Physical Minimum\n    </strong>\n</td>\n<td>\n    001101nn\n   </td>\n<td>\n    The logical minimum expressed in physical units.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Physical Maximum\n    </strong>\n</td>\n<td>\n    010001nn\n   </td>\n<td>\n    The logical maximum expressed in physical units.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Unit Exponent\n    </strong>\n</td>\n<td>\n    010101nn\n   </td>\n<td>\n    Base 10 exponent of the units.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Unit\n    </strong>\n</td>\n<td>\n    011001nn\n   </td>\n<td>\n    Specifies the unit values.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Report Size\n    </strong>\n</td>\n<td>\n    011101nn\n   </td>\n<td>\n    The size of an item's fields in bits.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Report ID\n    </strong>\n</td>\n<td>\n    100001nn\n   </td>\n<td>\n    Identifies a specific report (as explained earlier).\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Report Count\n    </strong>\n</td>\n<td>\n    100101nn\n   </td>\n<td>\n    Specifies the number of data fields for an item.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Push\n    </strong>\n</td>\n<td>\n    101001nn\n   </td>\n<td>\n    Places a copy of the global item state table onto the stack.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Pop\n    </strong>\n</td>\n<td>\n    101101nn\n   </td>\n<td>\n    Replaces the item state table with the last structure pushed.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Reserved\n    </strong>\n</td>\n<td>\n    110001nn to 111101nn\n   </td>\n<td>\n    Reserved for future use.\n   </td>\n</tr>\n</tbody>\n</table>\n<p>\n These\n <strong>\n  Global items\n </strong>\n help structure the HID report descriptor and ensure that all data items are correctly identified, with clear boundaries for what each value represents in the report. By using these items, a HID can maintain a compact and efficient descriptor without redundant information.\n</p>\n"}, "Page 386": {"response": "<h3>\n Human Interface Devices: Reports (Continued)\n</h3>\n<h4>\n Interrupt Transfers and Report IDs\n</h4>\n<p>\n When a HID supports more than one\n <strong>\n  Report ID\n </strong>\n , the\n <strong>\n  Report ID\n </strong>\n is sent before the report data during an interrupt transfer. However, if the interface only supports the default\n <strong>\n  Report ID\n </strong>\n of zero, the Report ID is not sent with the report in an interrupt transfer.\n</p>\n<p>\n In the context of Windows:\n</p>\n<ul>\n<li>\n  The\n  <strong>\n   report buffer\n  </strong>\n  used in API calls must be large enough to hold the report data and include an additional byte for the Report ID.\n </li>\n<li>\n  If a HID supports multiple\n  <strong>\n   Input Report IDs\n  </strong>\n  of different sizes, the Windows HID driver requires the application to allocate a buffer large enough to hold the largest report.\n </li>\n<li>\n  If the HID sends a report whose size is a multiple of the endpoint\u2019s maximum packet size, the HID signals the end of the report by sending a\n  <strong>\n   zero-length data packet\n  </strong>\n  .\n </li>\n</ul>\n<p>\n For Input reports with multiple\n <strong>\n  Input Report IDs\n </strong>\n , the host\u2019s driver cannot request a specific report from the HID. Instead, when the\n <strong>\n  IN token\n </strong>\n packet is received, the device simply sends the report that is in its buffer. The\n <strong>\n  device firmware\n </strong>\n determines which report to send. The host HID driver stores the received report along with its Report ID in a buffer.\n</p>\n<h4>\n Describing the Data's Use\n</h4>\n<p>\n Several\n <strong>\n  Global items\n </strong>\n describe how the data in a report is used, allowing the receiver to interpret the data meaningfully. These items include\n <strong>\n  Usage Page\n </strong>\n ,\n <strong>\n  Logical and Physical Maximums and Minimums\n </strong>\n ,\n <strong>\n  Unit\n </strong>\n , and\n <strong>\n  Unit Exponent\n </strong>\n .\n</p>\n<ul>\n<li>\n<strong>\n   Usage Page\n  </strong>\n  helps categorize the function of the data.\n </li>\n<li>\n<strong>\n   Logical and Physical Maximums and Minimums\n  </strong>\n  help define the valid range of data values.\n </li>\n<li>\n<strong>\n   Unit\n  </strong>\n  and\n  <strong>\n   Unit Exponent\n  </strong>\n  help specify the units of the data (e.g., distance, pressure, etc.).\n </li>\n</ul>\n<p>\n These Global items are essential for converting raw report data into usable values, but the conversion process may also involve the sender of the report data, depending on the device's configuration.\n</p>\n<h4>\n Usage Page\n</h4>\n<p>\n The\n <strong>\n  Usage Page\n </strong>\n is a\n <strong>\n  32-bit value\n </strong>\n that identifies a function performed by the device. It is divided into:\n</p>\n<ul>\n<li>\n  The\n  <strong>\n   upper 16 bits\n  </strong>\n  , which represent the\n  <strong>\n   Global Usage Page item\n  </strong>\n  .\n </li>\n<li>\n  The\n  <strong>\n   lower 16 bits\n  </strong>\n  , which represent the\n  <strong>\n   Local Usage item\n  </strong>\n  , specifically the\n  <strong>\n   Usage ID\n  </strong>\n  .\n </li>\n</ul>\n<p>\n The\n <strong>\n  Usage ID\n </strong>\n is the actual identifier for the specific function the device performs. The term\n <strong>\n  Usage\n </strong>\n may refer to the entire 32-bit value or just the lower 16-bit\n <strong>\n  Local Usage ID\n </strong>\n . To avoid confusion, some sources use the term\n <strong>\n  Extended Usage\n </strong>\n to refer to the entire 32-bit value.\n</p>\n<p>\n This structure ensures that the data's function and meaning can be interpreted by the host or application that receives it.\n</p>\n"}, "Page 387": {"response": "<h3>\n Human Interface Devices: Reports (Continued)\n</h3>\n<h4>\n Usage Page and Usage ID\n</h4>\n<p>\n In the HID protocol, the\n <strong>\n  Usage\n </strong>\n type is a\n <strong>\n  16-bit value\n </strong>\n that can represent either a\n <strong>\n  Usage Page\n </strong>\n or a\n <strong>\n  Usage ID\n </strong>\n .\n</p>\n<ul>\n<li>\n<strong>\n   Usage Page\n  </strong>\n  groups related functionalities together, and multiple items can share a Usage Page but have different Usage IDs.\n </li>\n<li>\n  Once a\n  <strong>\n   Usage Page\n  </strong>\n  is declared in a report, all subsequent\n  <strong>\n   Usage IDs\n  </strong>\n  will use that same page until a new\n  <strong>\n   Usage Page\n  </strong>\n  is declared.\n </li>\n</ul>\n<p>\n The\n <strong>\n  HID Usage Tables\n </strong>\n document lists all the defined Usage Pages along with their associated values. It also provides information on where to find more details about each Usage Page and its indexes. Many\n <strong>\n  common device types\n </strong>\n , such as mice, keyboards, joysticks, and bar-code scanners, have predefined Usage Pages. However, specialized devices that don\u2019t have a predefined Usage Page can use vendor-defined pages, which fall within the\n <strong>\n  FF00h to FFFFh\n </strong>\n range.\n</p>\n<h4>\n Logical Minimum and Logical Maximum\n</h4>\n<p>\n The\n <strong>\n  Logical Minimum\n </strong>\n and\n <strong>\n  Logical Maximum\n </strong>\n define the range of valid reported values for an item. These values are expressed in\n <strong>\n  logical units\n </strong>\n , meaning they share the same units as the data being measured. For instance, if a device reports readings in milliamperes with increments of 2 milliamperes, a Logical Maximum of\n <strong>\n  250\n </strong>\n would indicate a maximum value of\n <strong>\n  500 milliamperes\n </strong>\n .\n</p>\n<ul>\n<li>\n  If the most significant bit (MSB) of the highest byte is\n  <strong>\n   1\n  </strong>\n  , the value is negative, expressed using\n  <strong>\n   two\u2019s complement\n  </strong>\n  notation. This means that to find the negative value represented by the two's complement, you must:\n  <ol>\n<li>\n    Invert each bit of the value.\n   </li>\n<li>\n    Add 1 to the result.\n   </li>\n</ol>\n</li>\n</ul>\n<p>\n For example, using a\n <strong>\n  1-byte value\n </strong>\n , the positive decimal range is\n <strong>\n  0 to 127\n </strong>\n (from\n <strong>\n  00h to 7Fh\n </strong>\n ), while the negative range is\n <strong>\n  -1 to -128\n </strong>\n (from\n <strong>\n  FFh to 80h\n </strong>\n ).\n</p>\n<p>\n In cases where both the\n <strong>\n  Logical Minimum\n </strong>\n and\n <strong>\n  Logical Maximum\n </strong>\n are positive values, there is no need for a sign bit. However, if a negative range is represented incorrectly, as seen in the example below, it will cause a\n <strong>\n  compliance failure\n </strong>\n :\n</p>\n<ul>\n<li>\n<strong>\n   Incorrect Example:\n  </strong>\n<ul>\n<li>\n<code>\n     0x15 0x00 // Logical Minimum (0)\n    </code>\n</li>\n<li>\n<code>\n     0x25 0xFF // Logical Maximum (-1)\n    </code>\n</li>\n</ul>\n</li>\n</ul>\n<p>\n To avoid this issue, if the desired\n <strong>\n  Logical Minimum\n </strong>\n is\n <strong>\n  0\n </strong>\n and the\n <strong>\n  Logical Maximum\n </strong>\n is\n <strong>\n  255\n </strong>\n , it's necessary to use a\n <strong>\n  2-byte value\n </strong>\n to correctly represent the maximum value.\n</p>\n"}, "Page 388": {"response": "<h3>\n Converting Units and Logical/Physical Limits\n</h3>\n<h4>\n Correcting the Logical Maximum\n</h4>\n<p>\n In cases where both\n <strong>\n  Logical Minimum\n </strong>\n and\n <strong>\n  Logical Maximum\n </strong>\n values are defined, it's important to use the correct number of bytes. For example, in the corrected case:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Logical Minimum:\n   </strong>\n</p>\n<ul>\n<li>\n<code>\n     0x15 0x00\n    </code>\n    (This represents a minimum of 0)\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Logical Maximum:\n   </strong>\n</p>\n<ul>\n<li>\n<code>\n     0x26 0x00FF\n    </code>\n    (This represents a maximum of 255, in two bytes)\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n This ensures that the\n <strong>\n  Logical Maximum\n </strong>\n is properly represented with two bytes and that the\n <strong>\n  most-significant bit\n </strong>\n (MSB) is zero, indicating that the value is positive. This configuration passes the compliance test and is considered valid.\n</p>\n<h4>\n Converting Units Using Physical Limits\n</h4>\n<p>\n The\n <strong>\n  Physical Minimum\n </strong>\n and\n <strong>\n  Physical Maximum\n </strong>\n values are used to convert reported data into\n <strong>\n  real-world units\n </strong>\n . These values define the limits of the reported data when expressed in units specified by the\n <strong>\n  Unit\n </strong>\n tag.\n</p>\n<p>\n For example, if the device reports values ranging from\n <strong>\n  0 to 250\n </strong>\n and the unit is\n <strong>\n  2 milliamperes\n </strong>\n , the\n <strong>\n  Physical Minimum\n </strong>\n would be\n <strong>\n  0\n </strong>\n and the\n <strong>\n  Physical Maximum\n </strong>\n would be\n <strong>\n  500 milliamperes\n </strong>\n (since 250 * 2 = 500). The device sending this data uses these limits to translate it into the required units, but using a coarser unit (like 2 milliamperes per unit) can result in less resolution than if each unit represented 1 milliamperes.\n</p>\n<p>\n If the report doesn't specify the\n <strong>\n  Physical Minimum\n </strong>\n and\n <strong>\n  Physical Maximum\n </strong>\n , these values default to the same values as the\n <strong>\n  Logical Minimum\n </strong>\n and\n <strong>\n  Logical Maximum\n </strong>\n .\n</p>\n<h4>\n Unit Exponent and Unit Conversion\n</h4>\n<p>\n The\n <strong>\n  Unit Exponent\n </strong>\n defines how to scale the value after it's been converted into the desired units using the\n <strong>\n  Logical\n </strong>\n and\n <strong>\n  Physical\n </strong>\n limits. The exponent indicates the power of 10 to multiply by the value. The exponent ranges from\n <strong>\n  -8\n </strong>\n to\n <strong>\n  +7\n </strong>\n , and here are the possible codes:\n</p>\n<ul>\n<li>\n<strong>\n   Exponent 0 (No Exponent):\n  </strong>\n  The value is multiplied by\n  <strong>\n   1\n  </strong>\n  (or no scaling applied).\n </li>\n<li>\n<strong>\n   Exponent +1 to +7\n  </strong>\n  : The value is scaled by powers of 10 (e.g., *10, *100, *1000, etc.).\n </li>\n<li>\n<strong>\n   Exponent -8 to -1\n  </strong>\n  : The value is scaled by fractions (e.g., *0.1, *0.01, *0.001, etc.).\n </li>\n</ul>\n<p>\n For instance, if a value of\n <strong>\n  1234\n </strong>\n is reported and the\n <strong>\n  Unit Exponent\n </strong>\n is\n <strong>\n  0Eh\n </strong>\n , it means the final value will be\n <strong>\n  12.34\n </strong>\n (shifting the decimal by two places).\n</p>\n<p>\n The exponent values range as follows:\n</p>\n<table>\n<thead>\n<tr>\n<th>\n    Exponent Code\n   </th>\n<th>\n    Exponent Value\n   </th>\n<th>\n    Multiplier (Power of 10)\n   </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n    00h\n   </td>\n<td>\n    0\n   </td>\n<td>\n    1\n   </td>\n</tr>\n<tr>\n<td>\n    01h\n   </td>\n<td>\n    1\n   </td>\n<td>\n    10\n   </td>\n</tr>\n<tr>\n<td>\n    02h\n   </td>\n<td>\n    2\n   </td>\n<td>\n    100\n   </td>\n</tr>\n<tr>\n<td>\n    03h\n   </td>\n<td>\n    3\n   </td>\n<td>\n    1000\n   </td>\n</tr>\n<tr>\n<td>\n    ...\n   </td>\n<td>\n    ...\n   </td>\n<td>\n    ...\n   </td>\n</tr>\n<tr>\n<td>\n    0Fh\n   </td>\n<td>\n    +7\n   </td>\n<td>\n    10,000,000\n   </td>\n</tr>\n<tr>\n<td>\n    08h\n   </td>\n<td>\n    -8\n   </td>\n<td>\n    0.00000001\n   </td>\n</tr>\n</tbody>\n</table>\n"}, "Page 389": {"response": "<p>\n It seems like you entered a period. How can I assist you further?\n</p>\n"}, "Page 390": {"response": "<h3>\n Converting and Applying Units in HID Reports\n</h3>\n<p>\n The\n <code>\n  Physical Minimum\n </code>\n ,\n <code>\n  Physical Maximum\n </code>\n ,\n <code>\n  Unit\n </code>\n , and\n <code>\n  Unit Exponent\n </code>\n items are essential for converting the raw data received in HID reports into meaningful, user-friendly units. Here\u2019s a more digestible breakdown of these concepts:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Physical Minimum &amp; Maximum\n   </strong>\n<br/>\n   These values define the range of the physical units that a report can represent. The conversion of reported data to these physical units is done by the receiver. For example, if a device reports values between 0 and 250 (in logical units), and you want to convert it into milliamperes, the physical minimum could be 0, and the physical maximum could be 500 milliamperes. This conversion allows the data to be transferred efficiently without requiring the full scale of raw values.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Unit Exponent\n   </strong>\n<br/>\n   The\n   <code>\n    Unit Exponent\n   </code>\n   helps adjust the scale of the data by indicating the power of 10 to apply to the value after conversion. It can range from -8 to +7, and each exponent represents a different factor for scaling. For example:\n  </p>\n<ul>\n<li>\n    An exponent of\n    <code>\n     0\n    </code>\n    means no scaling (value remains unchanged).\n   </li>\n<li>\n    An exponent of\n    <code>\n     0Fh\n    </code>\n    (or\n    <code>\n     +15\n    </code>\n    ) represents scaling by 0.1 (tenths of the base unit).\n   </li>\n</ul>\n<p>\n   For example, a\n   <code>\n    Unit Exponent\n   </code>\n   of\n   <code>\n    0Fh\n   </code>\n   applied to a value of 1234 would scale the result to 12.34 seconds, representing time in tenths of a second instead of full seconds.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Unit Item\n   </strong>\n<br/>\n   The\n   <code>\n    Unit\n   </code>\n   item specifies the type of unit being used for the report, based on a 4-bit nibble (half of a byte). Each nibble indicates a different measurement system, including:\n  </p>\n<ul>\n<li>\n<strong>\n     English Linear (3)\n    </strong>\n    : For example, time in seconds.\n   </li>\n<li>\n<strong>\n     SI Linear (1)\n    </strong>\n    : For example, temperature in Kelvin.\n   </li>\n<li>\n<strong>\n     English Rotation (4)\n    </strong>\n    : For example, temperature in Fahrenheit.\n   </li>\n</ul>\n<p>\n   Nibble 0 specifies the measuring system (such as length, mass, time, temperature, etc.), while other nibbles can define specific properties such as units of time, current, or luminous intensity.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Example Conversion\n   </strong>\n<br/>\n   Suppose you're measuring time and the device sends values between 0 and 60, representing up to a minute. Here's how the report data would be structured:\n  </p>\n<ul>\n<li>\n<strong>\n     Logical Minimum\n    </strong>\n    : 0\n   </li>\n<li>\n<strong>\n     Logical Maximum\n    </strong>\n    : 60\n   </li>\n<li>\n<strong>\n     Physical Minimum\n    </strong>\n    : 0\n   </li>\n<li>\n<strong>\n     Physical Maximum\n    </strong>\n    : 60\n   </li>\n<li>\n<strong>\n     Unit\n    </strong>\n    : 1003h (English Linear, Time in Seconds)\n   </li>\n<li>\n<strong>\n     Unit Exponent\n    </strong>\n    : 0 (no exponent, meaning the value is in seconds)\n   </li>\n</ul>\n<p>\n   If you change the time range to tenths of a second (up to 600), you adjust the\n   <code>\n    Logical Maximum\n   </code>\n   and\n   <code>\n    Physical Maximum\n   </code>\n   to 600 and apply an exponent of\n   <code>\n    -1\n   </code>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Unit Exponent\n    </strong>\n    : 0Fh, indicating tenths of seconds.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Unit Measurement Tables\n   </strong>\n<br/>\n   The\n   <code>\n    Unit\n   </code>\n   item uses a system of codes that define the type of measurement and the system of units used. For instance, nibble 0 indicates the type of measurement, such as length, mass, or time, while nibble 1-7 defines the specific unit within that measurement type. Some common examples include:\n  </p>\n<ul>\n<li>\n<strong>\n     Nibble 0 = 3\n    </strong>\n    : English Linear system, meaning units like inches.\n   </li>\n<li>\n<strong>\n     Nibble 1 = 4\n    </strong>\n    : Temperature measured in Fahrenheit.\n   </li>\n<li>\n<strong>\n     Nibble 2 = 3\n    </strong>\n    : Time in seconds.\n   </li>\n</ul>\n<p>\n   These coding structures ensure that the data transmitted in HID reports is correctly interpreted based on the system's predefined measurement standards.\n  </p>\n</li>\n</ol>\n<p>\n This system provides a structured and efficient way to report and convert raw data from various devices into units that are meaningful and understandable for users. The combination of Logical Minimums, Maximums, Physical values, Unit Exponent, and Unit helps ensure the data is both compact and accurately represented.\n</p>\n"}, "Page 391": {"response": "<h3>\n Converting Raw Data to Physical Units\n</h3>\n<p>\n When working with Human Interface Devices (HIDs) that send values as reports, it's essential to correctly convert the raw data to physical units (e.g., temperature, pressure, or distance) so that the receiver can interpret the data properly. The process involves specifying logical and physical ranges and understanding how to calculate the resolution and convert the values into meaningful units.\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Report Size and Range\n   </strong>\n<br/>\n   When transmitting large values, the report size (specified in the\n   <code>\n    Report Size\n   </code>\n   tag) may need to be expanded. For example, if you're sending a temperature value ranging from -20 to 110 degrees Fahrenheit, the report descriptor would define a logical range that spans -128 to 127 (which can fit into one byte of data). This ensures that the device can transmit values across a broad range while still maintaining compact report sizes.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Temperature Example\n   </strong>\n<br/>\n   If you want to use 1 byte (8 bits) to represent temperatures between -20\u00b0F and 110\u00b0F, the descriptor could look like this:\n  </p>\n<ul>\n<li>\n<strong>\n     Logical Minimum\n    </strong>\n    : -128 (in hexadecimal, this is 80h in two\u2019s complement)\n   </li>\n<li>\n<strong>\n     Logical Maximum\n    </strong>\n    : 127 (7Fh)\n   </li>\n<li>\n<strong>\n     Physical Minimum\n    </strong>\n    : -20 (ECh in two\u2019s complement)\n   </li>\n<li>\n<strong>\n     Physical Maximum\n    </strong>\n    : 110 (6Eh)\n   </li>\n<li>\n<strong>\n     Unit\n    </strong>\n    : 10003h (English Linear measuring system, with Fahrenheit as the unit for temperature)\n   </li>\n<li>\n<strong>\n     Unit Exponent\n    </strong>\n    : 0 (no exponent, meaning the value is in Fahrenheit without any scaling)\n   </li>\n</ul>\n<p>\n   These values ensure that the transmitted data uses the full range of a byte (0\u2013255), achieving the best resolution for this temperature range.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Calculating Resolution\n   </strong>\n<br/>\n   Resolution refers to how finely the data can represent the physical range with the available bits. To calculate the resolution (in bits per unit), use this formula:\n  </p>\n  scss\n  Copy code\n  <code class=\"!whitespace-pre hljs language-scss\">\n   Resolution = (Logical_Maximum - Logical_Minimum) / ((Physical_Maximum - Physical_Minimum) * (\n   10\n   ^ Unit_Exponent))\n  </code>\n<p>\n   Using the given values:\n  </p>\n<ul>\n<li>\n<strong>\n     Logical Range\n    </strong>\n    : 127 - (-128) = 255\n   </li>\n<li>\n<strong>\n     Physical Range\n    </strong>\n    : 110 - (-20) = 130\n   </li>\n<li>\n<strong>\n     Unit Exponent\n    </strong>\n    : 0 (no scaling)\n   </li>\n</ul>\n<p>\n   So, the resolution is:\n  </p>\n  makefile\n  Copy code\n  <code class=\"!whitespace-pre hljs language-makefile\">\n   Resolution = 255 / (130 * (10 ^ 0)) = 255 / 130 = 1.96 bits per degree\n  </code>\n<p>\n   This means each bit represents approximately 1.96\u00b0F, or 0.51\u00b0F per bit.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Converting Raw Values to Physical Units\n   </strong>\n<br/>\n   To convert the raw report data (expressed in logical units) into physical units, use the following formula:\n  </p>\n  scss\n  Copy code\n  <code class=\"!whitespace-pre hljs language-scss\">\n   Value = (Value_In_Logical_Units * (Physical_Maximum - Physical_Minimum) * (\n   10\n   ^ Unit_Exponent)) / (Logical_Maximum - Logical_Minimum)\n  </code>\n<p>\n   For example, if the raw value is 63 (logical units), you would calculate the physical temperature as follows:\n  </p>\n<ul>\n<li>\n<strong>\n     Logical Value\n    </strong>\n    : 63\n   </li>\n<li>\n<strong>\n     Physical Range\n    </strong>\n    : 110 - (-20) = 130\n   </li>\n<li>\n<strong>\n     Unit Exponent\n    </strong>\n    : 0 (no scaling)\n   </li>\n<li>\n<strong>\n     Logical Range\n    </strong>\n    : 127 - (-128) = 255\n   </li>\n</ul>\n<p>\n   The conversion becomes:\n  </p>\n  makefile\n  Copy code\n  <code class=\"!whitespace-pre hljs language-makefile\">\n   Value = (63 * 130 * (10 ^ 0)) / 255 = 8190 / 255 = 32\u00b0F\n  </code>\n<p>\n   Therefore, the raw value of 63 corresponds to 32\u00b0F after conversion, which is the desired physical value in Fahrenheit.\n  </p>\n</li>\n</ol>\n<p>\n By using the descriptors and conversion formulas outlined above, HID devices can efficiently convert and transmit data, ensuring the raw values are accurately translated into real-world measurements like temperature, pressure, or distance.\n</p>\n"}, "Page 392": {"response": "<h3>\n Describing Data Size, Format, and Unit Values in HID Reports\n</h3>\n<p>\n Human Interface Devices (HIDs) require a structured way to send data, particularly in reports that involve units, sizes, and formats. This section breaks down how different Global items define these attributes, including how units and report sizes are specified.\n</p>\n<h4>\n Specifying Units in Reports\n</h4>\n<p>\n Units play a crucial role in converting raw data into physical quantities. For example, velocity in centimeters per second is specified using a Unit value that combines centimeters for length and seconds for time. According to Table 12-4, to select velocity in centimeters per second, the Unit value is\n <code>\n  1011h\n </code>\n :\n</p>\n<ul>\n<li>\n<strong>\n   Nibble 0\n  </strong>\n  :\n  <code>\n   1\n  </code>\n  for the SI (International System) measuring system.\n </li>\n<li>\n<strong>\n   Nibble 1\n  </strong>\n  :\n  <code>\n   1\n  </code>\n  for length in centimeters.\n </li>\n<li>\n<strong>\n   Nibble 3\n  </strong>\n  :\n  <code>\n   1\n  </code>\n  for time in seconds.\n </li>\n</ul>\n<p>\n In a more complex case, the Unit value for volts could be\n <code>\n  F0D121h\n </code>\n , which specifies:\n</p>\n<ul>\n<li>\n<strong>\n   SI Linear\n  </strong>\n  measuring system.\n </li>\n<li>\n<strong>\n   Units\n  </strong>\n  :\n  (cm\n  2\n  )\n  (\n  g\n  m\n  )\n  /\n  (\n  sec\n  \u2212\n  3\n  )\n  (\n  amp\n  \u2212\n  1\n  )\n  \\text{(cm}^2)(gm) / (\\text{sec}^{-3})(\\text{amp}^{-1})\n  (cm\n  2\n  )\n  (\n  g\n  m\n  )\n  /\n  (\n  sec\n  \u2212\n  3\n  )\n  (\n  amp\n  \u2212\n  1\n  )\n  , indicating the relationship between centimeters squared, grams, seconds, and amps.\n </li>\n</ul>\n<p>\n However, it\u2019s important to note that while the Unit value defines the unit system, the receiving device doesn't have to perform complex calculations. It simply identifies the Unit value and applies the units to the received data.\n</p>\n<h4>\n Defining Report Size and Count\n</h4>\n<p>\n Two Global items,\n <strong>\n  Report Size\n </strong>\n and\n <strong>\n  Report Count\n </strong>\n , define the structure of report data, indicating how much data is sent and how it's organized:\n</p>\n<ul>\n<li>\n<strong>\n   Report Size\n  </strong>\n  : Specifies the size of a field (in bits) in an Input, Output, or Feature item. For example, if a field is 8 bits,\n  <strong>\n   Report Size\n  </strong>\n  will be 8.\n </li>\n<li>\n<strong>\n   Report Count\n  </strong>\n  : Specifies how many fields are in a particular Input, Output, or Feature item.\n </li>\n</ul>\n<p>\n For example:\n</p>\n<ul>\n<li>\n  If a report has two 8-bit fields,\n  <strong>\n   Report Size\n  </strong>\n  would be 8, and\n  <strong>\n   Report Count\n  </strong>\n  would be 2.\n </li>\n<li>\n  If a report has one 16-bit field,\n  <strong>\n   Report Size\n  </strong>\n  would be 16, and\n  <strong>\n   Report Count\n  </strong>\n  would be 1.\n </li>\n</ul>\n<p>\n It\u2019s possible for a single report to have multiple fields, each with different sizes and counts. Each item in the report can be individually defined with a specific\n <strong>\n  Report Size\n </strong>\n and\n <strong>\n  Report Count\n </strong>\n , allowing for flexible and detailed data structures.\n</p>\n<h4>\n Saving and Restoring Global Items\n</h4>\n<p>\n To manage space efficiently in the device, there are two additional Global items used for saving and restoring the state of Global items:\n</p>\n<ul>\n<li>\n<strong>\n   Push\n  </strong>\n  : This item saves the current settings of all previously defined Global items to the CPU\u2019s stack. It effectively saves the \"state\" of the report descriptor, allowing for easy restoration.\n </li>\n<li>\n<strong>\n   Pop\n  </strong>\n  : This item restores the settings that were saved by the last\n  <strong>\n   Push\n  </strong>\n  command.\n </li>\n</ul>\n<p>\n These mechanisms allow HID devices to change their report formats without requiring redundant storage for each possible configuration. By saving and restoring settings, devices can reduce the storage requirements while maintaining flexibility in how they report data.\n</p>\n<p>\n In summary, these features allow HIDs to effectively manage data transmission, ensuring that the reports sent to and from devices contain well-defined units, sizes, and counts, while also minimizing storage requirements by leveraging the\n <strong>\n  Push\n </strong>\n and\n <strong>\n  Pop\n </strong>\n Global items.\n</p>\n"}, "Page 393": {"response": "<h3>\n Understanding Local Items in HID Reports\n</h3>\n<p>\n Local items are key components of Human Interface Device (HID) reports that define specific qualities of controls and data. These items are used to describe individual data elements and the context they belong to. Unlike Global items, Local items are specific to the current Main item in a report and don\u2019t carry over to the next Main item.\n</p>\n<h4>\n Functions of Local Items\n</h4>\n<p>\n Local items relate to the function and usage of controls, body-part designators, and even strings. They help specify how data should be interpreted by the receiving device, especially in relation to specific usages of buttons, controls, or other elements in the HID report.\n</p>\n<h4>\n Key Local Items and Their Roles\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Usage\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     Usage\n    </strong>\n    item is used to specify a control\u2019s function, like a button press, in conjunction with the\n    <strong>\n     Usage Page\n    </strong>\n    . The\n    <strong>\n     Usage\n    </strong>\n    ID is defined within a\n    <strong>\n     Usage Page\n    </strong>\n    and indicates the function of the data element or control.\n   </li>\n<li>\n    For instance, the\n    <strong>\n     Buttons Usage Page\n    </strong>\n    contains\n    <strong>\n     Usage IDs\n    </strong>\n    ranging from 1 to FFFFh, each identifying a button in a set. A value of 0 indicates that no button is pressed.\n   </li>\n<li>\n<strong>\n     Usage\n    </strong>\n    can be used for multiple items within a report. For example, a report might contain two data fields, each with a different\n    <strong>\n     Usage\n    </strong>\n    . If there\u2019s one\n    <strong>\n     Usage\n    </strong>\n    ID before multiple items, it applies to all the data following that Usage ID.\n   </li>\n<li>\n    If multiple\n    <strong>\n     Usage\n    </strong>\n    IDs precede a report item, each\n    <strong>\n     Usage\n    </strong>\n    ID is paired with a data item in sequence. For example, in a report with two bytes:\n    scss\n    Copy code\n    <code class=\"!whitespace-pre hljs language-scss\">\n     Usage (X),\nUsage (Y),\nReport Count (\n     2\n     ),\nReport Size (\n     8\n     ),\n     Input\n     (Data, Variable, Absolute)\n    </code>\n    The first byte uses\n    <strong>\n     Usage (X)\n    </strong>\n    , and the second byte uses\n    <strong>\n     Usage (Y)\n    </strong>\n    . If there are more controls or data items than\n    <strong>\n     Usage\n    </strong>\n    IDs, the last\n    <strong>\n     Usage\n    </strong>\n    applies to all remaining items.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Delimiter\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     Delimiter\n    </strong>\n    item allows grouping related Local items. It enables organizing different\n    <strong>\n     Usage\n    </strong>\n    IDs and other local items into sets for easier interpretation and processing.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Applying Multiple Usages\n</h4>\n<p>\n When a report includes more than one\n <strong>\n  Usage\n </strong>\n ID, each\n <strong>\n  Usage\n </strong>\n can correspond to a separate control or data item. If there\u2019s a mismatch in the number of\n <strong>\n  Usages\n </strong>\n and items, the report will match each\n <strong>\n  Usage\n </strong>\n to a data item in sequence, with the last\n <strong>\n  Usage\n </strong>\n applying to all remaining data items.\n</p>\n<h4>\n Summary\n</h4>\n<p>\n Local items are crucial for defining specific control functions and providing context to the data in HID reports. They work alongside\n <strong>\n  Global items\n </strong>\n to shape the overall report format but are specific to each Main item in the report. Understanding how\n <strong>\n  Usage\n </strong>\n IDs and\n <strong>\n  Delimiters\n </strong>\n work ensures that data is accurately interpreted and processed according to the device\u2019s function.\n</p>\n"}, "Page 394": {"response": "<h3>\n Understanding Local Items in HID Reports\n</h3>\n<p>\n Local items in Human Interface Device (HID) reports define specific qualities and characteristics of controls and data. These items provide further context for the data fields in a report, such as specifying which button or function is being used, associating body parts with controls, or linking strings to items. The key feature of Local items is that they only apply to the data items within the Main item that they precede. Once a new Main item begins, the Local items reset.\n</p>\n<h4>\n Key Local Item Types\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Usage (000010nn)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Usage\n    </strong>\n    specifies the purpose of a control or data item in the report. It indicates the function of a button or control in the context of a report. For example, in a multi-button device, each button may be associated with a specific\n    <strong>\n     Usage\n    </strong>\n    ID.\n   </li>\n<li>\n    Multiple\n    <strong>\n     Usages\n    </strong>\n    can apply to different data items in a report. For instance, if a report is 16 bytes long, the first byte could be assigned\n    <strong>\n     Usage (X)\n    </strong>\n    , the second byte\n    <strong>\n     Usage (Y)\n    </strong>\n    , and the subsequent bytes could each have their own\n    <strong>\n     vendor-defined Usage\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Usage Minimum (000110nn)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This item marks the starting\n    <strong>\n     Usage\n    </strong>\n    ID for elements in an array or bitmap. It is helpful when a range of controls or buttons share a common\n    <strong>\n     Usage\n    </strong>\n    ID but span multiple data fields.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Usage Maximum (001010nn)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Similar to\n    <strong>\n     Usage Minimum\n    </strong>\n    , this item defines the ending\n    <strong>\n     Usage\n    </strong>\n    ID for elements in an array or bitmap. It marks the boundary of a range of controls sharing the same\n    <strong>\n     Usage\n    </strong>\n    ID.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Designator Index (001110nn)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This item associates a specific\n    <strong>\n     Designator\n    </strong>\n    with a control, usually referencing a body part (e.g., a hand or foot). It\u2019s used in physical descriptors to specify the exact location or body part to which a control belongs.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Designator Minimum (010010nn)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This defines the starting index of a\n    <strong>\n     Designator\n    </strong>\n    in an array or bitmap. It is used when associating multiple controls with a specific body part or designator.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Designator Maximum (010110nn)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This item defines the ending\n    <strong>\n     Designator\n    </strong>\n    index for elements in an array or bitmap, indicating the boundary of the associated body parts or controls.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    String Index (011110nn)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This item links a string to a control or item in the report. It\u2019s used to associate textual data with specific controls, like naming a button or setting.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    String Minimum (100010nn)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This item marks the first string index when assigning a group of sequential strings to an array or bitmap of controls. It indicates the beginning of a series of string associations.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    String Maximum (100110nn)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This item marks the last string index in a series of sequential strings applied to an array or bitmap of controls, indicating the end of the string assignment.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Delimiter (101010nn)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     Delimiter\n    </strong>\n    item marks the start or end of a set of Local items. A\n    <strong>\n     Delimiter\n    </strong>\n    with a value of 1 indicates the beginning of a group, while 0 indicates the end of the group. This item is useful for organizing multiple Local items into meaningful groups.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Reserved (101011nn to 111110nn)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    These values are reserved for future use and are not currently defined in the HID specification. They are placeholders for potential extensions or changes to the HID protocol.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Example Usage of Local Items\n</h4>\n<p>\n When working with multi-byte reports, different\n <strong>\n  Usage\n </strong>\n IDs can be applied to each byte. For example, in a 16-byte report:\n</p>\n<ul>\n<li>\n  The first byte may be assigned\n  <strong>\n   Usage (X)\n  </strong>\n</li>\n<li>\n  The second byte may be assigned\n  <strong>\n   Usage (Y)\n  </strong>\n</li>\n<li>\n  The remaining bytes may each have a\n  <strong>\n   vendor-defined Usage\n  </strong>\n  Each of these usages provides context to the receiving system, indicating what each byte represents, whether it's for a button press, a joystick movement, or another control.\n </li>\n</ul>\n<h3>\n Summary\n</h3>\n<p>\n Local items help specify the detailed structure and context of data in HID reports, from identifying controls with\n <strong>\n  Usage\n </strong>\n IDs to linking body parts with\n <strong>\n  Designators\n </strong>\n and string associations. These items are essential for organizing and interpreting the data within a HID report and ensuring that the data is properly mapped to the corresponding control functions.\n</p>\n"}, "Page 395": {"response": "<h3>\n Understanding Usage, Designator, and String Indices in HID Reports\n</h3>\n<p>\n In HID reports,\n <strong>\n  Usage Minimum\n </strong>\n and\n <strong>\n  Usage Maximum\n </strong>\n are used to assign a series of\n <strong>\n  Usage IDs\n </strong>\n to elements within an array or bitmap. These elements represent the states or functions of controls, such as buttons, and help define the relationship between the data in the report and the controls it represents.\n</p>\n<h4>\n Usage Minimum and Maximum\n</h4>\n<p>\n<strong>\n  Usage Minimum\n </strong>\n and\n <strong>\n  Usage Maximum\n </strong>\n help group\n <strong>\n  Usage IDs\n </strong>\n that represent elements in a report. For example, in a report that tracks the states of multiple buttons, these items define which\n <strong>\n  Usage IDs\n </strong>\n are associated with each button.\n</p>\n<p>\n For instance, consider a report that monitors the state (0 or 1) of three buttons:\n</p>\n<ul>\n<li>\n  The first button has a\n  <strong>\n   Usage ID\n  </strong>\n  of 1\n </li>\n<li>\n  The second button has a\n  <strong>\n   Usage ID\n  </strong>\n  of 2\n </li>\n<li>\n  The third button has a\n  <strong>\n   Usage ID\n  </strong>\n  of 3\n </li>\n</ul>\n<p>\n This setup could be represented by the following report descriptor:\n</p>\n<ul>\n<li>\n<strong>\n   Usage Page (Button Page)\n  </strong>\n</li>\n<li>\n<strong>\n   Logical Minimum (0)\n  </strong>\n  : Defines the lowest value the buttons can have (e.g., not pressed).\n </li>\n<li>\n<strong>\n   Logical Maximum (1)\n  </strong>\n  : Defines the highest value (e.g., pressed).\n </li>\n<li>\n<strong>\n   Usage Minimum (1)\n  </strong>\n  : The first button's\n  <strong>\n   Usage ID\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Usage Maximum (3)\n  </strong>\n  : The third button's\n  <strong>\n   Usage ID\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Report Count (3)\n  </strong>\n  : Indicates three fields for the report (one for each button).\n </li>\n<li>\n<strong>\n   Report Size (1)\n  </strong>\n  : Each field is 1 bit in size.\n </li>\n<li>\n<strong>\n   Input (Data, Variable, Absolute)\n  </strong>\n  : Specifies that this is an input report where the data can vary and is absolute (no relative motion).\n </li>\n</ul>\n<h4>\n Designator Index, Minimum, and Maximum\n</h4>\n<p>\n For devices that require physical descriptors,\n <strong>\n  Designator Index\n </strong>\n is used to link a\n <strong>\n  Designator value\n </strong>\n to a body part or physical feature. For example, a device might specify which body part is used to operate a control (like a hand or foot).\n</p>\n<ul>\n<li>\n<strong>\n   Designator Index\n  </strong>\n  : Points to a specific body part related to a control.\n </li>\n<li>\n<strong>\n   Designator Minimum and Designator Maximum\n  </strong>\n  : These items assign\n  <strong>\n   Designator Indexes\n  </strong>\n  to a range of elements in an array or bitmap. For example, one could use these to specify that multiple body parts (hand, foot) are used to control several buttons or sliders in a report.\n </li>\n</ul>\n<h4>\n String Index, Minimum, and Maximum\n</h4>\n<p>\n A\n <strong>\n  String Index\n </strong>\n links a string (such as a name or description) to a control or item. The string data, as explained in Chapter 4, could be for identifying the device, its manufacturer, or its serial number.\n</p>\n<ul>\n<li>\n<strong>\n   String Index\n  </strong>\n  : This item assigns a specific string to an item or control. It allows the receiver to map string data to the appropriate control.\n </li>\n<li>\n<strong>\n   String Minimum and String Maximum\n  </strong>\n  : When a report has multiple string indexes for elements in an array or bitmap, these items assign a sequence of string indexes to the corresponding control elements. They help organize the strings applied to the control array.\n </li>\n</ul>\n<h4>\n Delimiter\n</h4>\n<p>\n A\n <strong>\n  Delimiter\n </strong>\n item is used to mark the start (1) or end (0) of a set of local items. This allows a more flexible and organized structure in HID reports. It is especially useful for defining alternate usages of a control, as different applications may interpret the same physical control in different ways.\n</p>\n<p>\n For example, a button could have:\n</p>\n<ul>\n<li>\n  A\n  <strong>\n   generic\n  </strong>\n  usage (e.g., Button 1).\n </li>\n<li>\n  A\n  <strong>\n   specific\n  </strong>\n  usage (e.g., \"Send\" or \"Quit\").\n </li>\n</ul>\n<p>\n By using a\n <strong>\n  Delimiter\n </strong>\n , a device can have multiple interpretations of the same physical button, allowing applications to adapt to different needs and functionalities.\n</p>\n<h3>\n Summary\n</h3>\n<p>\n<strong>\n  Usage Minimum\n </strong>\n and\n <strong>\n  Usage Maximum\n </strong>\n help define the range of\n <strong>\n  Usage IDs\n </strong>\n in a report, while\n <strong>\n  Designator\n </strong>\n and\n <strong>\n  String Indices\n </strong>\n link controls to body parts or strings, respectively. The\n <strong>\n  Delimiter\n </strong>\n item adds flexibility by enabling multiple usages for a single control. These Local items work together to structure and define the functionality and data mapping of controls in a HID report.\n</p>\n"}, "Page 396": {"response": "<h3>\n Physical Descriptors and Padding in HID Reports\n</h3>\n<h4>\n Physical Descriptors\n</h4>\n<p>\n A\n <strong>\n  physical descriptor\n </strong>\n in Human Interface Devices (HIDs) specifies which part of the body is intended to activate a particular control. For instance, each finger could be assigned to a separate control. These descriptors provide the physical mapping of the user's interactions with the device.\n</p>\n<p>\n<strong>\n  Physical descriptors\n </strong>\n are grouped together into a set, which typically consists of a header followed by one or more physical descriptors.\n</p>\n<p>\n To retrieve a physical descriptor set, the host sends a\n <strong>\n  Get_Descriptor request\n </strong>\n with specific values in the\n <code>\n  wValue\n </code>\n field:\n</p>\n<ul>\n<li>\n  The high byte is set to 23h.\n </li>\n<li>\n  The low byte indicates the number of the descriptor set.\n </li>\n</ul>\n<p>\n It is important to note that\n <strong>\n  physical descriptors are optional\n </strong>\n . For most devices, these descriptors either don\u2019t apply or the information they could provide is not practically used. However, for devices that require them, the\n <strong>\n  HID specification\n </strong>\n provides more detailed guidelines on their use.\n</p>\n<h4>\n Padding\n</h4>\n<p>\n In some cases, a report descriptor may need to be padded to ensure its size is a multiple of 8 bits. Padding can be achieved by adding a\n <strong>\n  Main item\n </strong>\n with no assigned\n <strong>\n  Usage\n </strong>\n , effectively filling up the space without altering the actual functionality of the report.\n</p>\n<p>\n For example, consider a\n <strong>\n  keyboard\u2019s report descriptor\n </strong>\n that specifies an Output report transferring five bits of data and includes three bits of padding. This ensures the total size of the report is aligned to an 8-bit boundary:\n</p>\n<ul>\n<li>\n<strong>\n   Usage Page (LEDs)\n  </strong>\n  : Defines the type of controls (in this case, LEDs).\n </li>\n<li>\n<strong>\n   Usage Minimum (1)\n  </strong>\n  and\n  <strong>\n   Usage Maximum (5)\n  </strong>\n  : Define the range of usages (the first to the fifth LED).\n </li>\n<li>\n<strong>\n   Output (Data, Variable, Absolute)\n  </strong>\n  : Specifies an Output report that includes data for five 1-bit LEDs.\n </li>\n<li>\n<strong>\n   Report Count (1)\n  </strong>\n  : Indicates that the report contains one set of data for the LEDs.\n </li>\n<li>\n<strong>\n   Report Size (3)\n  </strong>\n  : Specifies that the report has 3 bits dedicated to the LED data.\n </li>\n<li>\n<strong>\n   Output (Constant)\n  </strong>\n  : Specifies the additional 3 bits for padding, which do not hold any active data.\n </li>\n</ul>\n<p>\n This padding ensures that the descriptor's length is aligned with the expected data size, making it easier for the system to handle the report efficiently.\n</p>\n"}, "Page 397": {"response": "<p>\n It seems like the text you intended to include isn't visible. Could you please provide the content you'd like me to restate or explain? I'd be happy to help!\n</p>\n"}, "Page 398": {"response": "<h3>\n Human Interface Devices: Host Application\n</h3>\n<p>\n This section explains how applications written in Visual Basic .NET and Visual C++ .NET can communicate with HID-class devices using a handle obtained from previous operations discussed in Chapter 10.\n</p>\n<h4>\n HID API Functions\n</h4>\n<p>\n The Windows API provides a set of functions that allow applications to interact with HID-class devices. These functions can be used to learn about a device's reports and send or receive report data. The Windows Driver Development Kit (DDK) provides documentation for these functions.\n</p>\n<p>\n In the context of the HID API, each report item is categorized as either a \"button\" or a \"value.\" A\n <strong>\n  button\n </strong>\n is a control or data item that represents a discrete binary value (such as ON or OFF), while a\n <strong>\n  value\n </strong>\n represents a range of possible values. Buttons, therefore, are typically simple controls with just two states, whereas values can have a wider range of states or measurements.\n</p>\n"}, "Page 399": {"response": "<h3>\n Human Interface Devices: Host Application (Continued)\n</h3>\n<p>\n This section explains how applications in Visual Basic .NET and Visual C++ .NET can use the Windows HID API to interact with HID-class devices. It also covers how to request information about a device\u2019s reports and send or receive report data.\n</p>\n<h4>\n Button vs. Value\n</h4>\n<p>\n In the HID API, report items are categorized as either\n <strong>\n  buttons\n </strong>\n or\n <strong>\n  values\n </strong>\n . Buttons are simple binary controls, such as ON (1) or OFF (0), and are represented by unique Usage IDs in specific Usage Pages like Buttons, Keyboard, or LED. On the other hand,\n <strong>\n  values\n </strong>\n can represent a range of states or measurements. Any report item that isn\u2019t a button is classified as a value.\n</p>\n<h4>\n HID API Support in Windows\n</h4>\n<p>\n The HID API was first introduced in\n <strong>\n  Windows 98 Gold\n </strong>\n and was expanded in later versions like\n <strong>\n  Windows 98 SE\n </strong>\n ,\n <strong>\n  Windows 2000\n </strong>\n ,\n <strong>\n  Windows Me\n </strong>\n , and\n <strong>\n  Windows XP\n </strong>\n . As new versions of Windows were released, additional HID functionality was added, with some functions being supported only in newer versions of Windows.\n</p>\n<h4>\n Requesting Information about the HID\n</h4>\n<p>\n The\n <strong>\n  HidD_GetPreparsedData\n </strong>\n function is used to request a pointer to a buffer that contains information about a device\u2019s reports. This data can then be used by other functions like\n <strong>\n  HidP_GetCaps\n </strong>\n to retrieve a\n <strong>\n  HIDP_CAPS\n </strong>\n structure, which provides detailed information about the device\u2019s supported report types and the data they contain. For example, this structure may include the number of\n <strong>\n  HIDP_BUTTON_CAPS\n </strong>\n structures, which provide information about buttons or sets of buttons on the device.\n</p>\n<p>\n Applications can also use functions to retrieve strings related to the HID, as listed in\n <strong>\n  Table 13-2\n </strong>\n .\n</p>\n<h4>\n Sending and Receiving Reports\n</h4>\n<p>\n The HID API also includes functions to send and receive reports between the application and the device, as shown in\n <strong>\n  Table 13-3\n </strong>\n . The\n <strong>\n  HID driver\n </strong>\n in Windows causes the host controller to request\n <strong>\n  Input reports\n </strong>\n from the device periodically. These reports are stored in a buffer, and applications can use\n <strong>\n  ReadFile\n </strong>\n to retrieve one or more reports from the buffer. If the buffer is empty,\n <strong>\n  ReadFile\n </strong>\n will wait until a report is available. It's important to note that\n <strong>\n  ReadFile\n </strong>\n does not trigger the device to send a report; it simply reads reports that have already been requested by the driver.\n</p>\n<p>\n To send an\n <strong>\n  Output report\n </strong>\n to the device, applications use\n <strong>\n  WriteFile\n </strong>\n . Depending on the configuration,\n <strong>\n  WriteFile\n </strong>\n may use an interrupt transfer if the device has an interrupt OUT endpoint and the operating system is a version later than\n <strong>\n  Windows 98 Gold\n </strong>\n . If this is not the case,\n <strong>\n  WriteFile\n </strong>\n uses a control transfer instead.\n</p>\n"}, "Page 400": {"response": "<h3>\n API Functions for Retrieving HID Information\n</h3>\n<p>\n Table 13-1 lists the\n <strong>\n  API functions\n </strong>\n available to applications for retrieving information about a HID device and its reports. These functions help the application understand the structure of the device\u2019s reports and interact with them effectively.\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     API Function\n    </strong>\n</th>\n<th>\n<strong>\n     Purpose\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     HidD_FreePreparsedData\n    </strong>\n</td>\n<td>\n    Frees the resources used by\n    <code>\n     HidD_GetPreparsedData\n    </code>\n    .\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidD_GetPhysicalDescriptor\n    </strong>\n</td>\n<td>\n    Retrieves a physical descriptor from the HID.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidD_GetPreparsedData\n    </strong>\n</td>\n<td>\n    Returns a handle to a buffer containing information about the HID\u2019s reports.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_GetButtonCaps\n    </strong>\n</td>\n<td>\n    Retrieves an array containing information about the buttons in a top-level collection for a specific report type.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_GetCaps\n    </strong>\n</td>\n<td>\n    Retrieves a structure that describes the reports supported by a HID.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_GetExtendedAttributes\n    </strong>\n</td>\n<td>\n    Retrieves a structure with information about Global items that the HID parser did not recognize.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_GetLinkCollectionNodes\n    </strong>\n</td>\n<td>\n    Retrieves a structure with information about collections within a top-level collection.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_GetSpecificButtonCaps\n    </strong>\n</td>\n<td>\n    Similar to\n    <code>\n     HidP_GetButtonCaps\n    </code>\n    , but allows specifying a Usage Page, Usage ID, and link collection.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_GetSpecificValueCaps\n    </strong>\n</td>\n<td>\n    Similar to\n    <code>\n     HidP_GetValueCaps\n    </code>\n    , but allows specifying a Usage Page, Usage ID, and link collection.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_GetValueCaps\n    </strong>\n</td>\n<td>\n    Retrieves an array with information about the values in a top-level collection for a specified report type.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_IsSameUsageAndPage\n    </strong>\n</td>\n<td>\n    Determines if two Usages (Usage Page and Usage ID) are identical.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_MaxDataListLength\n    </strong>\n</td>\n<td>\n    Retrieves the maximum number of\n    <code>\n     HIDP_DATA\n    </code>\n    structures that\n    <code>\n     HidP_GetData\n    </code>\n    can return for a specific report type and top-level collection.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_MaxUsageListLength\n    </strong>\n</td>\n<td>\n    Retrieves the maximum number of Usage IDs that\n    <code>\n     HidP_GetUsages\n    </code>\n    can return for a specific report type and top-level collection.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_TranslateUsagesToI8042ScanCodes\n    </strong>\n</td>\n<td>\n    Maps Usages on the\n    <code>\n     HID_USAGE_PAGE_KEYBOARD\n    </code>\n    Usage Page to PS/2 scan codes.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_UsageAndPageListDifference\n    </strong>\n</td>\n<td>\n    Retrieves the differences between two arrays of Usages (Usage Page and Usage ID).\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_UsageListDifference\n    </strong>\n</td>\n<td>\n    Retrieves the differences between two arrays of Usage IDs.\n   </td>\n</tr>\n</tbody>\n</table>\n<h4>\n Notes:\n</h4>\n<ul>\n<li>\n<strong>\n   Windows 98 Gold\n  </strong>\n  does not support the functions marked with a note in the table. These functions are available in later versions of Windows.\n </li>\n</ul>\n"}, "Page 401": {"response": "<h3>\n Sending and Receiving Reports with HID API\n</h3>\n<p>\n In order to send and receive reports to and from HID devices, the\n <strong>\n  Windows HID API\n </strong>\n provides various functions that work through\n <strong>\n  control transfers\n </strong>\n and\n <strong>\n  interrupt transfers\n </strong>\n . These functions enable applications to retrieve input reports, send output reports, and interact with feature reports.\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Sending and Receiving Reports:\n   </strong>\n</p>\n<ul>\n<li>\n<code>\n     WriteFile\n    </code>\n    is used to send an Output report. It utilizes interrupt transfers if the device supports it, but falls back on control transfers for older systems. If the device doesn't respond or the transfer times out, an error code will be returned.\n   </li>\n<li>\n<code>\n     HidD_GetInputReport\n    </code>\n    allows an application to request an Input report via control transfer using a Get_Report request. This bypasses the Input report buffer, directly retrieving the data from the device.\n   </li>\n<li>\n<code>\n     HidD_SetOutputReport\n    </code>\n    allows sending an Output report through a Set_Report request, even if interrupt transfers are available.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Feature Reports:\n   </strong>\n</p>\n<ul>\n<li>\n    For\n    <strong>\n     Feature reports\n    </strong>\n    ,\n    <code>\n     HidD_GetFeature\n    </code>\n    and\n    <code>\n     HidD_SetFeature\n    </code>\n    allow retrieval and sending of feature data using control transfers and the Get_Report and Set_Report requests, respectively. Note that\n    <strong>\n     HidD_SetFeature\n    </strong>\n    is different from the standard USB\n    <strong>\n     Set_Feature\n    </strong>\n    request.\n   </li>\n</ul>\n<p>\n   All functions using control transfers will return an error code in case of failure or timeout.\n  </p>\n</li>\n</ol>\n<hr/>\n<h3>\n Extracting and Storing Report Data\n</h3>\n<p>\n Once a report is received, applications can either:\n</p>\n<ul>\n<li>\n  Use the raw data directly from the buffer.\n </li>\n<li>\n  Use API functions to extract specific button or value data.\n </li>\n</ul>\n<p>\n When sending data, applications can either:\n</p>\n<ul>\n<li>\n  Directly write data into the report's buffer.\n </li>\n<li>\n  Use API functions to format and store data into the buffer before sending it.\n </li>\n</ul>\n<h3>\n API Functions for Handling Report Data\n</h3>\n<p>\n Table 13-4 lists functions that help applications extract information from received reports and store data in reports to be sent.\n</p>\n<hr/>\n<h3>\n Retrieving Strings from HID Devices\n</h3>\n<p>\n HID devices can store strings such as manufacturer names, product names, and serial numbers. Applications can retrieve these strings using specific API functions.\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     API Function\n    </strong>\n</th>\n<th>\n<strong>\n     Purpose\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     HidD_GetIndexedString\n    </strong>\n</td>\n<td>\n    Retrieves a specified string from the HID device.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidD_GetManufacturerString\n    </strong>\n</td>\n<td>\n    Retrieves the manufacturer string from the device.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidD_GetProductString\n    </strong>\n</td>\n<td>\n    Retrieves the product string.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidD_GetSerialNumberString\n    </strong>\n</td>\n<td>\n    Retrieves the serial number string.\n   </td>\n</tr>\n</tbody>\n</table>\n<h4>\n Notes:\n</h4>\n<ul>\n<li>\n<strong>\n   Windows 98 Gold\n  </strong>\n  does not support these functions marked with a note in the table. These functions are supported in later versions of Windows.\n </li>\n</ul>\n"}, "Page 402": {"response": "<h3>\n Managing and Using HID Report Data\n</h3>\n<p>\n Applications can use various HID API functions to manage and manipulate HID report data, particularly for interacting with buttons and values in the reports.\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Handling Button Data:\n   </strong>\n</p>\n<ul>\n<li>\n    To check which buttons have been pressed, the\n    <code>\n     HidP_GetButtons\n    </code>\n    function can be called. This function returns a buffer that contains the Usage IDs of all buttons set to ON within a specified\n    <strong>\n     Usage Page\n    </strong>\n    .\n   </li>\n<li>\n    If an application wants to modify button states in a report, it can use:\n    <ul>\n<li>\n<code>\n       HidP_SetButtons\n      </code>\n      to set buttons to ON.\n     </li>\n<li>\n<code>\n       HidP_UnsetButtons\n      </code>\n      to clear (set to OFF) buttons.\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Managing Values:\n   </strong>\n</p>\n<ul>\n<li>\n    To retrieve or set specific values in a report, applications use:\n    <ul>\n<li>\n<code>\n       HidP_GetUsageValue\n      </code>\n      to get the value of a particular Usage.\n     </li>\n<li>\n<code>\n       HidP_SetUsageValue\n      </code>\n      to set a specific value in a report.\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<hr/>\n<h3>\n Managing HID Communications\n</h3>\n<p>\n Several HID API functions help in managing communication with HID devices, including adjusting input buffers, flushing reports, and identifying devices.\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Managing Input Buffers:\n   </strong>\n</p>\n<ul>\n<li>\n<code>\n     HidD_SetNumInputBuffers\n    </code>\n    allows an application to adjust the size of the buffer that stores incoming reports. Increasing the buffer size can prevent data loss when the application is busy and cannot immediately process incoming reports.\n   </li>\n<li>\n<code>\n     HidD_FlushQueue\n    </code>\n    clears the Input report buffer by deleting any reports currently stored.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Identifying HID Devices:\n   </strong>\n</p>\n<ul>\n<li>\n    To identify and retrieve information about a HID device, applications can use various functions from the HID API. For example,\n    <code>\n     HidD_GetHidGuid\n    </code>\n    , as mentioned in Chapter 10, helps in obtaining the\n    <strong>\n     device interface GUID\n    </strong>\n    for the HID class, which is crucial for further communication with the device.\n   </li>\n</ul>\n</li>\n</ol>\n<hr/>\n<h3>\n Sending and Receiving Reports\n</h3>\n<p>\n Applications use several API functions to send and receive reports to/from HID devices. These functions work through different transfer types, such as\n <strong>\n  control transfers\n </strong>\n and\n <strong>\n  interrupt transfers\n </strong>\n .\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     API Function\n    </strong>\n</th>\n<th>\n<strong>\n     Purpose\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     HidD_GetFeature\n    </strong>\n</td>\n<td>\n    Read a\n    <strong>\n     Feature report\n    </strong>\n    .\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidD_GetInputReport\n    </strong>\n</td>\n<td>\n    Read an\n    <strong>\n     Input report\n    </strong>\n    via control transfer.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidD_SetFeature\n    </strong>\n</td>\n<td>\n    Send a\n    <strong>\n     Feature report\n    </strong>\n    .\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidD_SetOutputReport\n    </strong>\n</td>\n<td>\n    Send an\n    <strong>\n     Output report\n    </strong>\n    using control transfer.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     ReadFile\n    </strong>\n</td>\n<td>\n    Read an\n    <strong>\n     Input report\n    </strong>\n    obtained via interrupt transfer.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     WriteFile\n    </strong>\n</td>\n<td>\n    Send an\n    <strong>\n     Output report\n    </strong>\n    . Will use an interrupt transfer if available, otherwise uses a control transfer.\n   </td>\n</tr>\n</tbody>\n</table>\n<h4>\n Note:\n</h4>\n<ul>\n<li>\n<strong>\n   Windows XP\n  </strong>\n  or later is required for certain functions like\n  <code>\n   HidD_GetInputReport\n  </code>\n  and\n  <code>\n   HidD_SetOutputReport\n  </code>\n  .\n </li>\n</ul>\n<p>\n These functions enable interaction with the HID device, either by reading its input or writing output data, facilitating effective communication between the host application and the HID device.\n</p>\n"}, "Page 403": {"response": "<h3>\n Identifying HID Devices and Communication Methods\n</h3>\n<p>\n To effectively communicate with HID devices, applications must identify the correct device based on specific identifiers or Usage. This allows applications to target the correct device for sending and receiving reports.\n</p>\n<ol>\n<li>\n<strong>\n   Identifying Devices by Vendor ID and Product ID:\n  </strong>\n<ul>\n<li>\n    For vendor-specific devices, particularly those without standard Usages, the application can identify the device by its\n    <strong>\n     Vendor ID\n    </strong>\n    and\n    <strong>\n     Product ID\n    </strong>\n    . These IDs are unique identifiers assigned to each manufacturer and their products.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Identifying Devices by Usage:\n  </strong>\n<ul>\n<li>\n    Alternatively, applications can search for a device based on a specific\n    <strong>\n     Usage\n    </strong>\n    . For example, if an application is looking for a game controller, it can search for devices with a Usage that corresponds to a game controller.\n   </li>\n</ul>\n</li>\n</ol>\n<hr/>\n<h3>\n Extracting and Storing Report Data\n</h3>\n<p>\n Applications can interact with the data in HID reports by using specific API functions designed to extract or store information from reports. These functions allow applications to retrieve information about button states and values, as well as modify the data in reports before sending it back to the HID.\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     API Function\n    </strong>\n</th>\n<th>\n<strong>\n     Purpose\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     HidP_GetButtons\n    </strong>\n</td>\n<td>\n    Same as\n    <strong>\n     HidP_GetUsages\n    </strong>\n    , retrieves button data.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_GetButtonsEx\n    </strong>\n</td>\n<td>\n    Same as\n    <strong>\n     HidP_GetUsagesEx\n    </strong>\n    , retrieves button data.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_GetData\n    </strong>\n</td>\n<td>\n    Retrieves an array with button states or value data for controls in the report.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_GetScaledUsageValue\n    </strong>\n</td>\n<td>\n    Retrieves a signed and scaled value from the report.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_GetUsages\n    </strong>\n</td>\n<td>\n    Retrieves a list of buttons that are ON in a specified Usage Page.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_GetUsagesEx\n    </strong>\n</td>\n<td>\n    Retrieves a list of all buttons that are ON (1) in the report.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_GetUsageValue\n    </strong>\n</td>\n<td>\n    Retrieves the data for a specific value in the report.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_GetUsageValueArray\n    </strong>\n</td>\n<td>\n    Retrieves data for an array of values with the same Usage ID.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_InitializeReportForID\n    </strong>\n</td>\n<td>\n    Initializes the report by setting all buttons to OFF (0) and all values to null or zero.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_SetButtons\n    </strong>\n</td>\n<td>\n    Same as\n    <strong>\n     HidP_SetUsages\n    </strong>\n    , sets button states in the report.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_SetData\n    </strong>\n</td>\n<td>\n    Sets button states or data for values in a report.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_SetScaledUsageValue\n    </strong>\n</td>\n<td>\n    Converts a physical number to a logical value and sets it in the report.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_SetUsages\n    </strong>\n</td>\n<td>\n    Sets buttons to ON (1) in the report.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_SetUsageValue\n    </strong>\n</td>\n<td>\n    Sets the data for a specified value in the report.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_SetUsageValueArray\n    </strong>\n</td>\n<td>\n    Sets the data for an array of values with the same Usage ID.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_UnsetButtons\n    </strong>\n</td>\n<td>\n    Same as\n    <strong>\n     HidP_UnsetUsages\n    </strong>\n    , sets buttons to OFF (0).\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidP_UnsetUsages\n    </strong>\n</td>\n<td>\n    Sets buttons to OFF (0) in the report.\n   </td>\n</tr>\n</tbody>\n</table>\n<p>\n These functions enable applications to both retrieve and modify report data, allowing them to accurately reflect the device's status or send new data for the device to act on.\n</p>\n"}, "Page 404": {"response": "<h3>\n Managing HID Communications and Identifying Devices\n</h3>\n<p>\n To manage communications with HID devices and retrieve device-specific information, applications can use various API functions. These functions help with managing buffers for reports, retrieving device identifiers, and interacting with the HID class driver.\n</p>\n<h4>\n Identifying Devices with\n <strong>\n  HidD_GetAttributes\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   HidD_GetAttributes\n  </strong>\n  retrieves device information such as the\n  <strong>\n   Vendor ID\n  </strong>\n  ,\n  <strong>\n   Product ID\n  </strong>\n  , and\n  <strong>\n   Version Number\n  </strong>\n  of a device. This function provides details about a connected HID device, which helps the application identify it.\n </li>\n<li>\n  The structure returned by this function is the\n  <strong>\n   HIDD_ATTRIBUTES\n  </strong>\n  structure, which contains:\n  <ul>\n<li>\n<strong>\n     VendorID\n    </strong>\n    : A unique identifier assigned to the device\u2019s manufacturer.\n   </li>\n<li>\n<strong>\n     ProductID\n    </strong>\n    : A unique identifier assigned to the specific product.\n   </li>\n<li>\n<strong>\n     VersionNumber\n    </strong>\n    : The version of the device's firmware or release number.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n<strong>\n  Structure Declaration (HIDD_ATTRIBUTES):\n </strong>\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n typedef\n struct\n _HIDD_ATTRIBUTES\n {\n  ULONG   Size;\n // Size of the structure\n USHORT  VendorID;\n // Vendor ID of the device\n USHORT  ProductID;\n // Product ID of the device\n USHORT  VersionNumber;\n // Version number of the device\n } HIDD_ATTRIBUTES, *PHIDD_ATTRIBUTES;\n</code>\n<p>\n<strong>\n  Function Declaration:\n </strong>\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n BOOLEAN\n HidD_GetAttributes\n (\n  IN HANDLE HidDeviceObject,\n // Handle to the HID device\n OUT PHIDD_ATTRIBUTES Attributes\n // Pointer to the attributes structure\n )\n ;\n</code>\n<hr/>\n<h4>\n Managing HID Communication Buffers\n</h4>\n<p>\n Applications can control how HID communication buffers are managed using the following API functions:\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     API Function\n    </strong>\n</th>\n<th>\n<strong>\n     Purpose\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     HidD_FlushQueue\n    </strong>\n</td>\n<td>\n    Deletes all Input reports stored in the buffer.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidD_GetHidGuid\n    </strong>\n</td>\n<td>\n    Retrieves the device interface GUID for HID-class devices, which helps identify the device class.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidD_GetNumInputBuffers\n    </strong>\n</td>\n<td>\n    Retrieves the number of Input reports the HID's buffer can hold.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidD_SetNumInputBuffers\n    </strong>\n</td>\n<td>\n    Sets the number of Input reports the HID's buffer can hold.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     HidRegisterMinidriver\n    </strong>\n</td>\n<td>\n    Registers a HID mini-driver with the HID class driver during initialization (not available in Windows 98 Gold).\n   </td>\n</tr>\n</tbody>\n</table>\n<p>\n These functions allow applications to better manage the flow of data between the device and the application, particularly when dealing with multiple reports or a busy communication interface. For instance, the\n <strong>\n  HidD_SetNumInputBuffers\n </strong>\n function allows developers to adjust the buffer size, which is important for preventing data loss when multiple reports are being sent in quick succession.\n</p>\n"}, "Page 405": {"response": "<h3>\n Retrieving and Comparing Vendor and Product Information\n</h3>\n<p>\n When working with HID devices, applications may need to identify a specific device based on its\n <strong>\n  Vendor ID\n </strong>\n and\n <strong>\n  Product ID\n </strong>\n . Here\u2019s how you can retrieve and compare these values to ensure the correct device is being interacted with.\n</p>\n<h4>\n Retrieving Device Information in\n <strong>\n  Visual C++\n </strong>\n</h4>\n<p>\n To retrieve the\n <strong>\n  HIDD_ATTRIBUTES\n </strong>\n structure, which contains the\n <strong>\n  Vendor ID\n </strong>\n ,\n <strong>\n  Product ID\n </strong>\n , and\n <strong>\n  Version Number\n </strong>\n , you first call the\n <strong>\n  HidD_GetAttributes\n </strong>\n function. Here\u2019s how you would write the code in\n <strong>\n  Visual C++\n </strong>\n :\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n BOOLEAN Result;\nHIDD_ATTRIBUTES Attributes;\n // Set the Size member to the number of bytes in the structure.\n Attributes.Size =\n sizeof\n (Attributes);\n // Call HidD_GetAttributes to retrieve the device attributes.\n Result =\n HidD_GetAttributes\n (DeviceHandle, &amp;Attributes);\n // Compare the retrieved Vendor ID and Product ID with the desired ones.\n const\n unsigned\n int\n VendorID =\n 0x0925\n ;\n const\n unsigned\n int\n ProductID =\n 0x1234\n ;\n if\n (Attributes.VendorID == VendorID) {\n if\n (Attributes.ProductID == ProductID) {\n // The Vendor ID and Product ID match.\n }\n else\n {\n // The Product ID doesn't match, handle the mismatch.\n // Close the handle.\n }\n}\n else\n {\n // The Vendor ID doesn't match, handle the mismatch.\n // Close the handle.\n }\n</code>\n<ul>\n<li>\n<strong>\n   Attributes.Size\n  </strong>\n  : This is set to the size of the structure before calling the function.\n </li>\n<li>\n<strong>\n   HidD_GetAttributes\n  </strong>\n  : Retrieves the\n  <strong>\n   Vendor ID\n  </strong>\n  ,\n  <strong>\n   Product ID\n  </strong>\n  , and\n  <strong>\n   Version Number\n  </strong>\n  based on the device handle.\n </li>\n<li>\n  After retrieving these values, compare them against the known\n  <strong>\n   Vendor ID\n  </strong>\n  and\n  <strong>\n   Product ID\n  </strong>\n  . If they match, the application can proceed to interact with the device; otherwise, it will handle the mismatch by closing the device handle.\n </li>\n</ul>\n<h4>\n Retrieving Device Information in\n <strong>\n  Visual Basic\n </strong>\n</h4>\n<p>\n In\n <strong>\n  Visual Basic\n </strong>\n , the\n <strong>\n  HIDD_ATTRIBUTES\n </strong>\n structure is defined as follows, allowing you to retrieve the same information:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;StructLayout(LayoutKind.Sequential)&gt; _\n Public\n Structure\n HIDD_ATTRIBUTES\n Dim\n Size\n As\n Integer\n Dim\n VendorID\n As\n Short\n Dim\n ProductID\n As\n Short\n Dim\n VersionNumber\n As\n Short\n End\n Structure\n</code>\n<ul>\n<li>\n<strong>\n   Size\n  </strong>\n  : The size of the structure in bytes.\n </li>\n<li>\n<strong>\n   VendorID\n  </strong>\n  ,\n  <strong>\n   ProductID\n  </strong>\n  , and\n  <strong>\n   VersionNumber\n  </strong>\n  are the same fields as in the C++ version, used to store the device-specific identifiers.\n </li>\n</ul>\n<p>\n This structure is used similarly to the\n <strong>\n  Visual C++\n </strong>\n example. The retrieved\n <strong>\n  Vendor ID\n </strong>\n and\n <strong>\n  Product ID\n </strong>\n are compared to predefined values to identify the correct device.\n</p>\n"}, "Page 406": {"response": "<h3>\n Retrieving Device Attributes in\n <strong>\n  Visual Basic\n </strong>\n</h3>\n<p>\n In\n <strong>\n  Visual Basic\n </strong>\n , you can use the\n <strong>\n  HidD_GetAttributes\n </strong>\n function to retrieve device information, including the\n <strong>\n  Vendor ID\n </strong>\n and\n <strong>\n  Product ID\n </strong>\n , to identify whether the correct device is connected. Below is how to implement this functionality.\n</p>\n<h4>\n Declaring the Function\n</h4>\n<p>\n To use the\n <strong>\n  HidD_GetAttributes\n </strong>\n function, you first declare it with\n <strong>\n  DllImport\n </strong>\n to import it from the\n <code>\n  hid.dll\n </code>\n library:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;DllImport(\n \"hid.dll\"\n )&gt; _\n Function\n HidD_GetAttributes _\n    (\n ByVal\n HidDeviceObject\n As\n Integer\n , _\n ByRef\n Attributes\n As\n HIDD_ATTRIBUTES) _\n As\n Boolean\n End\n Function\n</code>\n<ul>\n<li>\n  This declaration allows you to call the\n  <strong>\n   HidD_GetAttributes\n  </strong>\n  function, passing the device handle and receiving the\n  <strong>\n   HIDD_ATTRIBUTES\n  </strong>\n  structure.\n </li>\n</ul>\n<h4>\n Retrieving the Device Attributes\n</h4>\n<p>\n Next, you can retrieve the device's\n <strong>\n  Vendor ID\n </strong>\n and\n <strong>\n  Product ID\n </strong>\n by setting up the\n <strong>\n  HIDD_ATTRIBUTES\n </strong>\n structure and calling\n <strong>\n  HidD_GetAttributes\n </strong>\n :\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Dim\n DeviceAttributes\n As\n HIDD_ATTRIBUTES\n Dim\n MyVendorID\n As\n Short\n Dim\n MyProductID\n As\n Short\n Dim\n Result\n As\n Boolean\n ' Set the Size property of DeviceAttributes to the number of bytes in the structure.\n DeviceAttributes.Size = Marshal.SizeOf(myHID.DeviceAttributes)\n ' Call the function to retrieve device attributes.\n Result = HidD_GetAttributes(DeviceHandle, DeviceAttributes)\n</code>\n<ul>\n<li>\n<strong>\n   DeviceAttributes.Size\n  </strong>\n  : Before calling the function, you set the\n  <code>\n   Size\n  </code>\n  property to the number of bytes in the structure using\n  <strong>\n   Marshal.SizeOf\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Result\n  </strong>\n  : This variable holds the return value from\n  <strong>\n   HidD_GetAttributes\n  </strong>\n  , which indicates whether the function was successful.\n </li>\n</ul>\n<h4>\n Comparing the Vendor ID and Product ID\n</h4>\n<p>\n Once you have the device attributes, you can compare the\n <strong>\n  Vendor ID\n </strong>\n and\n <strong>\n  Product ID\n </strong>\n with predefined values:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n MyVendorID =\n &amp;h0925\n MyProductID =\n &amp;h1234\n If\n (DeviceAttributes.VendorID = MyVendorID)\n And\n _\n    (DeviceAttributes.ProductID = MyProductID)\n Then\n Debug.WriteLine(\n \"My device detected\"\n )\n Else\n Debug.WriteLine(\n \"Not my device\"\n )\n ' Close the handle.\n End\n If\n</code>\n<ul>\n<li>\n<strong>\n   MyVendorID\n  </strong>\n  and\n  <strong>\n   MyProductID\n  </strong>\n  are the values you want to match. The\n  <strong>\n   HIDD_ATTRIBUTES\n  </strong>\n  structure contains the\n  <strong>\n   VendorID\n  </strong>\n  and\n  <strong>\n   ProductID\n  </strong>\n  fields.\n </li>\n<li>\n  If the\n  <strong>\n   Vendor ID\n  </strong>\n  and\n  <strong>\n   Product ID\n  </strong>\n  match the desired values, the application will indicate that the correct device is detected; otherwise, it will log that it\u2019s not the expected device and close the handle.\n </li>\n</ul>\n"}, "Page 407": {"response": "<h3>\n Retrieving Device Capabilities with\n <code>\n  HidD_GetPreparsedData\n </code>\n</h3>\n<p>\n To gather more information about a device's capabilities, you can use the\n <strong>\n  HidD_GetPreparsedData\n </strong>\n function. This function provides a pointer to a buffer containing detailed information about the device's capabilities, such as supported report formats, types, and other relevant data.\n</p>\n<h4>\n Visual C++ Example\n</h4>\n<p>\n In\n <strong>\n  Visual C++\n </strong>\n , the declaration for\n <strong>\n  HidD_GetPreparsedData\n </strong>\n is as follows:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n BOOLEAN\n HidD_GetPreparsedData\n (\n    IN HANDLE HidDeviceObject,\n    OUT PHIDP_PREPARSED_DATA *PreparsedData\n)\n ;\n</code>\n<ul>\n<li>\n<strong>\n   HidDeviceObject\n  </strong>\n  : This is the device handle, which is obtained using\n  <strong>\n   CreateFile\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   PreparsedData\n  </strong>\n  : This is a pointer to the buffer where the device's capabilities will be stored.\n </li>\n</ul>\n<p>\n To call this function and retrieve the device's capabilities, you use the following code:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n PHIDP_PREPARSED_DATA PreparsedData;\n HidD_GetPreparsedData\n (DeviceHandle, &amp;PreparsedData);\n</code>\n<ul>\n<li>\n<strong>\n   DeviceHandle\n  </strong>\n  : This is the handle of the device you are interested in. It was previously obtained through\n  <strong>\n   CreateFile\n  </strong>\n  or another means of accessing the device.\n </li>\n<li>\n<strong>\n   PreparsedData\n  </strong>\n  : After calling the function, this pointer holds the information about the device's report descriptors, such as the types of reports the device can handle.\n </li>\n</ul>\n<h4>\n Important Notes\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Setting the Size\n   </strong>\n   : Before calling\n   <strong>\n    HidD_GetAttributes\n   </strong>\n   (which retrieves device attributes), you need to ensure that the\n   <strong>\n    Size\n   </strong>\n   member of the\n   <strong>\n    DeviceAttributes\n   </strong>\n   structure is correctly set to the size of the structure.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Validating the Device\n   </strong>\n   : Once you get the device attributes (like\n   <strong>\n    Vendor ID\n   </strong>\n   and\n   <strong>\n    Product ID\n   </strong>\n   ), you can compare them with expected values. If they do not match, close the device handle using the\n   <strong>\n    CloseHandle\n   </strong>\n   function and continue searching for other devices.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Using the Capabilities Data\n   </strong>\n   : The information retrieved through\n   <strong>\n    HidD_GetPreparsedData\n   </strong>\n   gives you a pointer to the\n   <strong>\n    PHIDP_PREPARSED_DATA\n   </strong>\n   structure. This structure contains details about the device's report descriptors, which are crucial for understanding how data is communicated with the device (e.g., button states, value types).\n  </p>\n</li>\n</ol>\n"}, "Page 408": {"response": "<h3>\n Human Interface Devices: Host Application\n</h3>\n<h4>\n Function Declaration and Usage\n</h4>\n<p>\n To interact with HID devices using Visual Basic, you can use the\n <code>\n  HidD_GetPreparsedData\n </code>\n function from\n <code>\n  hid.dll\n </code>\n . Here's the declaration for this function:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;DllImport(\n \"hid.dll\"\n )&gt; _\n Function\n HidD_GetPreparsedData _\n    (\n ByVal\n HidDeviceObject\n As\n Integer\n , _\n ByRef\n PreparsedData\n As\n IntPtr) _\n As\n Boolean\n End\n Function\n</code>\n<p>\n To call this function, you use the following code:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Dim\n PreparsedData\n As\n IntPtr\nHidD_GetPreparsedData _\n    (DeviceHandle, _\n    PreparsedData)\n</code>\n<ul>\n<li>\n<strong>\n   DeviceHandle\n  </strong>\n  : This is the handle returned by the\n  <code>\n   CreateFile\n  </code>\n  function when accessing the HID device.\n </li>\n<li>\n<strong>\n   PreparsedData\n  </strong>\n  : This is a pointer to the buffer that will contain data related to the device's capabilities. The application does not need to directly interact with the data inside the buffer but just passes the pointer to other API functions.\n </li>\n</ul>\n<p>\n Once you are done with the\n <code>\n  PreparsedData\n </code>\n buffer, it is crucial to release system resources by calling\n <code>\n  HidD_FreePreparsedData\n </code>\n .\n</p>\n<h4>\n Getting the Device\u2019s Capabilities\n</h4>\n<p>\n To retrieve detailed information about the device, the\n <code>\n  HidP_GetCaps\n </code>\n function provides a pointer to a structure that contains key capabilities of the device. The structure includes:\n</p>\n<ul>\n<li>\n<strong>\n   Usage Pages and Usages\n  </strong>\n  : Defines the type of data the device can report.\n </li>\n<li>\n<strong>\n   Report Lengths\n  </strong>\n  : Indicates the size of the reports the device can generate.\n </li>\n<li>\n<strong>\n   Button-Capabilities Structures\n  </strong>\n  : Describes buttons and their behaviors.\n </li>\n<li>\n<strong>\n   Value-Capabilities Structures\n  </strong>\n  : Describes other input/output controls.\n </li>\n<li>\n<strong>\n   Data Indexes\n  </strong>\n  : Identifies specific controls and data in Input, Output, and Feature reports.\n </li>\n</ul>\n<p>\n The capabilities structure allows the application to understand the specifics of the HID device's reports, though not every element of the structure applies to every device.\n</p>\n"}, "Page 409": {"response": "<h3>\n HIDP_CAPS Structure and Function in Visual C++\n</h3>\n<h4>\n HIDP_CAPS Structure\n</h4>\n<p>\n In Visual C++, the\n <code>\n  HIDP_CAPS\n </code>\n structure defines the capabilities of a Human Interface Device (HID). The structure includes various fields that describe the device\u2019s usage, report lengths, and the number of capabilities for different types of input/output controls. The structure is defined as follows:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n typedef\n struct\n _HIDP_CAPS\n {\n    USAGE    Usage;\n // Device usage\n USAGE    UsagePage;\n // Usage page\n USHORT   InputReportByteLength;\n // Length of input report\n USHORT   OutputReportByteLength;\n // Length of output report\n USHORT   FeatureReportByteLength;\n // Length of feature report\n USHORT   Reserved[\n 17\n ];\n // Reserved for future use\n USHORT   NumberLinkCollectionNodes;\n // Number of link collection nodes\n USHORT   NumberInputButtonCaps;\n // Number of input button capabilities\n USHORT   NumberInputValueCaps;\n // Number of input value capabilities\n USHORT   NumberInputDataIndices;\n // Number of input data indices\n USHORT   NumberOutputButtonCaps;\n // Number of output button capabilities\n USHORT   NumberOutputValueCaps;\n // Number of output value capabilities\n USHORT   NumberOutputDataIndices;\n // Number of output data indices\n USHORT   NumberFeatureButtonCaps;\n // Number of feature button capabilities\n USHORT   NumberFeatureValueCaps;\n // Number of feature value capabilities\n USHORT   NumberFeatureDataIndices;\n // Number of feature data indices\n } HIDP_CAPS, *PHIDP_CAPS;\n</code>\n<h4>\n Function Declaration\n</h4>\n<p>\n The\n <code>\n  HidP_GetCaps\n </code>\n function retrieves the capabilities of a HID device using a pointer to\n <code>\n  HIDP_CAPS\n </code>\n . Here is the function's declaration:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n NTSTATUS\n HidP_GetCaps\n (\n    IN PHIDP_PREPARSED_DATA PreparsedData,\n // Pointer to the parsed data\n OUT PHIDP_CAPS Capabilities\n // Pointer to the capabilities structure\n )\n ;\n</code>\n<h4>\n Calling the Function\n</h4>\n<p>\n To call the\n <code>\n  HidP_GetCaps\n </code>\n function in your application, you can use the following code:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n HIDP_CAPS Capabilities;\n // Declare a variable to store the capabilities\n HidP_GetCaps\n (PreparsedData, &amp;Capabilities);\n // Call the function, passing the parsed data and a pointer to the capabilities structure\n</code>\n<ul>\n<li>\n<strong>\n   PreparsedData\n  </strong>\n  : A pointer to the data that was previously prepared (typically obtained from\n  <code>\n   HidD_GetPreparsedData\n  </code>\n  ).\n </li>\n<li>\n<strong>\n   Capabilities\n  </strong>\n  : A pointer to the\n  <code>\n   HIDP_CAPS\n  </code>\n  structure that will be populated with the device\u2019s capabilities.\n </li>\n</ul>\n"}, "Page 410": {"response": "<h3>\n HIDP_CAPS Structure and Function in Visual Basic\n</h3>\n<h4>\n HIDP_CAPS Structure\n</h4>\n<p>\n In Visual Basic, the\n <code>\n  HIDP_CAPS\n </code>\n structure is used to define the capabilities of a Human Interface Device (HID). This structure includes fields that describe the device\u2019s usage, report lengths, and the number of various types of capabilities. The structure is defined as follows:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;StructLayout(LayoutKind.Sequential)&gt; _\n Public\n Structure\n HIDP_CAPS\n Dim\n Usage\n As\n Short\n ' Device usage\n Dim\n UsagePage\n As\n Short\n ' Usage page\n Dim\n InputReportByteLength\n As\n Short\n ' Length of input report\n Dim\n OutputReportByteLength\n As\n Short\n ' Length of output report\n Dim\n FeatureReportByteLength\n As\n Short\n ' Length of feature report\n &lt;MarshalAs (UnmanagedType.ByValArray, _\n        SizeConst:=\n 17\n )&gt; _\n Dim\n Reserved()\n As\n Short\n ' Reserved for future use\n Dim\n NumberLinkCollectionNodes\n As\n Short\n ' Number of link collection nodes\n Dim\n NumberInputButtonCaps\n As\n Short\n ' Number of input button capabilities\n Dim\n NumberInputValueCaps\n As\n Short\n ' Number of input value capabilities\n Dim\n NumberInputDataIndices\n As\n Short\n ' Number of input data indices\n Dim\n NumberOutputButtonCaps\n As\n Short\n ' Number of output button capabilities\n Dim\n NumberOutputValueCaps\n As\n Short\n ' Number of output value capabilities\n Dim\n NumberOutputDataIndices\n As\n Short\n ' Number of output data indices\n Dim\n NumberFeatureButtonCaps\n As\n Short\n ' Number of feature button capabilities\n Dim\n NumberFeatureValueCaps\n As\n Short\n ' Number of feature value capabilities\n Dim\n NumberFeatureDataIndices\n As\n Short\n ' Number of feature data indices\n End\n Structure\n</code>\n<h4>\n Function Declaration\n</h4>\n<p>\n To interact with the\n <code>\n  HIDP_CAPS\n </code>\n structure in Visual Basic, you can use the\n <code>\n  HidP_GetCaps\n </code>\n function. This function retrieves the capabilities of a HID device. Here\u2019s the function declaration:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;DllImport(\n \"hid.dll\"\n )&gt; _\n Function\n HidP_GetCaps _\n    (\n ByVal\n PreparsedData\n As\n IntPtr, _\n ByRef\n Capabilities\n As\n HIDP_CAPS) _\n As\n Boolean\n End\n Function\n</code>\n<ul>\n<li>\n<strong>\n   PreparsedData\n  </strong>\n  : This is a pointer to the parsed data (usually obtained through a previous call to\n  <code>\n   HidD_GetPreparsedData\n  </code>\n  ).\n </li>\n<li>\n<strong>\n   Capabilities\n  </strong>\n  : This is a reference to an instance of the\n  <code>\n   HIDP_CAPS\n  </code>\n  structure, which will be populated with the device\u2019s capabilities.\n </li>\n</ul>\n<h4>\n Calling the Function\n</h4>\n<p>\n To call the\n <code>\n  HidP_GetCaps\n </code>\n function in Visual Basic, you can use the following code:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Dim\n Capabilities\n As\n HIDP_CAPS\n ' Declare a variable to hold the capabilities\n HidP_GetCaps _\n    (PreparsedData, _\n    Capabilities)\n ' Call the function, passing the parsed data and the capabilities structure\n</code>\n<ul>\n<li>\n<strong>\n   Capabilities\n  </strong>\n  : After the function call, this variable will hold the capabilities of the HID device.\n </li>\n</ul>\n"}, "Page 411": {"response": "<h3>\n Retrieving Device Capabilities and Report Information\n</h3>\n<h4>\n Using PreparsedData and Capabilities Structure\n</h4>\n<p>\n The\n <code>\n  PreparsedData\n </code>\n pointer, returned by\n <code>\n  HidD_GetPreparsedData\n </code>\n , is used to retrieve a HID device's capabilities. Once\n <code>\n  HidP_GetCaps\n </code>\n is called, the application can examine the populated\n <code>\n  Capabilities\n </code>\n structure to access the device\u2019s details. For example, if you are searching for a joystick, you would look for a\n <strong>\n  Usage Page\n </strong>\n of\n <code>\n  01h\n </code>\n and a\n <strong>\n  Usage\n </strong>\n of\n <code>\n  04h\n </code>\n in the structure.\n</p>\n<p>\n Additionally, the\n <strong>\n  report lengths\n </strong>\n within the\n <code>\n  Capabilities\n </code>\n structure are essential for determining appropriate buffer sizes for sending and receiving data reports.\n</p>\n<h4>\n Getting Button and Value Capabilities\n</h4>\n<p>\n Applications can also access detailed capabilities of buttons and values within a HID report. This is done using the\n <code>\n  HidP_GetValueCaps\n </code>\n and\n <code>\n  HidP_GetButtonCaps\n </code>\n functions.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    HidP_GetValueCaps\n   </strong>\n   : This function returns a pointer to an array of structures describing the values in a report. The number of structures returned is specified by the\n   <code>\n    NumberInputValueCaps\n   </code>\n   property in the\n   <code>\n    HIDP_CAPS\n   </code>\n   structure. These structures contain key details from the HID report descriptor, including:\n  </p>\n<ul>\n<li>\n<strong>\n     Report ID\n    </strong>\n</li>\n<li>\n<strong>\n     Value type\n    </strong>\n    (absolute or relative)\n   </li>\n<li>\n<strong>\n     Null state\n    </strong>\n    information\n   </li>\n<li>\n<strong>\n     Logical and physical minimums and maximums\n    </strong>\n</li>\n<li>\n    A\n    <strong>\n     LinkCollection identifier\n    </strong>\n    to distinguish between controls with the same Usage and Usage Page within the same collection.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    HidP_GetButtonCaps\n   </strong>\n   : This function retrieves information about the buttons in a report and stores it in a\n   <code>\n    HidP_ButtonCaps\n   </code>\n   structure.\n  </p>\n</li>\n</ul>\n<p>\n If your application doesn\u2019t need information on buttons or values, you can skip retrieving it.\n</p>\n<h4>\n Sending and Receiving Reports\n</h4>\n<p>\n The previous API functions are primarily focused on discovering and understanding the capabilities of the device. Once this information is gathered, you can proceed with sending and receiving data reports between the application and the HID device.\n</p>\n"}, "Page 412": {"response": "<h3>\n Sending and Receiving Reports with HID Devices\n</h3>\n<h4>\n Exchanging Data with a HID Device\n</h4>\n<p>\n Once an application identifies a suitable device, it can begin exchanging data in the form of reports. To send or receive data from the device, the application uses specific API functions designed for this purpose, as outlined in Table 13-3. The transfer type used for these reports can vary based on factors such as the report type, the operating system, and the availability of certain endpoints, as shown in Table 13-6.\n</p>\n<h4>\n Sending an Output Report\n</h4>\n<p>\n After obtaining a handle for the HID device and determining the report size, the application can send an\n <strong>\n  Output report\n </strong>\n . Here\u2019s how it works:\n</p>\n<ol>\n<li>\n  The application prepares the data to be sent by copying it to a buffer.\n </li>\n<li>\n  It then calls\n  <code>\n   WriteFile\n  </code>\n  to send the data to the device.\n </li>\n</ol>\n<p>\n The specific transfer type used by the HID driver to send the Output report depends on the Windows edition and whether the HID interface has an\n <strong>\n  interrupt OUT endpoint\n </strong>\n . The application does not need to be concerned with the transfer type; the driver handles the appropriate method.\n</p>\n<h4>\n Transfer Types for Sending and Receiving Reports\n</h4>\n<p>\n The transfer type for reports depends on the type of report being exchanged, the API function used, and the available endpoints. Here is a breakdown:\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Report Type\n    </strong>\n</th>\n<th>\n<strong>\n     API Function\n    </strong>\n</th>\n<th>\n<strong>\n     Transfer Type\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     Input\n    </strong>\n</td>\n<td>\n<code>\n     ReadFile\n    </code>\n</td>\n<td>\n    Interrupt IN\n   </td>\n</tr>\n<tr>\n<td>\n</td>\n<td>\n<code>\n     HidD_GetInputReport\n    </code>\n</td>\n<td>\n    Control with\n    <code>\n     Get_Report\n    </code>\n    request\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Output\n    </strong>\n</td>\n<td>\n<code>\n     WriteFile\n    </code>\n</td>\n<td>\n    Interrupt OUT (if available); otherwise, Control with\n    <code>\n     Set_Report\n    </code>\n    request\n   </td>\n</tr>\n<tr>\n<td>\n</td>\n<td>\n<code>\n     HidD_SetOutputReport\n    </code>\n</td>\n<td>\n    Control with\n    <code>\n     Set_Report\n    </code>\n    request\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Feature IN\n    </strong>\n</td>\n<td>\n<code>\n     HidD_GetFeature\n    </code>\n</td>\n<td>\n    Control with\n    <code>\n     Get_Report\n    </code>\n    request\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Feature OUT\n    </strong>\n</td>\n<td>\n<code>\n     HidD_SetFeature\n    </code>\n</td>\n<td>\n    Control with\n    <code>\n     Set_Report\n    </code>\n    request\n   </td>\n</tr>\n</tbody>\n</table>\n<p>\n This table clarifies how different report types are handled based on the transfer type and system configuration.\n</p>\n"}, "Page 413": {"response": "<h3>\n Using\n <code>\n  WriteFile\n </code>\n to Send Output Reports in Visual C++\n</h3>\n<h4>\n<code>\n  WriteFile\n </code>\n Function Declaration\n</h4>\n<p>\n In Visual C++, the\n <code>\n  WriteFile\n </code>\n function is used to send data to a device, such as an Output report to a HID device. The function is declared as follows:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n BOOL\n WriteFile\n (\n  HANDLE hFile,\n // Handle to the device or file\n LPCVOID lpBuffer,\n // Pointer to the data buffer to send\n DWORD nNumberOfBytesToWrite,\n // Number of bytes to write\n LPDWORD lpNumberOfBytesWritten,\n // Pointer to number of bytes written\n LPOVERLAPPED lpOverlapped\n // Pointer to an OVERLAPPED structure (optional for asynchronous I/O)\n )\n ;\n</code>\n<ul>\n<li>\n<strong>\n   hFile\n  </strong>\n  : A handle to the device (typically obtained by calling\n  <code>\n   CreateFile\n  </code>\n  ).\n </li>\n<li>\n<strong>\n   lpBuffer\n  </strong>\n  : A pointer to the buffer containing the data to send.\n </li>\n<li>\n<strong>\n   nNumberOfBytesToWrite\n  </strong>\n  : The number of bytes in the buffer to write.\n </li>\n<li>\n<strong>\n   lpNumberOfBytesWritten\n  </strong>\n  : A pointer to a variable that will receive the number of bytes actually written.\n </li>\n<li>\n<strong>\n   lpOverlapped\n  </strong>\n  : Used for asynchronous operations, but typically set to\n  <code>\n   NULL\n  </code>\n  for synchronous operations.\n </li>\n</ul>\n<h4>\n Calling the\n <code>\n  WriteFile\n </code>\n Function\n</h4>\n<p>\n To send an Output report using\n <code>\n  WriteFile\n </code>\n , you can use the following code:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n BOOLEAN Result;\nCHAR OutputReport[\n 3\n ];\n // Declare an array to store the report\n DWORD BytesWritten;\n // Initialize the first byte of the report as the Report ID\n OutputReport[\n 0\n ] =\n 0\n ;\n // Store the actual data to send in the bytes following the Report ID\n OutputReport[\n 1\n ] =\n 79\n ;\n // Example data byte\n OutputReport[\n 2\n ] =\n 75\n ;\n // Example data byte\n // Call WriteFile to send the report to the device\n Result =\n WriteFile\n (\n  DeviceHandle,\n // The device handle\n OutputReport,\n // The buffer containing the report\n Capabilities.OutputReportByteLength,\n // The report length in bytes\n &amp;BytesWritten,\n // Pointer to receive the number of bytes written\n NULL\n // No overlap structure for synchronous I/O\n );\n</code>\n<ul>\n<li>\n<strong>\n   DeviceHandle\n  </strong>\n  : The handle to the HID device.\n </li>\n<li>\n<strong>\n   OutputReport\n  </strong>\n  : A buffer holding the report data to send. The first byte should be the\n  <strong>\n   Report ID\n  </strong>\n  , followed by the data to send.\n </li>\n<li>\n<strong>\n   Capabilities.OutputReportByteLength\n  </strong>\n  : The length of the Output report, typically obtained from the device\u2019s capabilities structure.\n </li>\n<li>\n<strong>\n   BytesWritten\n  </strong>\n  : This variable will hold the number of bytes successfully written to the device.\n </li>\n</ul>\n"}, "Page 414": {"response": "<h3>\n Sending Output Reports with\n <code>\n  WriteFile\n </code>\n in Visual Basic\n</h3>\n<h4>\n<code>\n  WriteFile\n </code>\n Function Declaration\n</h4>\n<p>\n In Visual Basic, the\n <code>\n  WriteFile\n </code>\n function is used to send an Output report to a HID device. The function is declared as follows:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;DllImport(\n \"kernel32.dll\"\n )&gt;\n Function\n WriteFile _\n    (\n ByVal\n hFile\n As\n Integer\n , _\n ByRef\n lpBuffer\n As\n Byte\n , _\n ByVal\n nNumberOfBytesToWrite\n As\n Integer\n , _\n ByRef\n lpNumberOfBytesWritten\n As\n Integer\n , _\n ByVal\n lpOverlapped\n As\n Integer\n ) _\n As\n Boolean\n End\n Function\n</code>\n<ul>\n<li>\n<strong>\n   hFile\n  </strong>\n  : The device handle, typically returned by\n  <code>\n   CreateFile\n  </code>\n  .\n </li>\n<li>\n<strong>\n   lpBuffer\n  </strong>\n  : A reference to the buffer containing the report data to send.\n </li>\n<li>\n<strong>\n   nNumberOfBytesToWrite\n  </strong>\n  : The number of bytes to write from the buffer.\n </li>\n<li>\n<strong>\n   lpNumberOfBytesWritten\n  </strong>\n  : A reference to a variable that will receive the number of bytes actually written.\n </li>\n<li>\n<strong>\n   lpOverlapped\n  </strong>\n  : Used for asynchronous operations (set to 0 for synchronous).\n </li>\n</ul>\n<h4>\n Code to Send an Output Report\n</h4>\n<p>\n To send an Output report to the HID, the following Visual Basic code can be used:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Dim\n NumberOfBytesWritten\n As\n Integer\n Dim\n OutputReportBuffer()\n As\n Byte\n Dim\n ReportID\n As\n Integer\n Dim\n Result\n As\n Boolean\n ' Redimension the buffer to the report length\n ReDim\n OutputReportBuffer(Capabilities.OutputReportByteLength -\n 1\n )\n ' Set the Report ID as the first byte in the buffer\n ReportID =\n 0\n OutputReportBuffer(\n 0\n ) = ReportID\n ' Store data in the bytes following the Report ID\n OutputReportBuffer(\n 1\n ) =\n 79\n ' Example data byte\n OutputReportBuffer(\n 2\n ) =\n 75\n ' Example data byte\n ' Call WriteFile to send the report\n Result = WriteFile _\n    (DeviceHandle, _\n    OutputReportBuffer(\n 0\n ), _\n    UBound(OutputReportBuffer) +\n 1\n , _\n    NumberOfBytesWritten, _\n 0\n )\n</code>\n<ul>\n<li>\n<strong>\n   OutputReportBuffer\n  </strong>\n  : A byte array used to store the report data. The first byte is the\n  <strong>\n   Report ID\n  </strong>\n  , followed by the actual data to send.\n </li>\n<li>\n<strong>\n   Capabilities.OutputReportByteLength\n  </strong>\n  : The length of the Output report, typically obtained from the device's capabilities.\n </li>\n<li>\n<strong>\n   NumberOfBytesWritten\n  </strong>\n  : This variable will hold the number of bytes successfully written to the device after the call to\n  <code>\n   WriteFile\n  </code>\n  .\n </li>\n</ul>\n"}, "Page 415": {"response": "<h3>\n Sending Reports and Handling Errors with\n <code>\n  WriteFile\n </code>\n</h3>\n<h4>\n Report Buffer Size and Structure\n</h4>\n<p>\n When using\n <code>\n  WriteFile\n </code>\n to send an Output report, the size of the buffer should match the\n <strong>\n  OutputReportByteLength\n </strong>\n property from the\n <code>\n  HIDP_CAPS\n </code>\n structure, which is obtained through\n <code>\n  HidP_GetCaps\n </code>\n . This value includes the report data size plus one byte for the\n <strong>\n  Report ID\n </strong>\n , which is placed as the first byte in the buffer.\n</p>\n<ul>\n<li>\n  The buffer must be large enough to accommodate both the Report ID and the report data.\n </li>\n<li>\n  If the device interface only supports the default Report ID of 0, the Report ID is not transmitted on the bus, but it must still be included in the buffer passed to\n  <code>\n   WriteFile\n  </code>\n  .\n </li>\n</ul>\n<h4>\n Overlapped I/O and Synchronization\n</h4>\n<p>\n The\n <code>\n  lpOverlapped\n </code>\n parameter is unused in the example but can be utilized for\n <strong>\n  overlapped I/O\n </strong>\n . This method is especially useful for preventing the application thread from being blocked if the HID\u2019s interrupt OUT endpoint repeatedly NAKs (negative acknowledgment) the data. Normally, the endpoint should accept the report data with minimal delay, but using overlapped I/O ensures the application does not hang in case of delays.\n</p>\n<h4>\n Success and Error Handling\n</h4>\n<p>\n When\n <code>\n  WriteFile\n </code>\n succeeds, it returns\n <strong>\n  True\n </strong>\n and the\n <strong>\n  NumberOfBytesWritten\n </strong>\n parameter is updated with the number of bytes successfully written to the HID.\n</p>\n<ul>\n<li>\n<strong>\n   Error handling\n  </strong>\n  : If there is an issue with the data transmission:\n  <ul>\n<li>\n    If the report data is sent to an interrupt endpoint,\n    <code>\n     WriteFile\n    </code>\n    either returns a success or an error. If the device NAKs the report data,\n    <code>\n     WriteFile\n    </code>\n    will wait until the endpoint acknowledges (ACKs) the data.\n   </li>\n<li>\n    If sending the report via the control endpoint, the function can return success, an error, or a timeout if the endpoint keeps NAKing the data.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n The most common error returned by\n <code>\n  WriteFile\n </code>\n in HID communications is a\n <strong>\n  CRC Error\n </strong>\n . This doesn\u2019t typically indicate a problem with the CRC calculation but rather suggests an issue with the firmware or the endpoint not accepting the report data. If\n <code>\n  WriteFile\n </code>\n does not return at all, it\u2019s likely because the interrupt OUT endpoint has not been configured to accept the report data.\n</p>\n<h4>\n Reading Input Reports with\n <code>\n  ReadFile\n </code>\n</h4>\n<p>\n The counterpart to\n <code>\n  WriteFile\n </code>\n is the\n <code>\n  ReadFile\n </code>\n function, which is used to read an\n <strong>\n  Input report\n </strong>\n from the device. When the application has a valid handle to the HID interface and knows the report size,\n <code>\n  ReadFile\n </code>\n can be used to retrieve data from the HID device.\n</p>\n"}, "Page 416": {"response": "<h3>\n Reading Input Reports with\n <code>\n  ReadFile\n </code>\n</h3>\n<h4>\n Using\n <code>\n  ReadFile\n </code>\n to Retrieve Input Reports\n</h4>\n<p>\n To read an\n <strong>\n  Input report\n </strong>\n from a HID device, an application uses the\n <code>\n  ReadFile\n </code>\n function. The application must declare a buffer to hold the incoming data, and the buffer size should match the\n <strong>\n  InputReportByteLength\n </strong>\n property from the\n <code>\n  HIDP_CAPS\n </code>\n structure, which is obtained through the\n <code>\n  HidP_GetCaps\n </code>\n function.\n</p>\n<h4>\n Blocking Call and Handling Delays\n</h4>\n<p>\n When using\n <strong>\n  non-overlapped I/O\n </strong>\n , the\n <code>\n  ReadFile\n </code>\n function is a blocking call. This means the application\u2019s thread will wait if the HID\u2019s read buffer is empty, and the thread will remain blocked until:\n</p>\n<ul>\n<li>\n  A report becomes available,\n </li>\n<li>\n  The user manually closes the application through the Task Manager, or\n </li>\n<li>\n  The device is removed from the bus.\n </li>\n</ul>\n<p>\n To prevent the application from hanging while waiting for a report, several approaches can be used:\n</p>\n<ol>\n<li>\n<strong>\n   Continuous Report Sending\n  </strong>\n  : The device can be configured to continuously send reports, ensuring that data is always available.\n </li>\n<li>\n<strong>\n   Request-Response Model\n  </strong>\n  : The application can first send an Output or Feature report to prompt the device to send an Input report.\n </li>\n<li>\n<strong>\n   Overlapped I/O\n  </strong>\n  : The application can use overlapped I/O with a timeout to avoid blocking.\n </li>\n<li>\n<strong>\n   Separate Thread\n  </strong>\n  : The application can manage the\n  <code>\n   ReadFile\n  </code>\n  call in a separate thread, preventing the main thread from being blocked.\n </li>\n</ol>\n<h4>\n Ensuring Data Availability from the Device\n</h4>\n<p>\n To ensure that data is consistently available from the HID device, the firmware can be designed in such a way that the\n <strong>\n  IN endpoint\n </strong>\n is always ready to respond to requests. If no new data is available, the device could:\n</p>\n<ul>\n<li>\n  Send the previous report again,\n </li>\n<li>\n  Return a vendor-defined code indicating there is no new data.\n </li>\n</ul>\n<p>\n Alternatively, the application can send a report before calling\n <code>\n  ReadFile\n </code>\n to prompt the firmware to provide fresh data.\n</p>\n<h4>\n Overlapped I/O and Timeout Handling\n</h4>\n<p>\n For\n <strong>\n  overlapped I/O\n </strong>\n , the\n <code>\n  ReadFile\n </code>\n function returns immediately even if no report is available. The application can then use\n <code>\n  WaitForSingleObject\n </code>\n to wait for the report to be ready. This method has the advantage of setting a\n <strong>\n  timeout\n </strong>\n . If the report does not arrive within the timeout period, the function returns a timeout code, and the application can choose to:\n</p>\n<ul>\n<li>\n  Retry reading the report,\n </li>\n<li>\n  Use the\n  <code>\n   CancelIo\n  </code>\n  function to cancel the read operation.\n </li>\n</ul>\n<p>\n This approach works well when reports are usually available without delay but ensures that the application regains control if there is a delay or no report.\n</p>\n<h4>\n Avoiding Long Delays with Zero Timeout\n</h4>\n<p>\n To prevent long waits while using\n <code>\n  WaitForSingleObject\n </code>\n , the application can set the timeout to\n <strong>\n  zero\n </strong>\n . This way, the function will return immediately if no report is available. The application can then call the function repeatedly in a loop or periodically, triggered by a timer, to check for the report without blocking for extended periods.\n</p>\n"}, "Page 417": {"response": "<h3>\n Improving Input Report Handling with Overlapped I/O\n</h3>\n<h4>\n Non-blocking Input Report Retrieval\n</h4>\n<p>\n To avoid long delays while waiting for an Input report, an application can perform\n <strong>\n  non-blocking\n </strong>\n<code>\n  ReadFile\n </code>\n operations. One approach is setting the timeout to\n <strong>\n  zero\n </strong>\n so that\n <code>\n  ReadFile\n </code>\n returns immediately, whether or not a report is available. The application can then process other tasks in the loop or between timeouts, ensuring it doesn\u2019t remain idle while waiting for data.\n</p>\n<h4>\n Multithreading for Improved Performance\n</h4>\n<p>\n Another approach to optimize the reading of Input reports is to perform\n <code>\n  ReadFile\n </code>\n in a\n <strong>\n  separate thread\n </strong>\n . The main thread can be notified when a report is available, preventing it from being blocked. In .NET applications, this can be achieved by using an\n <strong>\n  asynchronous delegate\n </strong>\n and the\n <code>\n  BeginInvoke\n </code>\n method to invoke a method that performs the\n <code>\n  ReadFile\n </code>\n operation on a separate thread. Once the\n <code>\n  ReadFile\n </code>\n operation completes, a\n <strong>\n  callback routine\n </strong>\n can be executed in the main thread to handle the retrieved report.\n</p>\n<h4>\n Visual C++ Overlapped I/O Functions\n</h4>\n<p>\n For\n <strong>\n  overlapped I/O\n </strong>\n in Visual C++, the following functions are essential:\n</p>\n<ol>\n<li>\n<strong>\n   CancelIo\n  </strong>\n  : Cancels any pending I/O operations for a given file handle.\n  cpp\n  Copy code\n  <code class=\"!whitespace-pre hljs language-cpp\">\n   BOOL\n   CancelIo\n   (HANDLE hFile)\n   ;\n  </code>\n</li>\n<li>\n<strong>\n   CreateEvent\n  </strong>\n  : Creates an event object used to synchronize the application. It can be used with overlapped I/O to signal when the read operation is complete.\n  cpp\n  Copy code\n  <code class=\"!whitespace-pre hljs language-cpp\">\n   HANDLE\n   CreateEvent\n   (LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCTSTR lpName)\n   ;\n  </code>\n</li>\n<li>\n<strong>\n   ReadFile\n  </strong>\n  : Reads data from a file or device. Used in overlapped I/O to initiate a non-blocking read operation.\n  cpp\n  Copy code\n  <code class=\"!whitespace-pre hljs language-cpp\">\n   BOOL\n   ReadFile\n   (HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)\n   ;\n  </code>\n</li>\n<li>\n<strong>\n   WaitForSingleObject\n  </strong>\n  : Waits for a signal on a specified event or object. This is used in conjunction with overlapped I/O to check for data availability.\n  cpp\n  Copy code\n  <code class=\"!whitespace-pre hljs language-cpp\">\n   DWORD\n   WaitForSingleObject\n   (HANDLE hHandle, DWORD dwMilliseconds)\n   ;\n  </code>\n</li>\n</ol>\n<p>\n These functions work together to allow the application to handle I/O operations asynchronously, improving the responsiveness and performance of the application when reading input reports from the HID device.\n</p>\n"}, "Page 418": {"response": "<h3>\n Overlapped\n <code>\n  ReadFile\n </code>\n Example\n</h3>\n<p>\n To perform an\n <strong>\n  overlapped read\n </strong>\n operation from a device, you can use the following approach in C/C++. This allows the application to read input reports without blocking the main thread.\n</p>\n<h4>\n Code Breakdown:\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Buffer and Variables\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<code>\n     InputReportBuffer[3]\n    </code>\n    : A buffer that will hold the input report data. The size of the buffer should be large enough to hold the report data (including the Report ID).\n   </li>\n<li>\n<code>\n     BytesRead\n    </code>\n    : Holds the number of bytes successfully read by\n    <code>\n     ReadFile\n    </code>\n    .\n   </li>\n<li>\n<code>\n     Result\n    </code>\n    : Holds the result of the\n    <code>\n     ReadFile\n    </code>\n    and\n    <code>\n     WaitForSingleObject\n    </code>\n    functions.\n   </li>\n<li>\n<code>\n     hEventObject\n    </code>\n    : An event object used for signaling when the read operation completes.\n   </li>\n<li>\n<code>\n     HIDOverlapped\n    </code>\n    : An\n    <strong>\n     OVERLAPPED\n    </strong>\n    structure used to manage the asynchronous I/O operation.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Creating the Event Object\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<code>\n     CreateEvent\n    </code>\n    is used to create a manual-reset event (\n    <code>\n     FALSE\n    </code>\n    for manual reset,\n    <code>\n     TRUE\n    </code>\n    for initial state to signaled).\n   </li>\n</ul>\n  cpp\n  Copy code\n  <code class=\"!whitespace-pre hljs language-cpp\">\n   hEventObject =\n   CreateEvent\n   ((LPSECURITY_ATTRIBUTES)\n   NULL\n   , FALSE, TRUE,\n   \"\"\n   );\n  </code>\n<ul>\n<li>\n    This event will be used to signal when the\n    <code>\n     ReadFile\n    </code>\n    operation has completed.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Setting Up the\n    <code>\n     OVERLAPPED\n    </code>\n    Structure\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <code>\n     OVERLAPPED\n    </code>\n    structure is initialized to prepare for the overlapped I/O operation:\n   </li>\n</ul>\n  cpp\n  Copy code\n  <code class=\"!whitespace-pre hljs language-cpp\">\n   HIDOverlapped.hEvent = hEventObject;\nHIDOverlapped.Offset =\n   0\n   ;\nHIDOverlapped.OffsetHigh =\n   0\n   ;\n  </code>\n<ul>\n<li>\n    The\n    <code>\n     hEvent\n    </code>\n    field is set to the event object created earlier, and the\n    <code>\n     Offset\n    </code>\n    and\n    <code>\n     OffsetHigh\n    </code>\n    fields are set to 0 (used for file offset, not needed for this example).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Setting the Report ID\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The first byte in the buffer is set to the\n    <strong>\n     Report ID\n    </strong>\n    (typically 0 for the default report):\n   </li>\n</ul>\n  cpp\n  Copy code\n  <code class=\"!whitespace-pre hljs language-cpp\">\n   InputReportBuffer[\n   0\n   ] =\n   0\n   ;\n  </code>\n</li>\n<li>\n<p>\n<strong>\n    Opening the Device\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <code>\n     CreateFile\n    </code>\n    function opens the HID device for reading and writing:\n   </li>\n</ul>\n  cpp\n  Copy code\n  <code class=\"!whitespace-pre hljs language-cpp\">\n   ReadHandle =\n   CreateFile\n   (DetailData-&gt;DevicePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, (LPSECURITY_ATTRIBUTES)\n   NULL\n   , OPEN_EXISTING, FILE_FLAG_OVERLAPPED,\n   NULL\n   );\n  </code>\n</li>\n<li>\n<p>\n<strong>\n    Performing the Overlapped Read\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <code>\n     ReadFile\n    </code>\n    function is called with the\n    <code>\n     OVERLAPPED\n    </code>\n    structure to initiate the read operation without blocking:\n   </li>\n</ul>\n  cpp\n  Copy code\n  <code class=\"!whitespace-pre hljs language-cpp\">\n   Result =\n   ReadFile\n   (ReadHandle, InputReportBuffer, Capabilities.InputReportByteLength, &amp;BytesRead, (LPOVERLAPPED) &amp;HIDOverlapped);\n  </code>\n</li>\n<li>\n<p>\n<strong>\n    Waiting for Completion\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <code>\n     WaitForSingleObject\n    </code>\n    function waits for the event object to be signaled, indicating that the read operation is complete:\n   </li>\n</ul>\n  cpp\n  Copy code\n  <code class=\"!whitespace-pre hljs language-cpp\">\n   Result =\n   WaitForSingleObject\n   (hEventObject,\n   3000\n   );\n  </code>\n<ul>\n<li>\n    The timeout is set to 3000 milliseconds (3 seconds), after which it will return if no report is available.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Key Points:\n</h4>\n<ul>\n<li>\n<strong>\n   Event Handling\n  </strong>\n  : The event object signals when the read operation has finished, allowing the application to avoid blocking.\n </li>\n<li>\n<strong>\n   Overlapped I/O\n  </strong>\n  : By using the\n  <code>\n   OVERLAPPED\n  </code>\n  structure and event object, the application can continue performing other tasks while waiting for the read operation to complete.\n </li>\n<li>\n<strong>\n   Timeout\n  </strong>\n  : The application specifies a timeout for how long it should wait for a report before proceeding with another action.\n </li>\n</ul>\n"}, "Page 419": {"response": "<h3>\n Handling Overlapped ReadFile Results\n</h3>\n<p>\n After initiating an overlapped read with\n <code>\n  ReadFile\n </code>\n , the result of the operation needs to be processed. The result is typically determined by\n <code>\n  WaitForSingleObject\n </code>\n , which waits for the operation to complete. Depending on the outcome, different actions are taken.\n</p>\n<h4>\n Handling the Results:\n</h4>\n<p>\n The following logic is used to handle the results of\n <code>\n  WaitForSingleObject\n </code>\n :\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n switch\n (Result) {\n case\n WAIT_OBJECT_0: {\n // Success\n // The read operation completed successfully.\n // Process the report data here.\n break\n ;\n    }\n case\n WAIT_TIMEOUT: {\n // Timeout error\n // The operation did not complete in the allotted time.\n // Cancel the read operation.\n CancelIo\n (ReadHandle);\n break\n ;\n    }\n default\n : {\n // Undefined error\n // There was an unexpected error during the read operation.\n // Cancel the read operation.\n CancelIo\n (ReadHandle);\n break\n ;\n    }\n}\n</code>\n<ul>\n<li>\n<strong>\n   WAIT_OBJECT_0\n  </strong>\n  : This indicates that the read operation was successful. The application can then proceed to process the report data.\n </li>\n<li>\n<strong>\n   WAIT_TIMEOUT\n  </strong>\n  : This indicates that the read operation timed out because it didn't complete within the specified time (e.g., 3000 milliseconds). In this case, the\n  <code>\n   CancelIo\n  </code>\n  function is called to cancel the read operation.\n </li>\n<li>\n<strong>\n   Default (Error Handling)\n  </strong>\n  : If an undefined error occurs, the\n  <code>\n   CancelIo\n  </code>\n  function is called to abort the read operation.\n </li>\n</ul>\n<h4>\n Constants for Overlapped Read in Visual Basic\n</h4>\n<p>\n In Visual Basic, the following constants are used to define file flags, access modes, and wait conditions for the overlapped\n <code>\n  ReadFile\n </code>\n operation:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Public\n Const\n FILE_FLAG_OVERLAPPED\n As\n Integer\n =\n &amp;H40000000\n Public\n Const\n FILE_SHARE_READ\n As\n Short\n =\n &amp;H1S\n Public\n Const\n FILE_SHARE_WRITE\n As\n Short\n =\n &amp;H2S\n Public\n Const\n GENERIC_READ\n As\n Integer\n =\n &amp;H80000000\n Public\n Const\n GENERIC_WRITE\n As\n Integer\n =\n &amp;H40000000\n Public\n Const\n OPEN_EXISTING\n As\n Short\n =\n 3\n Public\n Const\n WAIT_OBJECT_0\n As\n Short\n =\n 0\n Public\n Const\n WAIT_TIMEOUT\n As\n Integer\n =\n &amp;H102\n</code>\n<ul>\n<li>\n<strong>\n   FILE_FLAG_OVERLAPPED\n  </strong>\n  : Indicates that the file or device is being accessed using overlapped I/O (asynchronous operation).\n </li>\n<li>\n<strong>\n   FILE_SHARE_READ and FILE_SHARE_WRITE\n  </strong>\n  : These constants specify how other processes can access the file while it is open.\n </li>\n<li>\n<strong>\n   GENERIC_READ and GENERIC_WRITE\n  </strong>\n  : These constants specify the type of access the application has to the device (read and write permissions).\n </li>\n<li>\n<strong>\n   OPEN_EXISTING\n  </strong>\n  : Specifies that the function should open an existing file or device.\n </li>\n<li>\n<strong>\n   WAIT_OBJECT_0\n  </strong>\n  : Indicates that the wait operation completed successfully.\n </li>\n<li>\n<strong>\n   WAIT_TIMEOUT\n  </strong>\n  : Specifies that the operation timed out without completing.\n </li>\n</ul>\n"}, "Page 420": {"response": "<h3>\n Functions and Structures for Overlapped Read Operations\n</h3>\n<p>\n In order to perform an overlapped read operation in Visual Basic, the following structure and functions are used to manage I/O operations and handle events effectively.\n</p>\n<h4>\n OVERLAPPED Structure\n</h4>\n<p>\n The\n <code>\n  OVERLAPPED\n </code>\n structure is used to manage the I/O operations when performing an overlapped (asynchronous) read. The structure is defined as follows:\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;StructLayout(LayoutKind.Sequential)&gt; _\n Public\n Structure\n OVERLAPPED\n Dim\n Internal\n As\n Integer\n Dim\n InternalHigh\n As\n Integer\n Dim\n Offset\n As\n Integer\n Dim\n OffsetHigh\n As\n Integer\n Dim\n hEvent\n As\n Integer\n End\n Structure\n</code>\n<ul>\n<li>\n<strong>\n   Internal and InternalHigh\n  </strong>\n  : These are used internally by the operating system to store status information.\n </li>\n<li>\n<strong>\n   Offset and OffsetHigh\n  </strong>\n  : These fields specify the byte offset to start the operation (for large file support).\n </li>\n<li>\n<strong>\n   hEvent\n  </strong>\n  : A handle to an event object, which signals when the operation has completed.\n </li>\n</ul>\n<h4>\n Overlapped I/O Functions\n</h4>\n<p>\n The following functions are necessary to manage overlapped I/O operations:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    CancelIo\n   </strong>\n   : Used to cancel an I/O operation in progress for a specific file handle.\n  </p>\n  vb\n  Copy code\n  <code class=\"!whitespace-pre hljs language-vb\">\n   &lt;DllImport(\n   \"kernel32.dll\"\n   )&gt; _\n   Function\n   CancelIo _\n    (\n   ByVal\n   hFile\n   As\n   Integer\n   ) _\n   As\n   Integer\n   End\n   Function\n  </code>\n<ul>\n<li>\n<strong>\n     hFile\n    </strong>\n    : The handle to the file or device for which the I/O operation should be canceled.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    CreateEvent\n   </strong>\n   : Creates an event object used to signal the completion of an overlapped I/O operation.\n  </p>\n  vb\n  Copy code\n  <code class=\"!whitespace-pre hljs language-vb\">\n   &lt;DllImport(\n   \"kernel32.dll\"\n   , CharSet:=CharSet.\n   Auto\n   )&gt; _\n   Function\n   CreateEvent _\n    (\n   ByRef\n   SecurityAttributes\n   As\n   SECURITY_ATTRIBUTES, _\n   ByVal\n   bManualReset\n   As\n   Integer\n   , _\n   ByVal\n   bInitialState\n   As\n   Integer\n   , _\n   ByVal\n   lpName\n   As\n   String\n   ) _\n   As\n   Integer\n   End\n   Function\n  </code>\n<ul>\n<li>\n<strong>\n     SecurityAttributes\n    </strong>\n    : A reference to the security attributes for the event.\n   </li>\n<li>\n<strong>\n     bManualReset\n    </strong>\n    : Indicates whether the event is manual-reset (TRUE) or auto-reset (FALSE).\n   </li>\n<li>\n<strong>\n     bInitialState\n    </strong>\n    : Initial state of the event (set to signaled or non-signaled).\n   </li>\n<li>\n<strong>\n     lpName\n    </strong>\n    : Name of the event object.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    ReadFile\n   </strong>\n   : Performs a read operation on a file or device, using overlapped I/O.\n  </p>\n  vb\n  Copy code\n  <code class=\"!whitespace-pre hljs language-vb\">\n   &lt;DllImport(\n   \"kernel32.dll\"\n   )&gt; _\n   Function\n   ReadFile _\n    (\n   ByVal\n   hFile\n   As\n   Integer\n   , _\n   ByRef\n   lpBuffer\n   As\n   Byte\n   , _\n   ByVal\n   nNumberOfBytesToRead\n   As\n   Integer\n   , _\n   ByRef\n   lpNumberOfBytesRead\n   As\n   Integer\n   , _\n   ByRef\n   lpOverlapped\n   As\n   OVERLAPPED) _\n   As\n   Integer\n   End\n   Function\n  </code>\n<ul>\n<li>\n<strong>\n     hFile\n    </strong>\n    : Handle to the file or device to read from.\n   </li>\n<li>\n<strong>\n     lpBuffer\n    </strong>\n    : A reference to a byte buffer where the read data will be stored.\n   </li>\n<li>\n<strong>\n     nNumberOfBytesToRead\n    </strong>\n    : The number of bytes to read.\n   </li>\n<li>\n<strong>\n     lpNumberOfBytesRead\n    </strong>\n    : A reference to the number of bytes actually read.\n   </li>\n<li>\n<strong>\n     lpOverlapped\n    </strong>\n    : A reference to an\n    <code>\n     OVERLAPPED\n    </code>\n    structure to manage the asynchronous operation.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    WaitForSingleObject\n   </strong>\n   : Waits for a single object (such as the event object created for overlapped I/O) to be signaled, which indicates that the I/O operation has completed.\n  </p>\n  vb\n  Copy code\n  <code class=\"!whitespace-pre hljs language-vb\">\n   &lt;DllImport(\n   \"kernel32.dll\"\n   )&gt; _\n   Function\n   WaitForSingleObject _\n    (\n   ByVal\n   hHandle\n   As\n   Integer\n   , _\n   ByVal\n   dwMilliseconds\n   As\n   Integer\n   ) _\n   As\n   Integer\n   End\n   Function\n  </code>\n<ul>\n<li>\n<strong>\n     hHandle\n    </strong>\n    : Handle to the object being waited on, typically the event handle.\n   </li>\n<li>\n<strong>\n     dwMilliseconds\n    </strong>\n    : The timeout in milliseconds for the wait operation.\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n These functions and the\n <code>\n  OVERLAPPED\n </code>\n structure allow for efficient handling of asynchronous I/O operations, preventing the application from being blocked while waiting for data to be read.\n</p>\n"}, "Page 421": {"response": "<h3>\n Overlapped Read Operation Code in Visual Basic\n</h3>\n<p>\n This code demonstrates how to perform an overlapped read operation in Visual Basic. It uses the\n <code>\n  CreateEvent\n </code>\n ,\n <code>\n  CreateFile\n </code>\n , and\n <code>\n  ReadFile\n </code>\n functions, alongside the\n <code>\n  OVERLAPPED\n </code>\n structure to asynchronously read data from a HID device.\n</p>\n<h4>\n Key Components:\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Security Attributes\n   </strong>\n   : The\n   <code>\n    SECURITY_ATTRIBUTES\n   </code>\n   structure is used to specify security settings for the event object. It\u2019s configured to allow inheritance of the handle.\n  </p>\n  vb\n  Copy code\n  <code class=\"!whitespace-pre hljs language-vb\">\n   Dim\n   Security\n   As\n   SECURITY_ATTRIBUTES\nSecurity.lpSecurityDescriptor =\n   0\n   Security.bInheritHandle =\n   CInt\n   (\n   True\n   )\nSecurity.nLength = Len(Security)\n  </code>\n</li>\n<li>\n<p>\n<strong>\n    Create Event Object\n   </strong>\n   : An event object is created using\n   <code>\n    CreateEvent\n   </code>\n   , which will signal when the read operation completes.\n  </p>\n  vb\n  Copy code\n  <code class=\"!whitespace-pre hljs language-vb\">\n   EventObject = CreateEvent(Security,\n   CInt\n   (\n   False\n   ),\n   CInt\n   (\n   True\n   ),\n   \"\"\n   )\n  </code>\n<ul>\n<li>\n<code>\n     Security\n    </code>\n    : The security attributes (as defined above).\n   </li>\n<li>\n<code>\n     bManualReset\n    </code>\n    : Set to\n    <code>\n     False\n    </code>\n    , making the event auto-reset after being signaled.\n   </li>\n<li>\n<code>\n     bInitialState\n    </code>\n    : Set to\n    <code>\n     True\n    </code>\n    , so the event is signaled immediately.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Initialize Overlapped Structure\n   </strong>\n   : The\n   <code>\n    OVERLAPPED\n   </code>\n   structure is configured to use the event object, and to start reading from byte offset 0.\n  </p>\n  vb\n  Copy code\n  <code class=\"!whitespace-pre hljs language-vb\">\n   Dim\n   HIDOverlapped\n   As\n   OVERLAPPED\nHIDOverlapped.Offset =\n   0\n   HIDOverlapped.OffsetHigh =\n   0\n   HIDOverlapped.hEvent = EventObject\n  </code>\n</li>\n<li>\n<p>\n<strong>\n    Set Up the Report Buffer\n   </strong>\n   : The buffer where the input report will be stored is initialized, and the first byte is set as the Report ID (0 in this case).\n  </p>\n  vb\n  Copy code\n  <code class=\"!whitespace-pre hljs language-vb\">\n   Dim\n   InputReportBuffer()\n   As\n   Byte\n   InputReportBuffer(\n   0\n   ) =\n   0\n  </code>\n</li>\n<li>\n<p>\n<strong>\n    Open the HID Device\n   </strong>\n   : The device is opened with\n   <code>\n    CreateFile\n   </code>\n   . The\n   <code>\n    FILE_FLAG_OVERLAPPED\n   </code>\n   flag ensures that the operation is non-blocking (asynchronous).\n  </p>\n  vb\n  Copy code\n  <code class=\"!whitespace-pre hljs language-vb\">\n   Dim\n   ReadHandle\n   As\n   Integer\n   ReadHandle = CreateFile(DevicePathName, _\n                        GENERIC_READ\n   Or\n   GENERIC_WRITE, _\n                        FILE_SHARE_READ\n   Or\n   FILE_SHARE_WRITE, _\n                        Security, _\n                        OPEN_EXISTING, _\n                        FILE_FLAG_OVERLAPPED, _\n   0\n   )\n  </code>\n<ul>\n<li>\n<code>\n     DevicePathName\n    </code>\n    : The path to the HID device.\n   </li>\n<li>\n<code>\n     GENERIC_READ Or GENERIC_WRITE\n    </code>\n    : Opens the device for both reading and writing.\n   </li>\n<li>\n<code>\n     FILE_FLAG_OVERLAPPED\n    </code>\n    : Ensures that the operation is asynchronous.\n   </li>\n<li>\n<code>\n     OPEN_EXISTING\n    </code>\n    : Opens the device if it already exists.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Allocate Buffer for Input Report\n   </strong>\n   : The buffer size is adjusted to match the\n   <code>\n    InputReportByteLength\n   </code>\n   from the\n   <code>\n    Capabilities\n   </code>\n   structure. This length includes the report data.\n  </p>\n  vb\n  Copy code\n  <code class=\"!whitespace-pre hljs language-vb\">\n   ReDim\n   InputReportBuffer(Capabilities.InputReportByteLength -\n   1\n   )\n  </code>\n</li>\n</ol>\n<p>\n This setup prepares the environment for reading an input report asynchronously, using overlapped I/O. The application will be able to continue its operations without being blocked while waiting for the report from the device.\n</p>\n"}, "Page 422": {"response": "<h3>\n Handling Asynchronous Read with Overlapped I/O in Visual Basic\n</h3>\n<p>\n This code demonstrates how to perform an asynchronous read operation using overlapped I/O in Visual Basic, following the setup of event handling and error management.\n</p>\n<h4>\n Steps for Asynchronous Read:\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Initiate Read Operation\n   </strong>\n   : The\n   <code>\n    ReadFile\n   </code>\n   function is called with the\n   <code>\n    OVERLAPPED\n   </code>\n   structure (\n   <code>\n    HIDOverlapped\n   </code>\n   ) to start the asynchronous read operation. The buffer\n   <code>\n    InputReportBuffer\n   </code>\n   will hold the data from the device, and the result is stored in\n   <code>\n    NumberOfBytesRead\n   </code>\n   .\n  </p>\n  vb\n  Copy code\n  <code class=\"!whitespace-pre hljs language-vb\">\n   Result = ReadFile(ReadHandle, InputReportBuffer(\n   0\n   ), Capabilities.InputReportByteLength, NumberOfBytesRead, HIDOverlapped)\n  </code>\n</li>\n<li>\n<p>\n<strong>\n    Wait for Completion\n   </strong>\n   : The\n   <code>\n    WaitForSingleObject\n   </code>\n   function waits for the event object (\n   <code>\n    EventObject\n   </code>\n   ) to signal that the read operation has completed. The timeout is set to 3000 milliseconds (3 seconds).\n  </p>\n  vb\n  Copy code\n  <code class=\"!whitespace-pre hljs language-vb\">\n   Result = WaitForSingleObject(EventObject,\n   3000\n   )\n  </code>\n</li>\n<li>\n<p>\n<strong>\n    Handle Completion Results\n   </strong>\n   : The result of\n   <code>\n    WaitForSingleObject\n   </code>\n   is checked using a\n   <code>\n    Select Case\n   </code>\n   statement, which handles the possible outcomes of the read operation:\n  </p>\n<ul>\n<li>\n<strong>\n     Success (\n     <code>\n      WAIT_OBJECT_0\n     </code>\n     )\n    </strong>\n    : If the operation is successful, the application can process the report data.\n   </li>\n<li>\n<strong>\n     Timeout (\n     <code>\n      WAIT_TIMEOUT\n     </code>\n     )\n    </strong>\n    : If the operation times out (i.e., no data is available in 3 seconds), the\n    <code>\n     CancelIo\n    </code>\n    function is called to cancel the read operation.\n   </li>\n<li>\n<strong>\n     Other Errors\n    </strong>\n    : Any undefined errors will also result in the cancellation of the read operation.\n   </li>\n</ul>\n  vb\n  Copy code\n  <code class=\"!whitespace-pre hljs language-vb\">\n   Select\n   Case\n   Result\n   Case\n   WAIT_OBJECT_0\n   ' Success\n   ' Use the report data.\n   Case\n   WAIT_TIMEOUT\n   ' Timeout error.\n   ' Cancel the Read operation.\n   CancelIo(ReadHandle)\n   Case\n   Else\n   ' Undefined error.\n   ' Cancel the Read operation.\n   CancelIo(ReadHandle)\n   End\n   Select\n  </code>\n</li>\n</ol>\n<h4>\n Key Details:\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Create Event\n   </strong>\n   : Before calling\n   <code>\n    ReadFile\n   </code>\n   , the application must first create an event object with\n   <code>\n    CreateEvent\n   </code>\n   . This event will be set to a signaled state once the\n   <code>\n    ReadFile\n   </code>\n   operation completes.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Overlapped I/O\n   </strong>\n   : The read operation requires a handle obtained from\n   <code>\n    CreateFile\n   </code>\n   with the\n   <code>\n    FILE_FLAG_OVERLAPPED\n   </code>\n   flag, indicating that the operation should be asynchronous. This allows the application to continue executing while waiting for the device's response.\n  </p>\n</li>\n</ul>\n<p>\n By using overlapped I/O and event handling, this method ensures the application remains responsive and can manage potential delays or errors in data retrieval from the HID device.\n</p>\n"}, "Page 423": {"response": "<h3>\n Managing Input Reports with\n <code>\n  ReadFile\n </code>\n</h3>\n<p>\n To retrieve input reports from a Human Interface Device (HID), the application needs to handle asynchronous reading properly. The\n <code>\n  ReadFile\n </code>\n function allows the application to request data from the HID, and it works in tandem with event handling for efficient data retrieval.\n</p>\n<h4>\n Buffer and Report Setup:\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Input Report Buffer\n   </strong>\n   : The\n   <code>\n    InputReportBuffer\n   </code>\n   must be a byte array large enough to accommodate both the report ID and the largest input report defined by the HID\u2019s descriptor. The array's size should be determined based on the\n   <code>\n    InputReportByteLength\n   </code>\n   from the\n   <code>\n    HIDP_CAPS\n   </code>\n   structure obtained using the\n   <code>\n    HidP_GetCaps\n   </code>\n   function.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Report Reading Process\n   </strong>\n   : The application uses\n   <code>\n    ReadFile\n   </code>\n   to read the report from the HID. It passes the handle from\n   <code>\n    CreateFile\n   </code>\n   , the buffer where the report will be stored, the report\u2019s size, and an\n   <code>\n    OVERLAPPED\n   </code>\n   structure with an event object. The event object signals when the operation is complete. After calling\n   <code>\n    ReadFile\n   </code>\n   , the application uses\n   <code>\n    WaitForSingleObject\n   </code>\n   to wait for the report to arrive or for a timeout.\n  </p>\n</li>\n</ul>\n<h4>\n Report Handling and Timing:\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Report Data\n   </strong>\n   : Once\n   <code>\n    WaitForSingleObject\n   </code>\n   returns successfully (indicating that the report has been read), the first byte in the\n   <code>\n    InputReportBuffer\n   </code>\n   is the report ID. The subsequent bytes contain the actual report data from the device. If the HID uses the default report ID of 0, this ID will not be transmitted over the bus but will still be present in the buffer when the report is returned.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Data Retrieval\n   </strong>\n   : When\n   <code>\n    ReadFile\n   </code>\n   is called, it doesn't initiate any new data transfer. Instead, it retrieves a report that the host has previously requested through periodic interrupt IN transfers. If there are no reports waiting,\n   <code>\n    ReadFile\n   </code>\n   will block until one is available.\n  </p>\n</li>\n</ul>\n<h4>\n Report Buffering and Loss Prevention:\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Ring Buffer\n   </strong>\n   : HID reports are stored in a ring buffer by the HID driver. As new reports are received, they overwrite the oldest reports in the buffer once it reaches its maximum size. The default buffer size varies across different Windows versions. For example:\n  </p>\n<ul>\n<li>\n    Windows 98 Gold has a buffer size of 2.\n   </li>\n<li>\n    Windows XP has a buffer size of 32.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Multiple Applications\n   </strong>\n   : Each application that has read access to the HID has its own input buffer. This means multiple applications can read the same reports without conflict.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Buffer Overrun\n   </strong>\n   : If an application doesn\u2019t request reports frequently enough, some reports may be missed. To avoid losing reports, the application can increase the buffer size used with\n   <code>\n    ReadFile\n   </code>\n   . If multiple reports are available,\n   <code>\n    ReadFile\n   </code>\n   will return as many reports as can fit in the buffer. This ensures that no data is lost, but if the buffer is too small, older reports might be overwritten before the application reads them.\n  </p>\n</li>\n</ul>\n<p>\n By handling the buffer sizes and properly managing the timing of report requests, an application can efficiently interact with an HID and ensure that no important data is lost.\n</p>\n"}, "Page 424": {"response": "<h3>\n Troubleshooting\n <code>\n  ReadFile\n </code>\n Issues in HID Communication\n</h3>\n<p>\n When dealing with\n <code>\n  ReadFile\n </code>\n for Human Interface Devices (HIDs), there are several key factors to consider in order to avoid losing data or encountering delays. These factors include buffer size, report management, and understanding the Idle rate behavior.\n</p>\n<h4>\n Avoiding Data Loss with Feature Reports:\n</h4>\n<p>\n If you want to prevent the loss of reports, consider using\n <strong>\n  Feature Reports\n </strong>\n instead of relying on Input Reports. These allow for more reliable data retrieval, especially in situations where the application may not be reading reports frequently enough. Feature reports can be a more controlled way to request specific data when needed.\n</p>\n<p>\n For time-sensitive transfers, refer to the tips in\n <strong>\n  Chapter 3\n </strong>\n , which discuss how to handle such operations effectively.\n</p>\n<h4>\n Idle Rate and Report Transmission:\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Idle Rate\n   </strong>\n   : The Idle rate determines whether a device sends a report if the data has not changed since the last transfer. By default, during enumeration, Windows sets the Idle rate to 0. This means the device only sends a report when the data has changed.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Changing the Idle Rate\n   </strong>\n   : Unfortunately, there is no direct API call that allows applications to modify the Idle rate. However, the device firmware can manage this by either allowing or preventing reports from being sent. If the firmware doesn't support the Idle rate changes, it can return a\n   <strong>\n    STALL\n   </strong>\n   response to the host's Set_Idle request, indicating that the request is not supported. In some cases, the firmware can implement Idle rate behavior using a timer.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Device Firmware Control\n   </strong>\n   : To manage report sending behavior more effectively, the firmware can be programmed to only send a report once. After sending it, the firmware can configure the endpoint to return a NAK (negative acknowledgment) in response to IN token packets until new data is available. This prevents the device from sending the same report repeatedly unless there's new data to send.\n  </p>\n</li>\n</ul>\n<h4>\n Common Causes of\n <code>\n  ReadFile\n </code>\n Not Returning:\n</h4>\n<p>\n If\n <code>\n  ReadFile\n </code>\n is not returning or hanging indefinitely, here are some potential reasons:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    NAK Responses from Interrupt IN Endpoint\n   </strong>\n   : The interrupt IN endpoint may be configured to NAK the IN token packets because it hasn\u2019t been set up to send the report data. The endpoint should be pre-configured to send the initial report when the first interrupt occurs.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Mismatched Report Size\n   </strong>\n   : The endpoint may be sending a number of bytes that does not match the expected report size. If the device uses the default report ID (ID 0), the number of bytes sent must match the report size exactly. For other report IDs, the report size should be the number of bytes in the report plus 1 (for the report ID).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Issues with Report ID\n   </strong>\n   : If the report ID is set to zero but the endpoint is not configured to handle this, or if the endpoint is not sending the correct report ID with the data,\n   <code>\n    ReadFile\n   </code>\n   will fail to retrieve the data properly.\n  </p>\n</li>\n</ol>\n<p>\n By carefully managing the Idle rate, report sending behavior, and endpoint configurations, you can troubleshoot and ensure more reliable communication between your application and HID devices.\n</p>\n"}, "Page 425": {"response": "<h3>\n Writing a Feature Report to the Device\n</h3>\n<p>\n To send a\n <strong>\n  Feature Report\n </strong>\n to a device, you can use the\n <code>\n  HidD_SetFeature\n </code>\n function. This function sends a\n <strong>\n  Set_Report\n </strong>\n request followed by the report itself in a control transfer.\n</p>\n<h4>\n Visual C++ Example:\n</h4>\n<p>\n The\n <code>\n  HidD_SetFeature\n </code>\n function is declared as follows:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n BOOLEAN\n HidD_SetFeature\n (\n    IN HANDLE HidDeviceObject,\n    IN PVOID ReportBuffer,\n    IN ULONG ReportBufferLength\n)\n ;\n</code>\n<p>\n This is an example code snippet to call the function:\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n CHAR OutFeatureReportBuffer[\n 3\n ];\nBOOLEAN Result;\n // The first byte in the report buffer is the Report ID.\n OutFeatureReportBuffer[\n 0\n ] =\n 0\n ;\n // Store data to send in FeatureReport[] in the bytes following the Report ID.\n OutFeatureReportBuffer[\n 1\n ] =\n 79\n ;\n // Example data\n OutFeatureReportBuffer[\n 2\n ] =\n 75\n ;\n // Example data\n Result =\n HidD_SetFeature\n (\n    DeviceHandle, \n    OutFeatureReportBuffer, \n    Capabilities.FeatureReportByteLength\n);\n</code>\n<h3>\n Key Points:\n</h3>\n<ul>\n<li>\n  The\n  <strong>\n   first byte\n  </strong>\n  of the report buffer is reserved for the\n  <strong>\n   Report ID\n  </strong>\n  .\n </li>\n<li>\n  After the Report ID, you can add the actual\n  <strong>\n   data\n  </strong>\n  to be sent to the device.\n </li>\n<li>\n  The function\n  <code>\n   HidD_SetFeature\n  </code>\n  requires the\n  <strong>\n   DeviceHandle\n  </strong>\n  (obtained from a prior call like\n  <code>\n   CreateFile\n  </code>\n  ), the\n  <strong>\n   buffer\n  </strong>\n  that holds the report data, and the\n  <strong>\n   length\n  </strong>\n  of the report (which is available from the\n  <code>\n   Capabilities.FeatureReportByteLength\n  </code>\n  property).\n </li>\n</ul>\n<p>\n This function sends the Feature Report to the device via a control transfer, allowing you to modify device settings or control the device through specific features.\n</p>\n"}, "Page 426": {"response": "<h3>\n Writing a Feature Report to the Device (Visual Basic)\n</h3>\n<p>\n To send a\n <strong>\n  Feature Report\n </strong>\n to a device in Visual Basic, the function\n <code>\n  HidD_SetFeature\n </code>\n is used. This function sends a\n <strong>\n  Set_Report\n </strong>\n request along with the report data in a control transfer.\n</p>\n<h4>\n Function Declaration:\n</h4>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;DllImport(\n \"hid.dll\"\n )&gt; _\n Function\n HidD_SetFeature _\n    (\n ByVal\n HidDeviceObject\n As\n Integer\n , _\n ByRef\n lpReportBuffer\n As\n Byte\n , _\n ByVal\n ReportBufferLength\n As\n Integer\n ) _\n As\n Boolean\n End\n Function\n</code>\n<h4>\n Example Code to Call the Function:\n</h4>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Dim\n OutFeatureReportBuffer _\n    (Capabilities.FeatureReportByteLength -\n 1\n )\n as\n Byte\n Dim\n Success\n As\n Boolean\n ' The first byte in the report buffer is the report ID:\n OutFeatureReportBuffer(\n 0\n ) =\n 0\n ' Example report data following the report ID:\n OutFeatureReportBuffer(\n 1\n ) =\n 55\n OutFeatureReportBuffer(\n 2\n ) =\n 41\n ' Call the HidD_SetFeature function to send the report:\n Success = HidD_SetFeature _\n    (DeviceHandle, _\n    OutFeatureReportBuffer(\n 0\n ), _\n    Capabilities.FeatureReportByteLength)\n</code>\n<h3>\n Key Points:\n</h3>\n<ul>\n<li>\n  A\n  <strong>\n   byte array\n  </strong>\n  is used to hold the report that you want to send to the device.\n </li>\n<li>\n  The\n  <strong>\n   first byte\n  </strong>\n  of the array is reserved for the\n  <strong>\n   Report ID\n  </strong>\n  .\n </li>\n<li>\n  The length of the Feature report (plus the Report ID byte) is provided by the\n  <code>\n   HIDP_CAPS\n  </code>\n  structure, which can be retrieved using the\n  <code>\n   HidP_GetCaps\n  </code>\n  function.\n </li>\n<li>\n  The\n  <code>\n   HidD_SetFeature\n  </code>\n  function requires:\n  <ul>\n<li>\n    A\n    <strong>\n     handle\n    </strong>\n    to the HID device (e.g., obtained using\n    <code>\n     CreateFile\n    </code>\n    ).\n   </li>\n<li>\n    The\n    <strong>\n     address\n    </strong>\n    of the first byte of the report buffer.\n   </li>\n<li>\n    The\n    <strong>\n     length\n    </strong>\n    of the buffer (which is the size of the Feature Report plus the Report ID byte).\n   </li>\n</ul>\n</li>\n<li>\n  If the function executes successfully, it returns\n  <strong>\n   True\n  </strong>\n  . If the device does not acknowledge (NAKs) the report data, the function times out and returns\n  <strong>\n   False\n  </strong>\n  .\n </li>\n</ul>\n<p>\n This function is typically used to configure or control device settings that don't require continuous polling, such as setting specific features or configurations on the device.\n</p>\n"}, "Page 427": {"response": "<h3>\n Reading a Feature Report from a Device\n</h3>\n<p>\n To read a\n <strong>\n  Feature Report\n </strong>\n from a device, the\n <strong>\n  HidD_GetFeature\n </strong>\n API function is used. This function sends a\n <strong>\n  Get_Feature\n </strong>\n request as a control transfer, and the device responds by returning the requested report in the Data stage.\n</p>\n<h4>\n Visual C++ Example:\n</h4>\n<p>\n<strong>\n  Function Declaration:\n </strong>\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n BOOLEAN\n HidD_GetFeature\n (\n    IN HANDLE HidDeviceObject,\n    OUT PVOID ReportBuffer,\n    IN ULONG ReportBufferLength\n)\n ;\n</code>\n<p>\n<strong>\n  Code to Call the Function:\n </strong>\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n BOOLEAN Result;\nCHAR InFeatureReportBuffer[\n 3\n ];\n // The first byte in the report buffer is the report ID:\n InFeatureReportBuffer[\n 0\n ] =\n 0\n ;\n\nResult =\n HidD_GetFeature\n (DeviceHandle,\n    InFeatureReportBuffer,\n    Capabilities.FeatureReportByteLength);\n</code>\n<h3>\n Explanation:\n</h3>\n<ul>\n<li>\n<strong>\n   HidD_GetFeature\n  </strong>\n  is used to request a Feature Report from the device.\n </li>\n<li>\n  The function requires:\n  <ul>\n<li>\n    A\n    <strong>\n     handle\n    </strong>\n    to the HID device (\n    <code>\n     DeviceHandle\n    </code>\n    ).\n   </li>\n<li>\n    A\n    <strong>\n     pointer\n    </strong>\n    to a buffer (\n    <code>\n     InFeatureReportBuffer\n    </code>\n    ) where the device will store the returned Feature report.\n   </li>\n<li>\n    The\n    <strong>\n     length\n    </strong>\n    of the report (\n    <code>\n     Capabilities.FeatureReportByteLength\n    </code>\n    ), which is the total size of the report plus the Report ID byte.\n   </li>\n</ul>\n</li>\n<li>\n  The\n  <strong>\n   first byte\n  </strong>\n  of the buffer holds the\n  <strong>\n   Report ID\n  </strong>\n  . The following bytes contain the report data returned from the device.\n </li>\n</ul>\n<p>\n This function allows applications to retrieve configuration or status information from a device, which is typically used for one-time settings or adjustments, rather than continuous data transfers.\n</p>\n"}, "Page 428": {"response": "<h3>\n Reading a Feature Report from a Device (Visual Basic)\n</h3>\n<p>\n To read a\n <strong>\n  Feature Report\n </strong>\n from a device using Visual Basic, the\n <code>\n  HidD_GetFeature\n </code>\n API function is employed. This function sends a\n <strong>\n  Get_Feature\n </strong>\n request via a control transfer and retrieves the report data in the Data stage.\n</p>\n<h4>\n Visual Basic Example:\n</h4>\n<p>\n<strong>\n  Function Declaration:\n </strong>\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;DllImport(\n \"hid.dll\"\n )&gt;\n Function\n HidD_GetFeature _\n    (\n ByVal\n HidDeviceObject\n As\n Integer\n , _\n ByRef\n lpReportBuffer\n As\n Byte\n , _\n ByVal\n ReportBufferLength\n As\n Integer\n ) _\n As\n Boolean\n End\n Function\n</code>\n<p>\n<strong>\n  Code to Call the Function:\n </strong>\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n Dim\n InFeatureReportBuffer _\n    (Capabilities.FeatureReportByteLength -\n 1\n )\n As\n Byte\n Dim\n Success\n As\n Boolean\n ' The first byte in the report buffer is the report ID:\n InFeatureReportBuffer(\n 0\n ) =\n 0\n Success = HidD_GetFeature _\n    (DeviceHandle, _\n    InFeatureReportBuffer(\n 0\n ), _\n    Capabilities.FeatureReportByteLength)\n</code>\n<h3>\n Explanation:\n</h3>\n<ul>\n<li>\n<strong>\n   HidD_GetFeature\n  </strong>\n  is called to retrieve a\n  <strong>\n   Feature Report\n  </strong>\n  from the device.\n </li>\n<li>\n  The function requires:\n  <ul>\n<li>\n    A\n    <strong>\n     handle\n    </strong>\n    to the HID device (\n    <code>\n     DeviceHandle\n    </code>\n    ).\n   </li>\n<li>\n    A\n    <strong>\n     byte array\n    </strong>\n    (\n    <code>\n     InFeatureReportBuffer\n    </code>\n    ) to store the returned report. The first byte in this array is reserved for the\n    <strong>\n     Report ID\n    </strong>\n    .\n   </li>\n<li>\n    The\n    <strong>\n     length\n    </strong>\n    of the report (\n    <code>\n     Capabilities.FeatureReportByteLength\n    </code>\n    ), which includes the Report ID byte plus the actual report data.\n   </li>\n</ul>\n</li>\n<li>\n  The\n  <strong>\n   function returns True\n  </strong>\n  if it successfully retrieves the report. If the device continues to\n  <strong>\n   NAK (Negative Acknowledge)\n  </strong>\n  during the Data stage of the transfer, the function will time out and return False.\n </li>\n</ul>\n<h3>\n Details:\n</h3>\n<ul>\n<li>\n  The\n  <strong>\n   byte array\n  </strong>\n  stores the retrieved report. The\n  <strong>\n   first byte\n  </strong>\n  contains the\n  <strong>\n   Report ID\n  </strong>\n  , and the remaining bytes contain the actual report data.\n </li>\n<li>\n  The report length is obtained from the\n  <strong>\n   HIDP_CAPS structure\n  </strong>\n  (via\n  <code>\n   HidP_GetCaps\n  </code>\n  ), which includes the\n  <strong>\n   Feature Report\n  </strong>\n  size plus one byte for the\n  <strong>\n   Report ID\n  </strong>\n  .\n </li>\n<li>\n  If the device does not respond correctly or times out, the function will not return successfully.\n </li>\n</ul>\n<h3>\n Reading an Input Report (Similar Process):\n</h3>\n<ul>\n<li>\n  Similarly to reading a\n  <strong>\n   Feature Report\n  </strong>\n  , reading an\n  <strong>\n   Input Report\n  </strong>\n  can be done using the\n  <code>\n   HidD_GetInputReport\n  </code>\n  function. This also uses a control transfer and requires passing a handle to the HID, a pointer to a byte array to hold the report, and the report length plus one byte for the Report ID.\n </li>\n</ul>\n<p>\n This functionality is commonly used for retrieving device settings or status information in response to a request.\n</p>\n"}, "Page 429": {"response": "<h3>\n Closing Communications with a Device\n</h3>\n<p>\n When communication with a device is complete, it is important to properly close any resources and clean up. This process includes closing handles that were opened for device interaction and freeing any memory buffers that were allocated for device data.\n</p>\n<h4>\n Steps to Properly Close Communication:\n</h4>\n<ol>\n<li>\n<strong>\n   Closing Handles:\n  </strong>\n<ul>\n<li>\n    After finishing communication, use the\n    <code>\n     CloseHandle\n    </code>\n    function to close any handles that were opened using\n    <code>\n     CreateFile\n    </code>\n    (as discussed in Chapter 10).\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Freeing PreparsedData:\n  </strong>\n<ul>\n<li>\n    When finished using the\n    <strong>\n     PreparsedData\n    </strong>\n    buffer obtained from the\n    <code>\n     HidD_GetPreparsedData\n    </code>\n    function, it is necessary to call\n    <code>\n     HidD_FreePreparsedData\n    </code>\n    to free the memory and prevent leaks.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Visual C++ Example:\n</h4>\n<p>\n<strong>\n  Function Declaration for\n  <code>\n   HidD_FreePreparsedData\n  </code>\n  :\n </strong>\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n BOOLEAN\n HidD_FreePreparsedData\n (\n    IN PHIDP_PREPARSED_DATA PreparsedData\n)\n ;\n</code>\n<p>\n<strong>\n  Code to Call the Function:\n </strong>\n</p>\ncpp\nCopy code\n<code class=\"!whitespace-pre hljs language-cpp\">\n HidD_FreePreparsedData\n (PreparsedData);\n</code>\n<h4>\n Visual Basic Example:\n</h4>\n<p>\n<strong>\n  Function Declaration for\n  <code>\n   HidD_FreePreparsedData\n  </code>\n  :\n </strong>\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n &lt;DllImport(\n \"hid.dll\"\n )&gt; _\n Function\n HidD_FreePreparsedData _\n    (\n ByRef\n PreparsedData\n As\n IntPtr) _\n As\n Boolean\n End\n Function\n</code>\n<p>\n<strong>\n  Code to Call the Function:\n </strong>\n</p>\nvb\nCopy code\n<code class=\"!whitespace-pre hljs language-vb\">\n HidD_FreePreparsedData(PreparsedData)\n</code>\n<h3>\n Explanation:\n</h3>\n<ul>\n<li>\n<p>\n<strong>\n<code>\n     CloseHandle\n    </code>\n</strong>\n   is used to close any handles that were created to communicate with the device. This is a necessary cleanup step to free system resources.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n<code>\n     HidD_FreePreparsedData\n    </code>\n</strong>\n   is called to release the\n   <strong>\n    PreparsedData\n   </strong>\n   buffer that was previously allocated by the\n   <code>\n    HidD_GetPreparsedData\n   </code>\n   function. This buffer contains information about the device's report descriptors, and once it is no longer needed, it should be freed to avoid memory leaks.\n  </p>\n</li>\n</ul>\n<p>\n By properly closing handles and freeing resources, you ensure that your application does not consume unnecessary resources and behaves efficiently.\n</p>\n"}, "Page 430": {"response": "<h3>\n Bulk Transfers for Any CPU\n</h3>\n<p>\n This chapter introduces two example applications using FTDI Chip\u2019s FT245BM and FT232BM device controllers, which allow various CPUs\u2014whether they have a parallel or asynchronous serial interface\u2014to communicate with a USB host. These controllers simplify USB communication by handling tasks like enumeration automatically, without needing USB-specific programming.\n</p>\n<h4>\n Two Example Applications\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    First Example (FT232BM with Asynchronous Serial Interface):\n   </strong>\n</p>\n<ul>\n<li>\n    This application uses the FT232BM chip, which connects to a Microchip PICMicro 16F877 microcontroller. The FT232BM chip provides an asynchronous serial interface for communication.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Second Example (FT245BM with Parallel Interface):\n   </strong>\n</p>\n<ul>\n<li>\n    The second example uses the FT245BM chip, which has a parallel interface for communication with the microcontroller.\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n Both examples use firmware written for the\n <strong>\n  PicBasic Pro Basic compiler\n </strong>\n by microEngineering Labs. However, the code can be adapted for use with other programming languages.\n</p>\n<p>\n This chapter provides further details and tips on designing systems using these FTDI controllers. These controllers enable developers to interface CPUs with USB hosts easily, without needing to dive into complex USB protocols.\n</p>\n"}, "Page 431": {"response": "<h3>\n Asynchronous Serial Interface for FT232BM\n</h3>\n<p>\n The FT232BM chip, which features a USB port and an asynchronous serial interface, allows communication with an external CPU. Writing device firmware and host applications for this chip requires minimal knowledge of USB specifics. However, having an understanding of USB can help you better grasp the chip\u2019s capabilities and limitations.\n</p>\n<h4>\n The Circuit\n</h4>\n<p>\n<strong>\n  Figure 14-1\n </strong>\n illustrates an example circuit. The DLP-232M module from DLP Design includes the FT232BM chip, an EEPROM for storing configuration data, and a USB connector. In this example, the circuit is built using microEngineering Labs, Inc.\u2019s LAB-X2 board. This board contains a 40-pin DIP socket for the PICMicro 16F877 microcontroller, a power supply regulator, and a 40-pin header for easy access to the microcontroller\u2019s port pins.\n</p>\n<p>\n While the circuit uses the LAB-X2 board in this example, it is possible to use any FT232BM-based circuit following FTDI Chip\u2019s reference schematic, paired with any CPU that has an asynchronous serial port.\n</p>\n<p>\n For the LAB-X2 board specifically:\n</p>\n<ul>\n<li>\n  The MAX232 chip should be removed from its socket because the microcontroller\u2019s serial-port pins are now connected to the FT232BM instead.\n </li>\n<li>\n  If hardware handshaking is used, switches S1 and S2 on the board won\u2019t be available.\n </li>\n</ul>\n<h4>\n Data Transmission\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Sending Data to the Host:\n   </strong>\n</p>\n<ul>\n<li>\n    The microcontroller\u2019s firmware writes serial data to its TX output, which is connected to the RXD input of the DLP-232M module.\n   </li>\n<li>\n    The RXD pin on the DLP-232M then connects to the RXD pin of the FT232BM.\n   </li>\n<li>\n    Once the FT232BM receives data at its RXD pin, it sends that data via its USB port to the host computer.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Receiving Data from the Host:\n   </strong>\n</p>\n<ul>\n<li>\n    When the FT232BM receives USB data from the host computer, it writes the data to its TXD output.\n   </li>\n<li>\n    This TXD output connects to the RX pin on the DLP-232M and the RX input on the microcontroller.\n   </li>\n<li>\n    The microcontroller\u2019s firmware then reads the received data from the RX pin.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Optional Features\n</h4>\n<ul>\n<li>\n<strong>\n   LED Indicators:\n  </strong>\n  The circuit includes two optional LEDs that flash when the FT232BM is either sending data to or receiving data from the host PC.\n </li>\n<li>\n<strong>\n   Hardware Handshaking:\n  </strong>\n  The circuit also supports hardware handshaking. When both the FT232BM and the microcontroller are configured to use this feature, it provides additional control for data flow between the devices.\n </li>\n</ul>\n<p>\n This design makes it straightforward to use the FT232BM for communication with an external CPU using USB, allowing the creation of systems with minimal USB-specific knowledge while leveraging the power of the FT232BM chip.\n</p>\n"}, "Page 432": {"response": "<h3>\n FT232BM USB UART Interface for CPUs with Asynchronous Serial Ports\n</h3>\n<p>\n<strong>\n  Figure 14-1\n </strong>\n shows how the FT232BM USB UART from FTDI can connect to nearly any CPU with an asynchronous serial port. This interface provides a simple and effective way to add USB connectivity to a system with minimal effort and knowledge of USB protocol.\n</p>\n"}, "Page 433": {"response": "<h3>\n FT232BM Serial Communication with the PIC16F877 Microcontroller\n</h3>\n<p>\n The FT232BM provides an asynchronous serial interface to the PIC16F877 microcontroller. Here's an overview of the key points in establishing communication:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Handshaking Mechanism\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The FT232BM only transmits data when the PIC16F877 brings the RTS# (Request to Send) line low, signaling readiness for transmission.\n   </li>\n<li>\n    Similarly, the PIC16F877 only transmits when the FT232BM brings the CTS# (Clear to Send) line low, indicating it is ready to receive data.\n   </li>\n<li>\n    If the handshaking signals are not active (high), the sender must wait.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Microcontroller Handshaking\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Microcontrollers like the PIC16F877 often do not have dedicated pins for serial handshaking. Instead, spare port pins are used to manage and monitor the RTS and CTS lines through software-controlled firmware.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Power Supply Considerations\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The circuit typically uses its own +5V power supply. However, if bus power is used for the DLP-USB232M module, certain pins such as VCC-IO, EXTVCC, and RESET# should be connected to the PORTVCC.\n   </li>\n<li>\n    Bus-powered circuits must limit their current to 100 milliamps initially until the host USB device is configured. Additionally, they need to reduce power consumption in the Suspend state.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Programming the CPU\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Programming the microcontroller to handle asynchronous serial communication with the FT232BM does not require knowledge of USB protocols. The FT232BM handles the USB communication independently.\n   </li>\n<li>\n    The communication between the PIC16F877's USART (Universal Synchronous Asynchronous Receiver Transmitter) and the FT232BM is an asynchronous serial connection. The microcontroller's USART transmits data on the TX pin and receives data on the RX pin.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Sample Program Code\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    An example program in\n    <strong>\n     PicBasic Pro\n    </strong>\n    demonstrates how the PIC16F877 communicates with the FT232BM:\n    <ul>\n<li>\n      The PIC16F877 reads a byte received from the USB host, increments it, and sends it back to the host.\n     </li>\n<li>\n      The program uses two port bits for handshaking:\n      <ul>\n<li>\n<strong>\n         PORTB.4\n        </strong>\n        for CTS output (indicating readiness to receive data).\n       </li>\n<li>\n<strong>\n         PORTB.5\n        </strong>\n        for RTS input (indicating the status of the sender).\n       </li>\n</ul>\n</li>\n<li>\n      The program ensures the RTS# line is low to signal readiness, and when the FT232BM detects this, it writes the received byte to the microcontroller\u2019s RX pin.\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>\n This communication setup allows for easy integration of USB functionality into a project with minimal USB-specific knowledge.\n</p>\n"}, "Page 434": {"response": "<h3>\n PicBasic Pro Code for FT232BM Communication with PIC16F877\n</h3>\n<p>\n This code demonstrates how to enable communication between a\n <strong>\n  PIC16F877\n </strong>\n microcontroller and an\n <strong>\n  FTDI Chip FT232BM\n </strong>\n via asynchronous serial communication. The code configures the serial communication settings and handshaking signals (CTS and RTS).\n</p>\n<h4>\n Key Definitions and Setup:\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Serial Communication Registers\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<code>\n     DEFINE HSER_CLROERR 1\n    </code>\n    : Automatically clears any receive overflow errors.\n   </li>\n<li>\n<code>\n     DEFINE HDER_BAUD 2400\n    </code>\n    : Sets the baud rate for serial communication to 2400 bps.\n   </li>\n<li>\n<code>\n     DEFINE HSER_RCSTA 90h\n    </code>\n    : Enables the serial receiver.\n   </li>\n<li>\n<code>\n     DEFINE HER_TXSTA 20h\n    </code>\n    : Enables the serial transmitter.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Handshaking Configuration\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<code>\n     CTS VAR PORTB.4\n    </code>\n    : Assigns a port pin (PORTB.4) for the\n    <strong>\n     CTS\n    </strong>\n    (Clear to Send) signal.\n   </li>\n<li>\n<code>\n     RTS VAR PORTB.5\n    </code>\n    : Assigns a port pin (PORTB.5) for the\n    <strong>\n     RTS\n    </strong>\n    (Request to Send) signal.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Other Variables\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<code>\n     error VAR BYTE\n    </code>\n    : A variable to store error codes.\n   </li>\n<li>\n<code>\n     byte_was_received VAR BIT\n    </code>\n    : A flag indicating whether a byte was received.\n   </li>\n<li>\n<code>\n     serial_in VAR BYTE\n    </code>\n    : A variable to store incoming serial data.\n   </li>\n<li>\n<code>\n     serial_out VAR BYTE\n    </code>\n    : A variable to store outgoing serial data.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Pin Configuration:\n</h4>\n<ul>\n<li>\n  The\n  <strong>\n   CTS\n  </strong>\n  output (PORTB.4) connects to the\n  <strong>\n   RTS#\n  </strong>\n  input on the FT232BM.\n </li>\n<li>\n  The\n  <strong>\n   RTS\n  </strong>\n  input (PORTB.5) connects to the\n  <strong>\n   CTS#\n  </strong>\n  output on the FT232BM.\n </li>\n<li>\n  The\n  <strong>\n   CTS\n  </strong>\n  pin is set as an output and the\n  <strong>\n   RTS\n  </strong>\n  pin as an input.\n </li>\n</ul>\n<h4>\n Interrupt and Interrupt Service Routine:\n</h4>\n<ul>\n<li>\n  The program is configured to jump to an interrupt service routine upon detecting a hardware interrupt:\n  <ul>\n<li>\n<code>\n     ON INTERRUPT GOTO interrupt_service\n    </code>\n    : Executes the\n    <code>\n     interrupt_service\n    </code>\n    routine on an interrupt.\n   </li>\n<li>\n<code>\n     INTCON = %11000000\n    </code>\n    : Enables global and peripheral interrupts.\n   </li>\n<li>\n<code>\n     PIE1 = %00100000\n    </code>\n    : Enables the serial receive peripheral interrupt.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Initial Handshaking:\n</h4>\n<ul>\n<li>\n  The program signals to the FT232BM that it's okay to send a byte by setting the\n  <strong>\n   CTS\n  </strong>\n  line low (\n  <code>\n   CTS = 0\n  </code>\n  ) and setting the\n  <code>\n   byte_was_received\n  </code>\n  flag to 0, indicating no data has been received yet.\n </li>\n</ul>\n<p>\n This code essentially configures the serial communication settings for the PIC16F877, sets up the necessary handshaking signals for proper data flow, and prepares the system for interrupt-driven communication.\n</p>\n"}, "Page 435": {"response": "<h3>\n Main Program Loop for FT232BM Communication in PicBasic Pro\n</h3>\n<p>\n This part of the code defines the\n <strong>\n  main program loop\n </strong>\n for handling serial communication between the\n <strong>\n  PIC16F877\n </strong>\n microcontroller and the\n <strong>\n  FTDI Chip FT232BM\n </strong>\n . The loop processes received serial data, increments the byte, and sends it back to the host.\n</p>\n<h4>\n Main Loop Explanation:\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Check for Received Data\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<code>\n     if byte_was_received = 1 then\n    </code>\n    : The program checks if a byte has been received. This flag is set when data is available.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Check if FT232BM is Ready to Receive\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<code>\n     if RTS = 0 then\n    </code>\n    : It verifies whether the\n    <strong>\n     RTS\n    </strong>\n    (Request to Send) signal is low, indicating that the FT232BM is ready to accept data.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Process Received Data\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    If the\n    <strong>\n     RTS\n    </strong>\n    line is low and data is available:\n    <ul>\n<li>\n<strong>\n       Increment the received byte\n      </strong>\n      :\n      <ul>\n<li>\n<code>\n         If (serial_in = 255) then serial_out = 0\n        </code>\n        : If the received byte is 255, it resets the value of the byte to 0.\n       </li>\n<li>\n<code>\n         else serial_out = (serial_in + 1) endif\n        </code>\n        : Otherwise, it increments the byte by 1.\n       </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Transmit the Data\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<code>\n     HSEROUT [serial_out]\n    </code>\n    : The incremented byte is transmitted back through the serial port using\n    <code>\n     HSEROUT\n    </code>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Prepare for the Next Data\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<code>\n     byte_was_received = 0\n    </code>\n    : Resets the flag, indicating that the byte has been processed and the system is ready for another.\n   </li>\n<li>\n<code>\n     CTS = 0\n    </code>\n    : The\n    <strong>\n     CTS\n    </strong>\n    line is set low to indicate readiness to receive the next byte.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Repeat the Process\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<code>\n     GOTO loop\n    </code>\n    : The program jumps back to the start of the loop to repeat the process.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Summary:\n</h4>\n<p>\n This part of the code continuously monitors for incoming data, processes it (in this case by incrementing the byte), and then sends the modified data back to the host. The handshaking signals (CTS and RTS) ensure that the data flow is managed properly between the microcontroller and the FT232BM.\n</p>\n"}, "Page 436": {"response": "<h3>\n Interrupt Service Routine for FT232BM Communication in PicBasic Pro\n</h3>\n<p>\n This section of code defines the\n <strong>\n  Interrupt Service Routine (ISR)\n </strong>\n used to handle hardware interrupts triggered by serial data events. The routine is responsible for detecting incoming data on the serial port, managing handshaking signals, and ensuring error-free data processing.\n</p>\n<h4>\n ISR Explanation:\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Disable Interrupts\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<code>\n     DISABLE INTERRUPT\n    </code>\n    : Interrupts are disabled at the start of the routine to prevent nested interrupts or further interrupts while the routine is executing.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Check for Incoming Data\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<code>\n     if ((PIR1 &amp; %00100000) = %00100000) then\n    </code>\n    : The program checks if a serial byte has been received. This is done by inspecting the\n    <strong>\n     PIR1\n    </strong>\n    register's flag related to the serial port receive interrupt.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Handle CTS (Clear to Send) Signal\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<code>\n     CTS = 1\n    </code>\n    : When the interrupt is triggered by data being received, the program sets the\n    <strong>\n     CTS\n    </strong>\n    (Clear to Send) signal high to prevent the FT232BM from sending more data while the current byte is being processed.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Check for Framing Errors\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<code>\n     error = (RCSTA &amp; %000000100)\n    </code>\n    : The program checks the\n    <strong>\n     RCSTA\n    </strong>\n    register for any framing errors by inspecting the relevant bit.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Store Received Data\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<code>\n     HSERIN [serial_in]\n    </code>\n    : The received byte is stored in the\n    <strong>\n     serial_in\n    </strong>\n    variable using the\n    <strong>\n     HSERIN\n    </strong>\n    command. This operation also clears any framing error flags in the process.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Verify Data Integrity\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<code>\n     if error = 0 then\n    </code>\n    : If no framing error occurred, the program sets the flag\n    <strong>\n     byte_was_received\n    </strong>\n    to 1, signaling the main program loop that a valid byte is ready for further processing.\n   </li>\n<li>\n<code>\n     byte_was_received = 1\n    </code>\n    : This flag indicates to the main program loop that new data has been successfully received and should be sent back to the host.\n   </li>\n<li>\n<code>\n     else CTS = 0\n    </code>\n    : If a framing error occurred, the program sets\n    <strong>\n     CTS\n    </strong>\n    low to enable receiving another byte while ignoring the erroneous data.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Resume Interrupts\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<code>\n     RESUME\n    </code>\n    : The interrupt handling is complete, and execution resumes from where it was interrupted.\n   </li>\n<li>\n<code>\n     ENABLE INTERRUPT\n    </code>\n    : Interrupt processing is re-enabled after handling the data.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Summary:\n</h4>\n<p>\n The ISR is responsible for processing incoming serial data when an interrupt occurs. It checks for any errors, processes the received byte, and sets flags to notify the main program loop to send the byte back. If an error is detected, it ensures that the system waits for valid data by controlling the\n <strong>\n  CTS\n </strong>\n signal accordingly. This routine plays a key role in managing the communication between the\n <strong>\n  PIC16F877\n </strong>\n microcontroller and the\n <strong>\n  FT232BM\n </strong>\n .\n</p>\n"}, "Page 437": {"response": "<h3>\n FT245BM Parallel Interface Communication\n</h3>\n<p>\n The\n <strong>\n  FT245BM\n </strong>\n chip operates similarly to the\n <strong>\n  FT232BM\n </strong>\n , but instead of using an asynchronous serial interface, it uses an\n <strong>\n  8-bit parallel interface\n </strong>\n for communication. This section outlines how the FT245BM is used in a circuit and communicates with a microcontroller, specifically focusing on the parallel interface.\n</p>\n<h4>\n Circuit Setup for FT245BM:\n</h4>\n<ul>\n<li>\n<strong>\n   FT245BM Module\n  </strong>\n  : The DLP-245M module, designed by DLP Design, contains the FT245BM chip, an EEPROM for configuration, and a USB connector.\n </li>\n<li>\n<strong>\n   Microcontroller Setup\n  </strong>\n  : The setup uses the\n  <strong>\n   microEngineering Labs' LAB-X2 board\n  </strong>\n  , which includes a 40-pin DIP socket for the\n  <strong>\n   PICMicro 16F877 microcontroller\n  </strong>\n  . This board also contains a power-supply regulator and a 40-pin header for accessing the microcontroller\u2019s pins.\n </li>\n</ul>\n<p>\n Just like with the FT232BM, any\n <strong>\n  parallel interface circuit\n </strong>\n based on FTDI Chip's example schematic can work with any CPU that supports parallel communication. If using the\n <strong>\n  LAB-X2 board\n </strong>\n , ensure to remove unnecessary components like the\n <strong>\n  MAX232 chip\n </strong>\n , as the\n <strong>\n  PIC16F877\u2019s serial-port pins\n </strong>\n are repurposed for use with the FT245BM chip.\n</p>\n<h4>\n Communication Flow:\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Data Sending from Microcontroller\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The microcontroller\u2019s firmware sends data via its\n    <strong>\n     TX\n    </strong>\n    pin, which is connected to the FT245BM\u2019s parallel\n    <strong>\n     RXD\n    </strong>\n    pin.\n   </li>\n<li>\n    Once the FT245BM receives the data on\n    <strong>\n     RXD\n    </strong>\n    , it transmits the data through the\n    <strong>\n     USB\n    </strong>\n    connection to the host computer.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Data Receiving from Host\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    When data is received from the host computer, the FT245BM sends it to the microcontroller via the\n    <strong>\n     TXD\n    </strong>\n    pin, which is connected to the microcontroller's\n    <strong>\n     RX\n    </strong>\n    input.\n   </li>\n<li>\n    The firmware of the microcontroller reads the data at\n    <strong>\n     RX\n    </strong>\n    for further processing.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    LED Indicators\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The circuit can include optional\n    <strong>\n     LEDs\n    </strong>\n    that flash when the FT245BM is actively sending or receiving data from the PC, providing visual feedback for data transfers.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Handshaking:\n</h4>\n<ul>\n<li>\n<strong>\n   RTS (Request to Send)\n  </strong>\n  and\n  <strong>\n   CTS (Clear to Send)\n  </strong>\n  handshaking signals are used for controlling data flow. For proper handshaking:\n  <ul>\n<li>\n    The\n    <strong>\n     FT245BM\n    </strong>\n    will transmit data only when the\n    <strong>\n     RTS\n    </strong>\n    signal from the microcontroller is low, indicating that the microcontroller is ready to receive.\n   </li>\n<li>\n    Similarly, the microcontroller will transmit data only when\n    <strong>\n     CTS\n    </strong>\n    is low, indicating the FT245BM is ready to receive data.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Power Considerations:\n</h4>\n<ul>\n<li>\n  The circuit can either use its own\n  <strong>\n   5V power supply\n  </strong>\n  or draw power from the USB bus. If using USB bus power, ensure that the current consumption does not exceed USB power limits, particularly the 100mA maximum before device configuration by the host. Devices that draw power from the USB bus must also comply with power limits during the\n  <strong>\n   Suspend state\n  </strong>\n  , as explained in Chapter 16.\n </li>\n</ul>\n<h4>\n Using FT245BM with a Virtual COM Port:\n</h4>\n<p>\n If the FT245BM is installed using the\n <strong>\n  FTDI Chip\u2019s virtual COM port (VCP) drivers\n </strong>\n , the operating system will create a virtual COM port for communication. You can use\n <strong>\n  any application\n </strong>\n that supports COM-port communication (like\n <strong>\n  HyperTerminal\n </strong>\n ) to interact with the device. Here, the\n <strong>\n  COM port settings\n </strong>\n must match the microcontroller\u2019s configuration (e.g., baud rate, data bits, stop bits, and parity settings). These parameters are passed through the\n <strong>\n  vendor-specific requests\n </strong>\n to the FT245BM chip, ensuring that the FT245BM uses these settings for communication over its parallel interface.\n</p>\n<h3>\n Summary:\n</h3>\n<p>\n The\n <strong>\n  FT245BM\n </strong>\n offers a robust parallel interface for communication between a microcontroller and a USB host. It supports handshaking via\n <strong>\n  RTS\n </strong>\n and\n <strong>\n  CTS\n </strong>\n signals for flow control and can be powered either through the USB bus or from an external source. Using FTDI\u2019s\n <strong>\n  VCP drivers\n </strong>\n , the FT245BM enables simple communication via a virtual COM port, making it easy to interface with a wide range of host applications.\n</p>\n"}, "Page 438": {"response": "<h3>\n FT245BM USB FIFO with 8-bit Parallel Interface\n</h3>\n<p>\n The\n <strong>\n  FT245BM\n </strong>\n chip from FTDI Chip is a USB FIFO (First In, First Out) device with an\n <strong>\n  8-bit parallel interface\n </strong>\n . This enables it to easily communicate with various microcontrollers or systems that support parallel communication.\n</p>\n<h4>\n Key Features of the FT245BM:\n</h4>\n<ul>\n<li>\n<strong>\n   Parallel Interface\n  </strong>\n  : Unlike the FT232BM, which uses an asynchronous serial interface, the FT245BM communicates via an\n  <strong>\n   8-bit parallel interface\n  </strong>\n  . This allows for faster data transfers compared to serial communication.\n </li>\n<li>\n<strong>\n   FIFO Buffer\n  </strong>\n  : The chip includes a\n  <strong>\n   FIFO buffer\n  </strong>\n  , ensuring that data is temporarily stored before it is processed or transferred. This buffer helps manage data flow, improving efficiency and reducing the risk of data loss.\n </li>\n<li>\n<strong>\n   USB Interface\n  </strong>\n  : The FT245BM allows the parallel interface to communicate with a USB host, making it compatible with a wide range of systems and devices.\n </li>\n</ul>\n<p>\n This chip is ideal for applications where higher-speed data transfer is necessary, and it can be easily integrated into projects involving microcontrollers or other systems that require a parallel connection.\n</p>\n"}, "Page 439": {"response": "<h3>\n Using the FT245BM with the PICMicro 16F877\n</h3>\n<p>\n The\n <strong>\n  FT245BM\n </strong>\n chip, which provides an 8-bit parallel interface for USB communication, can be connected to a variety of microcontrollers, including the\n <strong>\n  PICMicro 16F877\n </strong>\n . The setup involves a parallel I/O port and four extra spare port pins, making it adaptable to many CPU systems.\n</p>\n<h4>\n Circuit Setup and Operation\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    External CPU Communication\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The FT245BM allows bidirectional data transfer between the PC and the microcontroller.\n   </li>\n<li>\n<strong>\n     Reading Data\n    </strong>\n    : When a byte is written to the FT245BM by the PC, the chip sets its\n    <strong>\n     RXF#\n    </strong>\n    (Receive FIFO Empty) output low to signal that data is available. The external CPU can then read the byte by bringing the\n    <strong>\n     RD#\n    </strong>\n    (Read) input low. Once the byte is read, the CPU sets\n    <strong>\n     RD#\n    </strong>\n    high to finish the operation. The FT245BM will bring\n    <strong>\n     RXF#\n    </strong>\n    low again when more data is available.\n   </li>\n<li>\n<strong>\n     Writing Data\n    </strong>\n    : To send data from the CPU to the PC, the external CPU brings the\n    <strong>\n     WR\n    </strong>\n    (Write) input high. The CPU must wait until the FT245BM sets its\n    <strong>\n     TXE#\n    </strong>\n    (Transmit FIFO Empty) low to indicate readiness. The CPU then places the data on the data pins (D0\u2013D7) and brings\n    <strong>\n     WR\n    </strong>\n    low, sending the byte to the FT245BM, which transmits it to the USB host. Once the byte is written,\n    <strong>\n     TXE#\n    </strong>\n    is set high again, indicating that the chip is ready for the next byte.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Pin Connections\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The data pins are connected to\n    <strong>\n     Port D\n    </strong>\n    on the\n    <strong>\n     16F877\n    </strong>\n    , while the handshaking signals are mapped to\n    <strong>\n     Port B\n    </strong>\n    and\n    <strong>\n     Port E\n    </strong>\n    . Any spare pins can be used for interfacing with the FT245BM\u2019s data pins and control signals.\n   </li>\n<li>\n    The power supply setup is similar to the one used for the\n    <strong>\n     FT232BM\n    </strong>\n    chip.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Program Code Example\n</h4>\n<p>\n The example code (written in\n <strong>\n  PICBasic Pro\n </strong>\n ) waits to receive a byte from the host via the FT245BM, increments the byte, and sends it back. The firmware follows these steps:\n</p>\n<ul>\n<li>\n  It first checks the state of\n  <strong>\n   RXF#\n  </strong>\n  to see if data is available.\n </li>\n<li>\n  When\n  <strong>\n   RXF#\n  </strong>\n  is low, the CPU reads the data from the FT245BM\u2019s data pins.\n </li>\n<li>\n  After processing the data (in this case, incrementing the byte), the firmware then checks the state of\n  <strong>\n   TXE#\n  </strong>\n  to ensure the FT245BM is ready to receive a new byte.\n </li>\n<li>\n  Once\n  <strong>\n   TXE#\n  </strong>\n  is low, the CPU sends the incremented byte back to the FT245BM for transmission to the host.\n </li>\n</ul>\n<p>\n Alternatively, the program could use a hardware interrupt to trigger the action when\n <strong>\n  RXF#\n </strong>\n goes low, indicating data availability. Similarly, it can wait for\n <strong>\n  TXE#\n </strong>\n to be low before writing new data to the FT245BM.\n</p>\n<p>\n This setup demonstrates how simple and effective it is to interface the FT245BM with a microcontroller like the\n <strong>\n  PIC16F877\n </strong>\n , using parallel data transfer for efficient communication with USB devices.\n</p>\n"}, "Page 440": {"response": "<h3>\n FT245BM Read and Write Operations\n</h3>\n<p>\n The\n <strong>\n  FT245BM\n </strong>\n allows two primary types of data transfer between a microcontroller (device CPU) and a USB host: reading and writing.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Read Operation\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    When the FT245BM has a byte of data ready to be read, it pulls its\n    <strong>\n     RXF#\n    </strong>\n    (Receive FIFO) low to signal the device CPU.\n   </li>\n<li>\n    The device CPU then asserts the\n    <strong>\n     RD#\n    </strong>\n    (Read) signal low, which tells the FT245BM to place the byte onto the data pins (\n    <strong>\n     D0\u2013D7\n    </strong>\n    ).\n   </li>\n<li>\n    The CPU reads the byte from the FT245BM, then raises\n    <strong>\n     RD#\n    </strong>\n    high to complete the operation.\n   </li>\n<li>\n    FT245BM will then pull\n    <strong>\n     RXF#\n    </strong>\n    low again when new data is available for reading.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Write Operation\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    In this process, the device CPU places data on the\n    <strong>\n     D0\u2013D7\n    </strong>\n    data pins and waits for the FT245BM to set the\n    <strong>\n     TXE#\n    </strong>\n    (Transmit FIFO Empty) low, indicating that the chip is ready to receive data.\n   </li>\n<li>\n    The device CPU then asserts the\n    <strong>\n     WR\n    </strong>\n    (Write) signal low, causing the FT245BM to load the byte into its transmit buffer and transmit it to the USB host.\n   </li>\n<li>\n    After writing,\n    <strong>\n     TXE#\n    </strong>\n    goes high, signaling the device CPU that the operation is complete and the chip is ready for the next byte.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n These operations ensure smooth and efficient data transfers between the device CPU and the FT245BM, with proper signaling for synchronization.\n</p>\n"}, "Page 441": {"response": "<h3>\n PICBasic Pro Code for FT245BM Communication\n</h3>\n<p>\n This\n <strong>\n  PICBasic Pro code\n </strong>\n enables a\n <strong>\n  PICMicro 16F877\n </strong>\n to interface with an\n <strong>\n  FT245BM\n </strong>\n , which connects the microcontroller\u2019s parallel port to the USB port of a PC. The code demonstrates how to receive a byte from the PC, increment it, and send it back.\n</p>\n<p>\n Key components of the code:\n</p>\n<ol>\n<li>\n<strong>\n   Data Port Configuration\n  </strong>\n  :\n  <ul>\n<li>\n    The\n    <strong>\n     data_port\n    </strong>\n    (connected to\n    <strong>\n     PORTD\n    </strong>\n    ) is used for transferring the data.\n   </li>\n<li>\n    The\n    <strong>\n     data_port_direction\n    </strong>\n    (connected to\n    <strong>\n     TRISD\n    </strong>\n    ) sets the direction of the data pins, allowing the microcontroller to read from or write to the FT245BM.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Control and Status Signals\n  </strong>\n  :\n  <ul>\n<li>\n    The control signals for the FT245BM, such as\n    <strong>\n     RD\n    </strong>\n    (Read) and\n    <strong>\n     WR\n    </strong>\n    (Write), are set as output pins.\n   </li>\n<li>\n    The\n    <strong>\n     RXF\n    </strong>\n    (Receive FIFO) and\n    <strong>\n     TXE\n    </strong>\n    (Transmit FIFO Empty) are set as input pins to check whether data is available for reading or if the FT245BM is ready to write.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Initialization\n  </strong>\n  :\n  <ul>\n<li>\n    The control signals\n    <strong>\n     RD\n    </strong>\n    and\n    <strong>\n     WR\n    </strong>\n    are set to their default states.\n    <strong>\n     RD\n    </strong>\n    is set high (inactive), and\n    <strong>\n     WR\n    </strong>\n    is set low (inactive).\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n The code prepares the microcontroller to communicate with the FT245BM by correctly setting up the necessary control and data lines.\n</p>\n"}, "Page 442": {"response": "<h3>\n Main Program Loop for FT245BM Communication\n</h3>\n<p>\n In this section of the\n <strong>\n  PICBasic Pro code\n </strong>\n , the\n <strong>\n  PICMicro 16F877\n </strong>\n either waits to receive a byte from the\n <strong>\n  FT245BM\n </strong>\n or sends a byte to it, depending on the value of the\n <code>\n  read_or_write\n </code>\n variable.\n</p>\n<p>\n Key aspects of the loop:\n</p>\n<ol>\n<li>\n<strong>\n   Waiting to Receive a Byte (read_or_write = 1)\n  </strong>\n  :\n  <ul>\n<li>\n    The program first checks if\n    <strong>\n     read_or_write\n    </strong>\n    is set to 1, indicating that the microcontroller is waiting for data from the FT245BM.\n   </li>\n<li>\n    It then checks if the\n    <strong>\n     RXF\n    </strong>\n    signal is low (\n    <strong>\n     RXF = 0\n    </strong>\n    ), which means that a byte is available from the FT245BM.\n   </li>\n<li>\n    The\n    <strong>\n     data_port_direction\n    </strong>\n    is set to\n    <strong>\n     INPUTS\n    </strong>\n    , allowing the microcontroller to read the byte from the data port.\n   </li>\n<li>\n<strong>\n     RD\n    </strong>\n    (Read) is brought low to signal the\n    <strong>\n     FT245BM\n    </strong>\n    to place the byte onto the data bus.\n   </li>\n<li>\n    The byte is read from the\n    <strong>\n     data_port\n    </strong>\n    and stored in\n    <strong>\n     data_in\n    </strong>\n    .\n   </li>\n<li>\n    After reading the byte,\n    <strong>\n     RD\n    </strong>\n    is set high again, completing the read operation.\n   </li>\n<li>\n    Finally, the code calls the\n    <strong>\n     process_received_data\n    </strong>\n    subroutine to process the received byte.\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n This process allows the microcontroller to receive data from the FT245BM and take necessary action based on the received byte.\n</p>\n"}, "Page 443": {"response": "<h3>\n Sending a Byte to FT245BM and Switching to Receive Mode\n</h3>\n<p>\n In this part of the\n <strong>\n  PICBasic Pro code\n </strong>\n , the\n <strong>\n  PICMicro 16F877\n </strong>\n is set up to send a byte to the\n <strong>\n  FT245BM\n </strong>\n when\n <strong>\n  read_or_write\n </strong>\n is set to 0. The process involves checking the status of the\n <strong>\n  TXE\n </strong>\n signal and sending data when it's ready.\n</p>\n<p>\n Key aspects of the loop:\n</p>\n<ol>\n<li>\n<strong>\n   Waiting to Send a Byte (read_or_write = 0)\n  </strong>\n  :\n  <ul>\n<li>\n    If\n    <strong>\n     read_or_write\n    </strong>\n    is 0, the program checks if the\n    <strong>\n     TXE\n    </strong>\n    signal is low (\n    <strong>\n     TXE = 0\n    </strong>\n    ), which indicates that the\n    <strong>\n     FT245BM\n    </strong>\n    is ready to receive a byte.\n   </li>\n<li>\n    The\n    <strong>\n     data_port_direction\n    </strong>\n    is set to\n    <strong>\n     OUTPUTS\n    </strong>\n    , allowing the microcontroller to place the byte to be sent on the data port.\n   </li>\n<li>\n    The byte to be sent is written to the\n    <strong>\n     data_port\n    </strong>\n    from\n    <strong>\n     data_out\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     WR\n    </strong>\n    (Write) is brought high and then low to trigger the\n    <strong>\n     FT245BM\n    </strong>\n    to read the byte from the data bus and send it to the host via USB.\n   </li>\n<li>\n    After the byte is sent,\n    <strong>\n     read_or_write\n    </strong>\n    is set back to 1, signaling that the microcontroller is ready to receive data again.\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n This section ensures that the microcontroller can send a byte to the FT245BM only when it's ready to receive a byte, keeping communication in sync.\n</p>\n"}, "Page 444": {"response": "<h3>\n Host Programming: VCP and D2XX Drivers\n</h3>\n<p>\n When developing applications that communicate with\n <strong>\n  FTDI Chip controllers\n </strong>\n , two main driver options are available: the\n <strong>\n  VCP driver\n </strong>\n and the\n <strong>\n  D2XX Direct driver\n </strong>\n .\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    VCP Driver\n   </strong>\n   : This is the ideal choice for applications that need to communicate with a\n   <strong>\n    USB device\n   </strong>\n   via a\n   <strong>\n    virtual COM port\n   </strong>\n   (VCP). It is especially useful when upgrading existing devices that use standard serial communication protocols like\n   <strong>\n    RS-232\n   </strong>\n   or other asynchronous serial interfaces. The VCP driver essentially makes the USB device appear as a regular COM port to the host operating system, enabling communication with existing serial software.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    D2XX Direct Driver\n   </strong>\n   : This driver provides more flexibility than the VCP driver. It allows applications to access vendor-specific functions and supports direct communication with the\n   <strong>\n    FT232BM\n   </strong>\n   and\n   <strong>\n    FT245BM\n   </strong>\n   chips, bypassing the virtual COM port abstraction. The D2XX driver offers several advantages:\n  </p>\n<ul>\n<li>\n<strong>\n     Faster Data Transfers\n    </strong>\n    : By enabling direct communication, data transfer speeds can be higher than those achievable with the VCP driver.\n   </li>\n<li>\n<strong>\n     More Control\n    </strong>\n    : Developers gain finer control over the USB communication, making it suitable for more advanced use cases.\n   </li>\n<li>\n<strong>\n     Bit Bang Mode\n    </strong>\n    : This mode allows for bit-level control of the parallel interface, providing further customization of data handling.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n The\n <strong>\n  D2XX\n </strong>\n driver is particularly beneficial in applications that require more sophisticated data handling or when higher performance is needed.\n</p>\n<h3>\n Example Program: Process and Return Data\n</h3>\n<p>\n In the\n <strong>\n  process_received_data\n </strong>\n function, the program processes the byte received by the microcontroller. Here's the breakdown of the logic:\n</p>\n<ol>\n<li>\n<strong>\n   Increment Received Data\n  </strong>\n  : If the received byte (\n  <strong>\n   data_in\n  </strong>\n  ) is 255, it is reset to 0. Otherwise, it is incremented by 1.\n </li>\n<li>\n<strong>\n   Set for Sending Data\n  </strong>\n  : After processing, the\n  <strong>\n   read_or_write\n  </strong>\n  flag is set to 0, signaling that the microcontroller is now ready to send the incremented byte back to the host through the\n  <strong>\n   FT245BM\n  </strong>\n  .\n </li>\n</ol>\n<p>\n This function demonstrates a simple data-handling routine where data is received from the host, modified (in this case, incremented), and then sent back to the host.\n</p>\n"}, "Page 445": {"response": "<h3>\n Using the D2XX Direct Driver\n</h3>\n<p>\n The\n <strong>\n  D2XX Direct driver\n </strong>\n allows applications to interact with\n <strong>\n  FTDI Chip controllers\n </strong>\n for faster and more flexible communication. There are two primary function sets available for this driver:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Classic Interface Functions\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    These are the original functions provided by FTDI for communication with their devices.\n   </li>\n<li>\n    Key functions for data exchange include:\n    <ul>\n<li>\n<strong>\n       FT_Open\n      </strong>\n      : Opens the device for communication.\n     </li>\n<li>\n<strong>\n       FT_Read\n      </strong>\n      : Reads data from the device.\n     </li>\n<li>\n<strong>\n       FT_Write\n      </strong>\n      : Writes data to the device.\n     </li>\n<li>\n<strong>\n       FT_Close\n      </strong>\n      : Closes the communication channel with the device.\n     </li>\n</ul>\n</li>\n<li>\n    Other functions allow for configuring the device and accessing the EEPROM.\n   </li>\n<li>\n    Some of these functions are specific to handling\n    <strong>\n     handshaking signals\n    </strong>\n    and\n    <strong>\n     serial communication settings\n    </strong>\n    for the\n    <strong>\n     FT232BM\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    FT-Win32 API Function Set\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    These functions mimic standard\n    <strong>\n     Windows API functions\n    </strong>\n    like\n    <strong>\n     CreateFile\n    </strong>\n    ,\n    <strong>\n     ReadFile\n    </strong>\n    , and\n    <strong>\n     WriteFile\n    </strong>\n    , making them convenient for applications that already use Win32 functions.\n   </li>\n<li>\n    However, this set has some limitations:\n    <ul>\n<li>\n      It doesn't support setting the\n      <strong>\n       latency timer\n      </strong>\n      .\n     </li>\n<li>\n      It lacks\n      <strong>\n       EEPROM access\n      </strong>\n      .\n     </li>\n<li>\n<strong>\n       Bit Bang mode\n      </strong>\n      isn't available.\n     </li>\n</ul>\n</li>\n<li>\n    Applications should choose either the\n    <strong>\n     Classic interface\n    </strong>\n    or the\n    <strong>\n     FT-Win32 interface\n    </strong>\n    , but not both.\n   </li>\n</ul>\n</li>\n</ol>\n<h3>\n Selecting the Right Driver\n</h3>\n<p>\n When choosing the correct driver for an FTDI device, it's important to understand that there are two main options: the\n <strong>\n  VCP driver\n </strong>\n and the\n <strong>\n  D2XX Direct driver\n </strong>\n . Here are some key points to consider:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Windows Driver Selection\n   </strong>\n   : Chapter 9 covers how Windows selects drivers for devices, and\n   <strong>\n    FTDI devices\n   </strong>\n   are an exception due to having multiple driver options.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Vendor ID and Product ID\n   </strong>\n   : The default\n   <strong>\n    Vendor ID\n   </strong>\n   (VID) and\n   <strong>\n    Product ID\n   </strong>\n   (PID) are used for selecting the driver. These defaults are sufficient for devices that don't require an EEPROM. However, to avoid confusion or issues with driver selection, it's best to use an\n   <strong>\n    EEPROM\n   </strong>\n   with a unique\n   <strong>\n    VID/PID\n   </strong>\n   pair.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Device Compatibility\n   </strong>\n   : The\n   <strong>\n    FT232BM\n   </strong>\n   and\n   <strong>\n    FT245BM\n   </strong>\n   chips may have different interfaces for interacting with their respective CPUs, but from the host's perspective, these two devices appear identical. As a result:\n  </p>\n<ul>\n<li>\n    Both chips can use the same drivers and\n    <strong>\n     INF files\n    </strong>\n    .\n   </li>\n<li>\n    The\n    <strong>\n     FT245BM\n    </strong>\n    can still use the\n    <strong>\n     VCP driver\n    </strong>\n    , even though it lacks the asynchronous serial interface found in traditional COM ports, which is a key feature of the\n    <strong>\n     FT232BM\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n In summary, when using FTDI Chip controllers, you can choose between the\n <strong>\n  Classic functions\n </strong>\n or the\n <strong>\n  FT-Win32 functions\n </strong>\n based on the needs of your application, but ensure you're not mixing both. For proper device identification and driver selection, using an EEPROM with a unique\n <strong>\n  VID/PID\n </strong>\n pair will help avoid driver conflicts, ensuring smoother communication.\n</p>\n"}, "Page 446": {"response": "<h3>\n Classic Interface Functions for D2XX Direct Driver\n</h3>\n<p>\n Applications using the\n <strong>\n  D2XX Direct Driver\n </strong>\n can interact with devices using a variety of functions. Here is an overview of the\n <strong>\n  Classic interface functions\n </strong>\n available in the driver:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    FT_EE_Read\n   </strong>\n   : Reads data from the EEPROM, using the FT_PROGRAM_DATA structure.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_EE_Program\n   </strong>\n   : Programs the EEPROM with data from an FT_PROGRAM_DATA structure.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_EE_UARead\n   </strong>\n   : Reads the user area of the EEPROM.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_EE_UASize\n   </strong>\n   : Retrieves the size of the EEPROM\u2019s user area.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_EE_UAWrite\n   </strong>\n   : Writes data to the EEPROM\u2019s user area.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_GetBitMode\n   </strong>\n   : Reads the bits in\n   <strong>\n    Bit Bang mode\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_GetLatencyTimer\n   </strong>\n   : Retrieves the current value of the latency timer.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_GetModemStatus\n   </strong>\n   : Gets the current states of modem status signals (note that this function may not be available on all devices).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_GetQueueStatus\n   </strong>\n   : Returns the number of characters in the receive buffer.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_GetStatus\n   </strong>\n   : Returns the number of characters in both the transmit and receive buffers, as well as the event status.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_ListDevices\n   </strong>\n   : Lists the number of connected devices and their associated device strings.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_Open\n   </strong>\n   : Opens a device by specifying the device number, providing a handle for access.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_OpenEx\n   </strong>\n   : Opens a device by specifying the serial number or description, providing a handle for access.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_Purge\n   </strong>\n   : Clears both the transmit and receive buffers.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_Read\n   </strong>\n   : Reads a specified number of bytes from the device.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_ResetDevice\n   </strong>\n   : Resets the device to its default state.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_SetBaudRate\n   </strong>\n   : Sets the baud rate for the device, including support for non-standard rates.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_SetBitMode\n   </strong>\n   : Enables or disables\n   <strong>\n    Bit Bang mode\n   </strong>\n   and configures the associated pins as inputs or outputs.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_SetBreakOff\n   </strong>\n   : Resets any active break condition.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_SetChars\n   </strong>\n   : Defines an event character and an error character for data transmission.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_SetDataCharacteristics\n   </strong>\n   : Configures the number of bits per character, the number of stop bits, and parity settings.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_SetDTR\n   </strong>\n   : Sets the\n   <strong>\n    DTR\n   </strong>\n   (Data Terminal Ready) signal.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_SetEventNotification\n   </strong>\n   : Configures event notifications, such as when a character is received or when there is a change in modem status.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_SetFlowControl\n   </strong>\n   : Selects a flow-control method, such as hardware or software flow control.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    FT_SetLatencyTimer\n   </strong>\n   : Sets the latency timer (the default is typically 16 milliseconds).\n  </p>\n</li>\n</ul>\n<p>\n These functions enable precise control and interaction with FTDI Chip\u2019s USB interface devices, offering extensive configuration options, from communication parameters to EEPROM management.\n</p>\n"}, "Page 447": {"response": "<h3>\n Ensuring Proper Driver Assignment with Unique IDs\n</h3>\n<p>\n To ensure Windows uses the correct driver for your device, it's crucial to assign a\n <strong>\n  unique Vendor ID\n </strong>\n and\n <strong>\n  Product ID\n </strong>\n . You can either assign your own IDs or use\n <strong>\n  FTDI Chip\u2019s Vendor ID\n </strong>\n with a unique Product ID that you request from FTDI. These IDs should be stored in the\n <strong>\n  EEPROM\n </strong>\n connected to the controller and referenced in the\n <strong>\n  INF file\n </strong>\n for the driver.\n</p>\n<p>\n By doing this, you ensure that Windows always recognizes your device correctly and assigns the appropriate driver. When Windows assigns the driver, it will copy the INF file, renaming it as\n <code>\n  oemxx.inf\n </code>\n , where\n <code>\n  xx\n </code>\n is a unique number. This way, even if other vendors use the same FTDI-provided INF file, Windows will still identify your device correctly.\n</p>\n<h3>\n Issues with Default Vendor and Product IDs\n</h3>\n<p>\n When using the default\n <strong>\n  Vendor ID\n </strong>\n and\n <strong>\n  Product ID\n </strong>\n , Windows may automatically select a driver for you, and this might not be the driver you want. This can happen, especially if your INF file is unsigned, which can cause complications. To avoid this issue, you can follow these steps during the device installation:\n</p>\n<ul>\n<li>\n  Delete, move, or rename any signed INF files that may specify an unwanted driver for the default IDs.\n </li>\n<li>\n  Disconnect from the Internet to prevent Windows from downloading a driver automatically.\n </li>\n</ul>\n<p>\n While these steps work, they can create challenges for end users. Ideally, you should ensure your device uses a unique Vendor ID and Product ID to avoid such complications during installation.\n</p>\n<h3>\n Additional D2XX Driver Functions\n</h3>\n<ul>\n<li>\n<strong>\n   FT_SetRTS\n  </strong>\n  : Sets the\n  <strong>\n   RTS (Request to Send)\n  </strong>\n  signal.\n </li>\n<li>\n<strong>\n   FT_SetTimeouts\n  </strong>\n  : Configures timeouts for reading and writing operations to the device.\n </li>\n<li>\n<strong>\n   FT_SetUSBParameters\n  </strong>\n  : Sets the maximum transfer size for USB communications (the default is 4096 bytes).\n </li>\n<li>\n<strong>\n   FT_Write\n  </strong>\n  : Writes a specified number of bytes to the device.\n </li>\n</ul>\n<p>\n<em>\n  Note: Some functions, like\n  <strong>\n   FT_SetRTS\n  </strong>\n  , are not necessary or supported by the\n  <strong>\n   FT245BM\n  </strong>\n  , except in\n  <strong>\n   Bit Bang mode\n  </strong>\n  . Additionally, the\n  <strong>\n   SetBaudRate\n  </strong>\n  function is relevant for configuring Bit Bang mode.\n </em>\n</p>\n<p>\n These functions offer granular control over data transmission, device interaction, and various communication settings, especially when using FTDI\u2019s D2XX Direct driver.\n</p>\n"}, "Page 448": {"response": "<h3>\n Using Default Vendor ID and Product ID with Serial Numbers\n</h3>\n<p>\n If you need to use the\n <strong>\n  default Vendor ID\n </strong>\n and\n <strong>\n  Product ID\n </strong>\n , a solution is to assign a\n <strong>\n  serial number\n </strong>\n to each device. This serial number helps Windows distinguish your device from others that use the same Vendor ID and Product ID. When a serial number is present, Windows creates a\n <strong>\n  hardware key\n </strong>\n for the device, using this serial number to remember which driver should be assigned. If there are no serial numbers available, Windows may face difficulties in identifying and correctly assigning the right driver.\n</p>\n<h3>\n FT-Win32 Driver Functions\n</h3>\n<p>\n As an alternative to using the Classic interface functions, applications can communicate with FTDI Chip controllers via the\n <strong>\n  FT-Win32 API\n </strong>\n , which emulates standard Windows API functions like\n <strong>\n  CreateFile\n </strong>\n ,\n <strong>\n  ReadFile\n </strong>\n , and\n <strong>\n  WriteFile\n </strong>\n . This interface is particularly useful if your application already uses these standard Windows functions and you want to integrate FTDI's D2XX Direct driver without rewriting large parts of your code.\n</p>\n<p>\n Here\u2019s a breakdown of\n <strong>\n  FT-Win32 functions\n </strong>\n :\n</p>\n<ul>\n<li>\n<strong>\n   FT_W32_ClearCommBreak\n  </strong>\n  : Clears the\n  <strong>\n   Break\n  </strong>\n  condition on the device.\n </li>\n<li>\n<strong>\n   FT_W32_ClearCommError\n  </strong>\n  : Retrieves the device status and error information related to communications.\n </li>\n<li>\n<strong>\n   FT_W32_CloseHandle\n  </strong>\n  : Closes a handle that was obtained through\n  <strong>\n   FT_W32_CreateFile\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   FT_W32_CreateFile\n  </strong>\n  : Opens a handle to the device, specifying it by serial number or description.\n </li>\n<li>\n<strong>\n   FT_W32_EscapeCommFunction\n  </strong>\n  : Sets or clears signals like\n  <strong>\n   RTS\n  </strong>\n  (Request to Send),\n  <strong>\n   DTS\n  </strong>\n  (Data Terminal Ready), or\n  <strong>\n   Break\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   FT_W32_GetCommModemStatus\n  </strong>\n  : Retrieves the state of modem status signals.\n </li>\n<li>\n<strong>\n   FT_W32_GetCommState\n  </strong>\n  : Gets the communication parameters from the device control block.\n </li>\n<li>\n<strong>\n   FT_W32_GetCommTimeouts\n  </strong>\n  : Retrieves the read and write timeout values.\n </li>\n<li>\n<strong>\n   FT_W32_GetLastError\n  </strong>\n  : Returns the status code for the last operation on the device.\n </li>\n<li>\n<strong>\n   FT_W32_GetOverlappedResult\n  </strong>\n  : Retrieves the result of an overlapped operation.\n </li>\n<li>\n<strong>\n   FT_W32_PurgeComm\n  </strong>\n  : Cancels outstanding reads/writes and clears the read/write buffers.\n </li>\n<li>\n<strong>\n   FT_W32_ReadFile\n  </strong>\n  : Reads a specified number of bytes from the device.\n </li>\n<li>\n<strong>\n   FT_W32_SetCommBreak\n  </strong>\n  : Puts the communication into a\n  <strong>\n   Break\n  </strong>\n  state.\n </li>\n<li>\n<strong>\n   FT_W32_SetCommMask\n  </strong>\n  : Specifies the events that the program will monitor.\n </li>\n<li>\n<strong>\n   FT_W32_SetCommState\n  </strong>\n  : Configures communication parameters for the device.\n </li>\n<li>\n<strong>\n   FT_W32_SetCommTimeouts\n  </strong>\n  : Sets the timeout values for reads and writes.\n </li>\n<li>\n<strong>\n   FT_W32_SetupComm\n  </strong>\n  : Configures the size of the read and write buffers.\n </li>\n<li>\n<strong>\n   FT_W32_WaitCommEvent\n  </strong>\n  : Waits for a communication event to occur.\n </li>\n<li>\n<strong>\n   FT_W32_WriteFile\n  </strong>\n  : Writes a specified number of bytes to the device.\n </li>\n</ul>\n<p>\n<em>\n  Note: Some functions, like\n  <strong>\n   FT_W32_EscapeCommFunction\n  </strong>\n  and\n  <strong>\n   FT_W32_GetCommState\n  </strong>\n  , are not supported or needed by the\n  <strong>\n   FT245BM\n  </strong>\n  , as it lacks certain communication features like serial port management.\n </em>\n</p>\n"}, "Page 449": {"response": "<h3>\n Device Identification and COM-Port Management\n</h3>\n<p>\n In Windows, the\n <strong>\n  physical port\n </strong>\n is used to identify a connected device. However, this port can change when devices are disconnected and reattached. This can cause problems, particularly when dealing with devices from different sources that use the same\n <strong>\n  Vendor ID\n </strong>\n and\n <strong>\n  Product ID\n </strong>\n . This situation can lead to multiple devices potentially being assigned the same\n <strong>\n  serial number\n </strong>\n , causing conflicts.\n</p>\n<h4>\n Avoiding COM-Port Overload\n</h4>\n<p>\n When using the\n <strong>\n  VCP driver\n </strong>\n , Windows creates a new\n <strong>\n  COM port\n </strong>\n for each device that includes a\n <strong>\n  serial number\n </strong>\n . During testing, if you have many devices, you could quickly reach the\n <strong>\n  maximum limit of 256 COM ports\n </strong>\n . To resolve this, you can:\n</p>\n<ol>\n<li>\n<strong>\n   Uninstall unused devices\n  </strong>\n  : Use Windows\u2019\n  <strong>\n   Device Manager\n  </strong>\n  to remove devices that are no longer in use, freeing up COM port numbers.\n </li>\n<li>\n<strong>\n   Edit the INF file\n  </strong>\n  : For internal testing environments, you can modify the\n  <strong>\n   ftdibus.inf\n  </strong>\n  file to assign the\n  <strong>\n   VCP driver\n  </strong>\n  only to devices attached to specific physical ports. This method will cause Windows to assign a single COM port for all these devices, even if they have different serial numbers. FTDI Chip provides detailed instructions for editing this INF file.\n </li>\n</ol>\n<h3>\n Performance Tips for Optimal Data Transfer\n</h3>\n<p>\n To maximize performance when using\n <strong>\n  FTDI Chip\u2019s controllers\n </strong>\n , it is essential to consider factors that influence\n <strong>\n  data transfer speed\n </strong>\n and prevent\n <strong>\n  data loss\n </strong>\n . The following tips focus on optimizing data transfer between the\n <strong>\n  host computer\n </strong>\n , the\n <strong>\n  device controller\n </strong>\n , and the device\u2019s\n <strong>\n  CPU\n </strong>\n .\n</p>\n<h4>\n Speed Considerations\n</h4>\n<p>\n When determining\n <strong>\n  data transfer rates\n </strong>\n using FTDI Chip controllers, two main factors should be considered:\n</p>\n<ol>\n<li>\n<strong>\n   Host to Device Controller Transfer\n  </strong>\n  : The rate at which data is transferred between the host computer and the FTDI device controller. This can vary depending on the\n  <strong>\n   bus load\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Device Controller to CPU Transfer\n  </strong>\n  : The rate at which the device controller communicates with the device\u2019s CPU. This is important for asynchronous serial and parallel interfaces, as data transfer may be delayed if the receiving end is not ready to accept data.\n </li>\n</ol>\n<p>\n The time required for transferring a specific amount of data can vary, especially in systems using bulk transfers, where bus congestion can slow the process. Similarly, if the device interface is slow to receive data, it can cause additional delays.\n</p>\n"}, "Page 450": {"response": "<h3>\n Optimizing Data Transfer Speed and Minimizing Latency\n</h3>\n<p>\n When dealing with data transfer speeds and latency, several factors influence how efficiently data can move between devices, especially in bulk transfer operations.\n</p>\n<h4>\n Data Transfer Speeds\n</h4>\n<p>\n For devices using\n <strong>\n  VCP\n </strong>\n or\n <strong>\n  D2XX drivers\n </strong>\n , the transfer rates vary depending on the chip and the driver in use:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    FT232BM\n   </strong>\n   (using VCP or D2XX driver):\n  </p>\n<ul>\n<li>\n    Maximum transfer rate:\n    <strong>\n     3 Megabits per second (Mbps)\n    </strong>\n    , which equals around\n    <strong>\n     300 kilobytes per second (KB/s)\n    </strong>\n    , assuming standard serial communication parameters (one Start bit and one Stop bit).\n   </li>\n<li>\n    To reach this transfer rate, the baud rate of the\n    <strong>\n     asynchronous serial port\n    </strong>\n    on the controller must be set to\n    <strong>\n     3 Mbps\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    FT245BM\n   </strong>\n   (using VCP or D2XX driver):\n  </p>\n<ul>\n<li>\n    Maximum transfer rate using the\n    <strong>\n     VCP driver\n    </strong>\n    :\n    <strong>\n     300 KB/s\n    </strong>\n    .\n   </li>\n<li>\n    Maximum transfer rate using the\n    <strong>\n     D2XX driver\n    </strong>\n    :\n    <strong>\n     1 Megabyte per second (MB/s)\n    </strong>\n    , which is significantly faster.\n   </li>\n<li>\n    For the best performance, it\u2019s recommended to use the\n    <strong>\n     D2XX driver\n    </strong>\n    as it supports faster data transfers.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Minimizing Latency in Bulk Transfers\n</h4>\n<p>\n When transferring small amounts of data (less than\n <strong>\n  62 bytes\n </strong>\n ), latency can be a concern. The controller\u2019s\n <strong>\n  bulk IN endpoint\n </strong>\n by default may introduce delays unless certain conditions are met. Specifically, the controller may not send the data immediately but will\n <strong>\n  NAK\n </strong>\n (Negative Acknowledge) the\n <strong>\n  IN packet\n </strong>\n unless one of the following is true:\n</p>\n<ol>\n<li>\n  The\n  <strong>\n   transmit buffer\n  </strong>\n  contains at least\n  <strong>\n   62 bytes\n  </strong>\n  of data.\n </li>\n<li>\n<strong>\n   16 milliseconds\n  </strong>\n  have passed since the last\n  <strong>\n   IN packet\n  </strong>\n  was acknowledged.\n </li>\n<li>\n  An\n  <strong>\n   event character\n  </strong>\n  has been enabled and is received by the device.\n </li>\n<li>\n  For the\n  <strong>\n   FT232BM\n  </strong>\n  , the\n  <strong>\n   CTS\n  </strong>\n  ,\n  <strong>\n   DSR\n  </strong>\n  ,\n  <strong>\n   DCD\n  </strong>\n  , or\n  <strong>\n   RI\n  </strong>\n  signal states have changed.\n </li>\n</ol>\n<p>\n If one of these conditions is satisfied, the controller will send\n <strong>\n  two status bytes\n </strong>\n followed by the data (up to\n <strong>\n  62 bytes\n </strong>\n ) from the transmit buffer.\n</p>\n<h4>\n Reducing Latency with the D2XX Driver\n</h4>\n<p>\n For devices that need to send less than\n <strong>\n  62 bytes\n </strong>\n with minimal delay, the\n <strong>\n  D2XX driver\n </strong>\n offers a function that allows you to adjust the\n <strong>\n  latency timer\n </strong>\n . By default, this timer is set to\n <strong>\n  16 milliseconds\n </strong>\n , but it can be configured to a range of\n <strong>\n  1 to 255 milliseconds\n </strong>\n . For the shortest possible latency, set the timer to\n <strong>\n  1 millisecond\n </strong>\n . With this configuration, the device will send status bytes and any available data as long as at least\n <strong>\n  1 millisecond\n </strong>\n has passed since the last\n <strong>\n  IN packet\n </strong>\n was acknowledged.\n</p>\n<h4>\n Event Characters for Immediate Data Transfer\n</h4>\n<p>\n An\n <strong>\n  event character\n </strong>\n is a special marker that prompts the device to send data immediately upon its reception. The\n <strong>\n  D2XX driver\n </strong>\n can be used to define an event character. Once the device receives this event character, it will respond by sending\n <strong>\n  status bytes\n </strong>\n and up to\n <strong>\n  62 data bytes\n </strong>\n in the next\n <strong>\n  IN packet\n </strong>\n . The event character is embedded in the transmitted data, allowing the firmware to handle the immediate request for data efficiently.\n</p>\n<p>\n This system helps minimize delays in bulk data transfers, ensuring that small amounts of data are sent quickly and reliably.\n</p>\n"}, "Page 451": {"response": "<h3>\n Preventing Lost Data and Using Handshaking\n</h3>\n<p>\n When managing data transfer, especially in systems with limited buffer sizes, ensuring that data is not lost is crucial. Both\n <strong>\n  asynchronous serial\n </strong>\n and\n <strong>\n  parallel\n </strong>\n links can benefit from\n <strong>\n  handshaking\n </strong>\n to prevent data from being lost during transmission.\n</p>\n<h4>\n Prompting Data Transmission\n</h4>\n<p>\n Data transmission in the\n <strong>\n  FT232BM\n </strong>\n can be initiated in several ways:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Event Characters:\n   </strong>\n   As discussed earlier, when an\n   <strong>\n    event character\n   </strong>\n   is received by the device, it triggers immediate data transmission. The firmware is responsible for identifying and discarding any irrelevant event characters, ensuring only meaningful data is sent.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Handshaking Inputs:\n   </strong>\n   The\n   <strong>\n    FT232BM\n   </strong>\n   can also be prompted to send data by changing the state of its\n   <strong>\n    handshaking inputs\n   </strong>\n   , providing another way to control data flow.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Buffer Padding:\n   </strong>\n   If necessary, the transmit buffer can be padded to contain\n   <strong>\n    62 bytes\n   </strong>\n   of data, forcing the controller to send the data to the host, ensuring that the data is transmitted even if no other triggers are in place.\n  </p>\n</li>\n</ol>\n<h4>\n Managing Data Flow and Preventing Data Loss\n</h4>\n<p>\n To avoid data loss, especially when dealing with devices that can only accept data at specific times,\n <strong>\n  handshaking\n </strong>\n is a critical feature. It is particularly important when one side of the communication link (such as a device) has a buffer that may be too small to store incoming data.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Transmitting Data from the CPU to FT232BM:\n   </strong>\n<br/>\n   When data is written to the\n   <strong>\n    FT232BM\n   </strong>\n   from the CPU, it is stored in a\n   <strong>\n    384-byte transmit buffer\n   </strong>\n   . This buffer is then used to send data to the host via\n   <strong>\n    bulk IN transfers\n   </strong>\n   . However, because the USB transfer process uses bulk transfers, there\u2019s no guarantee when the host will request the data. If the USB bus is busy or the host is occupied, the data may not be sent immediately. If new data arrives and the buffer is full, any new data may be\n   <strong>\n    lost\n   </strong>\n   unless handshaking is in place to indicate when the host is ready to receive it.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Writing Data from Host to the Device:\n   </strong>\n<br/>\n   On the host side, software writes data to a buffer, which is then sent to the\n   <strong>\n    FT232BM\n   </strong>\n   via\n   <strong>\n    bulk OUT transfers\n   </strong>\n   . The\n   <strong>\n    FT232BM\n   </strong>\n   has a\n   <strong>\n    128-byte buffer\n   </strong>\n   to store the incoming data. If this buffer is full, the FT232BM will send\n   <strong>\n    NAK\n   </strong>\n   (Negative Acknowledge) signals, indicating it cannot accept more data. The data in the buffer is then transmitted to the device's CPU using the\n   <strong>\n    asynchronous serial link\n   </strong>\n   . If the receiving device has limited buffer space or none at all, there\u2019s a risk that data will be lost. In such cases, handshaking is necessary to ensure that the device can handle the data at the right time, preventing any loss during the transfer process.\n  </p>\n</li>\n</ul>\n<p>\n By using handshaking effectively, both sides of the communication can manage the data flow to avoid loss, especially in situations where buffers are small or data arrives at unexpected times.\n</p>\n"}, "Page 452": {"response": "<h3>\n Handshaking Methods and EEPROM Programming\n</h3>\n<h4>\n Handshaking Methods Supported by the FT232BM and FT245BM\n</h4>\n<p>\n The\n <strong>\n  FT232BM\n </strong>\n supports three handshaking methods to control data flow and prevent data loss:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    RTS/CTS (Request to Send / Clear to Send) Pins:\n   </strong>\n<br/>\n   These are hardware handshaking signals commonly used for data flow control. The\n   <strong>\n    RTS#\n   </strong>\n   (Request to Send) pin on the transmitting side signals when the device is ready to send data, while the\n   <strong>\n    CTS#\n   </strong>\n   (Clear to Send) pin on the receiving side signals when the device is ready to receive data.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    DTR/DSR (Data Terminal Ready / Data Set Ready) Pins:\n   </strong>\n<br/>\n   Similar to RTS/CTS, the\n   <strong>\n    DTR#\n   </strong>\n   and\n   <strong>\n    DSR#\n   </strong>\n   pins can also be used for handshaking in a similar manner. These signals are used to indicate readiness to send or receive data and can be used independently or together as defined in the TIA/EIA-232 standard.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Xon/Xoff (Software Handshaking):\n   </strong>\n<br/>\n   This method uses special characters embedded within the data stream to control the flow of data.\n   <strong>\n    Xon\n   </strong>\n   signals the receiver to resume data transmission, while\n   <strong>\n    Xoff\n   </strong>\n   temporarily pauses transmission.\n  </p>\n</li>\n</ol>\n<p>\n For the\n <strong>\n  FT245BM\n </strong>\n , handshaking is supported through the\n <strong>\n  RXF#\n </strong>\n and\n <strong>\n  TXE#\n </strong>\n pins, which signal the readiness to receive or send data, respectively. Additionally,\n <strong>\n  RD#\n </strong>\n and\n <strong>\n  WR\n </strong>\n signals are used to indicate the completion of a read or write operation.\n</p>\n<h4>\n EEPROM Programming and Configuration\n</h4>\n<p>\n The\n <strong>\n  D2XX Direct Driver\n </strong>\n allows applications to read and write to an\n <strong>\n  EEPROM\n </strong>\n that is connected to either a\n <strong>\n  FT232BM\n </strong>\n or\n <strong>\n  FT245BM\n </strong>\n . The EEPROM can be used to store several device parameters, such as the\n <strong>\n  Vendor ID\n </strong>\n (VID),\n <strong>\n  Product ID\n </strong>\n (PID), and other configurable options like\n <strong>\n  remote wakeup support\n </strong>\n .\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Customizing Device Parameters:\n   </strong>\n<br/>\n   The EEPROM allows for customization of device characteristics such as the\n   <strong>\n    Vendor ID\n   </strong>\n   and\n   <strong>\n    Product ID\n   </strong>\n   . These parameters can be programmed using the\n   <strong>\n    FT_EE_Program\n   </strong>\n   function in the\n   <strong>\n    D2XX driver\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    User Area of the EEPROM:\n   </strong>\n<br/>\n   The EEPROM can also store data in a\n   <strong>\n    user area\n   </strong>\n   , which can be accessed by host applications. However, this area can only be accessed by the device's CPU when the USB controller is in the\n   <strong>\n    Reset\n   </strong>\n   state.\n  </p>\n</li>\n</ul>\n<h4>\n Editing EEPROM Data\n</h4>\n<p>\n To modify the\n <strong>\n  Vendor ID\n </strong>\n ,\n <strong>\n  Product ID\n </strong>\n ,\n <strong>\n  serial number\n </strong>\n , and other device-specific data in the EEPROM,\n <strong>\n  FTDI Chip\n </strong>\n provides a utility called\n <strong>\n  MPROG\n </strong>\n . This tool allows users to store and modify the values stored in the EEPROM, including configuring the\n <strong>\n  VID\n </strong>\n ,\n <strong>\n  PID\n </strong>\n , and\n <strong>\n  serial number\n </strong>\n .\n</p>\n<p>\n However, there is a complication when using\n <strong>\n  MPROG\n </strong>\n with a device that uses the default IDs (Vendor ID and Product ID).\n <strong>\n  Windows\n </strong>\n may not assign the\n <strong>\n  D2XX driver\n </strong>\n to such devices, which can prevent the proper programming of the EEPROM. To overcome this, users must ensure that the\n <strong>\n  D2XX driver\n </strong>\n is correctly assigned to the device, which may require manual adjustments to the system settings.\n</p>\n"}, "Page 453": {"response": "<h3>\n FTDI Chip EEPROM Data Structure\n</h3>\n<p>\n The\n <strong>\n  ft_program_data\n </strong>\n structure is used to define the contents of an EEPROM for an FTDI Chip device. This structure includes essential information about the device, such as its Vendor ID, Product ID, serial number, and additional configuration settings. Below is a detailed breakdown of each field within the structure.\n</p>\n<h4>\n Structure Fields\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Signature1 (DWORD)\n   </strong>\n   :\n   <br/>\n   This field must always contain the value\n   <strong>\n    0x00000000\n   </strong>\n   . It serves as the first part of a header to identify the structure.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Signature2 (DWORD)\n   </strong>\n   :\n   <br/>\n   This field must always contain the value\n   <strong>\n    0xFFFFFFFF\n   </strong>\n   . It completes the header, confirming that the structure is valid.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Version (DWORD)\n   </strong>\n   :\n   <br/>\n   This indicates the version of the\n   <strong>\n    ft_program_data\n   </strong>\n   structure.\n  </p>\n<ul>\n<li>\n<strong>\n     0\n    </strong>\n    = Original version.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    = Contains FT2232C extensions.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    VendorId (WORD)\n   </strong>\n   :\n   <br/>\n   This is the\n   <strong>\n    Vendor ID\n   </strong>\n   assigned to the device, typically\n   <strong>\n    0x0403\n   </strong>\n   for FTDI devices.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    ProductId (WORD)\n   </strong>\n   :\n   <br/>\n   The\n   <strong>\n    Product ID\n   </strong>\n   of the device, commonly set to\n   <strong>\n    0x6001\n   </strong>\n   for FTDI USB devices.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Manufacturer (char *)\n   </strong>\n   :\n   <br/>\n   A pointer to the\n   <strong>\n    Manufacturer\n   </strong>\n   string, typically\n   <strong>\n    \"FTDI\"\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    ManufacturerId (char *)\n   </strong>\n   :\n   <br/>\n   A pointer to the\n   <strong>\n    Manufacturer ID\n   </strong>\n   string, usually\n   <strong>\n    \"FT\"\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Description (char *)\n   </strong>\n   :\n   <br/>\n   A pointer to the\n   <strong>\n    Device Description\n   </strong>\n   string, such as\n   <strong>\n    \"USB HS Serial Converter\"\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    SerialNumber (char *)\n   </strong>\n   :\n   <br/>\n   A pointer to the\n   <strong>\n    Serial Number\n   </strong>\n   string. This could be a fixed serial number like\n   <strong>\n    \"FT000001\"\n   </strong>\n   or\n   <strong>\n    NULL\n   </strong>\n   if not set.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    MaxPower (WORD)\n   </strong>\n   :\n   <br/>\n   This indicates the maximum required bus power for the device in milliamps (\n   <strong>\n    mA\n   </strong>\n   ). The default value is\n   <strong>\n    44\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    PnP (WORD)\n   </strong>\n   :\n   <br/>\n   Defines whether\n   <strong>\n    Plug and Play\n   </strong>\n   is enabled or disabled.\n  </p>\n<ul>\n<li>\n<strong>\n     0\n    </strong>\n    = Disabled.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    = Enabled.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    SelfPowered (WORD)\n   </strong>\n   :\n   <br/>\n   Specifies the power source for the device:\n  </p>\n<ul>\n<li>\n<strong>\n     0\n    </strong>\n    = Powered by the USB bus.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    = Self-powered.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    RemoteWakeup (WORD)\n   </strong>\n   :\n   <br/>\n   Indicates whether the device supports\n   <strong>\n    remote wakeup\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     0\n    </strong>\n    = No.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    = Yes.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n FT-BM Series Extensions (Rev4)\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Rev4 (UCHAR)\n   </strong>\n   :\n   <br/>\n   Denotes the chip series.\n  </p>\n<ul>\n<li>\n<strong>\n     0\n    </strong>\n    = FT-BM series.\n   </li>\n<li>\n<strong>\n     non-zero\n    </strong>\n    = Other chip series.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    IsoIn (UCHAR)\n   </strong>\n   :\n   <br/>\n   Specifies the type of the\n   <strong>\n    IN endpoint\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     0\n    </strong>\n    = Bulk transfer.\n   </li>\n<li>\n<strong>\n     non-zero\n    </strong>\n    = Isochronous transfer.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    IsoOut (UCHAR)\n   </strong>\n   :\n   <br/>\n   Specifies the type of the\n   <strong>\n    OUT endpoint\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     0\n    </strong>\n    = Bulk transfer.\n   </li>\n<li>\n<strong>\n     non-zero\n    </strong>\n    = Isochronous transfer.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    PullDownEnable (UCHAR)\n   </strong>\n   :\n   <br/>\n   Determines whether\n   <strong>\n    pull-down mode\n   </strong>\n   is enabled:\n  </p>\n<ul>\n<li>\n<strong>\n     0\n    </strong>\n    = Not enabled.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    = Enabled.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    SerNumEnable (UCHAR)\n   </strong>\n   :\n   <br/>\n   Indicates whether the device's\n   <strong>\n    serial number\n   </strong>\n   is enabled:\n  </p>\n<ul>\n<li>\n<strong>\n     non-zero\n    </strong>\n    = Enabled.\n   </li>\n<li>\n<strong>\n     0\n    </strong>\n    = Not enabled.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    USBVersionEnable (UCHAR)\n   </strong>\n   :\n   <br/>\n   Indicates whether the\n   <strong>\n    USB version\n   </strong>\n   is enabled:\n  </p>\n<ul>\n<li>\n<strong>\n     non-zero\n    </strong>\n    = Enabled.\n   </li>\n<li>\n<strong>\n     0\n    </strong>\n    = Not enabled.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    USBVersion (WORD)\n   </strong>\n   :\n   <br/>\n   Specifies the\n   <strong>\n    USB version\n   </strong>\n   in\n   <strong>\n    BCD format\n   </strong>\n   .\n  </p>\n<ul>\n<li>\n<strong>\n     0x0200\n    </strong>\n    = USB 2.0.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n This data structure allows applications to program the EEPROM on FTDI devices, setting parameters like\n <strong>\n  Vendor ID\n </strong>\n ,\n <strong>\n  Product ID\n </strong>\n , and other configuration settings that influence how the device interacts with the system.\n</p>\n"}, "Page 454": {"response": "<h3>\n FTDI Chip EEPROM Data Structure (FT2232C Extensions)\n</h3>\n<p>\n The\n <strong>\n  ft_program_data\n </strong>\n structure for FTDI devices can include additional extensions for the\n <strong>\n  FT2232C\n </strong>\n chip, which has dual channels (A and B). These extensions allow more advanced configurations, particularly for devices that require more complex handling of endpoints, serial numbers, and driver options. Below is a detailed breakdown of the additional fields specific to the FT2232C chip.\n</p>\n<h4>\n FT2232C Chip Extensions\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Rev5 (UCHAR)\n   </strong>\n   :\n   <br/>\n   This field indicates if the chip is an\n   <strong>\n    FT2232C\n   </strong>\n   .\n  </p>\n<ul>\n<li>\n<strong>\n     non-zero\n    </strong>\n    = FT2232C chip.\n   </li>\n<li>\n<strong>\n     0\n    </strong>\n    = Not an FT2232C chip.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    IsoInA (UCHAR)\n   </strong>\n   :\n   <br/>\n   Specifies the type of\n   <strong>\n    IN endpoint\n   </strong>\n   for the\n   <strong>\n    A channel\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     0\n    </strong>\n    = Bulk transfer.\n   </li>\n<li>\n<strong>\n     non-zero\n    </strong>\n    = Isochronous transfer.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    IsoInB (UCHAR)\n   </strong>\n   :\n   <br/>\n   Specifies the type of\n   <strong>\n    IN endpoint\n   </strong>\n   for the\n   <strong>\n    B channel\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     0\n    </strong>\n    = Bulk transfer.\n   </li>\n<li>\n<strong>\n     non-zero\n    </strong>\n    = Isochronous transfer.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    IsoOutA (UCHAR)\n   </strong>\n   :\n   <br/>\n   Specifies the type of\n   <strong>\n    OUT endpoint\n   </strong>\n   for the\n   <strong>\n    A channel\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     0\n    </strong>\n    = Bulk transfer.\n   </li>\n<li>\n<strong>\n     non-zero\n    </strong>\n    = Isochronous transfer.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    IsoOutB (UCHAR)\n   </strong>\n   :\n   <br/>\n   Specifies the type of\n   <strong>\n    OUT endpoint\n   </strong>\n   for the\n   <strong>\n    B channel\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     0\n    </strong>\n    = Bulk transfer.\n   </li>\n<li>\n<strong>\n     non-zero\n    </strong>\n    = Isochronous transfer.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    PullDownEnable5 (UCHAR)\n   </strong>\n   :\n   <br/>\n   Indicates whether\n   <strong>\n    pull-down mode\n   </strong>\n   is enabled for the FT2232C chip:\n  </p>\n<ul>\n<li>\n<strong>\n     0\n    </strong>\n    = Not enabled.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    = Enabled.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    SerNumEnable5 (UCHAR)\n   </strong>\n   :\n   <br/>\n   Defines whether the device's\n   <strong>\n    serial number\n   </strong>\n   is enabled for the FT2232C chip:\n  </p>\n<ul>\n<li>\n<strong>\n     non-zero\n    </strong>\n    = Enabled.\n   </li>\n<li>\n<strong>\n     0\n    </strong>\n    = Not enabled.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    USBVersionEnable5 (UCHAR)\n   </strong>\n   :\n   <br/>\n   Indicates if\n   <strong>\n    USB version support\n   </strong>\n   is enabled:\n  </p>\n<ul>\n<li>\n<strong>\n     non-zero\n    </strong>\n    = Enabled.\n   </li>\n<li>\n<strong>\n     0\n    </strong>\n    = Not enabled.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    USBVersion5 (WORD)\n   </strong>\n   :\n   <br/>\n   Specifies the\n   <strong>\n    USB version\n   </strong>\n   (in BCD format) supported by the FT2232C.\n  </p>\n<ul>\n<li>\n<strong>\n     0x0200\n    </strong>\n    = USB 2.0.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    AIsHighCurrent (UCHAR)\n   </strong>\n   :\n   <br/>\n   Indicates whether the\n   <strong>\n    A channel\n   </strong>\n   supports\n   <strong>\n    high current\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     non-zero\n    </strong>\n    = Yes.\n   </li>\n<li>\n<strong>\n     0\n    </strong>\n    = No.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    BIsHighCurrent (UCHAR)\n   </strong>\n   :\n   <br/>\n   Indicates whether the\n   <strong>\n    B channel\n   </strong>\n   supports\n   <strong>\n    high current\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     non-zero\n    </strong>\n    = Yes.\n   </li>\n<li>\n<strong>\n     0\n    </strong>\n    = No.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    IFAIsFifo (UCHAR)\n   </strong>\n   :\n   <br/>\n   Indicates if the\n   <strong>\n    A channel\n   </strong>\n   is using a\n   <strong>\n    245 FIFO\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     non-zero\n    </strong>\n    = Yes.\n   </li>\n<li>\n<strong>\n     0\n    </strong>\n    = No.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    IFAIsFifoTar (UCHAR)\n   </strong>\n   :\n   <br/>\n   Indicates if the\n   <strong>\n    A channel\n   </strong>\n   is configured as a\n   <strong>\n    245 FIFO CPU target\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     non-zero\n    </strong>\n    = Yes.\n   </li>\n<li>\n<strong>\n     0\n    </strong>\n    = No.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    IFAIsFastSer (UCHAR)\n   </strong>\n   :\n   <br/>\n   Specifies if the\n   <strong>\n    A channel\n   </strong>\n   supports\n   <strong>\n    Fast Serial\n   </strong>\n   communication:\n  </p>\n<ul>\n<li>\n<strong>\n     non-zero\n    </strong>\n    = Yes.\n   </li>\n<li>\n<strong>\n     0\n    </strong>\n    = No.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    AIsVCP (UCHAR)\n   </strong>\n   :\n   <br/>\n   Indicates if the\n   <strong>\n    A channel\n   </strong>\n   uses the\n   <strong>\n    Virtual COM Port (VCP)\n   </strong>\n   driver:\n  </p>\n<ul>\n<li>\n<strong>\n     non-zero\n    </strong>\n    = Yes.\n   </li>\n<li>\n<strong>\n     0\n    </strong>\n    = No.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    IFBIsFifo (UCHAR)\n   </strong>\n   :\n   <br/>\n   Indicates if the\n   <strong>\n    B channel\n   </strong>\n   is using a\n   <strong>\n    245 FIFO\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     non-zero\n    </strong>\n    = Yes.\n   </li>\n<li>\n<strong>\n     0\n    </strong>\n    = No.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    IFBIsFifoTar (UCHAR)\n   </strong>\n   :\n   <br/>\n   Indicates if the\n   <strong>\n    B channel\n   </strong>\n   is configured as a\n   <strong>\n    245 FIFO CPU target\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     non-zero\n    </strong>\n    = Yes.\n   </li>\n<li>\n<strong>\n     0\n    </strong>\n    = No.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    IFBIsFastSer (UCHAR)\n   </strong>\n   :\n   <br/>\n   Specifies if the\n   <strong>\n    B channel\n   </strong>\n   supports\n   <strong>\n    Fast Serial\n   </strong>\n   communication:\n  </p>\n<ul>\n<li>\n<strong>\n     non-zero\n    </strong>\n    = Yes.\n   </li>\n<li>\n<strong>\n     0\n    </strong>\n    = No.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    BIsVCP (UCHAR)\n   </strong>\n   :\n   <br/>\n   Indicates if the\n   <strong>\n    B channel\n   </strong>\n   uses the\n   <strong>\n    Virtual COM Port (VCP)\n   </strong>\n   driver:\n  </p>\n<ul>\n<li>\n<strong>\n     non-zero\n    </strong>\n    = Yes.\n   </li>\n<li>\n<strong>\n     0\n    </strong>\n    = No.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n This extended structure allows further customization and configuration of FTDI devices, particularly those using the FT2232C chip, offering a wide range of features like\n <strong>\n  high current support\n </strong>\n ,\n <strong>\n  FIFO configuration\n </strong>\n , and\n <strong>\n  isochronous transfer modes\n </strong>\n .\n</p>\n"}, "Page 455": {"response": "<h3>\n Programming EEPROMs with MPROG\n</h3>\n<p>\n To enable the\n <strong>\n  MPROG utility\n </strong>\n on a device using the\n <strong>\n  default Vendor ID\n </strong>\n and\n <strong>\n  Product ID\n </strong>\n with the\n <strong>\n  VCP driver\n </strong>\n , FTDI Chip provides a special solution. Since the MPROG utility requires the D2XX driver, but a device using the default IDs may not have this driver assigned, FTDI offers a method to allow MPROG to work:\n</p>\n<ol>\n<li>\n<strong>\n   Product ID Change\n  </strong>\n  : The application modifies the\n  <strong>\n   Product ID\n  </strong>\n  to a special value called \"D2XX Recovery\" (Product ID\n  <strong>\n   6006h\n  </strong>\n  ).\n </li>\n<li>\n<strong>\n   Driver Assignment\n  </strong>\n  : An INF file is provided that specifically assigns the\n  <strong>\n   D2XX driver\n  </strong>\n  to devices with the new\n  <strong>\n   D2XX Recovery\n  </strong>\n  Product ID.\n </li>\n<li>\n<strong>\n   MPROG Utility\n  </strong>\n  : Once the Product ID is changed, you can run the\n  <strong>\n   MPROG utility\n  </strong>\n  and program the\n  <strong>\n   Vendor ID\n  </strong>\n  and/or\n  <strong>\n   Product ID\n  </strong>\n  in the device's EEPROM.\n </li>\n</ol>\n<p>\n Alternatively, you can program the EEPROM\n <strong>\n  before\n </strong>\n connecting it to the controller using other methods, bypassing the need to change the Product ID to \"D2XX Recovery\". This allows for more flexibility in handling EEPROM programming.\n</p>\n"}, "Page 456": {"response": "<h3>\n Hubs: The Link Between Devices and the Host\n</h3>\n<p>\n Every\n <strong>\n  USB peripheral\n </strong>\n needs to connect to a\n <strong>\n  hub\n </strong>\n . As explained in Chapter 1, a\n <strong>\n  hub\n </strong>\n is an intelligent device that facilitates connections for USB devices and manages the communication between the devices and the\n <strong>\n  host\n </strong>\n . Devices that connect directly to a\n <strong>\n  PC\n </strong>\n do so through the\n <strong>\n  root hub\n </strong>\n , while other devices connect to\n <strong>\n  external hubs\n </strong>\n that are downstream from the root hub.\n</p>\n<p>\n A hub has several important functions:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Managing Connections\n   </strong>\n   : Hubs help newly attached devices establish communication and prevent faulty or misbehaving devices from interfering with other devices on the bus.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Managing Power\n   </strong>\n   : Hubs supply the necessary\n   <strong>\n    bus current\n   </strong>\n   to attached devices, ensuring each device gets the power it requires.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Handling Traffic\n   </strong>\n   : The hub plays a key role in transferring data between the host and the devices. This process depends on the speed capabilities of the host, the device, and the hub itself.\n  </p>\n</li>\n</ol>\n"}, "Page 457": {"response": "<h3>\n Hub Basics: The Heart of USB Connectivity\n</h3>\n<p>\n A\n <strong>\n  USB hub\n </strong>\n serves as the intermediary between devices and the host, managing their connections. Here's a breakdown of how hubs function:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Upstream Port\n   </strong>\n   : Every external hub has one\n   <strong>\n    upstream port\n   </strong>\n   that connects to the\n   <strong>\n    host\n   </strong>\n   or the\n   <strong>\n    root hub\n   </strong>\n   . This port may also link to another external hub, creating a\n   <strong>\n    hub chain\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Downstream Ports\n   </strong>\n   : Hubs also feature multiple\n   <strong>\n    downstream ports\n   </strong>\n   where devices can connect. These ports typically have connectors for attaching cables, although some hubs may be part of a\n   <strong>\n    compound device\n   </strong>\n   , where the ports connect to embedded functions rather than external devices. Common configurations of hubs include those with\n   <strong>\n    one, two, four, or seven downstream ports\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Power Types\n   </strong>\n   : A hub can be either\n   <strong>\n    self-powered\n   </strong>\n   or\n   <strong>\n    bus-powered\n   </strong>\n   . Self-powered hubs provide their own power, while bus-powered hubs rely on the USB bus for power.\n   <strong>\n    Bus-powered hubs\n   </strong>\n   have limitations, especially when it comes to connecting high-power devices, as detailed in Chapter 16.\n  </p>\n</li>\n</ul>\n<p>\n While you don\u2019t need to know every intricate detail about how hubs work when designing a USB peripheral, understanding these basic hub functions helps in understanding device communication on the bus and how devices are detected and managed.\n</p>\n"}, "Page 458": {"response": "<h3>\n Hubs: The Link Between Devices and the Host\n</h3>\n<p>\n A USB hub serves as the connection point between USB devices and the host computer, typically acting as an intermediary to manage traffic and ensure communication between devices and the host. Every external USB hub contains two primary components: the\n <strong>\n  hub repeater\n </strong>\n and the\n <strong>\n  hub controller\n </strong>\n .\n</p>\n<h4>\n The Hub Repeater\n</h4>\n<p>\n The\n <strong>\n  hub repeater\n </strong>\n is responsible for transmitting USB data between the host's root hub (or another upstream hub) and any connected downstream devices. It ensures that data is passed with minimal modifications, forwarding packets from upstream to downstream or vice versa. Additionally, the hub repeater monitors the connection status of devices, detecting when a device is attached or removed, and establishes the device's connection to the USB bus. It also manages power delivery to the device and detects bus faults, such as over-current conditions.\n</p>\n<p>\n The hub repeater in USB 2.0 hubs operates in different modes based on the upstream connection\u2019s bus speed. If connected to a\n <strong>\n  full-speed\n </strong>\n bus, it functions as a low- and full-speed repeater, supporting devices that communicate at these speeds. If connected to a\n <strong>\n  high-speed\n </strong>\n bus, the repeater works as a high-speed repeater, supporting faster data transfer.\n</p>\n<p>\n For USB 1.x hubs, the hub repeater handles only low- and full-speed traffic. In USB 2.0 hubs, the same repeater is used when the upstream port is connected to a full-speed bus, in which case it behaves like a USB 1.x hub, meaning it will not support high-speed traffic.\n</p>\n<h4>\n The Hub Controller\n</h4>\n<p>\n The\n <strong>\n  hub controller\n </strong>\n manages the communication between the host and the hub repeater. It uses state machines to manage how the hub responds to events that occur at the hub repeater, as well as at the upstream and downstream ports. These state machines are crucial because the timing of these events is precise and cannot be handled by firmware alone. A USB 2.0 hub also includes transaction translators and routing logic, which are necessary for facilitating communication between low-speed, full-speed, and high-speed devices on the same bus.\n</p>\n<h4>\n The Host\u2019s Root Hub\n</h4>\n<p>\n The\n <strong>\n  root hub\n </strong>\n is a special case. It is integrated into the host computer and performs some of the functions that an external hub's repeater and controller would manage. In fact, the root hub may only consist of routing logic and downstream ports because the host controller already performs most of the necessary functions that are handled by the hub repeater and controller in an external hub.\n</p>\n<h3>\n Summary\n</h3>\n<p>\n In short, USB hubs are essential for linking devices to the host. The hub repeater re-transmits data between devices and the host, while the hub controller ensures proper communication. The root hub on the host computer is a simplified version of an external hub, handling many of the same functions.\n</p>\n"}, "Page 459": {"response": "<h3>\n USB 2.0 Hub and Its Components\n</h3>\n<p>\n A USB 2.0 hub contains special components that allow it to manage data traffic effectively between different types of devices. Specifically, it includes\n <strong>\n  transaction translators\n </strong>\n and\n <strong>\n  routing logic\n </strong>\n , which enable the hub to support communication between high-speed devices and low- or full-speed devices.\n</p>\n<p>\n In contrast, a\n <strong>\n  1.x hub\n </strong>\n is simpler, and its hub repeater is directly connected to the downstream ports without the need for transaction translators or additional routing logic. This setup limits the 1.x hub to handling only low- and full-speed communication.\n</p>\n"}, "Page 460": {"response": "<h3>\n Hubs: The Link Between Devices and the Host\n</h3>\n<h4>\n 1.x Hub and Low- and Full-Speed Devices\n</h4>\n<p>\n A\n <strong>\n  1.x USB hub\n </strong>\n is designed to repeat low- and full-speed data packets received from the host to all enabled, downstream ports. Enabled ports are those where devices are ready to communicate, which means they are actively responding to the hub's signals. Devices on ports that aren\u2019t enabled might be in different states, such as being suspended, disconnected due to errors, or not yet initialized after being attached.\n</p>\n<p>\n The hub repeater does not process or alter the data it transmits; it simply regenerates the signal\u2019s edges and passes the data along. Specifically, the hub does not examine or modify the traffic from full-speed ports. It merely repeats full-speed packets to full-speed devices.\n</p>\n<p>\n For\n <strong>\n  low-speed devices\n </strong>\n , the hub only repeats\n <strong>\n  low-speed packets\n </strong>\n . These packets are identified by a specific\n <strong>\n  PRE packet identifier\n </strong>\n that comes before the data. The hub sends these low-speed packets to any\n <strong>\n  enabled low-speed ports\n </strong>\n and also forwards them to full-speed ports because the full-speed port may be connected to another hub that links to a low-speed device.\n</p>\n<p>\n To ensure the low-speed device has time to be ready for communication, there is a delay added by the host. This delay is at least four full-speed bit-widths between the\n <strong>\n  PRE packet\n </strong>\n and the low-speed data packet.\n</p>\n<p>\n There are also differences in signal characteristics for low-speed and full-speed traffic. Low-speed traffic has a distinct\n <strong>\n  edge rate\n </strong>\n and\n <strong>\n  polarity\n </strong>\n . The hub closest to a low-speed device uses the low-speed settings for communication. When sending data upstream, the hub adjusts the signal to match full-speed\u2019s faster edge rate and inverted polarity. The repeater is responsible for making these necessary adjustments between low-speed and full-speed communication.\n</p>\n<h4>\n The High-Speed Repeater in USB 2.0 Hubs\n</h4>\n<p>\n A\n <strong>\n  USB 2.0 hub\n </strong>\n includes a\n <strong>\n  high-speed repeater\n </strong>\n when it connects to a high-speed bus. In this configuration, the hub handles all upstream traffic at high speed, even if the traffic is directed toward or from a full-speed or low-speed device. This ensures high-speed communication remains intact when passing through the hub, even if the attached devices operate at different speeds.\n</p>\n"}, "Page 461": {"response": "<h3>\n High-Speed Repeater and Transaction Translator in USB Hubs\n</h3>\n<h4>\n High-Speed Repeater\n</h4>\n<p>\n In a\n <strong>\n  USB 2.0 hub\n </strong>\n , the\n <strong>\n  high-speed repeater\n </strong>\n ensures efficient data transmission when the upstream port connects to a high-speed bus. The routing of traffic through the hub depends on the speed of the attached devices. The\n <strong>\n  routing logic\n </strong>\n in the hub decides if traffic needs to pass through a\n <strong>\n  transaction translator\n </strong>\n , based on the speed of the devices involved.\n</p>\n<p>\n One important feature of the high-speed repeater is that it\n <strong>\n  re-clocks\n </strong>\n the data it receives. This helps to minimize\n <strong>\n  jitter\n </strong>\n (timing errors). Rather than simply repeating the received signal transitions, the high-speed repeater extracts the data and uses its own\n <strong>\n  local clock\n </strong>\n to time the signal transitions accurately when sending the data out. The\n <strong>\n  edge rate\n </strong>\n and\n <strong>\n  polarity\n </strong>\n of the signal remain unchanged. An\n <strong>\n  elasticity buffer\n </strong>\n allows for small timing differences between the input and output clocks. When the buffer is half full, it starts sending out the data.\n</p>\n<p>\n High-speed devices do not require the\n <strong>\n  transaction translator\n </strong>\n . Data from these devices flows directly from the receiving port on the hub through the high-speed repeater and out through the transmitting port.\n</p>\n<p>\n However, for\n <strong>\n  low- and full-speed devices\n </strong>\n , the high-speed repeater works in conjunction with the\n <strong>\n  transaction translator\n </strong>\n , which manages the communication with these devices. When traffic is received from upstream, it is routed to the high-speed repeater, which passes the data to the transaction translator. The translator then adjusts the data for communication at the appropriate speed (low or full). Conversely, when traffic is sent from low- or full-speed devices, the transaction translator processes the data and sends it to the correct destination.\n</p>\n<h4>\n The Transaction Translator\n</h4>\n<p>\n Every\n <strong>\n  USB 2.0 hub\n </strong>\n must include a\n <strong>\n  transaction translator\n </strong>\n to facilitate communication with low- and full-speed devices. This component enables\n <strong>\n  1.x devices\n </strong>\n to communicate with the hub at low and full speeds, just as they would with a 1.x host.\n</p>\n<p>\n The transaction translator\n <strong>\n  stores\n </strong>\n the data received from low- or full-speed devices, and then forwards it at the correct speed (high-speed) for further processing. This allows\n <strong>\n  other bus communications\n </strong>\n to occur simultaneously, freeing up bus time and improving overall efficiency while the low- or full-speed transaction is being processed.\n</p>\n"}, "Page 462": {"response": "<h3>\n Transaction Translator and Its Role in USB 2.0 Hubs\n</h3>\n<h4>\n Enhancing Bandwidth for Low- and Full-Speed Devices\n</h4>\n<p>\n A\n <strong>\n  transaction translator\n </strong>\n in a\n <strong>\n  USB 2.0 hub\n </strong>\n allows low- and full-speed devices to use more bandwidth than they would on a shared 1.x USB bus. By acting as an intermediary between the host and these devices, the transaction translator enables more efficient data handling and communication.\n</p>\n<h4>\n Components of a Transaction Translator\n</h4>\n<p>\n The\n <strong>\n  transaction translator\n </strong>\n consists of three main sections:\n</p>\n<ol>\n<li>\n<strong>\n   High-Speed Handler\n  </strong>\n  : This section manages communication with the host at high speed.\n </li>\n<li>\n<strong>\n   Low/Full-Speed Handler\n  </strong>\n  : This section handles communication with devices operating at low or full speed.\n </li>\n<li>\n<strong>\n   Buffers\n  </strong>\n  : The buffers store data during transactions with low- and full-speed devices. Each translator requires at least four buffers:\n  <ul>\n<li>\n    One buffer for\n    <strong>\n     interrupt and isochronous start-split transactions\n    </strong>\n    .\n   </li>\n<li>\n    One buffer for\n    <strong>\n     interrupt and isochronous complete-split transactions\n    </strong>\n    .\n   </li>\n<li>\n    Two or more buffers for\n    <strong>\n     control and bulk transfers\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n These buffers ensure smooth data flow and facilitate efficient communication between devices and the host, especially for transactions that require splitting or handling multiple phases.\n</p>\n<h4>\n Managing Split Transactions\n</h4>\n<p>\n When a\n <strong>\n  2.0 host\n </strong>\n on a high-speed bus needs to communicate with a low- or full-speed device, the host starts a\n <strong>\n  start-split transaction\n </strong>\n through the 2.0 hub closest to the device. This transaction initiates communication at high speed and contains the necessary information for the hub to manage the transfer.\n</p>\n<p>\n A\n <strong>\n  start-split transaction\n </strong>\n enables the hub to perform the required data exchange, even if the devices operate at different speeds. The use of split transactions allows for smoother communication between high-speed hosts and low- or full-speed devices.\n</p>\n"}, "Page 463": {"response": "<h3>\n Managing Split Transactions and Completing Device Communication\n</h3>\n<h4>\n Handling Start-Split Transactions\n</h4>\n<p>\n When the\n <strong>\n  2.0 host\n </strong>\n communicates with a low- or full-speed device, the host starts a\n <strong>\n  start-split transaction\n </strong>\n through the hub closest to the device. The\n <strong>\n  transaction translator\n </strong>\n temporarily stores the information from the host and helps complete the start-split transaction. The hub, acting like a\n <strong>\n  host controller\n </strong>\n , takes over the transaction with the device, following the steps of the USB protocol, which includes three main phases:\n</p>\n<ol>\n<li>\n<strong>\n   Token Phase\n  </strong>\n  : The transaction translator initiates the transaction by sending the appropriate token.\n </li>\n<li>\n<strong>\n   Data Phase\n  </strong>\n  : The translator sends or stores data, or handles any status information that needs to be exchanged.\n </li>\n<li>\n<strong>\n   Handshake Phase\n  </strong>\n  : The transaction concludes with a status code being sent or received to confirm the successful completion of the transaction.\n </li>\n</ol>\n<p>\n The hub communicates with the device at the correct speed, using\n <strong>\n  low\n </strong>\n or\n <strong>\n  full-speed\n </strong>\n communication, depending on the device's capabilities. Once the data exchange is completed, the host initiates a\n <strong>\n  complete-split transaction\n </strong>\n to retrieve the information stored in the transaction translator's buffer.\n</p>\n<h4>\n Completing the Transaction\n</h4>\n<p>\n After the hub exchanges data with the device, the host requests the information stored in the transaction translator\u2019s buffer, except for\n <strong>\n  isochronous OUT transactions\n </strong>\n . These complete-split transactions are carried out at\n <strong>\n  high speed\n </strong>\n by the hub, ensuring efficient retrieval of the data from the device.\n</p>\n<h4>\n Bulk and Control Transfers\n</h4>\n<p>\n Bulk and\n <strong>\n  control transfers\n </strong>\n , unlike interrupt or\n <strong>\n  isochronous transfers\n </strong>\n , do not have strict timing requirements. The\n <strong>\n  start-split transaction\n </strong>\n involves the following steps:\n</p>\n<ol>\n<li>\n  The\n  <strong>\n   host\n  </strong>\n  sends a\n  <strong>\n   start-split token packet (SSPLIT)\n  </strong>\n  , followed by the usual low- or full-speed token packet and any data destined for the device.\n </li>\n<li>\n  The\n  <strong>\n   hub\n  </strong>\n  , which communicates upstream at high speed, acknowledges with either\n  <strong>\n   ACK\n  </strong>\n  or\n  <strong>\n   NAK\n  </strong>\n  .\n </li>\n<li>\n  The host is then free to use the bus for other transactions, while the device remains unaware of the transaction until the data is sent to it.\n </li>\n</ol>\n<p>\n After the\n <strong>\n  ACK\n </strong>\n is returned, the hub has two primary responsibilities:\n</p>\n<ol>\n<li>\n<strong>\n   Complete the transaction\n  </strong>\n  with the device by converting the received data into the appropriate speed and sending it to the device.\n </li>\n<li>\n<strong>\n   Continue managing other bus traffic\n  </strong>\n  for the host and any other attached devices.\n </li>\n</ol>\n<p>\n The hub processes the data, stores any responses from the device, and completes the transaction, all while maintaining communication efficiency and ensuring the correct data is exchanged.\n</p>\n"}, "Page 464": {"response": "<h3>\n Completing Transactions and Handling Multiple Bus Traffic\n</h3>\n<h4>\n Handling Data and Handshakes in Split Transactions\n</h4>\n<p>\n In a\n <strong>\n  split transaction\n </strong>\n , when the hub communicates with a low- or full-speed device, the device may return various responses, such as data, a handshake, or no response at all. For\n <strong>\n  IN transactions\n </strong>\n , the hub returns a handshake to the device, confirming that the transaction has completed successfully at the expected low or full speed. Importantly, the device is unaware that it was part of a split transaction and only sees the communication as a regular low- or full-speed interaction.\n</p>\n<p>\n While the hub is working on completing the transaction with the device, the\n <strong>\n  host\n </strong>\n can initiate other bus traffic. The hub is capable of handling these additional transactions simultaneously, thanks to separate hardware modules within the hub that manage different tasks. This allows the hub to maintain communication with the device while also processing new traffic from the host.\n</p>\n<h4>\n Starting and Completing a Complete-Split Transaction\n</h4>\n<p>\n Once the host assumes enough time has passed for the hub to complete the transaction with the device, the host starts a\n <strong>\n  complete-split transaction\n </strong>\n . In this phase, the host sends a\n <strong>\n  complete-split token packet (CSPLIT)\n </strong>\n followed by a low- or full-speed token packet. This signals the hub to send the data from the device back to the host.\n</p>\n<p>\n The\n <strong>\n  complete-split transaction\n </strong>\n allows the host to retrieve the data stored by the hub during the earlier stages of the split transaction. By managing this process efficiently, the host ensures it can continue its operations while waiting for data from devices that operate at slower speeds.\n</p>\n<h4>\n Isochronous Transactions and Multiple Split Transactions\n</h4>\n<p>\n For\n <strong>\n  isochronous transactions\n </strong>\n , which require continuous and time-sensitive data flow, multiple start-split and complete-split transactions may be used to ensure the timely transfer of data. The hub handles these transactions while maintaining synchronization with the host, ensuring that data is delivered in the required timeframes.\n</p>\n"}, "Page 465": {"response": "<h3>\n Completing Split Transactions and Isochronous Transfers\n</h3>\n<h4>\n Completing the Transfer\n</h4>\n<p>\n Once the\n <strong>\n  complete-split transaction\n </strong>\n begins, the hub sends the requested data or status information to the host. At this point, the transfer is considered complete from the host's perspective. The\n <strong>\n  host\n </strong>\n does not acknowledge (ACK) the hub\u2019s response. If the\n <strong>\n  hub\n </strong>\n is not ready with the data, it returns a\n <strong>\n  NYET\n </strong>\n (Not Yet) status code, prompting the host to retry the transfer later. The device remains unaware of the complete-split transaction taking place, as it only interacts with the hub during its low or full-speed communication.\n</p>\n<h4>\n Interrupt and Isochronous Transfers\n</h4>\n<p>\n For\n <strong>\n  interrupt\n </strong>\n and\n <strong>\n  isochronous transfers\n </strong>\n , the process is similar but requires more precise timing. The aim is to transfer data to the host as soon as the device has data ready and to send data to the device just before it is ready to receive new information. This timing ensures that the communication flow is efficient and meets the device's needs.\n</p>\n<p>\n In\n <strong>\n  isochronous transfers\n </strong>\n , especially with larger data packets, multiple\n <strong>\n  start-split\n </strong>\n or\n <strong>\n  complete-split transactions\n </strong>\n are used to transfer portions of the data in each transaction. Unlike\n <strong>\n  bulk and control transfers\n </strong>\n ,\n <strong>\n  interrupt\n </strong>\n and\n <strong>\n  isochronous transfers\n </strong>\n do not have a handshake phase. Instead, the transaction begins with a\n <strong>\n  start-split token\n </strong>\n followed by an\n <strong>\n  IN\n </strong>\n ,\n <strong>\n  OUT\n </strong>\n , or\n <strong>\n  Setup\n </strong>\n token, depending on the type of transaction (OUT or Setup for sending data to the device, and IN for receiving data from the device).\n</p>\n<h4>\n Table 15-1: Transaction Phases for Low/Full-Speed and High-Speed Devices\n</h4>\n<p>\n The table below compares the phases of transactions when a low- or full-speed device operates on a high-speed bus. The host uses\n <strong>\n  start-split (SSPLIT)\n </strong>\n and\n <strong>\n  complete-split (CSPLIT)\n </strong>\n transactions through the hub nearest the device, with the hub handling communication at the appropriate speed (low or full speed) for the device.\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Bus Speed\n    </strong>\n</th>\n<th>\n<strong>\n     Transaction Type\n    </strong>\n</th>\n<th>\n<strong>\n     Transaction Phase\n    </strong>\n</th>\n<th>\n<strong>\n     Token\n    </strong>\n</th>\n<th>\n<strong>\n     Data\n    </strong>\n</th>\n<th>\n<strong>\n     Handshake\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     Low/Full-speed communications\n    </strong>\n</td>\n<td>\n<strong>\n     Setup, OUT\n    </strong>\n</td>\n<td>\n    PRE (if low speed), LS/FS token\n   </td>\n<td>\n    PRE (if low speed), data\n   </td>\n<td>\n    Status (except for isochronous)\n   </td>\n<td>\n</td>\n</tr>\n<tr>\n<td>\n</td>\n<td>\n<strong>\n     IN\n    </strong>\n</td>\n<td>\n    PRE (if low speed), LS/FS token\n   </td>\n<td>\n    Data or status\n   </td>\n<td>\n    PRE (if low speed), status (except isochronous)\n   </td>\n<td>\n</td>\n</tr>\n<tr>\n<td>\n<strong>\n     High-speed communications\n    </strong>\n</td>\n<td>\n<strong>\n     Setup, OUT\n    </strong>\n    (isochronous OUT no CSPLIT)\n   </td>\n<td>\n    SSPLIT, LS/FS token\n   </td>\n<td>\n    Data\n   </td>\n<td>\n    Status (bulk and control only)\n   </td>\n<td>\n</td>\n</tr>\n<tr>\n<td>\n</td>\n<td>\n<strong>\n     CSPLIT\n    </strong>\n</td>\n<td>\n    SSPLIT, LS/FS token\n   </td>\n<td>\n    \u2013\n   </td>\n<td>\n    Status (bulk and control only)\n   </td>\n<td>\n</td>\n</tr>\n<tr>\n<td>\n</td>\n<td>\n<strong>\n     IN\n    </strong>\n</td>\n<td>\n    SSPLIT, LS/FS token\n   </td>\n<td>\n    Status (bulk and control only)\n   </td>\n<td>\n    CSPLIT, LS/FS token, data or status\n   </td>\n<td>\n</td>\n</tr>\n</tbody>\n</table>\n<p>\n This table outlines the structure of transactions at different bus speeds, showing how\n <strong>\n  start-split\n </strong>\n and\n <strong>\n  complete-split\n </strong>\n transactions are used to ensure proper communication and data exchange between devices and the host, with specific considerations for different types of transactions (e.g., bulk, control, and isochronous).\n</p>\n"}, "Page 466": {"response": "<h3>\n Interrupt and Isochronous Transactions in Split Transactions\n</h3>\n<h4>\n Interrupt Transactions and Scheduling\n</h4>\n<p>\n In\n <strong>\n  interrupt transactions\n </strong>\n , the hub schedules the\n <strong>\n  start-split\n </strong>\n at the earliest possible time within the\n <strong>\n  microframe\n </strong>\n , which is the smallest unit of time for data transfer. For example, if the microframes in a frame are numbered from\n <strong>\n  Y0\n </strong>\n to\n <strong>\n  Y7\n </strong>\n , and the\n <strong>\n  start-split\n </strong>\n occurs in\n <strong>\n  Y0\n </strong>\n , the transaction with the device can begin as early as\n <strong>\n  Y1\n </strong>\n . The device may have data or a handshake response ready for the host by\n <strong>\n  Y2\n </strong>\n .\n</p>\n<p>\n To manage these timings efficiently, the host schedules up to\n <strong>\n  three complete-split transactions\n </strong>\n for\n <strong>\n  Y2\n </strong>\n ,\n <strong>\n  Y3\n </strong>\n , and\n <strong>\n  Y4\n </strong>\n . If the\n <strong>\n  hub\n </strong>\n does not yet have the necessary data to return, it sends a\n <strong>\n  NYET\n </strong>\n (Not Yet) status code, and the host will retry the transaction.\n</p>\n<h4>\n Isochronous Transactions with Full-Speed Devices\n</h4>\n<p>\n<strong>\n  Full-speed isochronous transactions\n </strong>\n allow the transfer of up to\n <strong>\n  1023 bytes\n </strong>\n of data. For large data transfers, multiple\n <strong>\n  start-split\n </strong>\n or\n <strong>\n  complete-split transactions\n </strong>\n are used to ensure that data is transferred\n <strong>\n  just in time\n </strong>\n \u2014either as soon as the device has data to send or when it is ready to receive new data. Each\n <strong>\n  microframe\n </strong>\n can carry a maximum of\n <strong>\n  188 bytes\n </strong>\n of data at full speed. As a result, a single transaction may require up to\n <strong>\n  eight start-split\n </strong>\n or\n <strong>\n  complete-split transactions\n </strong>\n .\n</p>\n<h4>\n Isochronous IN Transactions\n</h4>\n<p>\n For\n <strong>\n  isochronous IN transactions\n </strong>\n (where data is being transferred from the device to the host), the host schedules\n <strong>\n  complete-split transactions\n </strong>\n in every microframe where it expects the device to have data ready. This approach ensures that the host receives the data as soon as the device has it available, without needing to wait for the entire data set to transfer all at once. The use of smaller data chunks allows for faster retrieval and more efficient data handling.\n</p>\n<h4>\n Isochronous OUT Transactions\n</h4>\n<p>\n In\n <strong>\n  isochronous OUT transactions\n </strong>\n (where data is sent from the host to the device), the host schedules one or more\n <strong>\n  start-split transactions\n </strong>\n to send the data. The hub\u2019s buffer is carefully managed to ensure it is never empty but holds as few bytes as possible at any given time. Each\n <strong>\n  SPLIT packet\n </strong>\n includes bits to indicate the position of the data within the low- or full-speed data packet (such as\n <strong>\n  beginning\n </strong>\n ,\n <strong>\n  middle\n </strong>\n ,\n <strong>\n  end\n </strong>\n , or\n <strong>\n  all\n </strong>\n ). Unlike other types of transactions, there is no\n <strong>\n  complete-split\n </strong>\n transaction in isochronous OUT transfers. The host simply continues sending data in the scheduled start-split transactions.\n</p>\n"}, "Page 467": {"response": "<h3>\n Bandwidth Use and Hub Controller Management\n</h3>\n<h4>\n Bandwidth Management for Low- and Full-speed Devices\n</h4>\n<p>\n In a\n <strong>\n  2.0 hub\n </strong>\n , low- and full-speed devices share bandwidth from the 1.x bus only with other devices that use the same\n <strong>\n  transaction translator\n </strong>\n . This setup allows more efficient use of bandwidth since two full-speed devices connected to separate\n <strong>\n  2.0 hubs\n </strong>\n on a high-speed bus can each utilize all of their allocated full-speed bandwidth. When the hub switches to high-speed mode, the\n <strong>\n  1.x communications\n </strong>\n (low- and full-speed devices) occupy minimal bandwidth on the high-speed bus.\n</p>\n<p>\n However, when performing\n <strong>\n  bulk transactions\n </strong>\n , the extra step of handling each transaction through a split can slow down the transfer rate, especially if the bus is also carrying high-speed bulk traffic. In such situations,\n <strong>\n  full-speed devices\n </strong>\n on a busy bus may experience slower data rates.\n</p>\n<p>\n Many hubs use a\n <strong>\n  single transaction translator\n </strong>\n for all ports, but some may provide a separate\n <strong>\n  transaction translator\n </strong>\n for each port that connects to a low- or full-speed device, which can help manage bandwidth more effectively.\n</p>\n<h4>\n Hub Controller Responsibilities\n</h4>\n<p>\n The\n <strong>\n  hub controller\n </strong>\n is in charge of managing communications between the\n <strong>\n  host\n </strong>\n and the\n <strong>\n  hub\n </strong>\n . This includes handling the enumeration process as well as managing other tasks and responding to events at the downstream ports.\n</p>\n<p>\n When the host detects a newly connected hub, it\n <strong>\n  enumerates\n </strong>\n the hub to gather information about its capabilities. The\n <strong>\n  hub descriptor\n </strong>\n retrieved during this process informs the host about the number of ports the hub has. After the hub is enumerated, the host asks the hub to report any attached devices. If devices are present, the host proceeds to enumerate them as well.\n</p>\n<p>\n To check whether a device is connected to a specific port, the host sends a\n <strong>\n  Get_Port_Status\n </strong>\n request to the hub. This is a\n <strong>\n  hub-class request\n </strong>\n similar to the\n <strong>\n  Get_Status\n </strong>\n request, but it targets the hub with a port number specified in the\n <strong>\n  Index field\n </strong>\n . The hub responds with two\n <strong>\n  16-bit values\n </strong>\n that indicate whether a device is attached, as well as other details such as the device's power status or whether it is in the\n <strong>\n  Suspend state\n </strong>\n .\n</p>\n<p>\n The hub controller is also responsible for managing situations where a port causes issues on the bus. If a port is responsible for\n <strong>\n  loss of bus activity\n </strong>\n (e.g., when a packet doesn't end with the expected\n <strong>\n  End-of-Packet\n </strong>\n signal) or\n <strong>\n  babble\n </strong>\n (when a device continues transmitting past the expected\n <strong>\n  End-of-Packet\n </strong>\n signal), the hub controller disables that port to maintain proper bus operation.\n</p>\n"}, "Page 468": {"response": "<h3>\n Hub Endpoints and Device Speed Detection\n</h3>\n<h4>\n Hub Status Change Endpoint\n</h4>\n<p>\n In addition to the required\n <strong>\n  Endpoint 0\n </strong>\n (used for control transfers), each\n <strong>\n  hub\n </strong>\n must also have a\n <strong>\n  Status Change endpoint\n </strong>\n . This endpoint is configured for\n <strong>\n  interrupt IN transfers\n </strong>\n , and the\n <strong>\n  host\n </strong>\n periodically polls it to check for any changes at the hub.\n</p>\n<p>\n When the host polls this endpoint, the\n <strong>\n  hub controller\n </strong>\n either responds with a\n <strong>\n  NAK\n </strong>\n (No Acknowledgment) if no changes have occurred, or it provides data indicating a specific port or the hub itself as the source of the change. If the hub reports a change, such as a new device being attached, the host will send additional requests to gather more information and take appropriate action, such as\n <strong>\n  enumerating the new device\n </strong>\n .\n</p>\n<h4>\n Speed Compatibility in Hubs\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    External 2.0 hubs\n   </strong>\n   : The\n   <strong>\n    downstream ports\n   </strong>\n   of a 2.0 hub must support all three USB speeds (low, full, and high speed). The hub\u2019s\n   <strong>\n    upstream communication\n   </strong>\n   speed depends on the upstream segment:\n  </p>\n<ul>\n<li>\n    If the upstream segment is high-speed, the hub communicates at high speed.\n   </li>\n<li>\n    Otherwise, the hub communicates at low or full speed.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    1.x hubs\n   </strong>\n   : The\n   <strong>\n    upstream port\n   </strong>\n   must support low- and full-speed communications only, and all\n   <strong>\n    downstream ports\n   </strong>\n   must also support these speeds.\n   <strong>\n    1.x hubs do not support high-speed communication\n   </strong>\n   .\n  </p>\n</li>\n</ul>\n<h4>\n Traffic Filtering Based on Speed\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Low-speed devices\n   </strong>\n   cannot process full-speed data. Therefore, hubs do not send full-speed traffic to low-speed devices. If full-speed traffic were sent to a low-speed device, it could misinterpret the data, which might lead to errors. Additionally,\n   <strong>\n    electromagnetic interference (EMI)\n   </strong>\n   from full-speed data on a low-speed cable could cause issues.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Low-speed devices\n   </strong>\n   can receive low-speed data from the upstream side, but they will not receive full- or high-speed traffic from the hub.\n  </p>\n</li>\n<li>\n<p>\n   Similarly,\n   <strong>\n    low- and full-speed devices\n   </strong>\n   cannot handle high-speed data, so\n   <strong>\n    2.0 hubs\n   </strong>\n   will not send high-speed traffic to these devices, including\n   <strong>\n    1.x hubs\n   </strong>\n   . This ensures proper operation and avoids potential communication issues.\n  </p>\n</li>\n</ul>\n<h4>\n Device Speed Detection\n</h4>\n<p>\n When a device is attached to a hub, the hub needs to identify whether the device operates at\n <strong>\n  low speed\n </strong>\n or\n <strong>\n  full speed\n </strong>\n . This is done through\n <strong>\n  speed detection\n </strong>\n mechanisms. The hub determines the device's speed by detecting which type of traffic it can handle and communicating accordingly.\n</p>\n"}, "Page 469": {"response": "<h3>\n Device Speed Detection in Hubs\n</h3>\n<h4>\n Speed Detection Process\n</h4>\n<p>\n When a device is attached to a\n <strong>\n  USB hub\n </strong>\n , the hub detects whether the device operates at\n <strong>\n  low speed\n </strong>\n or\n <strong>\n  full speed\n </strong>\n based on the voltage levels on the signal lines.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Pull-up and Pull-down Resistors\n   </strong>\n   : The hub\u2019s\n   <strong>\n    signal lines\n   </strong>\n   (D+ and D-) are each equipped with a\n   <strong>\n    pull-down resistor\n   </strong>\n   with a value between\n   <strong>\n    14.25k\u03a9 and 24.8k\u03a9\n   </strong>\n   . Meanwhile, the attached device has a\n   <strong>\n    pull-up resistor\n   </strong>\n   of\n   <strong>\n    900 to 1575 ohms\n   </strong>\n   on either the\n   <strong>\n    D+\n   </strong>\n   line (for full-speed devices) or the\n   <strong>\n    D-\n   </strong>\n   line (for low-speed devices).\n  </p>\n<ul>\n<li>\n    When a device is connected, the signal line with the pull-up resistor becomes more positive than the\n    <strong>\n     hub\u2019s logic-high input threshold\n    </strong>\n    . This change allows the hub to detect that a device is present.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Device Speed Identification\n   </strong>\n   : The hub determines the speed of the attached device by checking which signal line has been pulled up:\n  </p>\n<ul>\n<li>\n    If the\n    <strong>\n     D+ line\n    </strong>\n    is pulled up, the device is operating at\n    <strong>\n     full speed\n    </strong>\n    .\n   </li>\n<li>\n    If the\n    <strong>\n     D- line\n    </strong>\n    is pulled up, the device is operating at\n    <strong>\n     low speed\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n High-Speed Detection for Full-Speed Devices\n</h4>\n<p>\n After detecting a\n <strong>\n  full-speed device\n </strong>\n , the hub needs to check if the device also supports\n <strong>\n  high-speed\n </strong>\n communication. This is done through a\n <strong>\n  high-speed detection handshake\n </strong>\n , which occurs during the\n <strong>\n  Reset state\n </strong>\n that the hub initiates when the device is first enumerated. This handshake ensures that the device supports high-speed communication, if applicable.\n</p>\n<p>\n This process helps the hub configure the communication speed correctly and ensures the system is aware of the capabilities of the attached device.\n</p>\n"}, "Page 470": {"response": "<h3>\n Hub Functions and Bus Maintenance\n</h3>\n<h4>\n High-Speed Detection for Full-Speed Devices\n</h4>\n<p>\n When a full-speed device is connected to a\n <strong>\n  USB 2.0 hub\n </strong>\n , the hub attempts a\n <strong>\n  high-speed detection handshake\n </strong>\n to determine if the device also supports high-speed communication. This happens during the\n <strong>\n  Reset state\n </strong>\n when the device is first enumerated. If the handshake is successful, the device removes its pull-up resistor and switches to high-speed communication. However,\n <strong>\n  1.x hubs\n </strong>\n do not support the handshake process, and a failure of the handshake indicates that the device must communicate at\n <strong>\n  full speed\n </strong>\n instead of high speed. For further details on the handshake, see Chapter 18.\n</p>\n<h4>\n Maintaining an Idle Bus\n</h4>\n<p>\n To prevent devices from entering the\n <strong>\n  Suspend state\n </strong>\n during periods of inactivity, hubs manage communication signals on the bus:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Full- and High-Speed Devices\n   </strong>\n   : When there is no data traffic, the host continuously sends\n   <strong>\n    Start-of-Frame (SOF)\n   </strong>\n   packets to keep the bus active.\n  </p>\n<ul>\n<li>\n    On a\n    <strong>\n     full-speed bus\n    </strong>\n    , the host sends an SOF once per frame. All hubs pass these packets along to the connected\n    <strong>\n     full-speed devices\n    </strong>\n    .\n   </li>\n<li>\n    On a\n    <strong>\n     high-speed bus\n    </strong>\n    , the host sends an SOF once per\n    <strong>\n     microframe\n    </strong>\n    to maintain communication with\n    <strong>\n     high-speed devices\n    </strong>\n    .\n   </li>\n</ul>\n<p>\n   Additionally, a\n   <strong>\n    full-speed device\n   </strong>\n   connected to a 2.0 hub that communicates upstream at\n   <strong>\n    high speed\n   </strong>\n   also receives an SOF once per frame.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Low-Speed Devices\n   </strong>\n   : Low-speed devices do not receive\n   <strong>\n    Start-of-Frame packets\n   </strong>\n   . Instead, to prevent them from entering the\n   <strong>\n    Suspend state\n   </strong>\n   , hubs send a\n   <strong>\n    low-speed End-of-Packet (EOP)\n   </strong>\n   signal at least once per frame. This signal helps keep low-speed devices active in the absence of any data traffic. For further details on\n   <strong>\n    Suspend state management\n   </strong>\n   , refer to Chapter 16.\n  </p>\n</li>\n</ul>\n<h4>\n Maximum Cable Length and Hub Chains\n</h4>\n<p>\n USB 2.0 is designed for connecting peripherals over relatively short distances, but users often seek to extend this range using hubs.\n</p>\n<ul>\n<li>\n  The\n  <strong>\n   USB 2.0 specification\n  </strong>\n  does not specify a maximum cable length, but the system is limited by\n  <strong>\n   propagation delay\n  </strong>\n  . This typically results in:\n  <ul>\n<li>\n    A maximum cable length of\n    <strong>\n     5 meters\n    </strong>\n    for\n    <strong>\n     full-speed\n    </strong>\n    and\n    <strong>\n     high-speed\n    </strong>\n    communication.\n   </li>\n<li>\n    A maximum cable length of\n    <strong>\n     3 meters\n    </strong>\n    for\n    <strong>\n     low-speed\n    </strong>\n    communication.\n   </li>\n</ul>\n</li>\n<li>\n  To extend the connection further, you can use a series of hubs, with each hub connected to a\n  <strong>\n   5-meter cable\n  </strong>\n  , increasing the total length between the device and the host.\n </li>\n</ul>\n<p>\n In summary, hubs play a crucial role in managing device communication speeds, maintaining bus activity, and allowing for the extension of USB connections over greater distances.\n</p>\n"}, "Page 471": {"response": "<h3>\n Hubs and Their Limitations\n</h3>\n<h4>\n Maximum Hub Chain Length\n</h4>\n<p>\n The number of hubs that can be connected in series is constrained by the\n <strong>\n  electrical properties\n </strong>\n of both the hubs and the cables. As signals propagate along the cable and pass through each hub, delays can accumulate, limiting the number of hubs in a chain. The\n <strong>\n  maximum limit\n </strong>\n is five hubs in series. In this setup, each hub and the final device in the chain can be connected with\n <strong>\n  5-meter cables\n </strong>\n , resulting in a maximum distance of\n <strong>\n  30 meters\n </strong>\n from the host to the device.\n</p>\n<p>\n However, if the connected device is a\n <strong>\n  low-speed\n </strong>\n device, the cable can only be up to\n <strong>\n  3 meters\n </strong>\n in length, which reduces the total distance to\n <strong>\n  28 meters\n </strong>\n . For more information on extending USB distances beyond these limits, see Chapter 19.\n</p>\n<h3>\n The Hub Class\n</h3>\n<p>\n Hubs are classified under the\n <strong>\n  Hub Class\n </strong>\n , which is the only class defined in the\n <strong>\n  main USB specification\n </strong>\n .\n</p>\n<h3>\n Hub Descriptors\n</h3>\n<h4>\n Descriptors for 1.x Hubs\n</h4>\n<p>\n A\n <strong>\n  1.x hub\n </strong>\n has five primary descriptors:\n</p>\n<ol>\n<li>\n<strong>\n   Device Descriptor\n  </strong>\n</li>\n<li>\n<strong>\n   Hub Class Descriptor\n  </strong>\n</li>\n<li>\n<strong>\n   Configuration Descriptor\n  </strong>\n</li>\n<li>\n<strong>\n   Interface Descriptor\n  </strong>\n</li>\n<li>\n<strong>\n   Endpoint Descriptor\n  </strong>\n</li>\n</ol>\n<p>\n These descriptors provide the necessary information for the hub\u2019s basic functionality.\n</p>\n<h4>\n Descriptors for 2.0 Hubs\n</h4>\n<p>\n A\n <strong>\n  2.0 hub\n </strong>\n , in addition to the basic descriptors, has extra descriptors to support higher speeds and more complex functionality, such as\n <strong>\n  multiple transaction translators\n </strong>\n . These extra descriptors include:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Device_Qualifier Descriptor\n   </strong>\n   : This descriptor contains an alternative value for the\n   <strong>\n    bDeviceProtocol\n   </strong>\n   field found in the device descriptor. The alternate value is used when the hub switches between\n   <strong>\n    high-speed\n   </strong>\n   and\n   <strong>\n    full-speed\n   </strong>\n   modes.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Other_Speed_Configuration_Descriptor\n   </strong>\n   : This descriptor is required for\n   <strong>\n    high-speed-capable devices\n   </strong>\n   . It specifies the configuration that is not in use at the time, detailing the number of interfaces supported by this alternate configuration. It also includes the subordinate descriptors for the configuration not being used.\n  </p>\n</li>\n</ul>\n<p>\n For hubs supporting\n <strong>\n  multiple transaction translators\n </strong>\n , the\n <strong>\n  configuration descriptor\n </strong>\n will include two interface descriptors:\n</p>\n<ol>\n<li>\n  One interface descriptor for a\n  <strong>\n   single transaction translator\n  </strong>\n  .\n </li>\n<li>\n  An\n  <strong>\n   alternate setting\n  </strong>\n  interface descriptor for\n  <strong>\n   multiple transaction translators\n  </strong>\n  .\n </li>\n</ol>\n<p>\n The\n <strong>\n  bInterfaceProtocol\n </strong>\n field in the interface descriptor indicates whether the interface is set up for\n <strong>\n  one or multiple transaction translators\n </strong>\n .\n</p>\n<p>\n In conclusion, the descriptors define the hub\u2019s capabilities and how it handles different communication speeds and transaction translators, allowing for flexibility in connecting various USB devices to the host.\n</p>\n"}, "Page 472": {"response": "<h3>\n Hub Values for Standard Descriptors\n</h3>\n<p>\n The USB specification defines specific values for certain parameters within a hub's\n <strong>\n  device\n </strong>\n and\n <strong>\n  interface descriptors\n </strong>\n , as well as for the\n <strong>\n  status-change endpoint descriptor\n </strong>\n . These values help in identifying the hub and its capabilities.\n</p>\n<h4>\n Device Descriptor Values\n</h4>\n<p>\n The\n <strong>\n  Device Descriptor\n </strong>\n for a hub has the following values:\n</p>\n<ul>\n<li>\n<strong>\n   bDeviceClass\n  </strong>\n  : HUB_CLASSCODE (09h) \u2013 Identifies the hub as a USB hub.\n </li>\n<li>\n<strong>\n   bDeviceSubClass\n  </strong>\n  : 0 \u2013 No specific subclass for hubs.\n </li>\n<li>\n<strong>\n   bDeviceProtocol\n  </strong>\n  :\n  <ul>\n<li>\n    0: For hubs supporting\n    <strong>\n     low/full speed\n    </strong>\n    communication.\n   </li>\n<li>\n    1: For\n    <strong>\n     high-speed hubs\n    </strong>\n    that support a single transaction translator.\n   </li>\n<li>\n    2: For\n    <strong>\n     high-speed hubs\n    </strong>\n    that support multiple transaction translators.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n These values also apply to the\n <strong>\n  Device_Qualifier_Descriptor\n </strong>\n in\n <strong>\n  2.0 hubs\n </strong>\n .\n</p>\n<h4>\n Interface Descriptor Values\n</h4>\n<p>\n The\n <strong>\n  Interface Descriptor\n </strong>\n for a hub has the following values:\n</p>\n<ul>\n<li>\n<strong>\n   bNumEndpoints\n  </strong>\n  : 1 \u2013 Each hub supports one endpoint for communication.\n </li>\n<li>\n<strong>\n   bInterfaceClass\n  </strong>\n  : HUB_CLASSCODE (09h) \u2013 This signifies the interface as belonging to the\n  <strong>\n   Hub Class\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   bInterfaceSubClass\n  </strong>\n  : 0 \u2013 No specific subclass for hub interfaces.\n </li>\n<li>\n<strong>\n   bInterfaceProtocol\n  </strong>\n  :\n  <ul>\n<li>\n    0: For\n    <strong>\n     low/full speed\n    </strong>\n    hubs or\n    <strong>\n     high-speed hubs\n    </strong>\n    with a single transaction translator.\n   </li>\n<li>\n    1: For hubs supporting\n    <strong>\n     single transaction translator\n    </strong>\n    .\n   </li>\n<li>\n    2: For hubs supporting\n    <strong>\n     multiple transaction translators\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Status-Change Endpoint Descriptor Values\n</h4>\n<p>\n The\n <strong>\n  Endpoint Descriptor\n </strong>\n for the\n <strong>\n  status-change endpoint\n </strong>\n has the following values:\n</p>\n<ul>\n<li>\n<strong>\n   bEndpointAddress\n  </strong>\n  : Implementation-dependent, with\n  <strong>\n   bit 7\n  </strong>\n  (direction) set to\n  <strong>\n   IN (01h)\n  </strong>\n  \u2013 Indicates the direction of data transfer as incoming (IN).\n </li>\n<li>\n<strong>\n   wMaxPacketSize\n  </strong>\n  : Implementation-dependent \u2013 The maximum packet size for the endpoint.\n </li>\n<li>\n<strong>\n   bmAttributes\n  </strong>\n  :\n  <ul>\n<li>\n<strong>\n     Transfer Type\n    </strong>\n    : Interrupt \u2013 This specifies that the hub uses interrupt transfers to report status changes.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   bInterval\n  </strong>\n  :\n  <ul>\n<li>\n<strong>\n     FFh\n    </strong>\n    for full-speed hubs.\n   </li>\n<li>\n<strong>\n     0Ch\n    </strong>\n    for high-speed hubs \u2013 This determines the polling interval for the status change endpoint.\n   </li>\n</ul>\n</li>\n</ul>\n<h3>\n Hub Descriptor\n</h3>\n<p>\n Every hub must have a\n <strong>\n  hub-class descriptor\n </strong>\n that includes essential identifying fields:\n</p>\n<ul>\n<li>\n<strong>\n   bDescLength\n  </strong>\n  : The number of bytes in the descriptor, specifying its length.\n </li>\n<li>\n<strong>\n   bDescriptorType\n  </strong>\n  : Hub Descriptor (29h) \u2013 Identifies the descriptor as belonging to the\n  <strong>\n   Hub Class\n  </strong>\n  .\n </li>\n</ul>\n<p>\n These descriptors and values help in managing the hub's functionality, including transaction speed and the ability to handle multiple devices.\n</p>\n"}, "Page 473": {"response": "<h3>\n Hub Description\n</h3>\n<p>\n The\n <strong>\n  Hub Descriptor\n </strong>\n contains several important fields that define how the hub operates, its capabilities, and how it interacts with the attached devices. Below is a detailed explanation of the key fields in the\n <strong>\n  Hub Descriptor\n </strong>\n .\n</p>\n<h4>\n<strong>\n  bNbrPorts\n </strong>\n :\n</h4>\n<ul>\n<li>\n  This field specifies the\n  <strong>\n   number of downstream ports\n  </strong>\n  that the hub supports. Each downstream port can connect to a USB device.\n </li>\n</ul>\n<h4>\n<strong>\n  wHubCharacteristics\n </strong>\n :\n</h4>\n<p>\n This field contains several bit flags that define various characteristics of the hub:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Bits 1 and 0\n   </strong>\n   :\n   <strong>\n    Power-switching mode\n   </strong>\n</p>\n<ul>\n<li>\n<strong>\n     00\n    </strong>\n    :\n    <strong>\n     Ganged\n    </strong>\n    \u2013 All ports are powered together.\n   </li>\n<li>\n<strong>\n     01\n    </strong>\n    :\n    <strong>\n     Individual Port Power\n    </strong>\n    \u2013 Each port has its own power supply.\n   </li>\n<li>\n<strong>\n     1X\n    </strong>\n    : Only used on\n    <strong>\n     1.0 hubs\n    </strong>\n    with no power switching capability.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Bit 2\n   </strong>\n   : Indicates whether the hub is part of a\n   <strong>\n    compound device\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     1\n    </strong>\n    : The hub is part of a compound device.\n   </li>\n<li>\n<strong>\n     0\n    </strong>\n    : The hub is not part of a compound device.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Bits 4 and 3\n   </strong>\n   :\n   <strong>\n    Overcurrent Protection mode\n   </strong>\n</p>\n<ul>\n<li>\n<strong>\n     00\n    </strong>\n    : Global protection and reporting (for all ports).\n   </li>\n<li>\n<strong>\n     01\n    </strong>\n    : Protection and reporting for each port individually.\n   </li>\n<li>\n<strong>\n     1X\n    </strong>\n    : No overcurrent protection or reporting (only for bus-powered hubs).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Bits 6 and 5\n   </strong>\n   :\n   <strong>\n    Transaction Translator Think Time\n   </strong>\n<br/>\n   These bits define the maximum number of\n   <strong>\n    full-speed bit times\n   </strong>\n   required between transactions on a low- or full-speed downstream bus:\n  </p>\n<ul>\n<li>\n<strong>\n     00\n    </strong>\n    : 8 bit times.\n   </li>\n<li>\n<strong>\n     01\n    </strong>\n    : 16 bit times.\n   </li>\n<li>\n<strong>\n     10\n    </strong>\n    : 24 bit times.\n   </li>\n<li>\n<strong>\n     11\n    </strong>\n    : 32 bit times.\n   </li>\n<li>\n<strong>\n     Note\n    </strong>\n    : This applies only to\n    <strong>\n     2.0 hubs\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Bit 7\n   </strong>\n   : Indicates whether the hub supports\n   <strong>\n    Port Indicators\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     1\n    </strong>\n    : Hub supports port indicators.\n   </li>\n<li>\n<strong>\n     0\n    </strong>\n    : Hub does not support port indicators.\n   </li>\n<li>\n<strong>\n     Note\n    </strong>\n    : This applies only to\n    <strong>\n     2.0 hubs\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Bits 8 through 15\n   </strong>\n   :\n   <strong>\n    Reserved\n   </strong>\n   for future use.\n  </p>\n</li>\n</ul>\n<h4>\n<strong>\n  bPwrOn2PwrGood\n </strong>\n :\n</h4>\n<ul>\n<li>\n  This value specifies the\n  <strong>\n   maximum delay\n  </strong>\n  (in 2-millisecond increments) between the start of the power-on sequence for a port and the moment when power is available on that port.\n  <br/>\n  For example, a value of\n  <strong>\n   100\n  </strong>\n  means a\n  <strong>\n   200-millisecond delay\n  </strong>\n  .\n </li>\n</ul>\n<h4>\n<strong>\n  bHubContrCurrent\n </strong>\n :\n</h4>\n<ul>\n<li>\n  This field specifies the\n  <strong>\n   maximum current\n  </strong>\n  (in milliamperes) required by the\n  <strong>\n   hub controller\u2019s electronics\n  </strong>\n  only, excluding the power for downstream devices.\n </li>\n</ul>\n<h4>\n<strong>\n  DeviceRemovable\n </strong>\n :\n</h4>\n<ul>\n<li>\n  This field indicates whether the devices attached to the hub\u2019s ports are\n  <strong>\n   removable\n  </strong>\n  or\n  <strong>\n   non-removable\n  </strong>\n  .\n  <ul>\n<li>\n<strong>\n     0\n    </strong>\n    : Device(s) attached to the port are\n    <strong>\n     removable\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    : Device(s) attached to the port are\n    <strong>\n     non-removable\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n  The number of bits in this value equals the\n  <strong>\n   number of ports\n  </strong>\n  on the hub plus one.\n  <ul>\n<li>\n<strong>\n     Bit 0\n    </strong>\n    is reserved.\n   </li>\n<li>\n<strong>\n     Bit 1\n    </strong>\n    refers to\n    <strong>\n     Port 1\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     Bit 2\n    </strong>\n    refers to\n    <strong>\n     Port 2\n    </strong>\n    , and so on for all ports.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n<strong>\n  PortPowerCtrlMask\n </strong>\n :\n</h4>\n<ul>\n<li>\n  This field is used for\n  <strong>\n   compatibility with 1.0 software\n  </strong>\n  .\n  <ul>\n<li>\n    Each bit in this field corresponds to a port on the hub and should generally be set to\n    <strong>\n     1\n    </strong>\n    .\n   </li>\n<li>\n    The field should be padded with additional\n    <strong>\n     1s\n    </strong>\n    so that its size is a multiple of 8 bits.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n This\n <strong>\n  Hub Descriptor\n </strong>\n is essential for informing the host and other devices about the hub\u2019s capabilities, power management, transaction translator settings, and whether it supports features like overcurrent protection and port indicators.\n</p>\n"}, "Page 474": {"response": "<h3>\n 2.0 and 1.x Hub Class-Specific Requests\n</h3>\n<p>\n Hubs in the USB system support a variety of\n <strong>\n  class-specific requests\n </strong>\n . These requests vary between the 2.0 and 1.x hub classes, with 2.0 hubs supporting\n <strong>\n  12 requests\n </strong>\n and 1.x hubs supporting\n <strong>\n  9 requests\n </strong>\n . Many of these requests are specific to hubs and are variations of the standard USB requests. Below is a breakdown of these requests, their parameters, and data handling:\n</p>\n<h4>\n<strong>\n  Table 15-2: Hub Class-Specific Requests\n </strong>\n</h4>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Request\n    </strong>\n</th>\n<th>\n<strong>\n     USB Versions\n    </strong>\n</th>\n<th>\n<strong>\n     bRequest\n    </strong>\n</th>\n<th>\n<strong>\n     Data Source\n    </strong>\n</th>\n<th>\n<strong>\n     wValue\n    </strong>\n</th>\n<th>\n<strong>\n     wIndex\n    </strong>\n</th>\n<th>\n<strong>\n     Data Length\n    </strong>\n    (bytes)\n   </th>\n<th>\n<strong>\n     Data in Data Stage\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     Clear Hub Feature\n    </strong>\n</td>\n<td>\n    All\n   </td>\n<td>\n    Clear_Feature\n   </td>\n<td>\n    No Data\n   </td>\n<td>\n    Feature\n   </td>\n<td>\n    0\n   </td>\n<td>\n    -\n   </td>\n<td>\n    -\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Clear Port Feature\n    </strong>\n</td>\n<td>\n    All\n   </td>\n<td>\n    Clear_Feature\n   </td>\n<td>\n    No Data\n   </td>\n<td>\n    Feature\n   </td>\n<td>\n    Port\n   </td>\n<td>\n    -\n   </td>\n<td>\n    -\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Clear TT Buffer\n    </strong>\n</td>\n<td>\n    2.0 only\n   </td>\n<td>\n    Clear_TT_Buffer\n   </td>\n<td>\n    No Data\n   </td>\n<td>\n    Device address, endpoint #, TT_port\n   </td>\n<td>\n    -\n   </td>\n<td>\n    -\n   </td>\n<td>\n    -\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Get Bus State\n    </strong>\n</td>\n<td>\n    1.x only\n   </td>\n<td>\n    Get_State Hub\n   </td>\n<td>\n    0\n   </td>\n<td>\n    Port\n   </td>\n<td>\n    1\n   </td>\n<td>\n    Per-port bus state\n   </td>\n<td>\n    -\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Get Hub Descriptor\n    </strong>\n</td>\n<td>\n    All\n   </td>\n<td>\n    Get_Descriptor\n   </td>\n<td>\n    Hub\n   </td>\n<td>\n    Descriptor type &amp; index\n   </td>\n<td>\n    0 or Language ID\n   </td>\n<td>\n    Descriptor length\n   </td>\n<td>\n    Descriptor\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Get Hub Status\n    </strong>\n</td>\n<td>\n    All\n   </td>\n<td>\n    Get_Status\n   </td>\n<td>\n    Hub\n   </td>\n<td>\n    0\n   </td>\n<td>\n    0\n   </td>\n<td>\n    4\n   </td>\n<td>\n    Hub status &amp; change indicators\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Get Port Status\n    </strong>\n</td>\n<td>\n    All\n   </td>\n<td>\n    Get_Status\n   </td>\n<td>\n    Hub\n   </td>\n<td>\n    0\n   </td>\n<td>\n    Port\n   </td>\n<td>\n    4\n   </td>\n<td>\n    Port status &amp; change indicators\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Get TT State\n    </strong>\n</td>\n<td>\n    2.0 only\n   </td>\n<td>\n    Get_TT_State\n   </td>\n<td>\n    Hub\n   </td>\n<td>\n    TT flags\n   </td>\n<td>\n    Port\n   </td>\n<td>\n    Length\n   </td>\n<td>\n    TT state\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Reset TT\n    </strong>\n</td>\n<td>\n    2.0 only\n   </td>\n<td>\n    Reset_TT\n   </td>\n<td>\n    No Data\n   </td>\n<td>\n    0\n   </td>\n<td>\n    Port\n   </td>\n<td>\n    -\n   </td>\n<td>\n    -\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Set Hub Descriptor\n    </strong>\n</td>\n<td>\n    Optional\n   </td>\n<td>\n    Set_Descriptor\n   </td>\n<td>\n    Host\n   </td>\n<td>\n    Descriptor type &amp; index\n   </td>\n<td>\n    0 or Language ID\n   </td>\n<td>\n    Descriptor length\n   </td>\n<td>\n    Descriptor\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Set Hub Feature\n    </strong>\n</td>\n<td>\n    All\n   </td>\n<td>\n    Set_Feature\n   </td>\n<td>\n    No Data\n   </td>\n<td>\n    Feature\n   </td>\n<td>\n    0\n   </td>\n<td>\n    -\n   </td>\n<td>\n    -\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Set Port Feature\n    </strong>\n</td>\n<td>\n    All\n   </td>\n<td>\n    Set_Feature\n   </td>\n<td>\n    No Data\n   </td>\n<td>\n    Feature\n   </td>\n<td>\n    Port\n   </td>\n<td>\n    -\n   </td>\n<td>\n    -\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Stop TT\n    </strong>\n</td>\n<td>\n    2.0 only\n   </td>\n<td>\n    Stop_TT\n   </td>\n<td>\n    No Data\n   </td>\n<td>\n    0\n   </td>\n<td>\n    Port\n   </td>\n<td>\n    -\n   </td>\n<td>\n    -\n   </td>\n</tr>\n</tbody>\n</table>\n<h4>\n<strong>\n  Explanation of Common Fields:\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   bRequest\n  </strong>\n  : The specific request being made, such as\n  <code>\n   Clear_Feature\n  </code>\n  ,\n  <code>\n   Get_Descriptor\n  </code>\n  , etc.\n </li>\n<li>\n<strong>\n   Data Source\n  </strong>\n  : Indicates the source of the data, such as\n  <code>\n   Hub\n  </code>\n  ,\n  <code>\n   Device address\n  </code>\n  ,\n  <code>\n   Port\n  </code>\n  , etc.\n </li>\n<li>\n<strong>\n   wValue\n  </strong>\n  : This is a request-specific parameter, often used to specify features, device or port numbers.\n </li>\n<li>\n<strong>\n   wIndex\n  </strong>\n  : The index of the device or port being targeted by the request.\n </li>\n<li>\n<strong>\n   Data Length\n  </strong>\n  : Specifies how many bytes of data are expected in the data stage of the request. For many requests, this value will be 4 bytes or more, depending on the data returned.\n </li>\n<li>\n<strong>\n   Data in Data Stage\n  </strong>\n  : This shows the type of data that will be included in the response. For example, it could include the\n  <strong>\n   hub status\n  </strong>\n  ,\n  <strong>\n   port status\n  </strong>\n  , or\n  <strong>\n   TT state\n  </strong>\n  .\n </li>\n</ul>\n<h4>\n Key Requests:\n</h4>\n<ol>\n<li>\n<strong>\n   Clear Hub Feature\n  </strong>\n  : Resets a specific feature on the hub. This request does not have a data stage.\n </li>\n<li>\n<strong>\n   Get Hub Descriptor\n  </strong>\n  : Retrieves the hub descriptor, providing detailed information about the hub's capabilities.\n </li>\n<li>\n<strong>\n   Get Hub Status\n  </strong>\n  : Retrieves the current status of the hub and any changes.\n </li>\n<li>\n<strong>\n   Get Port Status\n  </strong>\n  : Retrieves the status of a specific port on the hub.\n </li>\n<li>\n<strong>\n   Get TT State\n  </strong>\n  : Only for\n  <strong>\n   2.0 hubs\n  </strong>\n  , retrieves the state of the transaction translator (TT).\n </li>\n<li>\n<strong>\n   Reset TT\n  </strong>\n  : Resets the transaction translator, available only on\n  <strong>\n   2.0 hubs\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Stop TT\n  </strong>\n  : Stops the transaction translator, available only on\n  <strong>\n   2.0 hubs\n  </strong>\n  .\n </li>\n</ol>\n<p>\n These requests enable the host to manage the hub, control the state of the ports, and gather important diagnostic information about the connected devices and hub itself.\n</p>\n"}, "Page 475": {"response": "<h3>\n Hub-Class Requests\n</h3>\n<p>\n Hubs in the USB system handle several types of requests, including the standard USB requests and additional hub-specific requests. While hubs accept or return data for seven of the eleven standard USB requests, some\n <strong>\n  2.0 hubs\n </strong>\n support one extra request. There are also some requests that are either optional or undefined for hubs.\n</p>\n<p>\n Like any USB device, hubs must return\n <strong>\n  STALL\n </strong>\n for any unsupported requests. The table below outlines the hub\u2019s response to the standard requests and their specifics:\n</p>\n<h4>\n Standard USB Requests for Hubs\n</h4>\n<p>\n Hubs process the following standard requests in the same manner as other devices:\n</p>\n<ul>\n<li>\n<strong>\n   Clear_Feature\n  </strong>\n</li>\n<li>\n<strong>\n   Get_Configuration\n  </strong>\n</li>\n<li>\n<strong>\n   Get_Descriptor\n  </strong>\n</li>\n<li>\n<strong>\n   Get_Status\n  </strong>\n</li>\n<li>\n<strong>\n   Set_Address\n  </strong>\n</li>\n<li>\n<strong>\n   Set_Configuration\n  </strong>\n</li>\n<li>\n<strong>\n   Set_Feature\n  </strong>\n</li>\n</ul>\n<p>\n The\n <strong>\n  Set_Descriptor\n </strong>\n request is optional, and if not supported by the hub, it should return\n <strong>\n  STALL\n </strong>\n . A 2.0 hub supporting multiple transaction translators is required to respond to\n <strong>\n  Get_Interface\n </strong>\n and\n <strong>\n  Set_Interface\n </strong>\n requests. However, hubs do not have\n <strong>\n  isochronous endpoints\n </strong>\n , so the\n <strong>\n  Synch_Frame\n </strong>\n request is undefined for hubs.\n</p>\n<h4>\n Hub-Specific Requests\n</h4>\n<p>\n The hub class defines\n <strong>\n  eight hub-specific requests\n </strong>\n , which are built on the standard requests but involve additional hub-specific values. These requests are primarily used for monitoring and controlling the hub\u2019s behavior and its ports. For instance, when a\n <strong>\n  Get_Status\n </strong>\n request is directed to a hub with an\n <strong>\n  Index = 0\n </strong>\n , the hub returns a data packet indicating whether it is using an external power supply and whether there is an over-current condition.\n</p>\n<p>\n Some of the most important hub-specific requests are:\n</p>\n<ul>\n<li>\n<strong>\n   Get_Hub_Status\n  </strong>\n  : Reads status bits related to the hub.\n </li>\n<li>\n<strong>\n   Set_Hub_Feature\n  </strong>\n  and\n  <strong>\n   Clear_Hub_Feature\n  </strong>\n  : Set or clear specific status bits in the hub.\n </li>\n<li>\n<strong>\n   Get_Port_Status\n  </strong>\n  ,\n  <strong>\n   Set_Port_Feature\n  </strong>\n  , and\n  <strong>\n   Clear_Port_Feature\n  </strong>\n  : Allow the host to manage and control status bits for individual ports on the hub.\n </li>\n</ul>\n<h4>\n Hub Status and Port Status Bits\n</h4>\n<p>\n Tables 15-3 and 15-4 (not shown here) provide the details of the bits in the hub\u2019s status and port status requests, which help manage and monitor the hub and its ports.\n</p>\n<p>\n For 2.0 hubs,\n <strong>\n  Set_Port_Feature\n </strong>\n can also place a port into one of five\n <strong>\n  Test Modes\n </strong>\n . More details about these modes are provided in Chapter 18.\n</p>\n<h4>\n 2.0-Specific Transaction Translator (TT) Requests\n</h4>\n<p>\n In addition to the above, the\n <strong>\n  USB 2.0 specification\n </strong>\n introduces four new requests that specifically deal with\n <strong>\n  Transaction Translators (TT)\n </strong>\n . These requests enable the host to manage the state and buffer of the TT:\n</p>\n<ul>\n<li>\n<strong>\n   Clear TT Buffer\n  </strong>\n  : Clears a buffer in the TT.\n </li>\n<li>\n<strong>\n   Stop TT\n  </strong>\n  : Stops the TT.\n </li>\n<li>\n<strong>\n   Get TT State\n  </strong>\n  : Retrieves the state of a stopped TT in a vendor-specific format.\n </li>\n<li>\n<strong>\n   Reset TT\n  </strong>\n  : Restarts the TT by resetting it.\n </li>\n</ul>\n<p>\n These requests provide more control over transaction handling in hubs, especially when using multiple transaction translators.\n</p>\n"}, "Page 476": {"response": "<h3>\n Port Indicators and Status Monitoring\n</h3>\n<p>\n The\n <strong>\n  USB 2.0 specification\n </strong>\n includes an optional feature that allows hubs to display the status of their ports to the user using\n <strong>\n  port indicators\n </strong>\n (such as LEDs). Many hubs are equipped with status LEDs that provide visual cues about the condition of each port. The\n <strong>\n  wHub-Characteristics\n </strong>\n field in the hub descriptor includes\n <strong>\n  Bit 7\n </strong>\n , which indicates whether the hub has these port indicators.\n</p>\n<h4>\n LED Indicator Colors and Meanings\n</h4>\n<p>\n Each\n <strong>\n  downstream port\n </strong>\n on a hub can have an indicator that uses either a\n <strong>\n  bi-color green/amber LED\n </strong>\n or individual LEDs for each color. These indicators represent the status of the\n <strong>\n  hub's port\n </strong>\n rather than the device connected to the port. The meanings of the different LED colors and their blinking patterns are as follows:\n</p>\n<ul>\n<li>\n<strong>\n   Green\n  </strong>\n  : The port is fully operational.\n </li>\n<li>\n<strong>\n   Amber\n  </strong>\n  : An error condition is present on the port.\n </li>\n<li>\n<strong>\n   Blinking Off/Green\n  </strong>\n  : The port requires software attention.\n </li>\n<li>\n<strong>\n   Blinking Off/Amber\n  </strong>\n  : The port requires hardware attention.\n </li>\n<li>\n<strong>\n   Off\n  </strong>\n  : The port is not operational.\n </li>\n</ul>\n<h4>\n Hub Status and Change Indicators\n</h4>\n<p>\n The host can monitor and control specific status bits of the hub using requests like\n <strong>\n  Get_Hub_Status\n </strong>\n ,\n <strong>\n  Set_Hub_Feature\n </strong>\n , and\n <strong>\n  Clear_Hub_Feature\n </strong>\n . These requests help manage and keep track of the hub\u2019s current state, including power and over-current conditions.\n</p>\n<p>\n Here is a breakdown of the hub status and change indicators:\n</p>\n<p>\n<strong>\n  Hub Status Bits\n </strong>\n :\n</p>\n<ul>\n<li>\n<strong>\n   HUB_LOCAL_POWER (Bit 0)\n  </strong>\n  : Indicates whether the local power supply is active.\n  <ul>\n<li>\n<strong>\n     0\n    </strong>\n    : Local power is not active.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    : Local power is active.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   HUB_OVER_CURRENT (Bit 1)\n  </strong>\n  : Indicates whether an over-current condition exists.\n  <ul>\n<li>\n<strong>\n     0\n    </strong>\n    : No over-current condition.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    : Over-current condition exists.\n   </li>\n</ul>\n</li>\n<li>\n  Bits\n  <strong>\n   2-15\n  </strong>\n  are reserved and return 0 when read.\n </li>\n</ul>\n<p>\n<strong>\n  Hub Change Status Bits\n </strong>\n :\n</p>\n<ul>\n<li>\n<strong>\n   C_HUB_LOCAL_POWER (Bit 0)\n  </strong>\n  : Indicates whether the local power status has changed.\n  <ul>\n<li>\n<strong>\n     0\n    </strong>\n    : No change in local power status.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    : Local power status has changed.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   C_HUB_OVER_CURRENT (Bit 1)\n  </strong>\n  : Indicates whether the over-current status has changed.\n  <ul>\n<li>\n<strong>\n     0\n    </strong>\n    : No change in over-current status.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    : Over-current status has changed.\n   </li>\n</ul>\n</li>\n<li>\n  Bits\n  <strong>\n   2-15\n  </strong>\n  are reserved and return 0 when read.\n </li>\n</ul>\n<p>\n These status bits and indicators allow the host to monitor the hub's power conditions and handle errors or changes efficiently.\n</p>\n"}, "Page 477": {"response": "<h3>\n Monitoring and Controlling Port Status\n</h3>\n<p>\n The\n <strong>\n  host\n </strong>\n can monitor and control the status of individual ports on a hub using the\n <strong>\n  Get_Port_Status\n </strong>\n ,\n <strong>\n  Set_Port_Feature\n </strong>\n , and\n <strong>\n  Clear_Port_Feature\n </strong>\n requests. These requests allow the host to interact with various status bits for each port to manage and track the device and port conditions effectively.\n</p>\n<h4>\n Port Status Indicators\n</h4>\n<p>\n Here are the key port status bits and their meanings:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    PORT_CONNECTION (Bit 0)\n   </strong>\n   : Indicates whether a device is connected to the port.\n  </p>\n<ul>\n<li>\n<strong>\n     0\n    </strong>\n    : No device connected.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    : A device is connected.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    PORT_ENABLE (Bit 1)\n   </strong>\n   : Indicates whether the port is enabled or disabled.\n  </p>\n<ul>\n<li>\n<strong>\n     0\n    </strong>\n    : Port is disabled.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    : Port is enabled.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    PORT_SUSPEND (Bit 2)\n   </strong>\n   : Indicates whether the port is in the Suspend state.\n  </p>\n<ul>\n<li>\n<strong>\n     0\n    </strong>\n    : Port is not in Suspend state.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    : Port is in Suspend state.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    PORT_OVERCURRENT (Bit 3)\n   </strong>\n   : Indicates the presence of an over-current condition.\n  </p>\n<ul>\n<li>\n<strong>\n     0\n    </strong>\n    : No over-current condition.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    : Over-current condition exists.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    PORT_RESET (Bit 4)\n   </strong>\n   : Indicates whether the hub is asserting a reset at the port.\n  </p>\n<ul>\n<li>\n<strong>\n     0\n    </strong>\n    : No reset is being asserted.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    : Reset is being asserted.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n   Bits\n   <strong>\n    5-7\n   </strong>\n   : Reserved for future use, always return 0 when read.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    PORT_POWER (Bit 8)\n   </strong>\n   : Indicates whether the port is in the powered-off state.\n  </p>\n<ul>\n<li>\n<strong>\n     0\n    </strong>\n    : Port is not powered off.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    : Port is powered off.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    PORT_LOW_SPEED (Bit 9)\n   </strong>\n   : Indicates the speed of the attached device (low speed or not).\n  </p>\n<ul>\n<li>\n<strong>\n     0\n    </strong>\n    : Full-speed or high-speed device.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    : Low-speed device.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    PORT_HIGH_SPEED (Bit 10)\n   </strong>\n   : Indicates the attached device's high-speed capability (only for 2.0 hubs).\n  </p>\n<ul>\n<li>\n<strong>\n     0\n    </strong>\n    : Full-speed device.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    : High-speed device (only on 2.0 hubs).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    PORT_TEST (Bit 11)\n   </strong>\n   : Indicates whether the port is in\n   <strong>\n    Test mode\n   </strong>\n   (only for 2.0 hubs).\n  </p>\n<ul>\n<li>\n<strong>\n     0\n    </strong>\n    : Port is not in Test mode.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    : Port is in Test mode.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    PORT_INDICATOR (Bit 12)\n   </strong>\n   : Indicates the state of the\n   <strong>\n    port indicator\n   </strong>\n   LED (only for 2.0 hubs).\n  </p>\n<ul>\n<li>\n<strong>\n     0\n    </strong>\n    : Default indicator color or software-controlled.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    : Indicator color is software-controlled (can indicate different states).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n   Bits\n   <strong>\n    13-15\n   </strong>\n   : Reserved and return 0 when read.\n  </p>\n</li>\n</ul>\n<h4>\n Port Status Change Indicators\n</h4>\n<p>\n The host can also monitor changes in the port status using\n <strong>\n  port change status\n </strong>\n bits. These bits tell the host whether a specific condition has changed at a port. Here are the change indicators:\n</p>\n<ul>\n<li>\n<strong>\n   C_PORT_CONNECTION (Bit 0)\n  </strong>\n  : Indicates whether the connection status has changed.\n  <ul>\n<li>\n<strong>\n     0\n    </strong>\n    : No change.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    : Connection status has changed.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   C_PORT_ENABLE (Bit 1)\n  </strong>\n  : Indicates whether a\n  <strong>\n   Port Error condition\n  </strong>\n  exists or has changed.\n  <ul>\n<li>\n<strong>\n     0\n    </strong>\n    : No error or change in error condition.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    : Port error has occurred or the error condition has changed.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   C_PORT_SUSPEND (Bit 2)\n  </strong>\n  : Indicates whether resume signaling is complete.\n  <ul>\n<li>\n<strong>\n     0\n    </strong>\n    : Resume signaling is not complete.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    : Resume signaling is complete.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   C_PORT_OVERCURRENT (Bit 3)\n  </strong>\n  : Indicates whether the\n  <strong>\n   over-current condition\n  </strong>\n  has changed.\n  <ul>\n<li>\n<strong>\n     0\n    </strong>\n    : No change in over-current condition.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    : Over-current condition has changed.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   C_PORT_RESET (Bit 4)\n  </strong>\n  : Indicates whether reset processing is complete.\n  <ul>\n<li>\n<strong>\n     0\n    </strong>\n    : Reset processing is not complete.\n   </li>\n<li>\n<strong>\n     1\n    </strong>\n    : Reset processing is complete.\n   </li>\n</ul>\n</li>\n<li>\n  Bits\n  <strong>\n   5-15\n  </strong>\n  : Reserved and return 0 when read.\n </li>\n</ul>\n<p>\n These port-specific status and change indicators help the host efficiently manage connected devices and handle any issues related to port functionality, device connectivity, and power conditions.\n</p>\n"}, "Page 478": {"response": "<h3>\n Managing Power in USB Devices\n</h3>\n<p>\n USB offers a convenient way for devices to draw power directly from the bus, which means many devices can be powered without needing their own external power supply. However, drawing power from the bus comes with responsibilities. Devices must stay within the limits of the available power and must enter the low-power\n <strong>\n  Suspend state\n </strong>\n when necessary. This chapter guides you on whether your design can rely on bus power and, if so, how to ensure compliance with the USB power management specifications.\n</p>\n<h3>\n Powering Options for USB Devices\n</h3>\n<p>\n Most typical PC power supplies have ample power capacity, with extra amperage available. Similarly, many USB hubs come with their own power supplies. These power sources can be used to power USB peripherals instead of requiring the devices to provide their own power. This option simplifies the design of USB devices by leveraging existing power supplies, reducing the need for additional components.\n</p>\n"}, "Page 479": {"response": "<h3>\n Powering USB Devices: Advantages and Requirements\n</h3>\n<p>\n USB offers the ability for devices to draw power directly from the same cable used for data transfer, providing several benefits. This eliminates the need for an electrical outlet near the device, allowing it to be smaller and lighter without needing an internal power supply. Devices that don't require their own power source are also cheaper to manufacture, which can result in a lower sales price. Bus-powered devices can also be more energy-efficient, as power supplies in PCs generally use efficient switching regulators, unlike the less efficient linear regulators found in many wall-powered peripherals. Although self-powered hubs tend to use wall adapters, bus-powered devices still offer significant energy savings.\n</p>\n<p>\n Before USB, peripherals typically connected to the PC through RS-232 serial or printer ports, which did not include a power supply line. Some devices relied on low-power schemes, drawing a small amount of current from unused data or control lines, or even the keyboard port, which had access to the PC\u2019s power supply. With USB, this is no longer necessary, as devices can directly draw power from the USB bus.\n</p>\n<h3>\n Voltage Requirements for USB Devices\n</h3>\n<p>\n The standard nominal voltage for USB power is 5V between the VBUS and GND wires, though the actual voltage can fluctuate slightly. Devices that are bus-powered must be able to handle these variations in voltage. The USB specification defines the minimum and maximum voltage ranges that a hub\u2019s downstream ports can supply to devices:\n</p>\n<ul>\n<li>\n<strong>\n   High Power Devices\n  </strong>\n  : Minimum voltage of 4.75V, maximum voltage of 5.25V\n </li>\n<li>\n<strong>\n   Low Power Devices\n  </strong>\n  : Minimum voltage of 4.4V, maximum voltage of 5.25V\n </li>\n</ul>\n<p>\n To accommodate for potential losses in cables and other components, devices should be capable of operating with supply voltages slightly lower than the minimum voltage provided at the hub\u2019s downstream ports.\n</p>\n"}, "Page 480": {"response": "<h3>\n Power Management for USB Devices: Bus-Powered vs. Self-Powered\n</h3>\n<p>\n USB provides devices with the ability to draw power directly from the same cable that handles data transfer, but the voltage and current it supplies have limitations. Understanding how to manage power efficiently is crucial for ensuring that devices perform optimally while adhering to USB standards.\n</p>\n<h3>\n Voltage Considerations and Device Power Requirements\n</h3>\n<p>\n The voltage supplied by the USB bus is typically 5V, but can fluctuate. At low-power hubs, voltage can briefly drop as low as 4.07V due to transient conditions. For devices that require higher voltages, a step-up switching regulator can be used. Many USB controllers require a 5V or 3.3V supply, and using 3.3V components allows for inexpensive low-dropout linear regulators that convert the bus power (VBUS) to the necessary 3.3V.\n</p>\n<h3>\n Which Devices Can Use Bus Power?\n</h3>\n<p>\n Not all peripherals are suitable for bus power, as the available current is limited by the host\u2019s power supply or the hub\u2019s power capacity. With advances in semiconductor technology, many devices now require much less power. Devices using CMOS processes, low-voltage components, and energy-saving CPU modes can work effectively with as little as 100 milliamperes of current.\n</p>\n<ul>\n<li>\n<strong>\n   Bus-powered Devices\n  </strong>\n  : Devices that draw up to 100 milliamperes can be powered by any host or hub.\n </li>\n<li>\n<strong>\n   Self-powered Devices\n  </strong>\n  : Devices that draw up to 500 milliamperes can be bus-powered when connected to a self-powered hub or a host (except some battery-powered hosts).\n </li>\n</ul>\n<p>\n However, no device should draw more than 100 milliamperes before it is configured by the host, and devices must reduce their power consumption when the bus enters the Suspend state.\n</p>\n<h3>\n Self-Powered Devices\n</h3>\n<p>\n Some devices, such as digital cameras, need to function even when not connected to a host. These devices require their own power sources, which could be from batteries or a wall outlet. To optimize energy use, some devices are designed to be bus-powered when connected to a host and self-powered when disconnected. Additionally, some battery-powered devices can recharge when connected to the bus.\n</p>\n<h3>\n Suspend State and Power Management\n</h3>\n<p>\n Devices in the Suspend state must draw minimal power from the bus. Therefore, devices that need to operate while the bus is suspended may require their own power sources, ensuring they continue to function without relying on the bus power.\n</p>\n"}, "Page 481": {"response": "<h3>\n Power Requirements for USB Devices: Low-Power vs High-Power\n</h3>\n<p>\n USB devices are classified based on the amount of current they require from the bus. These classifications help determine whether the device can be bus-powered or if it needs a separate power source.\n</p>\n<h3>\n Low-Power vs High-Power Devices\n</h3>\n<ul>\n<li>\n<strong>\n   Low-Power Devices\n  </strong>\n  : These devices draw up to\n  <strong>\n   100 milliamperes\n  </strong>\n  from the USB bus.\n </li>\n<li>\n<strong>\n   High-Power Devices\n  </strong>\n  : These devices draw\n  <strong>\n   up to 500 milliamperes\n  </strong>\n  from the bus.\n </li>\n</ul>\n<p>\n Devices that draw more than 100 milliamperes need to be classified properly to ensure they can receive the correct amount of power, either from the bus or an external supply.\n</p>\n<h3>\n Self-Powered Devices\n</h3>\n<p>\n A\n <strong>\n  self-powered device\n </strong>\n can still draw\n <strong>\n  up to 100 milliamperes\n </strong>\n from the USB bus but relies primarily on its own power supply for additional energy. These devices are not limited by the bus\u2019s power constraints.\n</p>\n<h3>\n Power Source Considerations\n</h3>\n<p>\n When deciding whether a device can be bus-powered or requires self-power, the following factors must be considered:\n</p>\n<ul>\n<li>\n<strong>\n   Does the device need to function when not connected to the bus?\n  </strong>\n</li>\n<li>\n<strong>\n   Does the device draw more than 500 milliamperes from the bus?\n  </strong>\n</li>\n<li>\n<strong>\n   Does the device need to operate from all battery-powered computers or bus-powered hubs?\n  </strong>\n</li>\n</ul>\n<p>\n Based on the answers to these questions, a device might require\n <strong>\n  self-power\n </strong>\n or be able to operate with\n <strong>\n  bus power\n </strong>\n alone.\n</p>\n<h3>\n Suspend State Compliance\n</h3>\n<p>\n All devices that use bus power must meet the USB specification\u2019s limits for\n <strong>\n  Suspend current\n </strong>\n , meaning they must reduce their power consumption when the bus enters the Suspend state. This helps prevent overuse of available power and ensures efficient operation.\n</p>\n"}, "Page 482": {"response": "<h3>\n Managing Power for USB Devices\n</h3>\n<p>\n USB devices must adhere to strict power management rules to ensure they operate efficiently within the limits of available bus power. This section explains the power consumption rules for devices and hubs, particularly focusing on high-power and self-powered devices.\n</p>\n<h3>\n Power Consumption during Enumeration\n</h3>\n<p>\n When a USB device powers up, it can draw up to\n <strong>\n  100 milliamperes\n </strong>\n of current from the bus before it is configured during the enumeration process. During this phase, the host retrieves the device's configuration descriptor, which includes the\n <strong>\n  bMaxPower\n </strong>\n value. This value tells the host how much power the device will need. If enough current is available, the host then sends a\n <strong>\n  Set_Configuration\n </strong>\n request to finalize the configuration. Once the configuration is set, the device can draw up to the specified amount of power (as indicated in\n <strong>\n  bMaxPower\n </strong>\n ).\n</p>\n<p>\n However, in practice, hosts and hubs typically allocate\n <strong>\n  either 100 or 500 milliamperes\n </strong>\n to a device rather than a precise amount based on the\n <strong>\n  bMaxPower\n </strong>\n value.\n</p>\n<h3>\n Self-Powered Devices\n</h3>\n<p>\n Self-powered devices can still draw up to\n <strong>\n  100 milliamperes\n </strong>\n from the bus whenever the bus is not suspended. This allows the device\u2019s USB interface to remain functional even if the device\u2019s main power supply is off, which is necessary for the host to detect and enumerate the device. However, if only the pull-up resistor is bus-powered and the rest of the device\u2019s interface is self-powered, the host may detect the device but will not be able to communicate with it properly.\n</p>\n<h3>\n Power Limits\n</h3>\n<p>\n The power limits specified for USB devices are\n <strong>\n  absolute maximums\n </strong>\n , not averages. For example, a device must never exceed the maximum amount of power specified, and the voltage on the bus can reach up to\n <strong>\n  5.25V\n </strong>\n , which may cause the device to draw slightly more current.\n</p>\n<p>\n Importantly,\n <strong>\n  self-powered devices must not provide upstream power\n </strong>\n . The device\u2019s pull-up resistor, like all other components, must remain unpowered until\n <strong>\n  VBUS\n </strong>\n (the power supply from the bus) is present. This ensures that self-powered devices can still detect the presence of\n <strong>\n  VBUS\n </strong>\n even if they do not use bus power for operation.\n</p>\n<h3>\n Informing the Host About Power Requirements\n</h3>\n<p>\n During the enumeration process, the host determines whether the device is\n <strong>\n  self-powered\n </strong>\n or\n <strong>\n  bus-powered\n </strong>\n and learns the maximum current the device will draw from the bus. This information is stored in the\n <strong>\n  bMaxPower\n </strong>\n field in the device's configuration descriptor.\n</p>\n<p>\n Hubs are designed with\n <strong>\n  over-current protection\n </strong>\n to prevent excessive current from flowing to any connected device. If a high-power device is connected to a low-power hub, the host may display a warning message, alerting the user that the hub does not have enough power available to support the device. The message may offer assistance in resolving the issue.\n</p>\n"}, "Page 483": {"response": "<h3>\n Power Source Switching and Re-enumeration\n</h3>\n<p>\n USB devices can support both\n <strong>\n  bus-powered\n </strong>\n and\n <strong>\n  self-powered\n </strong>\n modes, allowing them to switch between power sources based on availability. For example, a device can use\n <strong>\n  self power\n </strong>\n when it's available, but revert to\n <strong>\n  bus power\n </strong>\n (with possibly limited capabilities) when no external power source is present.\n</p>\n<p>\n When a device switches between power sources, the host must\n <strong>\n  re-enumerate\n </strong>\n the device to update its power status. This re-enumeration can be triggered by briefly turning off the power to the device's\n <strong>\n  bus pull-up resistor\n </strong>\n and then turning it back on. This action simulates a\n <strong>\n  disconnection\n </strong>\n and\n <strong>\n  reconnection\n </strong>\n of the device, prompting the host to re-enumerate it.\n</p>\n<p>\n If the device is unable to automatically trigger re-enumeration, users will need to physically remove the device from the bus before attaching or removing the power supply.\n</p>\n<h3>\n Reporting Power Mode to the Host\n</h3>\n<p>\n The device reports whether it is using\n <strong>\n  bus power\n </strong>\n or\n <strong>\n  self power\n </strong>\n through a\n <strong>\n  Get_Status (Device)\n </strong>\n request from the host. This allows the host to track the power source currently in use and adjust its behavior accordingly.\n</p>\n<h3>\n Windows Warning for Power Source Issues\n</h3>\n<p>\n If a\n <strong>\n  high-power device\n </strong>\n is connected to a\n <strong>\n  low-power hub\n </strong>\n , Windows will display a warning message to inform the user that the hub does not provide enough power. The message will help users identify an alternate connection option, such as switching to a hub or port that can supply sufficient power, or connecting the device directly to a more powerful source.\n</p>\n"}, "Page 484": {"response": "<h3>\n Hub Power Management\n</h3>\n<p>\n Hubs, like other USB devices, can be either\n <strong>\n  self-powered\n </strong>\n or\n <strong>\n  bus-powered\n </strong>\n , but they have additional responsibilities, such as controlling and monitoring power distribution to their connected devices. This ensures that the devices do not draw excessive power, which could pose a safety risk.\n</p>\n<h3>\n Power Sources for Hubs\n</h3>\n<ul>\n<li>\n<p>\n<strong>\n    Root Hub\n   </strong>\n   : The root hub always draws power directly from the host.\n  </p>\n<ul>\n<li>\n    If the host is\n    <strong>\n     AC-powered\n    </strong>\n    (i.e., using wall socket power), the root hub must supply\n    <strong>\n     500 milliamperes\n    </strong>\n    to each port on the hub.\n   </li>\n<li>\n    If the host is\n    <strong>\n     battery-powered\n    </strong>\n    , the root hub may supply either\n    <strong>\n     500 milliamperes\n    </strong>\n    (high power) or\n    <strong>\n     100 milliamperes\n    </strong>\n    (low power) to each port.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Bus-Powered Hubs\n   </strong>\n   : A bus-powered hub can only provide\n   <strong>\n    100 milliamperes\n   </strong>\n   per downstream port, and it can draw a total of\n   <strong>\n    500 milliamperes\n   </strong>\n   from the host. However, the hub itself uses some of this power, so the remaining current available for the downstream devices will be less than 500 milliamperes in total.\n  </p>\n</li>\n</ul>\n<h3>\n Series Connection of Bus-Powered Hubs\n</h3>\n<p>\n You should\n <strong>\n  not\n </strong>\n connect two bus-powered hubs in series. The reason is that the upstream hub can only guarantee\n <strong>\n  100 milliamperes\n </strong>\n per port, and this is insufficient for powering a second hub, which also requires at least 100 milliamperes for each downstream port.\n</p>\n<h3>\n Compound Bus-Powered Devices\n</h3>\n<p>\n An exception to the series connection rule is\n <strong>\n  bus-powered compound devices\n </strong>\n . These devices combine a hub with one or more non-removable downstream devices. In this case, the hub\u2019s configuration descriptor reports the total maximum power required by the hub and its non-removable devices. These non-removable devices have a\n <strong>\n  bMaxPower = 0\n </strong>\n , indicating that they are\n <strong>\n  self-powered\n </strong>\n , and do not contribute to the current drawn from the bus.\n</p>\n<h3>\n Power Management during Configuration\n</h3>\n<ul>\n<li>\n<strong>\n   Bus-powered hubs\n  </strong>\n  can draw\n  <strong>\n   up to 100 milliamperes\n  </strong>\n  before being configured, and\n  <strong>\n   up to 500 milliamperes\n  </strong>\n  after the configuration process is complete.\n </li>\n<li>\n  During the\n  <strong>\n   configuration\n  </strong>\n  phase, the hub must manage its power usage properly to ensure it does not exceed the available limits.\n </li>\n</ul>\n"}, "Page 485": {"response": "<h3>\n Hub Power Management and Over-Current Protection\n</h3>\n<h4>\n Power Management for Self-Powered Hubs\n</h4>\n<p>\n A\n <strong>\n  self-powered hub\n </strong>\n can also draw\n <strong>\n  up to 100 milliamperes\n </strong>\n from the bus. This allows the hub\u2019s interface to continue functioning even when the hub\u2019s main power supply is off. The power supply for a self-powered hub can be either:\n</p>\n<ul>\n<li>\n<strong>\n   External (AC power)\n  </strong>\n  : In this case, the hub must be capable of supplying\n  <strong>\n   500 milliamperes\n  </strong>\n  to each of its ports.\n </li>\n<li>\n<strong>\n   Battery power\n  </strong>\n  : The hub may supply either\n  <strong>\n   100 milliamperes\n  </strong>\n  or\n  <strong>\n   500 milliamperes\n  </strong>\n  to each port, depending on the power source.\n </li>\n</ul>\n<h4>\n Over-Current Protection in Hubs\n</h4>\n<p>\n Hubs are required to have\n <strong>\n  over-current protection\n </strong>\n to prevent dangerous situations where the total current drawn by all connected devices exceeds a safe limit. This protection works as follows:\n</p>\n<ul>\n<li>\n  When an over-current condition is detected, the hub limits the current to prevent further damage.\n </li>\n<li>\n  The hub must notify the host about the over-current condition.\n </li>\n<li>\n<strong>\n   Windows\n  </strong>\n  provides a warning to the user if a device exceeds the current limit of its hub port.\n </li>\n</ul>\n<p>\n The USB specification doesn't define a precise current level that triggers the over-current protection, but it does specify that the threshold must be\n <strong>\n  less than 5 amperes\n </strong>\n . To account for brief transient currents, the over-current protection is set to a value higher than the combined maximum current of all devices connected to the hub.\n</p>\n<p>\n For example, a hub with seven\n <strong>\n  high-power, bus-powered devices\n </strong>\n can legally draw up to\n <strong>\n  3.5 amperes\n </strong>\n (500 milliamperes each). Therefore, the power supply for a self-powered hub with seven downstream devices must be significantly lower than\n <strong>\n  5 amperes\n </strong>\n to avoid triggering the over-current protection under normal conditions.\n</p>\n<h4>\n Inrush Current Consideration\n</h4>\n<p>\n When devices are connected to the bus, they may draw a larger\n <strong>\n  inrush current\n </strong>\n momentarily, which is typically supplied by a capacitor downstream of the over-current protection. This allows the protection circuits to avoid responding to the initial surge of current. However, if the inrush current is too large, the device will fail compliance tests set by the\n <strong>\n  USB-IF\n </strong>\n (USB Implementers Forum).\n</p>\n"}, "Page 486": {"response": "<h3>\n Power Switching for Hubs\n</h3>\n<h4>\n Power Switching in Bus-Powered Hubs\n</h4>\n<p>\n A\n <strong>\n  bus-powered hub\n </strong>\n must be able to manage power to its downstream ports. This means it should be able to provide power to the ports when necessary and cut off power when required, based on control requests. The power switching can be handled in one of two ways:\n</p>\n<ul>\n<li>\n  A single switch that controls\n  <strong>\n   all ports\n  </strong>\n  .\n </li>\n<li>\n  Individual switches for each\n  <strong>\n   downstream port\n  </strong>\n  .\n </li>\n</ul>\n<h4>\n Power Switching in Self-Powered Hubs\n</h4>\n<p>\n For\n <strong>\n  self-powered hubs\n </strong>\n , they must support switching to a\n <strong>\n  Powered Off state\n </strong>\n . Additionally, they may also provide the ability to manage power switching through\n <strong>\n  control transfers\n </strong>\n , allowing for more flexible power management.\n</p>\n<h4>\n Windows Warning for Over-Current Conditions\n</h4>\n<p>\n As illustrated in\n <strong>\n  Figure 16-3\n </strong>\n , if a device exceeds the current limit of its hub's port,\n <strong>\n  Windows\n </strong>\n will notify the user and offer help with addressing the issue, ensuring users are aware of potential power management problems.\n</p>\n"}, "Page 487": {"response": "<h3>\n Saving Power with USB\n</h3>\n<h4>\n The Suspend State\n</h4>\n<p>\n The\n <strong>\n  Suspend state\n </strong>\n is designed to reduce a device's power usage when the host isn't actively communicating with it. A device must enter this state after\n <strong>\n  3 milliseconds\n </strong>\n of inactivity on the bus. When a device enters the Suspend state, its power consumption is significantly reduced to save energy.\n</p>\n<ul>\n<li>\n<strong>\n   High-power devices\n  </strong>\n  with remote wakeup enabled can draw a few milliamperes of current.\n </li>\n<li>\n  Other devices can only draw a\n  <strong>\n   much smaller amount\n  </strong>\n  of current in the Suspend state.\n </li>\n<li>\n  Devices that need to continue functioning even when the host stops communicating may need their own\n  <strong>\n   self-power\n  </strong>\n  source.\n </li>\n</ul>\n<h4>\n Global and Selective Suspends\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Global Suspend\n   </strong>\n   : This is the most common type of suspend. It occurs when the host stops communicating with the entire bus. When the PC detects inactivity, it enters a low-power state and stops sending Start-of-Frame packets.\n  </p>\n<ul>\n<li>\n    For full or high-speed devices, they must enter the Suspend state if they don\u2019t receive a Start-of-Frame packet for\n    <strong>\n     3 milliseconds\n    </strong>\n    .\n   </li>\n<li>\n    Low-speed devices enter the Suspend state after not receiving a keep-alive signal for\n    <strong>\n     3 milliseconds\n    </strong>\n    .\n   </li>\n<li>\n    A device must enter the Suspend state within\n    <strong>\n     10 milliseconds\n    </strong>\n    of detecting no bus activity.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Selective Suspend\n   </strong>\n   : In some cases, the host may request a selective suspend, affecting only individual ports. The host sends a\n   <strong>\n    Set_Port_Feature\n   </strong>\n   request to the hub, specifying which port should be suspended. The hub then stops sending any traffic, including Start-of-Frame packets, to that port.\n  </p>\n</li>\n</ul>\n<h4>\n Current Limits for Suspended Devices\n</h4>\n<p>\n When a device enters the Suspend state, its power usage is strictly limited:\n</p>\n<ul>\n<li>\n  For\n  <strong>\n   most devices\n  </strong>\n  , the current limit is\n  <strong>\n   500 microamperes\n  </strong>\n  .\n </li>\n<li>\n  This current limit applies to the device's bus-powered operations, including the bus-powered parts of the device.\n </li>\n<li>\n<strong>\n   High-power devices\n  </strong>\n  with remote wakeup enabled may have slightly higher current allowances, but they are still restricted.\n </li>\n</ul>\n<p>\n This minimal power consumption helps save energy when the device is not in active use, ensuring that USB devices don't waste power unnecessarily when idle.\n</p>\n"}, "Page 488": {"response": "<h3>\n Power Management in the Suspend State\n</h3>\n<h4>\n Pull-up Resistor Current\n</h4>\n<p>\n In the\n <strong>\n  Suspend state\n </strong>\n , the current drawn by a device is tightly regulated, including the current through its\n <strong>\n  pull-up resistor\n </strong>\n . This current flows from the device's\n <strong>\n  pull-up supply\n </strong>\n , which must be between\n <strong>\n  3.0V and 3.6V\n </strong>\n , through the device\u2019s pull-up resistor and the hub\u2019s pull-down resistor to ground.\n</p>\n<ul>\n<li>\n  In the worst-case scenario, where the pull-up supply is\n  <strong>\n   3.6V\n  </strong>\n  and the resistors are at their minimum allowed values, the pull-up current is\n  <strong>\n   238 microamperes\n  </strong>\n  .\n </li>\n<li>\n  This leaves the device with only\n  <strong>\n   262 microamperes\n  </strong>\n  for other operations.\n </li>\n</ul>\n<p>\n High-speed devices, which normally do not use pull-ups for communication, are required to switch to full speed and activate a pull-up when entering the\n <strong>\n  Suspend state\n </strong>\n . This means high-speed devices are also subject to the same current restrictions as other devices when suspended.\n</p>\n<h4>\n Current Consumption Limits\n</h4>\n<ul>\n<li>\n  The\n  <strong>\n   USB-IF\n  </strong>\n  has granted an automatic waiver to\n  <strong>\n   low-power devices\n  </strong>\n  that draw up to\n  <strong>\n   2.5 milliamperes\n  </strong>\n  during the Suspend state, which is an exception to the usual 500-microampere limit.\n </li>\n<li>\n  A\n  <strong>\n   high-power device\n  </strong>\n  with the\n  <strong>\n   remote wakeup\n  </strong>\n  feature enabled can draw\n  <strong>\n   up to 2.5 milliamperes\n  </strong>\n  when suspended, including current through the pull-up resistor.\n </li>\n</ul>\n<p>\n It\u2019s important to note that all devices initially connect as low-power, so for compliance with the\n <strong>\n  USB specification\n </strong>\n , any device must meet the\n <strong>\n  500-microampere\n </strong>\n limit when the host suspends it before configuring it as a high-power device with remote wakeup enabled, unless a waiver has been granted.\n</p>\n<h4>\n Averaging Over Time\n</h4>\n<p>\n The current limits in the Suspend state are based on\n <strong>\n  average current\n </strong>\n over a time interval of up to\n <strong>\n  1 second\n </strong>\n . This means that brief bursts of higher current are allowed if the average over a longer period is within the limit. For example:\n</p>\n<ul>\n<li>\n  A device might briefly draw\n  <strong>\n   20 milliamperes\n  </strong>\n  for\n  <strong>\n   1/10th of a second\n  </strong>\n  , but this would average out to\n  <strong>\n   2 milliamperes per second\n  </strong>\n  , which is within the acceptable range.\n </li>\n</ul>\n<p>\n This flexibility allows devices to perform small tasks while still adhering to the low power consumption requirements of the Suspend state.\n</p>\n"}, "Page 489": {"response": "<h3>\n Managing Power Transitions: Suspend and Resume States\n</h3>\n<h4>\n Entering the Suspend State\n</h4>\n<p>\n A device should begin to enter the\n <strong>\n  Suspend state\n </strong>\n once its bus segment has been in the\n <strong>\n  Idle state\n </strong>\n for\n <strong>\n  3 milliseconds\n </strong>\n . The device must be fully in the Suspend state within\n <strong>\n  10 milliseconds\n </strong>\n of the bus segment entering Idle. The Suspend state reduces a device\u2019s power consumption by minimizing activity and drawing very little current from the bus.\n</p>\n<h4>\n Resuming Communications\n</h4>\n<p>\n When in the Suspend state, a device can be woken up (or enter the\n <strong>\n  Resume state\n </strong>\n ) in two ways:\n</p>\n<ol>\n<li>\n<strong>\n   Bus Activity:\n  </strong>\n  Any activity on the bus will trigger the device to enter the Resume state.\n </li>\n<li>\n<strong>\n   Remote Wakeup (if enabled):\n  </strong>\n  If the device has the remote wakeup feature enabled by the host, the device can also request a Resume at any time.\n </li>\n</ol>\n<p>\n To initiate a Resume:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Host Actions:\n   </strong>\n</p>\n<ul>\n<li>\n    The host places the bus in the\n    <strong>\n     Resume state\n    </strong>\n    (the\n    <strong>\n     K state\n    </strong>\n    , defined in Chapter 18) for\n    <strong>\n     at least 20 milliseconds\n    </strong>\n    .\n   </li>\n<li>\n    Afterward, the host sends an\n    <strong>\n     End-of-Packet signal\n    </strong>\n    for low-speed devices. (Some hosts might incorrectly send this signal after a few hundred microseconds.)\n   </li>\n<li>\n    The host then resumes sending\n    <strong>\n     Start-of-Frame packets\n    </strong>\n    and any other necessary communication from the device driver.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Device Actions:\n   </strong>\n</p>\n<ul>\n<li>\n    The device drives the upstream bus segment into the Resume state for\n    <strong>\n     between 1 and 15 milliseconds\n    </strong>\n    .\n   </li>\n<li>\n    It then places its drivers in a\n    <strong>\n     high-impedance state\n    </strong>\n    to receive traffic from the upstream hub.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n Once the Resume state is initiated, the host-controller software must allow all devices\n <strong>\n  at least 10 milliseconds\n </strong>\n to recover before communication resumes.\n</p>\n<h4>\n Power Management During Suspend and Resume\n</h4>\n<ul>\n<li>\n  When using\n  <strong>\n   bus power\n  </strong>\n  , the USB controller may need to control the power to external circuits. This means removing power when entering the Suspend state and restoring it when resuming.\n </li>\n<li>\n  To prevent issues like\n  <strong>\n   current surges\n  </strong>\n  when restoring power, a\n  <strong>\n   power switch with soft-start capability\n  </strong>\n  can be used. These switches manage current flow smoothly and safely.\n </li>\n</ul>\n<p>\n<strong>\n  Example of Suitable Components:\n </strong>\n Companies like\n <strong>\n  Micrel Inc.\n </strong>\n offer power-distribution switches that can be used with USB devices. These switches often include\n <strong>\n  high-side MOSFET switches\n </strong>\n with soft-start features to control power more effectively.\n</p>\n<p>\n In summary, the\n <strong>\n  Suspend\n </strong>\n state saves power by minimizing activity, while the\n <strong>\n  Resume\n </strong>\n state is triggered either by activity on the bus or the device itself through remote wakeup, ensuring communication can restart efficiently. Additionally, careful management of power and transitions between states helps maintain device stability and prevent issues like power surges.\n</p>\n"}, "Page 490": {"response": "<h3>\n Power Management in Windows\n</h3>\n<h4>\n ACPI Power Management\n</h4>\n<p>\n Modern PCs use\n <strong>\n  Advanced Configuration and Power Interface (ACPI)\n </strong>\n for power management. ACPI was developed in 1997 by companies such as Hewlett-Packard, Intel, Microsoft, Phoenix Technologies, and Toshiba, and its version 3.0 was released in 2004. ACPI enables operating systems to conserve power by turning off or suspending components, including the USB bus, when the system is idle.\n</p>\n<p>\n To implement ACPI, a PC must have an\n <strong>\n  ACPI controller\n </strong>\n , which works with an\n <strong>\n  ACPI BIOS\n </strong>\n . The BIOS provides tables that describe the system's power-management capabilities, along with routines the operating system can use to manage power.\n</p>\n<h4>\n Power States\n</h4>\n<p>\n PCs using ACPI support several low-power states, or sleep modes, to manage power consumption effectively:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    S1 State:\n   </strong>\n</p>\n<ul>\n<li>\n    The display is turned off, and drives are powered down.\n   </li>\n<li>\n    The USB buses are suspended, but\n    <strong>\n     VBUS\n    </strong>\n    (the power line for USB) remains powered.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    S3 State:\n   </strong>\n</p>\n<ul>\n<li>\n    The\n    <strong>\n     PCI bus's main power supply\n    </strong>\n    is turned off, and the system memory is no longer accessed. However,\n    <strong>\n     system memory continues to be refreshed\n    </strong>\n    to maintain data.\n   </li>\n<li>\n    Devices that can wake the system are powered via the\n    <strong>\n     PCI bus's auxiliary supply (Vaux)\n    </strong>\n    .\n   </li>\n<li>\n    In\n    <strong>\n     older systems\n    </strong>\n    ,\n    <strong>\n     VBUS\n    </strong>\n    is not powered in the S3 state, but in\n    <strong>\n     newer systems\n    </strong>\n    ,\n    <strong>\n     VBUS\n    </strong>\n    is powered by\n    <strong>\n     Vaux\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    S4 State:\n   </strong>\n</p>\n<ul>\n<li>\n    The system saves its context to disk (hibernation), and the entire system, including the USB bus, is powered off.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Power Management in Windows XP\n</h4>\n<p>\n In\n <strong>\n  Windows XP\n </strong>\n , users can configure power-management options through the\n <strong>\n  Control Panel &gt; Power Options\n </strong>\n . The\n <strong>\n  Power Schemes\n </strong>\n tab lets you set when the system should enter\n <strong>\n  standby\n </strong>\n or\n <strong>\n  hibernation\n </strong>\n :\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Hibernation\n   </strong>\n   corresponds to the\n   <strong>\n    S4 state\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Standby\n   </strong>\n   can refer to either the\n   <strong>\n    S1\n   </strong>\n   or\n   <strong>\n    S3 state\n   </strong>\n   , depending on the system configuration.\n  </p>\n<ul>\n<li>\n    For systems with no USB devices capable of waking the system, the standby state will default to\n    <strong>\n     S3\n    </strong>\n    .\n   </li>\n<li>\n    For systems with USB devices like a keyboard or mouse that can wake the system, the standby state will be\n    <strong>\n     S1\n    </strong>\n    , due to potential issues with using S3 in some hardware configurations. These issues include problems like\n    <strong>\n     loss of VBUS\n    </strong>\n    during the S3 state, which can affect the functionality of USB wakeup devices.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n In summary, Windows, through ACPI, manages power across different states (S1, S3, and S4) to optimize power use. The USB bus is typically suspended in low-power states, with special considerations for maintaining power to USB devices that can wake the system from sleep.\n</p>\n"}, "Page 491": {"response": "<h3>\n Managing Power in Windows and Remote Wakeup\n</h3>\n<h4>\n Power Management Issues in the S3 State\n</h4>\n<p>\n In the\n <strong>\n  S3\n </strong>\n (suspend) state, there can be some issues related to\n <strong>\n  false device removal\n </strong>\n and\n <strong>\n  arrival notifications\n </strong>\n when resuming the system. Additionally,\n <strong>\n  devices may not reset properly\n </strong>\n during the suspend and resume process, leading to a failure to fully resume in some cases. These problems can prevent the system from properly recognizing devices or cause devices to malfunction after waking from the suspend state.\n</p>\n<h4>\n Enabling or Disabling Remote Wakeup\n</h4>\n<p>\n For devices that support\n <strong>\n  remote wakeup\n </strong>\n (the ability to wake up the system from sleep), users can enable or disable this capability through\n <strong>\n  Windows Device Manager\n </strong>\n :\n</p>\n<ol>\n<li>\n  Right-click on the device in Device Manager.\n </li>\n<li>\n  Select\n  <strong>\n   Properties &gt; Power Management\n  </strong>\n  .\n </li>\n<li>\n  Check or uncheck the box labeled\n  <strong>\n   Allow this device to bring the computer out of standby\n  </strong>\n  .\n </li>\n</ol>\n<p>\n This allows users to control which devices can trigger the system to wake from sleep.\n</p>\n<h4>\n Issues with Early Intel Host Controllers\n</h4>\n<p>\n Some older\n <strong>\n  Intel host controllers\n </strong>\n had issues with correctly responding to a\n <strong>\n  remote wakeup\n </strong>\n signal when a\n <strong>\n  root port\n </strong>\n was in a suspended state. This can lead to problems where the device is not properly recognized or resumed after the system enters a suspended state.\n</p>\n<h4>\n Power Options in Windows\n</h4>\n<p>\n In\n <strong>\n  Windows XP\n </strong>\n , users can configure system power-saving settings through\n <strong>\n  Control Panel &gt; Power Options\n </strong>\n . The\n <strong>\n  Power Options Properties\n </strong>\n window (Figure 16-5) allows users to specify power-saving schemes, which include setting when USB devices should enter the\n <strong>\n  Suspend\n </strong>\n state.\n</p>\n<p>\n In summary, while Windows offers comprehensive power management features for USB devices, there are occasional issues with remote wakeup functionality and device resume behavior, especially in older hardware. Users can manage these settings via the Device Manager to control when devices are allowed to wake the system from sleep.\n</p>\n"}, "Page 492": {"response": "<h3>\n Power Management Issues in Older Windows Versions\n</h3>\n<h4>\n Problems with Remote Wakeup in Older Windows Versions\n</h4>\n<p>\n In earlier versions of\n <strong>\n  Windows 98 Gold\n </strong>\n ,\n <strong>\n  Windows 98 SE\n </strong>\n , and\n <strong>\n  Windows Me\n </strong>\n , there were specific challenges related to the\n <strong>\n  remote wakeup\n </strong>\n functionality. While a device could successfully wake up the system from suspend, the\n <strong>\n  device driver\n </strong>\n would not always be informed of this wakeup, which prevented proper communication from resuming after the system woke up.\n</p>\n<h4>\n Workarounds and Solutions\n</h4>\n<p>\n Intel provided a white paper titled\n <strong>\n  \"Understanding WDM Power Management\"\n </strong>\n by Kosta Koeman (available on the\n <strong>\n  USB-IF\n </strong>\n website) to explain this issue and its solutions. The main takeaway from this paper is that a device in these older Windows versions should not place itself in the\n <strong>\n  Suspend state\n </strong>\n unless explicitly requested by the\n <strong>\n  host\n </strong>\n . Additionally, extra coding in the\n <strong>\n  device driver\n </strong>\n is necessary to ensure that the wakeup process completes correctly.\n</p>\n<h4>\n No Issues in Later Versions\n</h4>\n<p>\n This issue does not affect newer versions of\n <strong>\n  Windows 2000\n </strong>\n and beyond, as these versions do not have the same problems with remote wakeup functionality.\n</p>\n<p>\n In summary, the problem primarily impacted systems running older versions of Windows, where the device driver was not notified about the wakeup event, preventing proper communication. However, newer Windows versions have resolved this issue.\n</p>\n"}, "Page 493": {"response": "<p>\n It seems like there is no content following \"Chapter 16\" in the text you've provided. Could you provide more details or clarify the content you'd like me to explain? I'll be happy to assist you with summarizing or restating it!\n</p>\n"}, "Page 494": {"response": "<h3>\n Testing and Debugging USB Devices\n</h3>\n<p>\n When developing USB devices, it's essential to have the right tools to test and debug both the device itself and its host software. This chapter covers various hardware and software tools available for USB testing, with a focus on the tools from the USB Implementers Forum (USB-IF) and other sources. It also explains the necessary tests required for devices and drivers to obtain certification, including the Certified USB logo and the Windows logo.\n</p>\n<h4>\n Key Tools for USB Development\n</h4>\n<p>\n One of the most valuable tools for USB device developers is a\n <strong>\n  protocol analyzer\n </strong>\n . This tool helps developers monitor and analyze USB traffic, capturing data from the bus and decoding it for examination. With a protocol analyzer, developers can:\n</p>\n<ul>\n<li>\n  Observe the device enumeration process.\n </li>\n<li>\n  Identify and troubleshoot protocol and signaling errors.\n </li>\n<li>\n  View data transferred in different types of USB communication, including control, interrupt, bulk, and isochronous transfers.\n </li>\n<li>\n  Focus on specific aspects of communication, such as specific device requests or responses.\n </li>\n</ul>\n<p>\n These analyzers provide a comprehensive look into the operation of a USB device, enabling efficient debugging and performance optimization during development.\n</p>\n"}, "Page 495": {"response": "<h3>\n Hardware and Software USB Analyzers\n</h3>\n<p>\n To test and debug USB devices effectively, developers rely on two main types of tools:\n <strong>\n  hardware protocol analyzers\n </strong>\n and\n <strong>\n  software analyzers\n </strong>\n . These tools help monitor and capture USB traffic, each offering unique features to support different aspects of development.\n</p>\n<h4>\n Hardware Protocol Analyzers\n</h4>\n<p>\n A\n <strong>\n  hardware protocol analyzer\n </strong>\n is a specialized piece of equipment used to capture and monitor the signals in a USB cable segment. This tool is positioned upstream from the device under test, allowing it to observe the traffic without disrupting the bus communication. The analyzer captures the signals, which are then displayed through a connection to a PC or logic analyzer.\n</p>\n<ul>\n<li>\n  The captured data can be analyzed on the connected PC, where it is decoded and presented in an understandable format.\n </li>\n<li>\n  This setup allows developers to closely monitor traffic, such as data transfers, and identify issues like protocol or signaling errors.\n </li>\n</ul>\n<p>\n The analyzer\u2019s main strength is that it provides a non-intrusive way to monitor USB traffic, ensuring that the traffic is captured accurately without influencing the bus's normal operation.\n</p>\n<h4>\n Software Analyzers\n</h4>\n<p>\n In contrast to hardware analyzers,\n <strong>\n  software analyzers\n </strong>\n are programs that run on the host computer to monitor USB traffic. While they overlap in functionality with hardware analyzers, software analyzers typically only track what is happening on the software level, often focusing on the interactions between the host and the connected USB devices.\n</p>\n<ul>\n<li>\n  Software analyzers are typically easier to use since they don\u2019t require additional hardware, but they can be limited in capturing traffic at lower levels of the USB protocol compared to hardware analyzers.\n </li>\n</ul>\n<p>\n Both types of analyzers serve valuable roles, with hardware analyzers offering more detailed and non-invasive data capture, while software analyzers are more accessible and convenient for quick debugging.\n</p>\n<h4>\n Traffic Generators\n</h4>\n<p>\n Another important tool is the\n <strong>\n  traffic generator\n </strong>\n , which emulates either a host or device and allows precise control over the traffic placed on the USB bus. This tool is useful for testing how devices or hosts react to specific traffic scenarios. By generating traffic that mimics real-world conditions, developers can test a device's behavior under different conditions before actual deployment.\n</p>\n"}, "Page 496": {"response": "<h3>\n Hardware Protocol Analyzers: Detailed Overview\n</h3>\n<p>\n Hardware protocol analyzers are invaluable tools for USB device testing and debugging. They allow developers to capture, view, and analyze USB traffic in great detail, providing insight into the actual data being transmitted over the USB bus.\n</p>\n<h4>\n Functionality of Hardware Analyzers\n</h4>\n<p>\n A hardware protocol analyzer works by monitoring the signals within a USB cable segment, capturing data down to the individual bytes of each packet. This level of detail allows you to clearly see every transaction between the host and device, making it easy to identify issues such as missing data or incorrect packet transmissions.\n</p>\n<p>\n For example, if the host sends an IN token packet, the analyzer can show whether the device responded with data or a NAK (negative acknowledgment). You can track the entire control request process, including the time stamps that indicate how often the host polls an endpoint.\n</p>\n<h4>\n Example: Ellisys USB Explorer 200\n</h4>\n<p>\n The\n <strong>\n  Ellisys USB Explorer 200\n </strong>\n is a widely used and affordable hardware protocol analyzer that supports all three USB bus speeds (low-speed, full-speed, and high-speed). This analyzer provides valuable functionality for monitoring and diagnosing USB traffic. The Explorer is used in this chapter to illustrate how an analyzer can be used to track bus activity.\n</p>\n<p>\n While the Explorer is a relatively inexpensive option, there are many other analyzers available from various vendors, each with different features and price ranges. Always check for the most up-to-date options and product improvements before making a purchase.\n</p>\n<h4>\n Setup and Hardware Requirements\n</h4>\n<p>\n To use the\n <strong>\n  USB Explorer 200\n </strong>\n , you need two USB host controllers. One controller is responsible for communicating with the analyzer, while the other controls the bus being monitored. Both host controllers can be located within the same PC, but for better performance, it's recommended to use two separate PCs.\n</p>\n<p>\n The analyzer connects to the PC running its software via a USB receptacle located on the back panel. The PC will recognize the Explorer as a USB device using a vendor-specific driver provided by Ellisys.\n</p>\n<p>\n On the front panel, the analyzer has two USB receptacles:\n</p>\n<ul>\n<li>\n  One connects to the device being tested or a hub upstream from the device.\n </li>\n<li>\n  The other connects to the host's root hub or another upstream hub.\n </li>\n</ul>\n<p>\n These connections allow the analyzer to capture traffic on the bus without interfering with the data being transmitted. The analyzer must operate in a way that is transparent to the host and device, meaning that the traffic on the bus should remain unchanged while the analyzer is monitoring it.\n</p>\n<h4>\n Ensuring Transparent Monitoring\n</h4>\n<p>\n To ensure the analyzer operates unobtrusively, the total cable length between the device under test, host, and analyzer should not exceed 3 meters for low-speed segments, or 5 meters for full-speed and high-speed segments. The analyzer\u2019s circuits must emulate a standard cable segment to avoid any impact on the USB communication. Ellisys recommends using cables totaling 3 meters or less in length for optimal performance.\n</p>\n<p>\n By using a protocol analyzer like the Ellisys USB Explorer 200, developers can monitor and troubleshoot USB traffic in real-time, making it easier to detect and resolve issues with USB devices and their communication with hosts.\n</p>\n"}, "Page 497": {"response": "<h3>\n Software for USB Protocol Analysis: Visual USB Analysis\n</h3>\n<p>\n Ellisys'\n <strong>\n  Visual USB Analysis Software\n </strong>\n is a powerful tool designed to work with the USB Explorer 200 hardware protocol analyzer. This software allows you to control data logging, view captured USB traffic, and print detailed reports. It provides a range of features to help developers monitor and analyze USB communication efficiently.\n</p>\n<h4>\n Key Features of Visual USB Analysis Software\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Data Logging Control\n   </strong>\n   : The software enables you to start and stop the logging of USB traffic, giving you flexibility in monitoring and analyzing device communication.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Customizable Data Display\n   </strong>\n   : The software allows you to tailor the amount, type, and format of the data displayed. For example, you can choose to hide specific details like individual packets or repeated NAKs to make the view less cluttered and more focused on the key elements of the communication.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Filters for Specific Data\n   </strong>\n   : The software offers powerful filtering capabilities, allowing you to refine the data displayed based on specific criteria. You can filter by device, endpoint, speed, status codes, and control requests, showing only the data that meets your set parameters.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Details and Data Panes\n   </strong>\n   : The software includes two main viewing areas:\n  </p>\n<ul>\n<li>\n<strong>\n     Details Pane\n    </strong>\n    : This pane provides in-depth information about a particular request, transaction, packet, or other element in the captured data.\n   </li>\n<li>\n<strong>\n     Data Pane\n    </strong>\n    : This pane displays the individual bytes of the captured data in both\n    <strong>\n     hexadecimal\n    </strong>\n    and\n    <strong>\n     ASCII\n    </strong>\n    formats, making it easier to analyze the raw data.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Example View of Data Capture\n</h4>\n<p>\n In the software\u2019s interface, you can see the transactions and events that occurred when a device was connected downstream from the analyzer. This helps visualize the flow of data, identify issues, and troubleshoot the USB communication between the host and device.\n</p>\n<p>\n By using\n <strong>\n  Visual USB Analysis Software\n </strong>\n , developers can gain detailed insights into USB traffic, allowing them to detect errors, verify proper communication, and optimize device interactions. This software, combined with the hardware analyzer, is a powerful toolkit for anyone involved in USB device development and testing.\n</p>\n"}, "Page 498": {"response": "<h3>\n Software Protocol Analyzers for USB Debugging\n</h3>\n<p>\n A\n <strong>\n  software-only protocol analyzer\n </strong>\n is a tool that runs directly on the host computer where the USB device is connected. Unlike hardware analyzers that monitor the physical USB traffic, software analyzers can monitor traffic to and from any USB device connected to the computer's host controllers.\n</p>\n<h4>\n Key Features of Software Protocol Analyzers:\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Driver Information Access\n   </strong>\n   : A significant advantage of software protocol analyzers is their ability to display driver-level information. These tools can access data that hardware analyzers cannot, specifically the\n   <strong>\n    I/O Request Packets (IRPs)\n   </strong>\n   and\n   <strong>\n    USB Request Blocks (URBs)\n   </strong>\n   used by Windows drivers to communicate with USB devices. This can be valuable for debugging issues related to device drivers and understanding how the host system interacts with the device.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Monitoring Host Controllers\n   </strong>\n   : Software analyzers can capture and display the communication between the host controllers and USB devices. This allows developers to examine the entire flow of data between the system and the device, including the IRPs and URBs, providing deeper insight into driver-level activity.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Search and Filtering\n   </strong>\n   : Software analyzers allow users to search for specific items like events, token-packet types, traffic from a specific device or endpoint, and individual data elements. This makes it easier to focus on relevant data during troubleshooting and debugging.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Additional Modules and Features\n   </strong>\n   : Many software analyzers come with additional modules that enhance their functionality. These may include:\n  </p>\n<ul>\n<li>\n<strong>\n     Triggering on Events\n    </strong>\n    : This feature lets you set up specific conditions or events that should trigger the analyzer to capture data.\n   </li>\n<li>\n<strong>\n     Class-Specific Decoding\n    </strong>\n    : Some analyzers can decode class-specific USB information, which helps in understanding higher-level protocols and device types.\n   </li>\n<li>\n<strong>\n     Exporting Data\n    </strong>\n    : You can export captured data in various formats like text or XML for further analysis or documentation.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n Advantages of Software Analyzers\n</h4>\n<ul>\n<li>\n<strong>\n   Cost and Flexibility\n  </strong>\n  : Software analyzers tend to be more cost-effective than hardware-based analyzers, as they do not require dedicated hardware. They also offer more flexibility in terms of the host system, as they can run on any host that supports the analyzer software.\n </li>\n<li>\n<strong>\n   Detailed Driver-Level Insights\n  </strong>\n  : They are particularly useful for developers needing to debug issues at the driver level, as they can directly show the communication between drivers and devices, which hardware analyzers cannot capture.\n </li>\n</ul>\n<p>\n By using software protocol analyzers, developers can debug USB device interactions, monitor I/O operations, and analyze the data exchanged between the host and device in a more detailed and cost-effective manner.\n</p>\n"}, "Page 499": {"response": "<h3>\n Limitations of Software Analyzers in USB Debugging\n</h3>\n<p>\n While\n <strong>\n  software analyzers\n </strong>\n offer many benefits, they do have some limitations compared to hardware-based analyzers. Here's a breakdown of these limitations:\n</p>\n<h4>\n 1.\n <strong>\n  Limited Access to Host-Controller or Hub Hardware\n </strong>\n :\n</h4>\n<ul>\n<li>\n<strong>\n   Software analyzers\n  </strong>\n  cannot capture low-level interactions that occur directly between the host controller or USB hub hardware and the devices. This means they can\u2019t show certain events like how many times an endpoint\n  <strong>\n   NAKed\n  </strong>\n  (Negative Acknowledged) a transaction before finally returning an\n  <strong>\n   ACK\n  </strong>\n  (Acknowledged) or the exact timing of transactions on the bus. These events are managed by the host controller or hub hardware, which is outside the scope of a software analyzer\u2019s ability to monitor.\n </li>\n</ul>\n<h4>\n 2.\n <strong>\n  Dependence on Filter Drivers\n </strong>\n :\n</h4>\n<ul>\n<li>\n  Some\n  <strong>\n   software analyzers\n  </strong>\n  work through a\n  <strong>\n   filter driver\n  </strong>\n  . This driver is loaded when the operating system loads the USB driver for the device being monitored. However, since the filter driver isn\u2019t activated until the host system has fully enumerated the device, the analyzer cannot capture events that occur during the\n  <strong>\n   enumeration process\n  </strong>\n  or during device attachment, such as the initial connection requests and responses.\n </li>\n</ul>\n<h4>\n 3.\n <strong>\n  SourceUSB as an Example\n </strong>\n :\n</h4>\n<ul>\n<li>\n<strong>\n   Sourcequest, Inc.'s SourceUSB\n  </strong>\n  is one example of a\n  <strong>\n   software analyzer\n  </strong>\n  that can monitor USB I/O requests and other events. It provides the ability to track the enumeration requests and other USB communications, such as the mouse data transactions in Figure 17-4. This shows that, while software analyzers may miss some low-level events, they still offer visibility into many aspects of USB communication, particularly those related to I/O requests and higher-level data exchanges.\n </li>\n</ul>\n<p>\n In summary, while\n <strong>\n  software analyzers\n </strong>\n are very useful for observing high-level USB communications and I/O requests, they have limitations in capturing real-time bus events, low-level hardware interactions, and certain device attachment phases. However, tools like\n <strong>\n  SourceUSB\n </strong>\n can still provide significant insights into USB traffic, including enumeration processes and I/O activities.\n</p>\n"}, "Page 500": {"response": "<h3>\n Testing and Debugging Tools for USB Development\n</h3>\n<p>\n In USB device and host software development, having the right tools for testing and debugging is crucial. This section covers some key tools that developers use to test USB devices and their communication with hosts.\n</p>\n<h4>\n Software Analyzers\n</h4>\n<p>\n<strong>\n  Software analyzers\n </strong>\n like\n <strong>\n  SourceUSB\n </strong>\n and\n <strong>\n  SnoopyPro\n </strong>\n are valuable tools for monitoring USB traffic at the host level. These analyzers capture USB I/O requests, giving detailed information about the host controllers, attached devices, and their assigned drivers.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    SourceUSB\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This tool records USB requests and provides detailed information about the host controllers and devices on the system. It displays requests along with additional system-level data, helping developers see the interactions between devices and drivers.\n   </li>\n<li>\n<strong>\n     Tree View\n    </strong>\n    : It also shows a tree structure of all the host controllers and their connected devices, along with the drivers assigned to each component.\n   </li>\n<li>\n    It offers flexibility in what you want to log, and developers can easily view or filter the data based on specific criteria.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    SnoopyPro\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    A free software-only analyzer available on\n    <strong>\n     sourceforge.net\n    </strong>\n    . It\u2019s a great tool for logging and analyzing USB communication, similar to SourceUSB.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Traffic Generators\n</h4>\n<p>\n A\n <strong>\n  traffic generator\n </strong>\n is an advanced tool used when developers need to simulate or control bus traffic and USB signaling. Some high-end protocol analyzers function as traffic generators, allowing precise control over the data traffic between a host and device. These tools can even introduce errors like\n <strong>\n  bit-stuffing\n </strong>\n or\n <strong>\n  CRC errors\n </strong>\n to test how a system handles faults.\n</p>\n<ul>\n<li>\n<strong>\n   Examples of Traffic Generators\n  </strong>\n  :\n  <ul>\n<li>\n<strong>\n     SBAE-30 Analyzer/Exerciser\n    </strong>\n    by\n    <strong>\n     Catalyst Enterprises\n    </strong>\n    : This device functions as both a protocol analyzer and a traffic generator, enabling precise control over USB bus traffic.\n   </li>\n<li>\n<strong>\n     CATC USBTracer/Trainer\n    </strong>\n    by\n    <strong>\n     LeCroy Corporation\n    </strong>\n    : Similar to the SBAE-30, it can generate USB traffic and simulate host or device behaviors.\n   </li>\n<li>\n<strong>\n     Root 2 USB Test Host\n    </strong>\n    by\n    <strong>\n     RPM Systems\n    </strong>\n    : This tool emulates a USB host and allows developers to generate traffic, control bus voltage, and measure current on the bus.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n USB Certification Testing\n</h4>\n<p>\n Both\n <strong>\n  USB-IF\n </strong>\n (USB Implementers Forum) and\n <strong>\n  Microsoft\n </strong>\n provide testing programs that allow developers to test their USB devices and drivers. Successful completion of these tests grants the product the right to display the\n <strong>\n  Certified USB\n </strong>\n logo and/or the\n <strong>\n  Microsoft Windows logo\n </strong>\n , instilling confidence in users that the device is reliable.\n</p>\n<ul>\n<li>\n<strong>\n   Certified USB Logo\n  </strong>\n  : Passing USB-IF\u2019s tests means the device is compliant with USB standards, ensuring it works correctly with other USB devices and hosts.\n </li>\n<li>\n<strong>\n   Windows Logo\n  </strong>\n  : Devices and drivers that pass\n  <strong>\n   Microsoft\u2019s tests\n  </strong>\n  can earn the\n  <strong>\n   Windows logo\n  </strong>\n  . A driver that passes can be digitally signed, assuring users that it is compatible and free from major issues.\n </li>\n</ul>\n<p>\n In summary, USB developers rely on software analyzers like SourceUSB and SnoopyPro for logging I/O requests, and traffic generators like the SBAE-30 and Root 2 USB Test Host for simulating and controlling bus traffic. Moreover, passing certification tests from the USB-IF and Microsoft ensures that USB products are compliant and compatible, helping to boost user confidence.\n</p>\n"}, "Page 501": {"response": "<h3>\n Compliance Testing for USB Devices\n</h3>\n<p>\n USB offers significant advantages over other interfaces, partly due to the ongoing support from the\n <strong>\n  USB Implementers Forum (USB-IF)\n </strong>\n . Unlike many other technologies, USB-IF continues to assist developers by providing tools and resources to design and test USB products effectively. This section explores the\n <strong>\n  USB-IF's compliance testing program\n </strong>\n and how it ensures that USB products meet the necessary standards.\n</p>\n<h4>\n The USB-IF Compliance Program\n</h4>\n<p>\n The\n <strong>\n  USB-IF\n </strong>\n plays a crucial role in maintaining and testing USB standards. Their compliance program sets out the specifications for various USB products, including:\n</p>\n<ul>\n<li>\n<strong>\n   Peripherals\n  </strong>\n</li>\n<li>\n<strong>\n   Hubs\n  </strong>\n</li>\n<li>\n<strong>\n   Host systems\n  </strong>\n</li>\n<li>\n<strong>\n   On-The-Go devices\n  </strong>\n</li>\n<li>\n<strong>\n   Silicon building blocks\n  </strong>\n</li>\n<li>\n<strong>\n   Cable assemblies\n  </strong>\n</li>\n<li>\n<strong>\n   Connectors\n  </strong>\n</li>\n</ul>\n<p>\n When a product passes the USB-IF\u2019s compliance tests, it is added to their\n <strong>\n  Integrators List\n </strong>\n of compliant devices, signifying that the product meets \u201creasonable measures of acceptability.\u201d After passing the tests, the device is authorized to display the\n <strong>\n  Certified USB logo\n </strong>\n , as long as the developer signs a license agreement and makes the required payment. Even if a developer does not plan to submit their product for official compliance testing, they can still use the tests as a benchmark to verify their product\u2019s performance.\n</p>\n<h4>\n Passing Compliance Testing\n</h4>\n<p>\n To pass USB-IF compliance testing, a device must meet specific criteria. The device must pass tests in the following areas:\n</p>\n<ul>\n<li>\n<strong>\n   Responses to standard control requests\n  </strong>\n</li>\n<li>\n<strong>\n   Compatibility with all host types and other devices on the USB bus\n  </strong>\n</li>\n<li>\n<strong>\n   Electrical performance\n  </strong>\n</li>\n</ul>\n<p>\n The USB-IF provides\n <strong>\n  checklists\n </strong>\n to help developers ensure their devices meet the required specifications. The tests cover a wide range of areas, including the electrical performance of the device, its ability to operate with various host systems, and its interoperability with other USB devices. The full and low-speed tests are covered in a document titled\n <strong>\n  Universal Serial Bus Implementers Forum Full and Low Speed Electrical and Interoperability Compliance Test Procedure\n </strong>\n , while\n <strong>\n  high-speed electrical tests\n </strong>\n are detailed in separate documents available on the USB-IF\u2019s website.\n</p>\n<h4>\n Submitting for Compliance Testing\n</h4>\n<p>\n You can submit a device for testing either through a\n <strong>\n  USB-IF compliance workshop\n </strong>\n or at one of the\n <strong>\n  independent labs authorized by the USB-IF\n </strong>\n . However, to minimize both\n <strong>\n  time and cost\n </strong>\n , it\u2019s advisable for developers to perform as many of the tests as possible on their own before submitting the product for formal compliance testing.\n</p>\n<h4>\n The Role of Checklists\n</h4>\n<p>\n The compliance checklists are essential tools in the testing process. These checklists contain a series of questions related to a product\u2019s specifications and behavior. There are several different checklists available, each designed for specific product types:\n</p>\n<ul>\n<li>\n<strong>\n   Peripheral checklist\n  </strong>\n  : Focuses on the specifications and behavior of USB peripheral devices.\n </li>\n<li>\n<strong>\n   Hub checklist\n  </strong>\n  : Focuses on USB hubs.\n </li>\n<li>\n<strong>\n   Hub and peripheral silicon checklist\n  </strong>\n  : Addresses the silicon used in hubs and peripherals.\n </li>\n<li>\n<strong>\n   Host system checklist\n  </strong>\n  : Covers the requirements for host systems.\n </li>\n</ul>\n<p>\n By using these checklists, developers can ensure that their devices are in line with the necessary USB standards before submitting them for official compliance testing.\n</p>\n<p>\n In conclusion, USB-IF's compliance testing program offers invaluable resources for developers to ensure their products meet USB specifications. By passing the compliance tests, a device can earn the\n <strong>\n  Certified USB logo\n </strong>\n , demonstrating its reliability and interoperability with other USB devices and systems.\n</p>\n"}, "Page 502": {"response": "<h3>\n Device Framework Testing and Compliance\n</h3>\n<p>\n When designing USB devices, it\u2019s essential to ensure that they meet the USB specification in terms of mechanical design, device states, signals, operating voltages, and power consumption. To help verify compliance, developers must answer \"yes\" to every question in a\n <strong>\n  compliance checklist\n </strong>\n provided by the USB Implementers Forum (USB-IF). Each checklist question is linked to a relevant section in the USB specification, offering developers more detailed guidance.\n</p>\n<h4>\n Device Framework Tests\n</h4>\n<p>\n The\n <strong>\n  Device Framework\n </strong>\n tests are designed to verify that a USB device responds correctly to standard control requests. The tests are carried out using the\n <strong>\n  USB Command Verifier (USBCV)\n </strong>\n software utility, which is detailed in the\n <strong>\n  USB Command Verifier Compliance Test Specification\n </strong>\n . This specification and the testing software are available from the USB-IF's website.\n</p>\n<p>\n To run the USBCV software, the host PC must have a\n <strong>\n  USB 2.0 host controller\n </strong>\n . If testing\n <strong>\n  low-speed or full-speed devices\n </strong>\n , they must be connected through an external USB 2.0 hub. The USBCV software temporarily replaces the host-controller's driver with its own test-stack driver during the testing process. When testing is finished, the software restores the original driver. The stack switching has been tested with\n <strong>\n  Microsoft\u2019s host-controller driver\n </strong>\n , and it is recommended to run the USBCV software only on hosts that are using this driver.\n</p>\n<h4>\n Test Suites in USBCV Software\n</h4>\n<p>\n The USBCV software includes several test suites designed to verify different aspects of USB device functionality. These test suites include:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Chapter 9 Tests\n   </strong>\n   : These tests involve issuing the standard control requests defined in\n   <strong>\n    Chapter 9\n   </strong>\n   of the USB specification. The host will check the information returned by the device to ensure it complies with USB standards. For example, the host will request specific information from a device and verify that the correct data is returned.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Current Measurement Tests\n   </strong>\n   : These tests ensure that the device meets the USB power requirements by measuring the current consumption.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    HID (Human Interface Device) Tests\n   </strong>\n   : These tests verify that devices like keyboards, mice, and other human interface devices operate correctly within the USB framework.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Hub Tests\n   </strong>\n   : These tests are designed to ensure that USB hubs are functioning properly and meet the required standards for device communication.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    OTG (On-The-Go) Tests\n   </strong>\n   : These tests ensure that devices that support USB On-The-Go functionality can correctly switch between host and device roles.\n  </p>\n</li>\n</ol>\n<p>\n By running these tests, developers can ensure that their USB devices are compliant with the USB specification and are capable of operating seamlessly with other USB devices and systems. The\n <strong>\n  USBCV software\n </strong>\n plays a critical role in automating and streamlining this process.\n</p>\n"}, "Page 503": {"response": "<h3>\n Chapter 9 Tests and Device Descriptor Verification\n</h3>\n<p>\n The\n <strong>\n  Chapter 9 tests\n </strong>\n are an essential part of USB compliance testing and are conducted using the\n <strong>\n  USB Command Verifier (USBCV)\n </strong>\n software. These tests focus on the correct handling of\n <strong>\n  standard control requests\n </strong>\n defined in Chapter 9 of the USB specification, which is critical for ensuring that USB devices respond properly to system queries.\n</p>\n<h4>\n Device Descriptor Check\n</h4>\n<p>\n One of the key components tested during Chapter 9 is the\n <strong>\n  device descriptor\n </strong>\n , which provides essential information about the device to the host. The USBCV software performs the following checks on the device descriptor:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    bMaxPacketSize0\n   </strong>\n   : This value must be valid for the device\u2019s speed. It defines the maximum packet size the device can handle for endpoint 0, which is crucial for proper communication between the device and the host. The test verifies that this value matches the expected size for the device\u2019s USB speed.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    bDeviceClass\n   </strong>\n   : This field indicates the device class, which is either a standard class or vendor-defined. The test ensures that the\n   <strong>\n    bDeviceClass\n   </strong>\n   value is either a standard value defined by the USB specification or\n   <strong>\n    0xFF\n   </strong>\n   (which indicates a vendor-specific class).\n  </p>\n</li>\n</ul>\n<p>\n The\n <strong>\n  USBCV software\n </strong>\n checks the device descriptor while the device is in the\n <strong>\n  default\n </strong>\n ,\n <strong>\n  address\n </strong>\n , and\n <strong>\n  configured states\n </strong>\n , as well as at both\n <strong>\n  full-speed\n </strong>\n and\n <strong>\n  high-speed\n </strong>\n if the device supports these speeds. The tests ensure the correct behavior for every configuration supported by the device.\n</p>\n<p>\n By thoroughly verifying the device descriptor, these tests ensure that the device correctly communicates its capabilities to the host and adheres to the USB specification\u2019s requirements for standard descriptors. This process helps identify any issues early on, ensuring smooth device integration with the USB ecosystem.\n</p>\n"}, "Page 504": {"response": "<h3>\n Chapter 9 Tests and Current Measurement\n</h3>\n<h4>\n Chapter 9 Tests\n</h4>\n<p>\n The\n <strong>\n  Chapter 9 tests\n </strong>\n are designed to ensure that a USB device properly handles the standard control requests specified in the USB specification. These tests involve a series of checks to verify the device\u2019s response to various commands and its compliance with USB protocols. The tests include:\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Device Enumeration\n   </strong>\n   : The device is enumerated multiple times with different addresses to ensure proper recognition by the host.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Endpoint Control\n   </strong>\n   : The tests ensure that all\n   <strong>\n    bulk\n   </strong>\n   and\n   <strong>\n    interrupt endpoints\n   </strong>\n   can be halted using a\n   <strong>\n    Clear_Feature\n   </strong>\n   request, which checks the device\u2019s ability to respond to such control commands.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Unsupported Descriptor Handling\n   </strong>\n   : The device is tested to confirm that it returns a\n   <strong>\n    STALL\n   </strong>\n   condition when it receives requests for unsupported descriptor types.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Feature Handling\n   </strong>\n   : The device is required to return a\n   <strong>\n    STALL\n   </strong>\n   in response to a\n   <strong>\n    Set_Feature\n   </strong>\n   request if the feature is not supported by the device.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Suspend and Resume\n   </strong>\n   : The device is tested to ensure that it correctly enters the suspend state and resumes when required.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Remote Wakeup\n   </strong>\n   : If the device supports\n   <strong>\n    remote wakeup\n   </strong>\n   , it is suspended, and the user is asked to perform an action to wake it up. The device must properly handle this request.\n  </p>\n</li>\n</ul>\n<p>\n All USB devices must pass every test in Chapter 9 to ensure compliance with USB standards.\n</p>\n<h4>\n Current Measurement Test Suite\n</h4>\n<p>\n The\n <strong>\n  Current Measurement test suite\n </strong>\n is essential for verifying the amount of power a device consumes during its operation. The test occurs in both the\n <strong>\n  unconfigured\n </strong>\n and\n <strong>\n  configured\n </strong>\n states of the device:\n</p>\n<ul>\n<li>\n<p>\n   In the\n   <strong>\n    unconfigured state\n   </strong>\n   , the device should draw no more than\n   <strong>\n    100 milliamps\n   </strong>\n   of current.\n  </p>\n</li>\n<li>\n<p>\n   Once\n   <strong>\n    configured\n   </strong>\n   , the device should only draw the amount of current specified in the\n   <strong>\n    bMaxPower\n   </strong>\n   field of its configuration descriptor.\n  </p>\n</li>\n</ul>\n<p>\n This test helps ensure that the device doesn\u2019t exceed its power limits, which is crucial for ensuring proper functioning and avoiding issues like overcurrent protection.\n</p>\n<h4>\n Other Test Suites\n</h4>\n<p>\n Additional test suites target specific types of USB devices and functionality, including:\n</p>\n<ul>\n<li>\n<strong>\n   Hub Tests\n  </strong>\n  : Ensuring USB hubs are functioning correctly.\n </li>\n<li>\n<strong>\n   HID (Human Interface Device) Tests\n  </strong>\n  : Verifying that HID-class devices meet the necessary standards.\n </li>\n<li>\n<strong>\n   OTG (On-The-Go) Devices\n  </strong>\n  : Testing devices that use On-The-Go functionality.\n </li>\n</ul>\n<p>\n The\n <strong>\n  USBCV software\n </strong>\n provides two modes for running these tests:\n</p>\n<ol>\n<li>\n<strong>\n   Compliance Test Mode\n  </strong>\n  : This mode runs the full test suite, ensuring all aspects of the device\u2019s functionality are covered.\n </li>\n<li>\n<strong>\n   Debug Mode\n  </strong>\n  : This mode allows you to run individual tests within a suite and gives more control, such as selecting the configuration for testing.\n </li>\n</ol>\n<h3>\n Interoperability Tests\n</h3>\n<p>\n Interoperability tests are critical to ensure that the device works well across different host controllers and with various USB devices in a real-world setting. These tests simulate the user experience and check the device\u2019s compatibility in different scenarios:\n</p>\n<ul>\n<li>\n<p>\n   The device must be tested with both\n   <strong>\n    EHCI (Enhanced Host Controller Interface)\n   </strong>\n   and\n   <strong>\n    UHCI/OHCI\n   </strong>\n   host controllers, which represent different generations of USB host controller technologies.\n  </p>\n</li>\n<li>\n<p>\n   The device must also be tested with\n   <strong>\n    hubs\n   </strong>\n   that support high-speed and those that do not, to ensure consistent behavior in different environments.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    S3 Sleep State Testing\n   </strong>\n   : The device must be tested under conditions where the host either maintains\n   <strong>\n    VBUS\n   </strong>\n   (the USB bus power) when entering the S3 sleep state or does not. This checks the device\u2019s ability to handle power-saving modes properly.\n  </p>\n</li>\n</ul>\n<p>\n By passing interoperability tests, a device ensures that it will function well across a wide range of USB host systems and configurations, providing a reliable user experience.\n</p>\n"}, "Page 505": {"response": "<h3>\n Interoperability Testing and the Gold Tree\n</h3>\n<p>\n Interoperability testing ensures that USB devices work well with a variety of USB host controllers and other devices. It mimics real-world usage, where devices are used with various setups, host systems, and buses. During these tests, the device is evaluated under different conditions:\n</p>\n<h4>\n Test Conditions:\n</h4>\n<ul>\n<li>\n  The bus carries\n  <strong>\n   control\n  </strong>\n  ,\n  <strong>\n   bulk\n  </strong>\n  ,\n  <strong>\n   interrupt\n  </strong>\n  , and\n  <strong>\n   isochronous\n  </strong>\n  transfers, which represent different types of data traffic on the USB bus.\n </li>\n<li>\n  The device is tested with\n  <strong>\n   five external hubs\n  </strong>\n  between it and the host to evaluate its ability to function across multiple hub connections.\n </li>\n<li>\n  The device can be placed\n  <strong>\n   up to 30 meters\n  </strong>\n  from the host (with the exception of low-speed devices, which are limited to 28 meters).\n </li>\n<li>\n  The bus is carrying both\n  <strong>\n   full-speed\n  </strong>\n  and\n  <strong>\n   high-speed\n  </strong>\n  data traffic to ensure the device operates correctly in different speed scenarios.\n </li>\n</ul>\n<h4>\n The Gold Tree Setup\n</h4>\n<p>\n The\n <strong>\n  Gold Tree\n </strong>\n is a reference configuration for interoperability testing, where the device under test is connected to a bus that includes various other devices and hubs. The test specification outlines the following devices that should be present in the Gold Tree:\n</p>\n<ul>\n<li>\n<strong>\n   Video Camera\n  </strong>\n  : A high-speed device that uses\n  <strong>\n   isochronous transfers\n  </strong>\n  , requires high power, and is bus-powered.\n </li>\n<li>\n<strong>\n   Mass Storage Device\n  </strong>\n  : A high-speed device using\n  <strong>\n   bulk transfers\n  </strong>\n  and is self-powered.\n </li>\n<li>\n<strong>\n   Flash Media Drive\n  </strong>\n  : Another high-speed device using\n  <strong>\n   bulk transfers\n  </strong>\n  , but bus-powered.\n </li>\n<li>\n<strong>\n   Keyboard\n  </strong>\n  : A low-speed\n  <strong>\n   HID (Human Interface Device)\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Mouse\n  </strong>\n  : A low-speed\n  <strong>\n   HID\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Hubs\n  </strong>\n  : Seven hubs in total, including five that support all three bus speeds (with one hub supporting multiple transaction translators) and two that support only low and full speeds.\n </li>\n</ul>\n<p>\n These devices are arranged in a specific configuration, and their interaction is monitored during testing. The test specification provides a list of products that have been verified to have no known interoperability issues. Developers can use these devices or equivalents for testing.\n</p>\n<h4>\n Actions During Testing\n</h4>\n<p>\n The device under test must undergo a variety of actions to confirm its functionality in different scenarios:\n</p>\n<ol>\n<li>\n<strong>\n   Device Detachment and Reattachment\n  </strong>\n  : After detaching the device from the bus and then reattaching it to the same port, the device must function properly.\n </li>\n<li>\n<strong>\n   Reattachment to Different Port\n  </strong>\n  : If the device is detached and then reattached to a different port, it must continue to work as expected.\n </li>\n</ol>\n<p>\n By testing under these conditions, the interoperability of the device with various host controllers, hubs, and other devices is ensured, ensuring that the device will work reliably in real-world USB setups.\n</p>\n"}, "Page 506": {"response": "<h3>\n The Gold Tree Configuration for Compliance Testing\n</h3>\n<p>\n In USB compliance testing, the\n <strong>\n  Gold Tree\n </strong>\n configuration is used to test how a device interacts within a system with other USB devices. This setup ensures that the device functions properly while sharing the bus with multiple devices and under various operating conditions.\n</p>\n<p>\n The\n <strong>\n  Gold Tree\n </strong>\n includes a range of devices and hubs, specifically chosen to simulate typical USB environments. This configuration allows for thorough testing of how the device under test behaves when connected to various other devices, ensuring it operates as expected in a real-world setting where multiple devices are often used simultaneously.\n</p>\n"}, "Page 507": {"response": "<h3>\n Testing Device Behavior and System Interactions\n</h3>\n<p>\n During USB compliance testing, a device is subjected to a variety of real-world scenarios to ensure it functions properly within a system where multiple devices are active. These tests simulate different system states and actions to check for device performance under various conditions:\n</p>\n<ul>\n<li>\n<strong>\n   Reboot Tests\n  </strong>\n  : The device is tested by performing both warm and cold boots. A warm boot involves restarting the system without turning it off, while a cold boot requires turning the system off and on again.\n </li>\n<li>\n<strong>\n   Sleep Mode Tests\n  </strong>\n  : The device is tested by entering and resuming from the S1 and S3 sleep states in both active and idle conditions. These tests ensure the device properly responds to sleep and wake cycles.\n </li>\n<li>\n<strong>\n   High-Speed Functionality\n  </strong>\n  : High-speed devices are tested to ensure they continue to operate at full speed without issues.\n </li>\n</ul>\n<p>\n These conditions ensure that the device functions correctly in a variety of everyday scenarios.\n</p>\n<h3>\n Waivers and USB Logo\n</h3>\n<p>\n In some cases, a device may not pass every compliance test, but it can still earn the\n <strong>\n  Certified USB Logo\n </strong>\n . The\n <strong>\n  USB-IF\n </strong>\n (USB Implementers Forum) can grant waivers for specific requirements, such as small deviations in power consumption during the\n <strong>\n  Suspend\n </strong>\n state. For example, devices that consume slightly more power than the expected 500 microamperes can still qualify for the logo if they meet other critical standards.\n</p>\n<h3>\n Certified USB Logo\n</h3>\n<p>\n When a device passes all compliance tests, it is eligible to display the\n <strong>\n  Certified USB Logo\n </strong>\n . This logo indicates that the device supports USB high speed and/or USB On-The-Go functionality. To use the logo, manufacturers must sign the\n <strong>\n  USB-IF Trademark License Agreement\n </strong>\n and pay an administration fee, which was $1500 at the time of writing. It is important to note that this logo is distinct from the general USB icon discussed in Chapter 19.\n</p>\n<h3>\n WHQL Testing for Windows Devices\n</h3>\n<p>\n For devices and drivers intended for use on Windows PCs, Microsoft offers\n <strong>\n  Windows Hardware Quality Labs (WHQL) Testing\n </strong>\n . This testing ensures that devices and drivers meet Microsoft's baseline features and quality standards, promoting a smooth and reliable experience for end-users. Devices that pass WHQL testing are allowed to display the\n <strong>\n  Designed for Microsoft Windows\n </strong>\n logo on their packaging and marketing materials.\n</p>\n"}, "Page 508": {"response": "<p>\n<strong>\n  Testing and Debugging: Windows Logo Program and USB Certification\n </strong>\n</p>\n<p>\n Microsoft\u2019s Windows Catalog lists compatible devices, and those with the certification logo in their listings have passed certain qualification tests. As described in Chapter 9, a driver that passes the Windows Hardware Quality Labs (WHQL) test is digitally signed, confirming that it is a trusted driver.\n</p>\n<h3>\n The Windows Logo Program\n</h3>\n<p>\n To earn the Windows logo, a device must:\n</p>\n<ol>\n<li>\n  Install and uninstall properly without causing issues with other system components.\n </li>\n<li>\n  Work well with other system components.\n </li>\n</ol>\n<p>\n There are separate tests and logos for Windows XP and Windows Server 2003. A single device can qualify for multiple logos by passing the specific tests for each version.\n</p>\n<h3>\n USB Certification\n</h3>\n<p>\n Devices that pass compliance testing can display one of the Certified USB logos, which indicate whether the device supports features like high speed or USB On-The-Go. The certification helps identify the device\u2019s functionality and ensures it meets USB standards.\n</p>\n"}, "Page 509": {"response": "<p>\n<strong>\n  Chapter 17: Windows Logo Program and Digital Signatures for USB Devices\n </strong>\n</p>\n<h3>\n Compatibility Tests for Windows Logo Certification\n</h3>\n<p>\n To qualify for the Windows logo, a device must:\n</p>\n<ol>\n<li>\n<strong>\n   Pass Compatibility Tests:\n  </strong>\n  Use the Windows Hardware Compatibility Test (HCT) kit provided by Microsoft to test the device\u2019s compatibility.\n </li>\n<li>\n<strong>\n   Create a Test Report:\n  </strong>\n  Use Microsoft's HCT Submission Review Utility to generate a report that includes the test logs.\n </li>\n<li>\n<strong>\n   Submit Hardware and Documentation:\n  </strong>\n  Submit the hardware, test logs, drivers (if any), user documentation, and any necessary configuration utilities or accessories. A fee of $250 (as of this writing) is required for each operating system. The submission is sent to a Windows Quality Online Services test location. Check Microsoft's website for the latest WHQL testing information.\n </li>\n</ol>\n<h3>\n Digital Signatures for Drivers\n</h3>\n<p>\n To receive the Windows logo, a device must use a\n <strong>\n  digitally signed driver\n </strong>\n . This driver can either be one provided with the operating system or one supplied by the vendor.\n</p>\n<h4>\n Steps to Obtain a Digital Signature:\n</h4>\n<ol>\n<li>\n<strong>\n   WHQL Testing:\n  </strong>\n  The driver must pass WHQL testing.\n </li>\n<li>\n<strong>\n   Obtain VeriSign ID:\n  </strong>\n  The vendor must obtain a VeriSign Digital Code Signing ID, which costs $400 (as of this writing), from\n  <a rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n   www\n   .verisign\n   .com\n  </a>\n  .\n </li>\n<li>\n<strong>\n   Digital Signing:\n  </strong>\n  Microsoft uses cryptographic technology to digitally sign the driver\u2019s catalog (.cat) file and sends it back to the vendor.\n </li>\n</ol>\n<p>\n Each device's\n <strong>\n  INF file\n </strong>\n references the catalog file. This digital signature allows Windows to verify if the driver has been modified since passing WHQL testing. If any changes are made to the INF file\u2014such as adding a new Product ID or device release number\u2014a new digital signature must be obtained.\n</p>\n<p>\n For most USB devices, the INF file of a signed driver must include a\n <strong>\n  device identification string\n </strong>\n containing the device's Vendor ID (VID) and Product ID (PID). INF files that use only a compatible ID (based on class and optional subclass/protocol) will not pass WHQL tests, except for printers.\n</p>\n<h3>\n Windows Update Driver Requirement\n</h3>\n<p>\n If a driver is digitally signed, it can be included in\n <strong>\n  Windows Update\n </strong>\n , which simplifies driver updates for users. In some cases, Windows Update may also automatically find the appropriate driver for newly installed devices.\n</p>\n"}, "Page 510": {"response": "<p>\n<strong>\n  Testing and Debugging: Alternate Digital Signature Method for Windows\n </strong>\n</p>\n<h3>\n Additional Driver Requirements for Windows Update\n</h3>\n<p>\n For a driver to be included in\n <strong>\n  Windows Update\n </strong>\n , it must meet specific requirements to ensure that Windows can easily identify, download, and install it. These additional requirements are necessary to make the process seamless for users.\n</p>\n<h3>\n Alternate Digital Signature Method\n</h3>\n<p>\n In\n <strong>\n  Windows Server 2003 and later\n </strong>\n , some devices can use an alternative method to obtain a digital signature. If the\n <strong>\n  WHQL\n </strong>\n (Windows Hardware Quality Labs) does not offer a test program for the driver's setup class, vendors have the option to use\n <strong>\n  Microsoft\u2019s code-signing tools\n </strong>\n . These tools allow vendors to generate an\n <strong>\n  Authenticode\n </strong>\n signature for their driver, providing an alternative way to digitally sign the driver.\n</p>\n"}, "Page 511": {"response": "<p>\n It seems like the content for Chapter 17, section 488, is missing or not provided in your message. Could you share the specific content you'd like restated or provide more context?\n</p>\n"}, "Page 512": {"response": "<p>\n<strong>\n  Signals and Encoding in USB\n </strong>\n</p>\n<h3>\n Overview\n</h3>\n<p>\n While it\u2019s possible to design and program a USB peripheral without knowing every detail about how data is encoded on the bus, having an understanding of these concepts can enhance your knowledge of your device\u2019s capabilities and limitations. This chapter covers the essential aspects of USB encoding and data formats, with more detailed information available in the USB specification.\n</p>\n<h3>\n Bus States\n</h3>\n<p>\n The USB specification defines various bus states, which are linked to the signal voltages on the bus or the conditions those voltages represent. Different segments of the bus can be in different states at the same time. For example, a hub might place one of its downstream ports in the\n <strong>\n  Reset\n </strong>\n state in response to a host request, while other ports could remain in the\n <strong>\n  Idle\n </strong>\n state.\n</p>\n<p>\n There are different bus states for\n <strong>\n  Low/Full speed\n </strong>\n and\n <strong>\n  High speed\n </strong>\n devices, though many of these states are similar across both speed types.\n</p>\n"}, "Page 513": {"response": "<p>\n<strong>\n  Low-Speed and Full-Speed Bus States in USB\n </strong>\n</p>\n<h3>\n Bus States in Low and Full Speed\n</h3>\n<p>\n Low-speed and full-speed devices share the same bus states, but the definition of certain states varies depending on the speed of the cable segment. A\n <strong>\n  low-speed segment\n </strong>\n refers to the connection between a low-speed device and its nearest hub. A\n <strong>\n  full-speed segment\n </strong>\n is any segment that transmits data at either low- or full-speed bit rates.\n</p>\n<h3>\n Differential 0 and Differential 1\n</h3>\n<p>\n During data transmission, the USB bus operates in two states:\n <strong>\n  Differential 0\n </strong>\n and\n <strong>\n  Differential 1\n </strong>\n .\n</p>\n<ul>\n<li>\n<strong>\n   Differential 0\n  </strong>\n  : This occurs when\n  <strong>\n   D+\n  </strong>\n  is at a logic low and\n  <strong>\n   D-\n  </strong>\n  is at a logic high.\n </li>\n<li>\n<strong>\n   Differential 1\n  </strong>\n  : This occurs when\n  <strong>\n   D+\n  </strong>\n  is at a logic high and\n  <strong>\n   D-\n  </strong>\n  is at a logic low.\n </li>\n</ul>\n<p>\n Note that these differential states do not directly translate to voltage levels, but instead represent changes in logic levels, no changes, or bit stuffing (explained later in the chapter). Chapter 19 provides details on the voltage levels for logic low and high.\n</p>\n<h3>\n Single-Ended Zero (SE0)\n</h3>\n<p>\n The\n <strong>\n  Single-Ended Zero (SE0)\n </strong>\n state occurs when both\n <strong>\n  D+\n </strong>\n and\n <strong>\n  D-\n </strong>\n are at logic low. This state is used by the bus in the following conditions:\n</p>\n<ul>\n<li>\n<strong>\n   End-of-Packet\n  </strong>\n</li>\n<li>\n<strong>\n   Disconnect\n  </strong>\n</li>\n<li>\n<strong>\n   Reset\n  </strong>\n</li>\n</ul>\n<h3>\n Single-Ended One (SE1)\n</h3>\n<p>\n The opposite of the\n <strong>\n  Single-Ended Zero\n </strong>\n is the\n <strong>\n  Single-Ended One (SE1)\n </strong>\n . This state occurs when both\n <strong>\n  D+\n </strong>\n and\n <strong>\n  D-\n </strong>\n are at logic high, which is considered an invalid bus state and should never occur.\n</p>\n<h3>\n Data J and Data K States\n</h3>\n<p>\n In addition to the Differential 0 and Differential 1 states, USB defines two other data bus states:\n <strong>\n  J\n </strong>\n and\n <strong>\n  K\n </strong>\n , which are further explained in the next section.\n</p>\n"}, "Page 514": {"response": "<p>\n<strong>\n  Signals and Encoding: USB Bus States and Data Encoding\n </strong>\n</p>\n<h3>\n J and K States\n</h3>\n<p>\n The\n <strong>\n  J\n </strong>\n and\n <strong>\n  K\n </strong>\n states are defined based on whether the bus is in\n <strong>\n  Differential 1\n </strong>\n or\n <strong>\n  Differential 0\n </strong>\n , and whether the cable segment is operating at\n <strong>\n  low speed\n </strong>\n or\n <strong>\n  full speed\n </strong>\n . This consistent terminology allows a uniform description of an event or logic state, even though the voltages on low-speed and full-speed lines differ. For example, the\n <strong>\n  Start-of-Packet (SOP)\n </strong>\n state occurs when the bus transitions from the\n <strong>\n  Idle\n </strong>\n state to the\n <strong>\n  K\n </strong>\n state. On full-speed segments, this transition happens when\n <strong>\n  D-\n </strong>\n becomes more positive than\n <strong>\n  D+\n </strong>\n , while on low-speed segments, the transition occurs when\n <strong>\n  D+\n </strong>\n becomes more positive than\n <strong>\n  D-\n </strong>\n .\n</p>\n<h3>\n Bus States\n</h3>\n<ol>\n<li>\n<p>\n<strong>\n    Idle State\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    No drivers are active.\n   </li>\n<li>\n    On a full-speed segment,\n    <strong>\n     D+\n    </strong>\n    is more positive than\n    <strong>\n     D-\n    </strong>\n    .\n   </li>\n<li>\n    On a low-speed segment,\n    <strong>\n     D-\n    </strong>\n    is more positive than\n    <strong>\n     D+\n    </strong>\n    .\n   </li>\n<li>\n    After a device is attached, the hub detects whether it is low or full speed by checking the voltages in the Idle state at the device's port.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Resume State\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    When a device is in the\n    <strong>\n     Suspend\n    </strong>\n    state, the\n    <strong>\n     Data K\n    </strong>\n    state at the device\u2019s port signals a resume from Suspend.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Start-of-Packet (SOP)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The SOP state occurs when the bus changes from the\n    <strong>\n     Idle\n    </strong>\n    state to the\n    <strong>\n     K\n    </strong>\n    state.\n   </li>\n<li>\n    This is the beginning of every low- or full-speed packet transmission.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    End-of-Packet (EOP)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The EOP state exists when the receiver has been in the\n    <strong>\n     Single-Ended-Zero (SE0)\n    </strong>\n    state for at least one bit time, followed by the\n    <strong>\n     Data J\n    </strong>\n    state for at least one bit time.\n   </li>\n<li>\n    The receiver may optionally define a shorter minimum for this transition.\n   </li>\n</ul>\n</li>\n</ol>\n<h3>\n Bus State vs. Data State\n</h3>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Bus State\n    </strong>\n</th>\n<th>\n<strong>\n     Data State\n    </strong>\n</th>\n<th>\n<strong>\n     Low Speed\n    </strong>\n</th>\n<th>\n<strong>\n     Full Speed\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n    Differential 0\n   </td>\n<td>\n    J\n   </td>\n<td>\n    K\n   </td>\n<td>\n    K\n   </td>\n</tr>\n<tr>\n<td>\n    Differential 1\n   </td>\n<td>\n    K\n   </td>\n<td>\n    J\n   </td>\n<td>\n    J\n   </td>\n</tr>\n</tbody>\n</table>\n"}, "Page 515": {"response": "<p>\n<strong>\n  USB Bus States and Data Encoding: Disconnect, Connect, Reset, and High-Speed Bus States\n </strong>\n</p>\n<h3>\n End-of-Packet (EOP)\n</h3>\n<p>\n The\n <strong>\n  End-of-Packet (EOP)\n </strong>\n state occurs when the bus has been in the\n <strong>\n  Single-Ended-Zero (SE0)\n </strong>\n state for at least one bit time, followed by the\n <strong>\n  Data J\n </strong>\n state for at least one bit time. The duration of the\n <strong>\n  SE0\n </strong>\n state is approximately two bit widths at the driver. Every transmitted low- or full-speed packet ends with an EOP.\n</p>\n<h3>\n Disconnect and Connect States\n</h3>\n<ol>\n<li>\n<p>\n<strong>\n    Disconnect State\n   </strong>\n   : A downstream port enters the\n   <strong>\n    Disconnect\n   </strong>\n   state when a\n   <strong>\n    Single-Ended Zero\n   </strong>\n   has lasted for at least\n   <strong>\n    2.5 microseconds\n   </strong>\n   .\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Connect State\n   </strong>\n   : A downstream port enters the\n   <strong>\n    Connect\n   </strong>\n   state when the bus has been in the\n   <strong>\n    Idle\n   </strong>\n   state for at least\n   <strong>\n    2.5 microseconds\n   </strong>\n   but no more than\n   <strong>\n    2.0 milliseconds\n   </strong>\n   .\n  </p>\n</li>\n</ol>\n<h3>\n Reset State\n</h3>\n<p>\n The\n <strong>\n  Reset\n </strong>\n state occurs when a\n <strong>\n  Single-Ended Zero\n </strong>\n has lasted for\n <strong>\n  10 milliseconds\n </strong>\n , though a device may enter the Reset state after just\n <strong>\n  2.5 microseconds\n </strong>\n . During the Reset state, a full-speed device capable of high-speed communication performs the\n <strong>\n  high-speed handshake\n </strong>\n . Upon exiting the Reset state, the device must be operating at its correct speed and must respond to communications addressed to the default address (\n <strong>\n  00h\n </strong>\n ).\n</p>\n<h3>\n High-Speed Bus States\n</h3>\n<p>\n Many of the bus states for\n <strong>\n  high-speed\n </strong>\n are similar to those for low and full speeds, but there are some unique high-speed states. Also, some low- and full-speed bus states have no equivalent at high speed.\n</p>\n<h4>\n High-Speed Differential 0 and Differential 1\n</h4>\n<p>\n High-speed data transfer also involves two primary bus states:\n <strong>\n  High-speed Differential 0\n </strong>\n and\n <strong>\n  High-speed Differential 1\n </strong>\n .\n</p>\n<ul>\n<li>\n<strong>\n   High-speed Differential 0\n  </strong>\n  : This occurs when\n  <strong>\n   D+\n  </strong>\n  is at logic low and\n  <strong>\n   D-\n  </strong>\n  is at logic high.\n </li>\n<li>\n<strong>\n   High-speed Differential 1\n  </strong>\n  : This occurs when\n  <strong>\n   D+\n  </strong>\n  is at logic high and\n  <strong>\n   D-\n  </strong>\n  is at logic low.\n </li>\n</ul>\n<p>\n Although similar to low and full-speed, the voltage requirements for high-speed transmission differ. High-speed also introduces additional requirements for\n <strong>\n  AC differential levels\n </strong>\n .\n</p>\n"}, "Page 516": {"response": "<p>\n<strong>\n  High-Speed Bus States and Handshake Process\n </strong>\n</p>\n<h3>\n High-Speed Data J and Data K States\n</h3>\n<p>\n The definitions for\n <strong>\n  High-speed Data J\n </strong>\n and\n <strong>\n  Data K\n </strong>\n states are the same as those for full-speed:\n</p>\n<ul>\n<li>\n<strong>\n   High-speed Data J\n  </strong>\n  : Defined when\n  <strong>\n   D+\n  </strong>\n  is at logic low and\n  <strong>\n   D-\n  </strong>\n  is at logic high.\n </li>\n<li>\n<strong>\n   High-speed Data K\n  </strong>\n  : Defined when\n  <strong>\n   D+\n  </strong>\n  is at logic high and\n  <strong>\n   D-\n  </strong>\n  is at logic low.\n </li>\n</ul>\n<h3>\n Chirp J and Chirp K States\n</h3>\n<p>\n The\n <strong>\n  Chirp J\n </strong>\n and\n <strong>\n  Chirp K\n </strong>\n states are only present during the\n <strong>\n  high-speed detection handshake\n </strong>\n . This handshake occurs when a\n <strong>\n  USB 2.0 hub\n </strong>\n places a downstream bus segment into the\n <strong>\n  Reset\n </strong>\n state.\n</p>\n<ul>\n<li>\n<strong>\n   Chirp J\n  </strong>\n  : Occurs when\n  <strong>\n   D+\n  </strong>\n  is more positive than\n  <strong>\n   D-\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Chirp K\n  </strong>\n  : Occurs when\n  <strong>\n   D-\n  </strong>\n  is more positive than\n  <strong>\n   D+\n  </strong>\n  .\n </li>\n</ul>\n<p>\n These are defined as\n <strong>\n  DC differential voltages\n </strong>\n .\n</p>\n<h3>\n High-Speed Device Attachment and Handshake\n</h3>\n<p>\n When a\n <strong>\n  high-speed device\n </strong>\n attaches to the bus, it initially operates at\n <strong>\n  full speed\n </strong>\n . The\n <strong>\n  high-speed detection handshake\n </strong>\n allows the device to inform the hub that it supports high-speed communication and to transition into high-speed mode.\n</p>\n<ol>\n<li>\n<strong>\n   Hub Action\n  </strong>\n  : After detecting the attachment, the hub places the device's port and bus segment into the\n  <strong>\n   Reset\n  </strong>\n  state.\n </li>\n<li>\n<strong>\n   Chirp K Transmission\n  </strong>\n  : The high-speed device sends a\n  <strong>\n   Chirp K\n  </strong>\n  to the hub for 1 to 7 milliseconds.\n </li>\n<li>\n<strong>\n   Hub Response\n  </strong>\n  : A\n  <strong>\n   2.0 hub\n  </strong>\n  , which is communicating at high speed, detects the\n  <strong>\n   Chirp K\n  </strong>\n  and responds by sending alternating\n  <strong>\n   Chirp K\n  </strong>\n  and\n  <strong>\n   Chirp J\n  </strong>\n  signals. This sequence continues until just before the end of the Reset state.\n </li>\n<li>\n<strong>\n   High-speed Enabled State\n  </strong>\n  : At the end of Reset, the hub transitions the port into the\n  <strong>\n   High-speed Enabled\n  </strong>\n  state.\n </li>\n<li>\n<strong>\n   Device Transition\n  </strong>\n  : Upon detecting the Chirp K and Chirp J sequence, the device disconnects its full-speed pull-up, enables its high-speed terminations, and enters the\n  <strong>\n   high-speed Default\n  </strong>\n  state.\n </li>\n</ol>\n<h3>\n 1.x Hub Behavior\n</h3>\n<p>\n A\n <strong>\n  1.x hub\n </strong>\n does not respond to the device\u2019s\n <strong>\n  Chirp K\n </strong>\n . The device, not receiving a response, understands that communications will occur at full speed.\n</p>\n<h3>\n High-Speed Bus States\n</h3>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Bus State\n    </strong>\n</th>\n<th>\n<strong>\n     Data State\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     High-Speed Differential 0\n    </strong>\n</td>\n<td>\n<strong>\n     K\n    </strong>\n</td>\n</tr>\n<tr>\n<td>\n<strong>\n     High-Speed Differential 1\n    </strong>\n</td>\n<td>\n<strong>\n     J\n    </strong>\n</td>\n</tr>\n</tbody>\n</table>\n"}, "Page 517": {"response": "<p>\n<strong>\n  High-Speed Bus States and Data Encoding\n </strong>\n</p>\n<h3>\n High-Speed Squelch State\n</h3>\n<p>\n The\n <strong>\n  High-speed Squelch\n </strong>\n state indicates an invalid signal. High-speed receivers are equipped with circuits that detect this state, which occurs when the differential bus voltage is\n <strong>\n  100 millivolts or less\n </strong>\n .\n</p>\n<h3>\n High-Speed Idle State\n</h3>\n<p>\n In the\n <strong>\n  High-speed Idle\n </strong>\n state, no high-speed drivers are active, and the low/full-speed drivers assert\n <strong>\n  Single-Ended Zeroes (SE0)\n </strong>\n . Both\n <strong>\n  D+\n </strong>\n and\n <strong>\n  D-\n </strong>\n are held within a voltage range of\n <strong>\n  -10 to +10 millivolts\n </strong>\n .\n</p>\n<h3>\n Start of High-Speed Packet\n</h3>\n<p>\n The\n <strong>\n  Start of High-speed Packet (HSSOP)\n </strong>\n occurs when the bus transitions from the\n <strong>\n  High-speed Idle\n </strong>\n state to the\n <strong>\n  High-speed Data K\n </strong>\n state. Every high-speed packet transmission begins with this state.\n</p>\n<h3>\n End of High-Speed Packet\n</h3>\n<p>\n The\n <strong>\n  End of High-speed Packet (HSEOP)\n </strong>\n is when the bus transitions from the\n <strong>\n  High-speed Data K\n </strong>\n or\n <strong>\n  Data J\n </strong>\n state back to the\n <strong>\n  High-speed Idle\n </strong>\n state. Every high-speed packet ends with this transition.\n</p>\n<h3>\n High-Speed Disconnect\n</h3>\n<p>\n When a high-speed device is removed from the bus, its high-speed line terminations are also removed. The removal of these terminations causes the differential voltage at the hub to double. If the differential voltage reaches\n <strong>\n  625 millivolts or more\n </strong>\n , this indicates the\n <strong>\n  High-speed Disconnect\n </strong>\n state. A\n <strong>\n  2.0 hub\n </strong>\n detects this voltage change through its built-in circuits.\n</p>\n<h3>\n Data Encoding: NRZI with Bit Stuffing\n</h3>\n<p>\n All data on the USB bus is encoded using the\n <strong>\n  Non-Return to Zero Inverted (NRZI)\n </strong>\n encoding format with\n <strong>\n  bit stuffing\n </strong>\n . This method ensures that the receiver stays synchronized with the transmitter without needing to send a separate clock signal or\n <strong>\n  Start\n </strong>\n and\n <strong>\n  Stop\n </strong>\n bits for each byte.\n</p>\n"}, "Page 518": {"response": "<p>\n<strong>\n  USB Data Encoding: NRZI and Bit Stuffing\n </strong>\n</p>\n<h3>\n NRZI Encoding\n</h3>\n<p>\n USB uses\n <strong>\n  Non-Return to Zero Inverted (NRZI)\n </strong>\n encoding, which differs from simpler voltage-based methods of defining logic levels. In NRZI:\n</p>\n<ul>\n<li>\n<strong>\n   Logic 0\n  </strong>\n  : This is represented by a\n  <strong>\n   voltage change\n  </strong>\n  from the previous state.\n </li>\n<li>\n<strong>\n   Logic 1\n  </strong>\n  : This is represented by\n  <strong>\n   no change\n  </strong>\n  in the voltage.\n </li>\n</ul>\n<p>\n The\n <strong>\n  least-significant bit (LSB)\n </strong>\n is transmitted first. This type of encoding makes it harder to directly interpret the data on an oscilloscope or logic analyzer, as the voltage levels do not directly represent logic 0s and 1s.\n</p>\n<h3>\n Bit Stuffing\n</h3>\n<p>\n In addition to NRZI encoding, USB uses\n <strong>\n  bit stuffing\n </strong>\n . This involves adding a\n <strong>\n  0\n </strong>\n after every sequence of six consecutive\n <strong>\n  1s\n </strong>\n to maintain proper synchronization.\n</p>\n<h3>\n Viewing USB Data\n</h3>\n<p>\n If you use an oscilloscope or logic analyzer to view USB data on the bus, interpreting the individual bits is not as straightforward as matching voltage levels to logic values. Fortunately, USB hardware handles the encoding and decoding automatically, so developers and programmers don't need to manage these details. To interpret USB data on an oscilloscope or logic analyzer, a\n <strong>\n  protocol analyzer\n </strong>\n is used to decode the data for easy reading, as explained in Chapter 17.\n</p>\n<h3>\n Example: NRZI Encoding\n</h3>\n<p>\n In\n <strong>\n  NRZI encoding\n </strong>\n :\n</p>\n<ul>\n<li>\n  A\n  <strong>\n   logic 0\n  </strong>\n  causes a voltage change.\n </li>\n<li>\n  A\n  <strong>\n   logic 1\n  </strong>\n  causes no change.\n </li>\n</ul>\n<p>\n Bit stuffing adds a\n <strong>\n  0\n </strong>\n after six consecutive\n <strong>\n  1s\n </strong>\n to ensure the bus remains synchronized.\n</p>\n"}, "Page 519": {"response": "<p>\n<strong>\n  Staying Synchronized in USB Communication\n </strong>\n</p>\n<h3>\n Synchronization Challenges\n</h3>\n<p>\n When two devices communicate, the receiving device must be able to detect when each bit is ready to be read. In interfaces like\n <strong>\n  RS-232\n </strong>\n , both the transmitter and receiver have separate clocks and must agree on a common\n <strong>\n  bit rate\n </strong>\n . Communication starts with a\n <strong>\n  Start bit\n </strong>\n that transitions from the\n <strong>\n  Idle state\n </strong>\n , allowing the receiver to synchronize to this transition and use the timing to read bits at the correct moments. A\n <strong>\n  Stop bit\n </strong>\n ends each word, returning the link to the Idle state.\n</p>\n<p>\n However, if the clocks of the transmitter and receiver differ slightly (within a few percent), the receiver can still read several bits before resynchronizing. Despite this, adding a\n <strong>\n  Start\n </strong>\n and\n <strong>\n  Stop bit\n </strong>\n to every data byte adds\n <strong>\n  25% overhead\n </strong>\n to the transmission. For example, a\n <strong>\n  9600-bps link\n </strong>\n with 8 data bits and one Start and Stop bit only transmits\n <strong>\n  7680 data bits (960 bytes)\n </strong>\n per second.\n</p>\n<h3>\n Clock Signal Methods\n</h3>\n<p>\n Interfaces like\n <strong>\n  SPI\n </strong>\n ,\n <strong>\n  I2C\n </strong>\n , and\n <strong>\n  Microwire\n </strong>\n use an additional clock signal to synchronize data transmission. The receiver detects data bits based on the clock's rising or falling edge, or its logic level. While this method ensures synchronization, it requires an extra signal line, and noise on the clock line can cause data errors.\n</p>\n<h3>\n USB Synchronization with NRZI Encoding\n</h3>\n<p>\n Unlike other protocols,\n <strong>\n  USB\n </strong>\n does not require a clock line or Start and Stop bits. Instead, USB uses\n <strong>\n  NRZI encoding\n </strong>\n and two techniques to maintain synchronization during communication:\n <strong>\n  bit stuffing\n </strong>\n and\n <strong>\n  SYNC fields\n </strong>\n . Although these methods introduce a small overhead, the impact is minimal, especially with large data packets.\n</p>\n<h3>\n Bit Stuffing\n</h3>\n<p>\n<strong>\n  Bit stuffing\n </strong>\n is used to ensure synchronization because the receiver relies on\n <strong>\n  transitions\n </strong>\n in the signal. If the data consists entirely of\n <strong>\n  0s\n </strong>\n , there are plenty of transitions. However, if the data contains a long sequence of\n <strong>\n  1s\n </strong>\n , there could be no transitions, which would cause the receiver to lose synchronization.\n</p>\n<p>\n To address this, if there are\n <strong>\n  six consecutive 1s\n </strong>\n , the transmitter inserts a\n <strong>\n  0\n </strong>\n (a transition) after the sixth\n <strong>\n  1\n </strong>\n . This guarantees that there is at least one transition for every\n <strong>\n  seven bit widths\n </strong>\n . The receiver detects these transitions and discards the stuffed\n <strong>\n  0\n </strong>\n , maintaining synchronization throughout the communication.\n</p>\n"}, "Page 520": {"response": "<p>\n<strong>\n  Bit Stuffing and SYNC Fields in USB Communication\n </strong>\n</p>\n<h3>\n Bit Stuffing Overhead\n</h3>\n<p>\n<strong>\n  Bit stuffing\n </strong>\n ensures that the receiver stays synchronized with the transmitter by adding a\n <strong>\n  0\n </strong>\n after every six consecutive\n <strong>\n  1s\n </strong>\n in the data stream. This extra\n <strong>\n  0\n </strong>\n guarantees that there will always be a transition for synchronization. While bit stuffing can increase the number of transmitted bits by up to\n <strong>\n  17%\n </strong>\n , the actual average increase is typically much lower, around\n <strong>\n  0.8%\n </strong>\n . This translates to approximately\n <strong>\n  one stuffed bit\n </strong>\n for every\n <strong>\n  125 data bits\n </strong>\n .\n</p>\n<h3>\n SYNC Field for Synchronization\n</h3>\n<p>\n While bit stuffing helps maintain synchronization, it alone isn\u2019t enough to keep the transmitting and receiving clocks perfectly aligned. Since USB devices and hosts don\u2019t share a clock, the receiving device doesn\u2019t know exactly when the transmitting device will start sending the first bit of a packet. A\n <strong>\n  single transition\n </strong>\n isn\u2019t sufficient to ensure the receiver stays synchronized throughout the packet.\n</p>\n<p>\n To address this, each USB packet begins with a\n <strong>\n  SYNC field\n </strong>\n . This field helps the receiving device synchronize its clock with the data transmission. The SYNC field serves as a reference point for the receiver, ensuring it knows when to expect the upcoming bits in the packet.\n</p>\n<ul>\n<li>\n<p>\n   For\n   <strong>\n    low-speed\n   </strong>\n   and\n   <strong>\n    full-speed\n   </strong>\n   communication, the SYNC field is\n   <strong>\n    8 bits long\n   </strong>\n   and follows the pattern:\n   <strong>\n    KJKJKJKK\n   </strong>\n   .\n  </p>\n<ul>\n<li>\n    The transition from\n    <strong>\n     Idle\n    </strong>\n    to the first\n    <strong>\n     K\n    </strong>\n    in the pattern acts as a kind of\n    <strong>\n     Start bit\n    </strong>\n    , signaling the start of a new packet.\n   </li>\n<li>\n    There\u2019s only\n    <strong>\n     one SYNC field per packet\n    </strong>\n    , unlike the Start bit that appears for each byte.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n   For\n   <strong>\n    high-speed\n   </strong>\n   communication, the SYNC field is\n   <strong>\n    32 bits long\n   </strong>\n   , consisting of\n   <strong>\n    fifteen repetitions of KJ\n   </strong>\n   , followed by\n   <strong>\n    KK\n   </strong>\n   . A high-speed hub may skip up to\n   <strong>\n    four bits\n   </strong>\n   when repeating the packet, so the SYNC field could be as short as\n   <strong>\n    12 bits\n   </strong>\n   when passed through five hubs.\n  </p>\n</li>\n</ul>\n<p>\n The alternating\n <strong>\n  Ks\n </strong>\n and\n <strong>\n  Js\n </strong>\n in the SYNC field provide the transitions required for synchronization. The last two\n <strong>\n  Ks\n </strong>\n mark the end of the SYNC field. By the time the SYNC pattern finishes, the receiver can precisely align its clock to the incoming data, ensuring it reads each bit at the correct time.\n</p>\n<p>\n However, the cost of this synchronization is the addition of\n <strong>\n  8 to 32 bit times\n </strong>\n to the total packet length. This overhead means that\n <strong>\n  large packets\n </strong>\n are more efficient than smaller ones, as the overhead becomes a smaller percentage of the total packet size.\n</p>\n<h3>\n End of Packet\n</h3>\n<p>\n When a packet is finished, an\n <strong>\n  End-of-Packet\n </strong>\n signal is sent to return the bus to the\n <strong>\n  Idle\n </strong>\n state, preparing for the next packet and its corresponding SYNC field. The\n <strong>\n  End-of-Packet\n </strong>\n signal differs between\n <strong>\n  low/full-speed\n </strong>\n and\n <strong>\n  high-speed\n </strong>\n communication.\n</p>\n"}, "Page 521": {"response": "<p>\n<strong>\n  End of Packet and Timing Accuracy in USB Communication\n </strong>\n</p>\n<h3>\n End of Packet for Low, Full, and High-Speed\n</h3>\n<ul>\n<li>\n<p>\n<strong>\n    Low and Full-Speed End of Packet\n   </strong>\n   :\nThe end of a packet in low and full-speed communication is marked by a\n   <strong>\n    Single-Ended-Zero\n   </strong>\n   (SE0) that lasts for\n   <strong>\n    two bit widths\n   </strong>\n   . This simple signal indicates that the packet has been transmitted.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    High-Speed End of Packet\n   </strong>\n   :\nFor high-speed communication, the\n   <strong>\n    End of High-speed Packet\n   </strong>\n   signal is more complex. High-speed receivers treat any bit-stuff error as an End of Packet. Therefore, to signal the end of a packet, a special pattern is used:\n  </p>\n<ul>\n<li>\n<p>\n     For most high-speed packets (except Start-of-Frame), the End of Packet is a\n     <strong>\n      byte of 01111111\n     </strong>\n     , without bit stuffing. If the preceding bit was a\n     <strong>\n      J\n     </strong>\n     , the End of Packet is represented as\n     <strong>\n      KKKKKKKK\n     </strong>\n     . The first\n     <strong>\n      0\n     </strong>\n     changes the state from\n     <strong>\n      J\n     </strong>\n     to\n     <strong>\n      K\n     </strong>\n     , and the following\n     <strong>\n      1s\n     </strong>\n     ensure no change in the remaining bits.\n    </p>\n</li>\n<li>\n<p>\n     If the preceding bit was a\n     <strong>\n      K\n     </strong>\n     , the End of Packet is represented as\n     <strong>\n      JJJJJJJJ\n     </strong>\n     . Again, the first\n     <strong>\n      0\n     </strong>\n     switches the state from\n     <strong>\n      K\n     </strong>\n     to\n     <strong>\n      J\n     </strong>\n     , with the remaining\n     <strong>\n      1s\n     </strong>\n     causing no further change. The sequence of\n     <strong>\n      seven 1s\n     </strong>\n     in this encoding will cause a bit-stuff error, which the receiver interprets as the End of Packet.\n    </p>\n</li>\n<li>\n<p>\n<strong>\n      Start-of-Frame Packets\n     </strong>\n     : For high-speed Start-of-Frame packets, the End of Packet is\n     <strong>\n      40 bits long\n     </strong>\n     , allowing the hub time to detect a\n     <strong>\n      doubled differential voltage\n     </strong>\n     , which signals that a device has been disconnected from the bus. This encoded byte begins with a\n     <strong>\n      0\n     </strong>\n     , followed by\n     <strong>\n      39 ones\n     </strong>\n     , resulting in\n     <strong>\n      40 Js or Ks\n     </strong>\n     . Like other high-speed packets, this sequence causes a bit-stuff error treated as the End of Packet.\n    </p>\n</li>\n</ul>\n</li>\n</ul>\n<h3>\n Timing Accuracy in USB\n</h3>\n<p>\n As USB speeds increase, the\n <strong>\n  timing requirements\n </strong>\n become more stringent:\n</p>\n<ul>\n<li>\n<strong>\n   High-Speed\n  </strong>\n  has the most critical timing requirements.\n </li>\n<li>\n<strong>\n   Full-Speed\n  </strong>\n  follows, with slightly less stringent timing.\n </li>\n<li>\n<strong>\n   Low-Speed\n  </strong>\n  has the most tolerance for timing variations.\n </li>\n</ul>\n<p>\n USB devices often derive their timing from a\n <strong>\n  crystal oscillator\n </strong>\n . Several factors can affect the accuracy of a crystal\u2019s frequency, including:\n</p>\n<ul>\n<li>\n<strong>\n   Initial accuracy\n  </strong>\n  of the crystal\n </li>\n<li>\n<strong>\n   Capacitive loading\n  </strong>\n</li>\n<li>\n<strong>\n   Crystal aging\n  </strong>\n</li>\n<li>\n<strong>\n   Supply voltage fluctuations\n  </strong>\n</li>\n<li>\n<strong>\n   Temperature variations\n  </strong>\n</li>\n</ul>\n<p>\n Crystal accuracy is typically measured in\n <strong>\n  parts per million (ppm)\n </strong>\n , indicating the number of cycles the crystal may vary in the time it takes for\n <strong>\n  1 million cycles\n </strong>\n at its rated frequency. This measure helps quantify the potential timing deviations a device may experience during communication.\n</p>\n"}, "Page 522": {"response": "<p>\n<strong>\n  Timing Accuracy and Packet Format in USB Communication\n </strong>\n</p>\n<h3>\n Timing Accuracy for USB Speeds\n</h3>\n<p>\n USB communication speeds have strict requirements for timing accuracy:\n</p>\n<ul>\n<li>\n<strong>\n   High-speed (480 Mbps)\n  </strong>\n  : The bit rate can vary by no more than\n  <strong>\n   0.05%\n  </strong>\n  , or\n  <strong>\n   500 parts per million (ppm)\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Full-speed (12 Mbps)\n  </strong>\n  : The bit rate can vary by no more than\n  <strong>\n   0.25%\n  </strong>\n  , or\n  <strong>\n   2500 ppm\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Low-speed (1.5 Mbps)\n  </strong>\n  : The bit rate can vary by up to\n  <strong>\n   1.5%\n  </strong>\n  , or\n  <strong>\n   15,000 ppm\n  </strong>\n  . This wider tolerance allows low-speed devices to use less expensive ceramic resonators instead of more precise quartz crystals.\n </li>\n</ul>\n<p>\n The\n <strong>\n  host\n </strong>\n or\n <strong>\n  2.0 hub\n </strong>\n must maintain an accuracy of\n <strong>\n  0.05%\n </strong>\n (500 ppm) for the data rate across all speeds. Additionally, the\n <strong>\n  frame intervals\n </strong>\n (the time between frame transmissions) must be accurate to\n <strong>\n  1 millisecond \u00b1500 nanoseconds per frame\n </strong>\n , or\n <strong>\n  125.0 \u00b162.5 microseconds per microframe\n </strong>\n . To maintain this accuracy,\n <strong>\n  hubs\n </strong>\n adjust their frame intervals to synchronize with the host\u2019s\n <strong>\n  Start-of-Frame signals\n </strong>\n .\n</p>\n<p>\n The USB specification also defines limits for\n <strong>\n  data jitter\n </strong>\n , which accounts for small variations in the timing of individual bit transitions. These limits allow for minor differences in the rise and fall times of drivers, as well as clock jitter and random noise.\n</p>\n<h3>\n USB Packet Format and Fields\n</h3>\n<p>\n All USB data is transmitted in\n <strong>\n  packets\n </strong>\n , which are structured blocks of information. These packets are composed of various\n <strong>\n  fields\n </strong>\n , each holding a specific type of information. Below is an overview of the\n <strong>\n  SYNC field\n </strong>\n and its purpose in the packet structure:\n</p>\n<ul>\n<li>\n<strong>\n   SYNC Field\n  </strong>\n  :\n  <ul>\n<li>\n    Every packet begins with an\n    <strong>\n     8-bit SYNC field\n    </strong>\n    .\n   </li>\n<li>\n    The SYNC field serves as the\n    <strong>\n     Start-of-Packet delimiter\n    </strong>\n    , marking the beginning of the data transmission.\n   </li>\n</ul>\n</li>\n</ul>\n"}, "Page 523": {"response": "<h3>\n USB Packet Fields Overview\n</h3>\n<p>\n USB communication packets consist of several fields, each with a specific purpose. These fields help identify the packet type, the device and endpoint being addressed, and ensure data integrity. Here's a breakdown of the key fields in USB packets:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Packet Identifier (PID)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Size\n    </strong>\n    : 8 bits\n   </li>\n<li>\n    The\n    <strong>\n     PID\n    </strong>\n    field identifies the type of packet being transmitted.\n    <ul>\n<li>\n      Bits 0 through 3 identify the packet type (e.g., token, data, handshake, or special).\n     </li>\n<li>\n      Bits 4 through 7 contain the\n      <strong>\n       one's complement\n      </strong>\n      of bits 0-3 for error checking.\n     </li>\n</ul>\n</li>\n<li>\n    There are 16 defined PID codes, which help differentiate between various packet types. The lower two bits identify the PID category, and the upper two bits specify the individual PID.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Address\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Size\n    </strong>\n    : 7 bits\n   </li>\n<li>\n    This field identifies which device the host is communicating with. It is used in\n    <strong>\n     IN, OUT,\n    </strong>\n    and\n    <strong>\n     Setup\n    </strong>\n    packets to target the correct device.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Endpoint\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Size\n    </strong>\n    : 4 bits\n   </li>\n<li>\n    This field identifies the specific endpoint within the device for communication. Like the\n    <strong>\n     Address\n    </strong>\n    field, it is used in\n    <strong>\n     IN, OUT,\n    </strong>\n    and\n    <strong>\n     Setup\n    </strong>\n    packets to direct the data to the right endpoint.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Frame Number\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Size\n    </strong>\n    : 11 bits\n   </li>\n<li>\n    Used in\n    <strong>\n     Start-of-Frame (SOF)\n    </strong>\n    packets, this field indicates the frame number for synchronization and timing of data transfers.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Data\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Size\n    </strong>\n    : Varies (0 to 8192 bits or 1024 bytes for USB 2.0, or 8184 bits/1023 bytes for USB 1.x hardware)\n   </li>\n<li>\n    This field carries the actual data being transferred. It can vary in size depending on the type of packet, and the hardware version being used. The data is divided into two categories:\n    <ul>\n<li>\n<strong>\n       Data0\n      </strong>\n      and\n      <strong>\n       Data1\n      </strong>\n      : These represent different data sequences used for data transmission.\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    CRC\n   </strong>\n   (Cyclic Redundancy Check):\n  </p>\n<ul>\n<li>\n<strong>\n     Size\n    </strong>\n    : 5 or 16 bits\n   </li>\n<li>\n    This field is used in\n    <strong>\n     IN, OUT, Setup, Data0,\n    </strong>\n    and\n    <strong>\n     Data1\n    </strong>\n    packets to detect errors in the transmitted data. It ensures data integrity by checking if any errors have occurred during the packet transfer.\n   </li>\n</ul>\n</li>\n</ol>\n<h3>\n Summary of USB Packet Fields\n</h3>\n<p>\n Each field within a USB packet serves a specific function, from identifying the packet type to ensuring error-free data transmission. Here's a quick reference to the field types:\n</p>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Field Name\n    </strong>\n</th>\n<th>\n<strong>\n     Size (bits)\n    </strong>\n</th>\n<th>\n<strong>\n     Packet Types\n    </strong>\n</th>\n<th>\n<strong>\n     Purpose\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     SYNC\n    </strong>\n</td>\n<td>\n    8\n   </td>\n<td>\n    All\n   </td>\n<td>\n    Start-of-packet and synchronization\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     PID\n    </strong>\n</td>\n<td>\n    8\n   </td>\n<td>\n    All\n   </td>\n<td>\n    Identify the packet type\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Address\n    </strong>\n</td>\n<td>\n    7\n   </td>\n<td>\n    IN, OUT, Setup\n   </td>\n<td>\n    Identify the function address\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Endpoint\n    </strong>\n</td>\n<td>\n    4\n   </td>\n<td>\n    IN, OUT, Setup\n   </td>\n<td>\n    Identify the endpoint\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Frame Number\n    </strong>\n</td>\n<td>\n    11\n   </td>\n<td>\n    SOF\n   </td>\n<td>\n    Identify the frame\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Data\n    </strong>\n</td>\n<td>\n    0 to 8192\n   </td>\n<td>\n    Data0, Data1\n   </td>\n<td>\n    Data content\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     CRC\n    </strong>\n</td>\n<td>\n    5 or 16\n   </td>\n<td>\n    IN, OUT, Setup, Data0, Data1\n   </td>\n<td>\n    Detect errors\n   </td>\n</tr>\n</tbody>\n</table>\n"}, "Page 524": {"response": "<h3>\n USB Packet Details: Frame Numbers, Data, CRC, and Inter-Packet Delay\n</h3>\n<p>\n USB packets are structured to ensure data is transmitted correctly and efficiently. Below is a detailed explanation of key elements such as frame numbers, data fields, CRC, and inter-packet delays.\n</p>\n<h4>\n<strong>\n  Frame Number\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   Size\n  </strong>\n  : 11 bits for full-speed, 14 bits for high-speed.\n </li>\n<li>\n  The\n  <strong>\n   Frame Number\n  </strong>\n  identifies the specific frame in which data is being transmitted. This number is included in the\n  <strong>\n   Start-of-Frame (SOF)\n  </strong>\n  packet sent at the beginning of each frame or microframe.\n </li>\n<li>\n  For\n  <strong>\n   full-speed\n  </strong>\n  hosts, an 11-bit counter increments every frame, with a maximum value of\n  <strong>\n   07FFh\n  </strong>\n  (2047), which then rolls over to zero.\n </li>\n<li>\n  For\n  <strong>\n   high-speed\n  </strong>\n  hosts, a 14-bit counter is used, with increments occurring every microframe. The frame number field only transmits bits\n  <strong>\n   3-13\n  </strong>\n  of the microframe counter. This means that for high-speed communication, eight microframes share the same frame number.\n </li>\n</ul>\n<h4>\n<strong>\n  Data Field\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   Size\n  </strong>\n  : 0 to 1024 bytes, depending on the transfer type, bus speed, and data amount.\n </li>\n<li>\n  The\n  <strong>\n   Data Field\n  </strong>\n  holds the actual data being transferred within the packet. The size of this field varies:\n  <ul>\n<li>\n    For\n    <strong>\n     low/full-speed\n    </strong>\n    communication, the data field can hold fewer bytes compared to\n    <strong>\n     high-speed\n    </strong>\n    where larger data fields are transmitted.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n<strong>\n  CRC (Cyclic Redundancy Check)\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   Size\n  </strong>\n  : 5 bits for address and endpoint fields, 16 bits for data fields.\n </li>\n<li>\n  The\n  <strong>\n   CRC Field\n  </strong>\n  is crucial for error-checking during data transmission. It ensures the integrity of the packet by allowing the receiver to check for transmission errors.\n </li>\n<li>\n  The CRC bits are typically inserted by the transmitting hardware, and the receiving hardware calculates and verifies them. This process is automatic, so software does not need to manually handle CRC calculations.\n </li>\n</ul>\n<h4>\n<strong>\n  Inter-packet Delay\n </strong>\n</h4>\n<ul>\n<li>\n  USB communication transmits data in both directions on a single pair of wires, but only one direction can be active at a time. This requires a brief delay between packets to ensure that the previous device has turned off its transmitter before the next packet starts.\n </li>\n<li>\n  The USB specification defines specific delay times based on the bus speed:\n  <ul>\n<li>\n<strong>\n     Low/Full Speed\n    </strong>\n    : The delay ensures proper signal switching, but the duration is relatively short.\n   </li>\n<li>\n<strong>\n     High Speed\n    </strong>\n    : The delay is even shorter, allowing faster communication.\n   </li>\n</ul>\n</li>\n<li>\n  These delays are handled by hardware automatically, and developers do not need to manage them in code.\n </li>\n</ul>\n<h3>\n Summary of Key Packet Details\n</h3>\n<table>\n<thead>\n<tr>\n<th>\n<strong>\n     Field\n    </strong>\n</th>\n<th>\n<strong>\n     Size\n    </strong>\n</th>\n<th>\n<strong>\n     Purpose\n    </strong>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<strong>\n     Frame Number\n    </strong>\n</td>\n<td>\n    11 bits (full-speed), 14 bits (high-speed)\n   </td>\n<td>\n    Identifies the frame in which data is transmitted.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Data\n    </strong>\n</td>\n<td>\n    0-1024 bytes\n   </td>\n<td>\n    Holds the data being transferred.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     CRC\n    </strong>\n</td>\n<td>\n    5 bits (address, endpoint); 16 bits (data)\n   </td>\n<td>\n    Provides error checking for the packet.\n   </td>\n</tr>\n<tr>\n<td>\n<strong>\n     Inter-packet Delay\n    </strong>\n</td>\n<td>\n    N/A\n   </td>\n<td>\n    Brief delay between packets for proper signal switching.\n   </td>\n</tr>\n</tbody>\n</table>\n"}, "Page 525": {"response": "<h3>\n USB Test Modes: Compliance Testing\n</h3>\n<p>\n USB 2.0 defines five test modes for compliance testing. These modes help ensure that host controllers, hubs, and high-speed devices meet USB standards.\n</p>\n<h4>\n<strong>\n  Entering and Exiting Test Modes\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   Entering Test Mode\n  </strong>\n  :\n  <ul>\n<li>\n<strong>\n     Upstream-facing ports\n    </strong>\n    : Enter a test mode in response to a\n    <code>\n     Set_Feature\n    </code>\n    request with the\n    <code>\n     TEST_MODE\n    </code>\n    value in the wValue field.\n   </li>\n<li>\n<strong>\n     Downstream-facing ports\n    </strong>\n    : Enter a test mode in response to a\n    <code>\n     Set_Port_Feature\n    </code>\n    request with the\n    <code>\n     PORT_TEST\n    </code>\n    value in the wValue field.\n   </li>\n<li>\n    Both cases use the\n    <code>\n     wIndex\n    </code>\n    field to specify the port number and test number.\n   </li>\n<li>\n<strong>\n     Ports in the hub\n    </strong>\n    : All downstream ports must be in suspended, disabled, or disconnected states before entering a test mode.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Exiting Test Mode\n  </strong>\n  :\n  <ul>\n<li>\n<strong>\n     Upstream-facing ports\n    </strong>\n    : Exit test mode when the device powers down and back up.\n   </li>\n<li>\n<strong>\n     Downstream-facing ports\n    </strong>\n    : Exit test mode when the hub is reset.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n<strong>\n  The Five Test Modes\n </strong>\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Test_SEO_NAK\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Value\n    </strong>\n    : 01h\n   </li>\n<li>\n<strong>\n     Action\n    </strong>\n    : The transceiver enters high-speed receive mode and remains there. Upstream-facing ports respond to IN token packets with NAK (Negative Acknowledgment).\n   </li>\n<li>\n<strong>\n     Purpose\n    </strong>\n    : This mode is used to test output impedance, low-level output voltage, and loading characteristics. It also helps test the device\u2019s squelch-level circuits and provides a stimulus-response test for basic functionality.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Test_J\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Value\n    </strong>\n    : 02h\n   </li>\n<li>\n<strong>\n     Action\n    </strong>\n    : The transceiver enters and remains in the High-speed Data J state.\n   </li>\n<li>\n<strong>\n     Purpose\n    </strong>\n    : This mode helps to test how the device behaves in a particular data state, specifically in the High-speed Data J state. It is crucial for ensuring proper data handling and compliance with USB specifications.\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n These test modes are part of the USB compliance process, ensuring that devices and hubs conform to the USB standard and can communicate effectively with one another.\n</p>\n"}, "Page 526": {"response": "<h3>\n USB Test Modes: Continued\n</h3>\n<p>\n The USB 2.0 specification includes several test modes for compliance and diagnostics, which help ensure that USB devices and hubs meet the required standards for performance and functionality. Here\u2019s a breakdown of the remaining test modes.\n</p>\n<h4>\n<strong>\n  Test Modes\n </strong>\n</h4>\n<ol start=\"3\">\n<li>\n<p>\n<strong>\n    Test_K\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Value\n    </strong>\n    : 03h\n   </li>\n<li>\n<strong>\n     Action\n    </strong>\n    : The transceiver enters and remains in the High-speed Data K state.\n   </li>\n<li>\n<strong>\n     Purpose\n    </strong>\n    : This mode is used to test the high output drive level on the D- line. It ensures that the device is capable of driving the D- line at the correct level.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Test_Packet\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Value\n    </strong>\n    : 04h\n   </li>\n<li>\n<strong>\n     Action\n    </strong>\n    : This mode repeatedly transmits a test packet, as defined by the USB specification.\n   </li>\n<li>\n<strong>\n     Purpose\n    </strong>\n    : The goal of this test is to examine the rise and fall times of the signal, eye patterns, jitter, and other dynamic waveform characteristics to ensure data integrity and transmission quality.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Test_Force_Enable\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Value\n    </strong>\n    : 05h\n   </li>\n<li>\n<strong>\n     Action\n    </strong>\n    : This mode enables downstream-facing hub ports to operate in high-speed mode. Any packets received by the upstream-facing port are then repeated at the tested downstream port.\n   </li>\n<li>\n<strong>\n     Purpose\n    </strong>\n    : It is primarily used to measure the disconnect-detection threshold by varying the load on the port and monitoring the disconnect-detect bit.\n   </li>\n</ul>\n</li>\n</ol>\n<h4>\n<strong>\n  Reserved and Vendor-Defined Test Modes\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   Test-mode values 06h through 3Fh\n  </strong>\n  : These values are reserved for future standard tests in the USB specification.\n </li>\n<li>\n<strong>\n   Test-mode values C0h through FFh\n  </strong>\n  : These values are available for vendor-defined tests, allowing manufacturers to implement their custom test routines.\n </li>\n<li>\n<strong>\n   Other Values\n  </strong>\n  : All values outside these ranges are reserved for future use or manufacturer-specific implementations.\n </li>\n</ul>\n<p>\n These test modes help maintain USB compliance, ensuring that devices perform correctly under different conditions and meet the technical requirements of the USB specification.\n</p>\n"}, "Page 527": {"response": "<p>\n It seems like the content from \"Chapter 18\" is empty or not provided. Could you please provide the specific text you'd like me to summarize or explain? I'd be happy to help!\n</p>\n"}, "Page 528": {"response": "<h3>\n The Electrical Interface\n</h3>\n<p>\n The electrical interface is a crucial element that ensures the signals in a USB system are transmitted properly. Without it, all the protocols and program code would be ineffective if the signals aren't correctly transmitted down the cable. This section focuses on the electrical interface, explaining its importance in making USB a reliable communication method.\n</p>\n<p>\n For most users who are utilizing compliant cables and components, there isn't a need to delve into the specifics of the electrical interface. However, for those designing USB transceivers, cables, printed-circuit boards with USB interfaces, or protocol analyzers that need to monitor the bus without interference, understanding the electrical interface is essential.\n</p>\n<p>\n This chapter provides the key concepts about the USB electrical interface, including the roles of drivers and receivers and insights into the cables used for signal transmission.\n</p>\n"}, "Page 529": {"response": "<h3>\n Transceivers and Signals\n</h3>\n<p>\n The electrical properties of signals on a USB cable differ depending on the speed of the cable segment. Low-speed, full-speed, and high-speed signaling each have distinct characteristics, including edge rate, which is a measure of how fast the voltage rises and falls on the data lines. This impacts how quickly an output switches. Additionally, the transceivers and circuits responsible for generating and detecting these signals also vary depending on the speed.\n</p>\n<p>\n At any USB speed, the components connecting to the USB cable must be durable enough to handle situations where any line may be shorted to another line or the cable shield without being damaged.\n</p>\n<h3>\n Cable Segments\n</h3>\n<p>\n A cable segment refers to a single physical cable that connects a device (like a hub) to an upstream hub (which could be the root hub on the host). The speed, edge rate, and polarity of the data in a segment depend on whether the segment operates at low-speed, full-speed, or high-speed. Below is an overview of each type of segment:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Low-speed Segments\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    These segments are only used between low-speed devices and their corresponding hubs.\n   </li>\n<li>\n    A low-speed segment carries data at the low-speed edge rate and uses inverted polarity compared to full speed.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Full-speed Segments\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    A full-speed segment exists when the downstream device operates at full speed, and it can be connected to a 1.x or 2.0 hub (including the root hub).\n   </li>\n<li>\n    If the downstream device is a hub, this segment may also carry low-speed data for devices downstream from that hub.\n   </li>\n<li>\n    In such cases, the low-speed data on the full-speed segment uses low-speed\u2019s bit rate but adopts full-speed's polarity and edge rate. The hub in this case is responsible for converting between low and full speed\u2019s edge rates and polarities.\n   </li>\n<li>\n    Full-speed segments cannot carry high-speed data. If a high-speed-capable device is connected to a 1.x hub, the communication will occur at full speed, though high-speed devices must at least respond to enumeration requests at full speed.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    High-speed Segments\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    High-speed segments are only used when the host supports USB 2.0, all upstream devices are 2.0 hubs, and the downstream device operates at high speed.\n   </li>\n</ul>\n</li>\n</ol>\n<p>\n Each speed (low, full, high) influences the transmission characteristics of the signals on the USB cable, and different transceivers are used to handle the varying electrical properties.\n</p>\n"}, "Page 530": {"response": "<h3>\n The Electrical Interface: Cable Segments and Speed\n</h3>\n<p>\n A\n <strong>\n  high-speed segment\n </strong>\n is only active when both the host and upstream hubs are USB 2.0 compliant, and the downstream device also operates at high-speed. In cases where the downstream device is a hub, the segment can also facilitate data transfer to and from low- or full-speed devices that are connected downstream from that hub. All data transmitted within a high-speed segment moves at high-speed rates, and the transaction translator in the downstream hub ensures proper conversion between low/full-speed and high-speed data as necessary.\n</p>\n<p>\n This arrangement allows devices operating at different speeds (low, full, or high) to coexist on the same bus, with hubs facilitating the conversion between the different speeds and ensuring smooth communication across the USB network.\n</p>\n<h3>\n Key Point:\n</h3>\n<ul>\n<li>\n<strong>\n   High-speed segments\n  </strong>\n  carry only high-speed data. A\n  <strong>\n   downstream hub\n  </strong>\n  facilitates data conversion when low- or full-speed devices are connected to it.\n </li>\n</ul>\n"}, "Page 531": {"response": "<h3>\n Low- and Full-Speed Transceivers\n</h3>\n<p>\n When devices are connected to a USB, they must initially communicate at low or full speed. However, high-speed-capable devices can switch from full-speed to high-speed communication during the high-speed handshake after attachment.\n</p>\n<h4>\n Key Differences Between Low and Full-Speed\n</h4>\n<p>\n Low-speed data differs from full-speed data in three key areas:\n</p>\n<ol>\n<li>\n<strong>\n   Bit Rate\n  </strong>\n  : Low-speed operates at 1.5 Megabits/sec, while full speed runs at 12 Megabits/sec.\n </li>\n<li>\n<strong>\n   Polarity\n  </strong>\n  : The polarity of low-speed data is inverted compared to full speed.\n </li>\n<li>\n<strong>\n   Edge Rate\n  </strong>\n  : Low-speed data has a slower edge rate, which refers to the speed at which the voltage changes.\n </li>\n</ol>\n<p>\n These differences affect how data is transmitted and how the transceivers are designed:\n</p>\n<ul>\n<li>\n<strong>\n   Slower Edge Rate\n  </strong>\n  : The reduced edge rate in low-speed communication reduces reflected voltages on the line. This allows low-speed cables to be less shielded and more flexible, making them cheaper to manufacture.\n </li>\n</ul>\n<p>\n The transceiver hardware itself does not concern itself with polarity; it simply retransmits whatever logic levels it receives. For drivers that handle both low and full speed (like those in hubs), the hardware must be able to switch between the different edge rates to accommodate both speeds.\n</p>\n<h3>\n In Summary:\n</h3>\n<ul>\n<li>\n<strong>\n   Low-speed\n  </strong>\n  communication has a slower bit rate, inverted polarity, and slower edge rate than\n  <strong>\n   full-speed\n  </strong>\n  .\n </li>\n<li>\n<strong>\n   Transceivers\n  </strong>\n  must support switching between different speeds and edge rates, particularly for devices like hubs that manage both low and full-speed traffic.\n </li>\n</ul>\n"}, "Page 532": {"response": "<h3>\n USB Port Circuits and Cable Segments\n</h3>\n<p>\n In USB systems, transceivers are responsible for sending and receiving data across the twisted pair of signal wires in the cable. These transceivers contain both a differential driver and receiver.\n</p>\n<h4>\n Differential Driver\n</h4>\n<p>\n The\n <strong>\n  differential driver\n </strong>\n has two outputs that are\n <strong>\n  180 degrees out of phase\n </strong>\n with each other. This means that when one output is high, the other is low. This configuration is used for transmitting data on the USB bus. A single driver can handle both low-speed and full-speed transmissions by adjusting the\n <strong>\n  edge rate\n </strong>\n (the speed at which the voltage levels change) using a control input.\n</p>\n<h4>\n Differential Receiver\n</h4>\n<p>\n The\n <strong>\n  differential receiver\n </strong>\n detects the\n <strong>\n  voltage difference\n </strong>\n between the two signal lines (D+ and D-). This receiver uses two inputs to determine the logic level based on the voltage difference. Unlike some other interfaces (e.g., RS-485), which only define logic levels based on voltage differences without referencing ground, USB receivers also require\n <strong>\n  absolute voltages\n </strong>\n in addition to the voltage difference for accurate detection. The receiver then outputs a\n <strong>\n  logic-high or logic-low voltage\n </strong>\n referenced to ground.\n</p>\n<h4>\n Single-Ended Receivers\n</h4>\n<p>\n Each port also has two\n <strong>\n  single-ended receivers\n </strong>\n that detect the voltages on D+ and D- lines with respect to the signal ground. These receivers help determine the speed of the bus (low or full speed) or whether the bus is in the\n <strong>\n  Single-Ended-Zero\n </strong>\n state.\n</p>\n<h4>\n Impedance and Termination\n</h4>\n<p>\n To ensure proper signal transmission and minimize reflections, each driver\u2019s output impedance, in combination with a\n <strong>\n  36-ohm series resistor\n </strong>\n at the output, acts as\n <strong>\n  source termination\n </strong>\n . These resistors may be\n <strong>\n  on-chip\n </strong>\n or external to the chip.\n</p>\n<h3>\n Pull-up and Pull-down Resistors\n</h3>\n<ul>\n<li>\n<strong>\n   Pull-up resistors\n  </strong>\n  : On a device\u2019s\n  <strong>\n   upstream-facing port\n  </strong>\n  , the pull-up resistor on either D+ or D- allows the hub to determine the device's speed.\n </li>\n<li>\n<strong>\n   Pull-down resistors\n  </strong>\n  : On the hub\u2019s\n  <strong>\n   downstream-facing port\n  </strong>\n  , pull-down resistors are connected to D+ and D-.\n </li>\n</ul>\n<p>\n For devices with detachable cables, the pull-up resistors must be connected to a\n <strong>\n  3.0\u20133.6V voltage source\n </strong>\n . Devices with\n <strong>\n  captive cables\n </strong>\n can instead use\n <strong>\n  internal pull-up resistors\n </strong>\n for the same purpose.\n</p>\n"}, "Page 533": {"response": "<h3>\n Downstream and Upstream Ports on USB Hubs\n</h3>\n<p>\n In a USB system,\n <strong>\n  downstream-facing ports\n </strong>\n on a\n <strong>\n  1.x hub\n </strong>\n must be able to support both\n <strong>\n  low\n </strong>\n and\n <strong>\n  full-speed\n </strong>\n devices, except in cases where the device has an embedded or permanently attached connection. These ports are capable of handling devices operating at either of these two speeds.\n</p>\n<p>\n On the other hand, a device\u2019s\n <strong>\n  upstream-facing port\n </strong>\n (which connects to the host or upstream hub) typically supports only\n <strong>\n  one speed\n </strong>\n . This means that while the downstream hub ports can manage multiple speeds, the upstream port usually operates at just one specific speed depending on the device's capability.\n</p>\n"}, "Page 534": {"response": "<h3>\n Pull-up and Pull-down Resistors for USB Termination\n</h3>\n<p>\n In USB designs, the\n <strong>\n  pull-up\n </strong>\n and\n <strong>\n  pull-down resistors\n </strong>\n are crucial for signaling and detecting device speeds. Devices with detachable cables typically connect pull-up resistors to a voltage source between\n <strong>\n  3.0V and 3.6V\n </strong>\n . For devices with captive cables, alternative termination methods, like connecting directly to\n <strong>\n  VBUS\n </strong>\n , may be used. However, if using alternative termination methods, the designer must ensure that all signal levels adhere to USB specification requirements.\n</p>\n<p>\n An\n <strong>\n  Engineering Change Notice (ECN)\n </strong>\n introduced adjustments to the tolerances for pull-up and pull-down resistors, allowing more flexibility in component design. The original values for pull-up and pull-down resistors were\n <strong>\n  1.5 k\u03a9 \u00b15%\n </strong>\n for pull-ups and\n <strong>\n  15 k\u03a9 \u00b15%\n </strong>\n for pull-downs. The new revisions loosen these tolerances to make it easier for manufacturers to include the resistors directly on the chip without the need for precise laser trimming.\n</p>\n<h3>\n New Tolerances\n</h3>\n<p>\n The updated tolerances make the design process slightly more complex, particularly for\n <strong>\n  upstream-facing ports\n </strong>\n , as the device must switch between two pull-up values depending on whether the bus is idle or active. Despite this added complexity, the revision lowers manufacturing costs. Devices that follow the original resistor tolerances will still be compliant and able to communicate with devices using the new values.\n</p>\n<p>\n The new pull-up and pull-down values have wider tolerances, allowing for up to\n <strong>\n  27%\n </strong>\n variance. For instance, pull-down resistors can now range from\n <strong>\n  19 k\u03a9 \u00b125%\n </strong>\n , and pull-up resistors can be\n <strong>\n  1200 \u03a9 and 2400 \u03a9 \u00b125%\n </strong>\n . To comply with the new tolerance limits, devices can use a\n <strong>\n  two-resistor setup\n </strong>\n , where one resistor is switched into the circuit when the upstream device begins transmitting. The switch must happen within\n <strong>\n  0.5 bit time\n </strong>\n of detecting a\n <strong>\n  J-to-K transition\n </strong>\n on the bus.\n</p>\n<p>\n Additionally, devices must switch to the higher resistance (when the bus is idle) to ensure the idle voltage is at least\n <strong>\n  2.7V\n </strong>\n . The system ensures that the data line stays in the correct high state even when the receiver interprets noise as a Start-of-Packet signal.\n</p>\n"}, "Page 535": {"response": "<h3>\n High-Speed Transceivers and 480 Megabits per Second\n</h3>\n<p>\n A\n <strong>\n  high-speed\n </strong>\n device, which operates at 480 Megabits per second, must be capable of handling\n <strong>\n  full-speed\n </strong>\n control requests as well. This means the device needs transceivers for both\n <strong>\n  full speed\n </strong>\n and\n <strong>\n  high speed\n </strong>\n , along with the logic to switch between them. However,\n <strong>\n  upstream transceivers\n </strong>\n in high-speed devices are not allowed to support\n <strong>\n  low speed\n </strong>\n . In external\n <strong>\n  USB 2.0 hubs\n </strong>\n , the\n <strong>\n  downstream transceivers\n </strong>\n at ports with user-accessible connectors must support all three speeds:\n <strong>\n  low\n </strong>\n ,\n <strong>\n  full\n </strong>\n , and\n <strong>\n  high speed\n </strong>\n .\n</p>\n<h4>\n Why 480 Megabits per Second?\n</h4>\n<p>\n The choice of\n <strong>\n  480 Megabits per second\n </strong>\n for\n <strong>\n  high-speed USB\n </strong>\n was made for several practical reasons:\n</p>\n<ol>\n<li>\n<strong>\n   Compatibility\n  </strong>\n  : The frequency is slow enough to be compatible with the same\n  <strong>\n   cables\n  </strong>\n  and\n  <strong>\n   connectors\n  </strong>\n  used for\n  <strong>\n   full-speed\n  </strong>\n  USB. This ensures consistency in hardware requirements across different speeds.\n </li>\n<li>\n<strong>\n   Cost-effective Components\n  </strong>\n  : This speed allows for the use of standard\n  <strong>\n   CMOS\n  </strong>\n  processes in components, which are simpler and less expensive compared to more advanced technologies used in high-speed digital signal processing.\n </li>\n<li>\n<strong>\n   Jitter Tolerance\n  </strong>\n  : Testing showed that high-speed drivers could tolerate\n  <strong>\n   20 to 30 percent jitter\n  </strong>\n  at 480 Megabits/sec.\n  <strong>\n   Receivers\n  </strong>\n  can be designed to handle up to\n  <strong>\n   40 percent jitter\n  </strong>\n  , offering a comfortable margin of error for high-speed transmission.\n </li>\n<li>\n<strong>\n   Crystal Compatibility\n  </strong>\n  :\n  <strong>\n   480 Megabits/sec.\n  </strong>\n  is an even multiple of\n  <strong>\n   12\n  </strong>\n  , meaning a single crystal oscillator can be used to support both full-speed (12 Megabits/sec) and high-speed (480 Megabits/sec) transmission, simplifying design and reducing costs.\n </li>\n</ol>\n<p>\n The use of\n <strong>\n  separate drivers\n </strong>\n for high-speed signals facilitates the integration of high-speed USB into existing systems. These drivers use\n <strong>\n  current-mode technology\n </strong>\n due to their speed and efficiency, making them ideal for high-speed data transmission.\n</p>\n"}, "Page 536": {"response": "<h3>\n High-Speed Transceiver Circuits\n</h3>\n<p>\n In\n <strong>\n  high-speed\n </strong>\n USB devices, specific\n <strong>\n  transceiver circuits\n </strong>\n are required to handle the higher data rates. These circuits differ from the ones used in lower-speed devices, as they must accommodate faster signaling.\n</p>\n<h4>\n Upstream-Facing Transceiver Circuits\n</h4>\n<p>\n As shown in\n <strong>\n  Figure 19-4\n </strong>\n , the\n <strong>\n  upstream-facing transceiver circuits\n </strong>\n in a high-speed-capable device must support both\n <strong>\n  full-speed\n </strong>\n and\n <strong>\n  high-speed\n </strong>\n communications. This is because\n <strong>\n  high-speed devices\n </strong>\n must still handle control requests at\n <strong>\n  full speed\n </strong>\n when initially connected. Therefore, the transceiver circuits must be designed to switch between these two speeds. For receiving data, a single receiver may be used, but high-speed devices require their own dedicated\n <strong>\n  drivers\n </strong>\n to ensure accurate and reliable signal transmission at higher data rates.\n</p>\n<h4>\n Downstream-Facing Transceiver Circuits in a Hub\n</h4>\n<p>\n Similarly, as depicted in\n <strong>\n  Figure 19-5\n </strong>\n ,\n <strong>\n  downstream-facing transceiver circuits\n </strong>\n in a\n <strong>\n  2.0 hub\n </strong>\n are responsible for supporting both\n <strong>\n  low-speed\n </strong>\n and\n <strong>\n  full-speed\n </strong>\n communications, as well as\n <strong>\n  high-speed\n </strong>\n when needed. These circuits need to manage data traffic across multiple devices that may operate at different speeds. The hub's circuits convert between various signal speeds and handle communication with multiple devices simultaneously.\n</p>\n<p>\n Thus, both\n <strong>\n  upstream\n </strong>\n and\n <strong>\n  downstream transceiver circuits\n </strong>\n are crucial for high-speed USB operation, ensuring that the system can support various speeds seamlessly.\n</p>\n"}, "Page 537": {"response": "<h3>\n Downstream-Facing Ports on External USB 2.0 Hubs\n</h3>\n<p>\n In USB 2.0 hubs, the\n <strong>\n  downstream-facing ports\n </strong>\n are the ones that connect to external devices. These ports are required to support all three USB speeds:\n <strong>\n  low-speed\n </strong>\n ,\n <strong>\n  full-speed\n </strong>\n , and\n <strong>\n  high-speed\n </strong>\n . However, there is an exception: ports that have\n <strong>\n  embedded\n </strong>\n or\n <strong>\n  permanently attached devices\n </strong>\n may not need to support all speeds.\n</p>\n<ul>\n<li>\n<strong>\n   Low-speed\n  </strong>\n  : 1.5 Mbps\n </li>\n<li>\n<strong>\n   Full-speed\n  </strong>\n  : 12 Mbps\n </li>\n<li>\n<strong>\n   High-speed\n  </strong>\n  : 480 Mbps\n </li>\n</ul>\n<p>\n This design ensures compatibility with a wide range of USB devices that operate at different speeds, from basic low-speed peripherals like keyboards and mice to high-speed devices like external storage drives.\n</p>\n<p>\n So, for external USB 2.0 hubs to function correctly, each downstream-facing port must be able to handle the appropriate communication speed for the device attached, except in the case of ports dedicated to permanently integrated devices.\n</p>\n"}, "Page 538": {"response": "<h3>\n The Electrical Interface of USB\n</h3>\n<p>\n USB transceivers need to handle different speeds, which means they must be able to manage both low/full-speed and high-speed signals, or they may use separate receivers for each speed type.\n</p>\n<ul>\n<li>\n<strong>\n   High-Speed Data Transmission\n  </strong>\n  : In high-speed USB, the driver sends data by driving one line with current, while keeping the other line at ground. There are two options for managing this current:\n  <ul>\n<li>\n<strong>\n     Always Active Current Source\n    </strong>\n    : This type of source is easier to design but uses more power because it remains active continuously.\n   </li>\n<li>\n<strong>\n     Transmitting-Only Current Source\n    </strong>\n    : This source is active only when transmitting data, but the USB specification requires strict signal-amplitude and timing compliance right from the first symbol in a packet. This makes designing a current source that only activates during transmission more complex.\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n To simplify this design challenge, USB devices often keep the current source active all the time. When not transmitting data, the current is directed to ground.\n</p>\n<h3>\n Impedance and Signal Termination\n</h3>\n<ul>\n<li>\n<p>\n<strong>\n    Impedance Differences\n   </strong>\n   : In high-speed-capable transceivers, the full-speed driver\u2019s output impedance needs to be more precise compared to full-speed-only drivers. For high-speed transceivers, the impedance tolerance is\n   <strong>\n    45 ohms \u00b110%\n   </strong>\n   , while for full-speed-only drivers, it\u2019s\n   <strong>\n    36 ohms \u00b122%\n   </strong>\n   . The high-speed bus uses full-speed drivers as\n   <strong>\n    electrical terminations\n   </strong>\n   on the cable, meaning the full-speed drivers play a key role in maintaining signal integrity.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Termination Method\n   </strong>\n   : When high-speed drivers are active, they pull both data lines low (Single-ended-Zero state). This acts as a\n   <strong>\n    45-ohm termination to ground\n   </strong>\n   . This termination occurs at both the source and the load ends of the cable, providing better signal quality than full-speed systems that only use series terminations at the source end.\n  </p>\n</li>\n</ul>\n<h3>\n Signal Integrity and Measurement\n</h3>\n<ul>\n<li>\n<p>\n<strong>\n    Eye Pattern Templates\n   </strong>\n   : The USB specification provides\n   <strong>\n    eye-pattern templates\n   </strong>\n   that detail the required high-speed transmitter outputs and receiver sensitivity. These templates help in ensuring that the signal remains clear and undistorted during transmission.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Receiver Sensitivity\n   </strong>\n   : High-speed receivers must meet stringent requirements. A\n   <strong>\n    differential time-domain reflectometer (TDR)\n   </strong>\n   is used to measure impedance characteristics accurately.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Differential Envelope Detector\n   </strong>\n   : High-speed receivers also need to include a differential envelope detector to detect the \"Squelch\" state. This is the invalid signal state, identified by a differential bus voltage of\n   <strong>\n    100 millivolts\n   </strong>\n   or less. This is crucial for ensuring that the data transmission is valid and uninterrupted.\n  </p>\n</li>\n</ul>\n<h3>\n Hub Requirements\n</h3>\n<ul>\n<li>\n<strong>\n   Downstream Ports on USB 2.0 Hubs\n  </strong>\n  : All downstream ports on USB 2.0 hubs must comply with these high-speed signal integrity standards, ensuring proper communication with devices at all USB speeds.\n </li>\n</ul>\n<p>\n In summary, the USB electrical interface requires precise impedance control, current source management, and sophisticated detection mechanisms to maintain signal integrity, especially for high-speed data transmission. The use of specific drivers and terminators on the bus and detailed specifications for receiver sensitivity ensures reliable performance across a range of devices.\n</p>\n"}, "Page 539": {"response": "<p>\n \u200b\n</p>\n"}, "Page 540": {"response": "<p>\n Something went wrong. If this issue persists please contact us through our help center at help.openai.com.\n</p>\n"}, "Page 541": {"response": ""}, "Page 542": {"response": ""}, "Page 543": {"response": ""}, "Page 544": {"response": ""}, "Page 545": {"response": ""}, "Page 546": {"response": ""}, "Page 547": {"response": ""}, "Page 548": {"response": ""}, "Page 549": {"response": ""}, "Page 550": {"response": ""}, "Page 551": {"response": ""}, "Page 552": {"response": ""}, "Page 553": {"response": ""}, "Page 554": {"response": ""}, "Page 555": {"response": ""}, "Page 556": {"response": ""}, "Page 557": {"response": ""}, "Page 558": {"response": ""}, "Page 559": {"response": ""}, "Page 560": {"response": ""}, "Page 561": {"response": ""}, "Page 562": {"response": ""}, "Page 563": {"response": ""}, "Page 564": {"response": ""}, "Page 565": {"response": ""}, "Page 566": {"response": ""}, "Page 567": {"response": ""}, "Page 568": {"response": ""}, "Page 569": {"response": ""}, "Page 570": {"response": ""}, "Page 571": {"response": "<h3>\n Cypress CY7C67200 EZ-OTG Controller\n</h3>\n<p>\n The\n <strong>\n  Cypress CY7C67200 EZ-OTG\n </strong>\n is a versatile USB controller designed for\n <strong>\n  On-The-Go (OTG)\n </strong>\n devices. It offers dual modes of operation and supports a wide range of USB features. Here\u2019s an overview of its key functionalities:\n</p>\n<h4>\n<strong>\n  Modes of Operation\n </strong>\n</h4>\n<ol>\n<li>\n<strong>\n   Stand-Alone Mode\n  </strong>\n  :\n  <ul>\n<li>\n    In this mode, the\n    <strong>\n     CY7C67200 EZ-OTG\n    </strong>\n    acts as the\n    <strong>\n     main CPU\n    </strong>\n    of the device.\n   </li>\n<li>\n    Firmware can be stored in an\n    <strong>\n     I2C EEPROM\n    </strong>\n    , or the controller can download firmware from a\n    <strong>\n     USB host\n    </strong>\n    using the same method as the\n    <strong>\n     EZ-USB chips\n    </strong>\n    discussed earlier.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Coprocessor Mode\n  </strong>\n  :\n  <ul>\n<li>\n    In coprocessor mode, the\n    <strong>\n     EZ-OTG\n    </strong>\n    acts as a\n    <strong>\n     coprocessor\n    </strong>\n    , interfacing with an\n    <strong>\n     external CPU\n    </strong>\n    that manages USB communications and other tasks.\n   </li>\n<li>\n    The external CPU can communicate with the controller via:\n    <ul>\n<li>\n      A\n      <strong>\n       parallel Host Peripheral Interface (HPI)\n      </strong>\n      , capable of up to\n      <strong>\n       16 Megabytes per second\n      </strong>\n      .\n     </li>\n<li>\n      A\n      <strong>\n       high-speed asynchronous serial interface\n      </strong>\n      , capable of up to\n      <strong>\n       2 Megabaud\n      </strong>\n      .\n     </li>\n<li>\n      A\n      <strong>\n       Serial Peripheral Interface (SPI)\n      </strong>\n      , supporting up to\n      <strong>\n       2 Megabits per second\n      </strong>\n      .\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4>\n<strong>\n  USB Ports and Interfaces\n </strong>\n</h4>\n<ul>\n<li>\n  The\n  <strong>\n   CY7C67200 EZ-OTG\n  </strong>\n  has\n  <strong>\n   two USB ports\n  </strong>\n  and\n  <strong>\n   two serial interface engines\n  </strong>\n  that support both\n  <strong>\n   low-speed\n  </strong>\n  and\n  <strong>\n   full-speed\n  </strong>\n  USB communications.\n </li>\n<li>\n  The controller\u2019s ports can function in various roles:\n  <ul>\n<li>\n<strong>\n     OTG device port\n    </strong>\n    : For dual-role functionality.\n   </li>\n<li>\n<strong>\n     Non-OTG host port\n    </strong>\n    : For standard host device interaction.\n   </li>\n<li>\n<strong>\n     Peripheral-only device port\n    </strong>\n    : For peripheral devices only.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n<strong>\n  Controller\u2019s Firmware and Development\n </strong>\n</h4>\n<ul>\n<li>\n  The controller includes a\n  <strong>\n   ROM BIOS\n  </strong>\n  , which executes an\n  <strong>\n   Idle task\n  </strong>\n  that continuously waits for interrupts, handles tasks in the\n  <strong>\n   Idle chain\n  </strong>\n  , and repeats this process.\n </li>\n<li>\n<strong>\n   Firmware developers\n  </strong>\n  can modify this Idle task, add new tasks, or completely replace the default programming with their own specific logic.\n </li>\n</ul>\n<h4>\n<strong>\n  Development Tools and Resources\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   Firmware Development\n  </strong>\n  : Developers can use the\n  <strong>\n   GNU Toolset\n  </strong>\n  to develop firmware. This toolset supports a wide variety of CPUs and includes:\n  <ul>\n<li>\n<strong>\n     C Compiler\n    </strong>\n</li>\n<li>\n<strong>\n     Assembler\n    </strong>\n</li>\n<li>\n<strong>\n     Make Utility\n    </strong>\n</li>\n<li>\n<strong>\n     Linker\n    </strong>\n</li>\n<li>\n<strong>\n     Debugger\n    </strong>\n    and other useful tools.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Frameworks C Code\n  </strong>\n  : Cypress provides\n  <strong>\n   C code frameworks\n  </strong>\n  to assist with USB-related tasks and managing components of the controller.\n </li>\n<li>\n<strong>\n   Tutorials and Examples\n  </strong>\n  : Cypress offers a free e-book titled \"\n  <strong>\n   USB Multi-Role Device Design By Example\n  </strong>\n  \" by John Hyde. This e-book, available from\n  <strong>\n<a rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n    www\n    .usb\n    -by\n    -example\n    .com\n   </a>\n</strong>\n  , provides detailed tutorials and examples to help developers get started with USB multi-role device design.\n </li>\n</ul>\n<p>\n This controller is designed to offer flexibility and ease of use for OTG devices, making it a valuable tool for developers working with USB OTG solutions.\n</p>\n"}, "Page 572": {"response": ""}, "Page 573": {"response": ""}, "Page 574": {"response": ""}, "Page 575": {"response": "<h3>\n Index (Continued)\n</h3>\n<p>\n The index continues with detailed references to USB topics, providing a comprehensive guide to important concepts, components, and devices mentioned throughout the book. This section expands on bus power, speed, and state concepts, cables, connectors, chipsets, and device classes.\n</p>\n<hr/>\n<h4>\n B\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Bus Power\n   </strong>\n   : Discusses the usage, challenges, and limitations of bus power in USB systems, including:\n  </p>\n<ul>\n<li>\n    Differences between\n    <strong>\n     self-power\n    </strong>\n    and bus power (pages 26\u201327, 457, 460, 462).\n   </li>\n<li>\n    Issues related to\n    <strong>\n     voltage\n    </strong>\n    in bus power (pages 456\u2013457).\n   </li>\n<li>\n<strong>\n     Soft-start capability\n    </strong>\n    and other related features (page 466).\n   </li>\n<li>\n    Which peripherals can utilize bus power (pages 457, 458).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Bus Speed\n   </strong>\n   : Covers various aspects of bus speed, including:\n  </p>\n<ul>\n<li>\n    Overview and significance of bus speed (page 5).\n   </li>\n<li>\n    How bus speed impacts\n    <strong>\n     bulk transfers\n    </strong>\n    (71),\n    <strong>\n     control transfers\n    </strong>\n    (66\u20138), and\n    <strong>\n     interrupt transfers\n    </strong>\n    (73\u20135).\n   </li>\n<li>\n    Converting bus speed (50\u201351).\n   </li>\n<li>\n    Differences between\n    <strong>\n     low-speed\n    </strong>\n    and\n    <strong>\n     high-speed\n    </strong>\n    (28\u201329, 50\u201351).\n   </li>\n<li>\n    Maximum data transfer rate per endpoint (62).\n   </li>\n<li>\n    How bus speed relates to\n    <strong>\n     signal voltage\n    </strong>\n    (517\u2013518).\n   </li>\n<li>\n    Speed considerations with\n    <strong>\n     split transactions\n    </strong>\n    (50\u201351, 439\u2013444).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Bus States\n   </strong>\n   : Discusses the three bus states in USB communication:\n  </p>\n<ul>\n<li>\n<strong>\n     Full-speed\n    </strong>\n    (490\u2013492).\n   </li>\n<li>\n<strong>\n     High-speed\n    </strong>\n    (492\u2013494).\n   </li>\n<li>\n<strong>\n     Low-speed\n    </strong>\n    (490\u2013492).\n   </li>\n<li>\n    Related to\n    <strong>\n     signal voltages\n    </strong>\n    (517\u2013518).\n   </li>\n</ul>\n</li>\n</ul>\n<hr/>\n<h4>\n C\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Cables\n   </strong>\n   : Provides comprehensive information on USB cables:\n  </p>\n<ul>\n<li>\n<strong>\n     General Cable Overview\n    </strong>\n    (518\u2013520).\n   </li>\n<li>\n    How cables interact with\n    <strong>\n     bus power\n    </strong>\n    (456\u2013457).\n   </li>\n<li>\n    Different types of\n    <strong>\n     connectors\n    </strong>\n    and\n    <strong>\n     conductors\n    </strong>\n    (520\u2013523).\n   </li>\n<li>\n    Types of cables, including\n    <strong>\n     captive cables\n    </strong>\n    (524),\n    <strong>\n     detachable cables\n    </strong>\n    (524), and\n    <strong>\n     extension cables\n    </strong>\n    (525).\n   </li>\n<li>\n    Issues related to\n    <strong>\n     length\n    </strong>\n    of cables and the impact on performance (447\u2013448, 524\u2013525).\n   </li>\n<li>\n    USB 2.0\n    <strong>\n     cable requirements\n    </strong>\n    and specifications (518\u2013525).\n   </li>\n<li>\n    Cable types for\n    <strong>\n     On-The-Go (OTG)\n    </strong>\n    devices (542\u2013544).\n   </li>\n<li>\n<strong>\n     Twisted-pair cables\n    </strong>\n    used in USB systems (527\u2013528).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Catalog Files (.cat)\n   </strong>\n   : References for catalog files, which are related to USB device setup and installation, discussed on pages 274 and 486.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    CCIDs (Chip Card Interface Devices)\n   </strong>\n   : Refers to the class for chip card interfaces (189\u2013191).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Certified USB Logo\n   </strong>\n   : Covers the\n   <strong>\n    Certified USB logo\n   </strong>\n   and the importance of compliance:\n  </p>\n<ul>\n<li>\n<strong>\n     Compliance checklists\n    </strong>\n    (478\u2013479).\n   </li>\n<li>\n    The official\n    <strong>\n     USB icon\n    </strong>\n    (484\u2013485).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Chip Cards\n   </strong>\n   : Information about\n   <strong>\n    chip cards\n   </strong>\n   and the related\n   <strong>\n    chip/smart card interface class\n   </strong>\n   (189).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Chips (Controller)\n   </strong>\n   : Discusses different\n   <strong>\n    controller chips\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    General\n    <strong>\n     controller chip\n    </strong>\n    information (8\u20139).\n   </li>\n<li>\n<strong>\n     Cypress CY7C67200 EZ-OTG\n    </strong>\n    (548\u2013549).\n   </li>\n<li>\n<strong>\n     Cypress enCoRe\n    </strong>\n    series (155, 163).\n   </li>\n<li>\n<strong>\n     Cypress EZ-USB family\n    </strong>\n    (155, 157\u2013162).\n   </li>\n<li>\n<strong>\n     Cypress WirelessUSB\n    </strong>\n    (530\u2013533).\n   </li>\n<li>\n<strong>\n     FDTI FT232BM\n    </strong>\n    (166, 170, 171, 173, 174\u2013176, 227\u2013229).\n   </li>\n<li>\n<strong>\n     FDTI FT245BM\n    </strong>\n    (166, 170, 171, 172, 174\u2013176).\n   </li>\n<li>\n<strong>\n     Freescale MC68HC08 family\n    </strong>\n    (164).\n   </li>\n</ul>\n</li>\n</ul>\n<hr/>\n<p>\n This index section continues to organize critical USB topics, making it easier to find references related to USB power, speed, and device types. It includes key information about cables, connectors, chipsets, and classes, alongside compliance requirements for USB devices.\n</p>\n"}, "Page 576": {"response": "<h3>\n Index (Continued)\n</h3>\n<p>\n The index continues to provide detailed references on USB device controllers, class descriptors, communication protocols, and API functions.\n</p>\n<hr/>\n<h4>\n C (Continued)\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Chipsets and Controllers\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Freescale MCF5482 ColdFire\n    </strong>\n    (164).\n   </li>\n<li>\n<strong>\n     Microchip Technology\n    </strong>\n    devices:\n    <ul>\n<li>\n<strong>\n       PIC16C745/65\n      </strong>\n      (155, 157).\n     </li>\n<li>\n<strong>\n       PIC16F877 microcontroller\n      </strong>\n      used in FT232BM controller example (408\u2013414).\n     </li>\n<li>\n<strong>\n       PIC16F877 microcontroller\n      </strong>\n      used in FT245BM controller example (414\u2013421).\n     </li>\n<li>\n<strong>\n       PIC18F4550\n      </strong>\n      (155, 156\u2013157, 338).\n     </li>\n</ul>\n</li>\n<li>\n<strong>\n     National Semiconductor USBN9603\n    </strong>\n    (165\u2013167).\n   </li>\n<li>\n<strong>\n     Philips Controllers\n    </strong>\n    :\n    <ul>\n<li>\n<strong>\n       ISP1181B\n      </strong>\n      (166, 167\u2013168).\n     </li>\n<li>\n<strong>\n       ISP1261\n      </strong>\n      (549).\n     </li>\n<li>\n<strong>\n       ISP1362\n      </strong>\n      (546\u2013547).\n     </li>\n<li>\n<strong>\n       ISP1581\n      </strong>\n      (166, 168\u2013169).\n     </li>\n<li>\n<strong>\n       PDIUSBD12\n      </strong>\n      (166).\n     </li>\n</ul>\n</li>\n<li>\n<strong>\n     PLX Technology NET2272\n    </strong>\n    (166, 169\u2013170).\n   </li>\n<li>\n<strong>\n     TransDimension TD242LP\n    </strong>\n    (547\u2013548).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Chip/Smart Card Interface Class\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    General information and references (179, 189\u2013191, 251, 276).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Chirp Bus States\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Chirp J\n    </strong>\n    (493).\n   </li>\n<li>\n<strong>\n     Chirp K\n    </strong>\n    (493).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    ChkInf Tool\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Details about the\n    <strong>\n     ChkInf\n    </strong>\n    tool (266, 277).\n   </li>\n</ul>\n</li>\n</ul>\n<hr/>\n<h4>\n Classes\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Overview\n   </strong>\n   : USB devices are classified into different\n   <strong>\n    device classes\n   </strong>\n   based on their functionality. Each class has its own set of descriptors and communication protocols.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Class Descriptors\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     HID (Human Interface Device)\n    </strong>\n    : Descriptors are discussed from 326\u2013328.\n   </li>\n<li>\n    Other class descriptors include:\n    <ul>\n<li>\n<strong>\n       Audio class\n      </strong>\n      (179, 181\u2013189).\n     </li>\n<li>\n<strong>\n       Chip/smart card interface class\n      </strong>\n      (179, 189\u2013191, 251, 276).\n     </li>\n<li>\n<strong>\n       Communication class\n      </strong>\n      (179, 191\u2013198, 251).\n     </li>\n<li>\n<strong>\n       Content Security class\n      </strong>\n      (179, 198\u2013200).\n     </li>\n<li>\n<strong>\n       Device Firmware Upgrade (DFU) class\n      </strong>\n      (179, 200\u2013202).\n     </li>\n<li>\n<strong>\n       Human Interface Device (HID) class\n      </strong>\n      (179, 203\u2013206, 251, 276, 319).\n     </li>\n<li>\n<strong>\n       IrDA Bridge class\n      </strong>\n      (179, 206\u2013208, 534).\n     </li>\n<li>\n<strong>\n       Mass-storage class\n      </strong>\n      (179, 208\u2013213, 251).\n     </li>\n<li>\n<strong>\n       Printer class\n      </strong>\n      (179, 213\u2013217, 251).\n     </li>\n<li>\n<strong>\n       Still-image class\n      </strong>\n      (179, 217\u2013220, 251).\n     </li>\n<li>\n<strong>\n       Test-and-measurement class\n      </strong>\n      (179, 220\u2013221).\n     </li>\n<li>\n<strong>\n       Video class\n      </strong>\n      (179, 221\u2013226).\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Class Drivers\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Advantages and considerations of using\n    <strong>\n     class drivers\n    </strong>\n    (226\u2013227).\n   </li>\n<li>\n<strong>\n     Class vs. custom drivers\n    </strong>\n    (226\u2013227).\n   </li>\n<li>\n<strong>\n     Operating system support\n    </strong>\n    for class drivers (8).\n   </li>\n<li>\n    The role of\n    <strong>\n     INF files\n    </strong>\n    in driver installation (276).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Class-Specific Requests\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    General information on class-specific requests (140).\n   </li>\n<li>\n    Specific class-related requests:\n    <ul>\n<li>\n<strong>\n       Audio class\n      </strong>\n      (188).\n     </li>\n<li>\n<strong>\n       Chip/smart card interface\n      </strong>\n      (191).\n     </li>\n<li>\n<strong>\n       Communication-device class\n      </strong>\n      (196).\n     </li>\n<li>\n<strong>\n       Content Security class\n      </strong>\n      (199\u2013200).\n     </li>\n<li>\n<strong>\n       Device Firmware Upgrade (DFU) class\n      </strong>\n      (202).\n     </li>\n<li>\n<strong>\n       HIDs\n      </strong>\n      (204\u2013205).\n     </li>\n<li>\n<strong>\n       Hub class\n      </strong>\n      (451\u2013453).\n     </li>\n<li>\n<strong>\n       IrDA interface\n      </strong>\n      (207).\n     </li>\n<li>\n<strong>\n       Mass-storage devices\n      </strong>\n      (212).\n     </li>\n<li>\n<strong>\n       Printer class\n      </strong>\n      (215).\n     </li>\n<li>\n<strong>\n       Still-image class\n      </strong>\n      (219).\n     </li>\n<li>\n<strong>\n       Test-and-measurement class\n      </strong>\n      (221).\n     </li>\n<li>\n<strong>\n       Video class\n      </strong>\n      (225).\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr/>\n<h4>\n Command Block Wrapper (CBW)\n</h4>\n<p>\n The\n <strong>\n  Command Block Wrapper (CBW)\n </strong>\n is defined on pages 209\u2013210, 210. This is part of the communication process for mass-storage devices in USB.\n</p>\n<hr/>\n<p>\n The index provides a clear guide to various USB chipsets, device classes, and class-specific requests. It also offers helpful references to API functions and tools, enhancing the ability to find information about developing USB devices and drivers.\n</p>\n"}, "Page 577": {"response": "<h3>\n Index (Continued)\n</h3>\n<p>\n This section of the index offers references to various topics such as\n <strong>\n  Command Status Wrapper (CSW)\n </strong>\n ,\n <strong>\n  communication-device class\n </strong>\n ,\n <strong>\n  composite devices\n </strong>\n ,\n <strong>\n  control transfers\n </strong>\n , and other technical terms related to USB devices and drivers.\n</p>\n<hr/>\n<h4>\n C (Continued)\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Command Status Wrapper (CSW)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     CSW\n    </strong>\n    is a key part of the mass-storage device communication protocol. Refer to pages 210\u2013211 for detailed explanations.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Common Language Runtime (CLR)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     CLR\n    </strong>\n    is a platform for running managed code and is mentioned on page 282.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Communication-Device Class\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Overview\n    </strong>\n    : The communication-device class allows for communication-related functionality in USB devices. More details can be found on pages 192\u2013197.\n   </li>\n<li>\n<strong>\n     Descriptors\n    </strong>\n    : The\n    <strong>\n     communication device class\n    </strong>\n    descriptors are listed from 193\u2013197, including details on where they are declared (179).\n   </li>\n<li>\n<strong>\n     Windows Support\n    </strong>\n    : Details about how this class is supported in Windows (197\u2013198).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Compaq\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     OHCI Standard\n    </strong>\n    : Compaq's involvement in the\n    <strong>\n     Open Host Controller Interface\n    </strong>\n    (OHCI) standard (241).\n   </li>\n<li>\n<strong>\n     USB 2.0 Specification\n    </strong>\n    : Compaq's role in the USB 2.0 specification (14).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Compatible IDs\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Compatible IDs\n    </strong>\n    are used for driver identification and can be found on pages 272\u2013275.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Compilers\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Compilers\n    </strong>\n    are essential tools for USB device development, as mentioned on page 30.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Compliance Testing\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Compliance testing for USB devices ensures that they meet USB specifications. It is discussed on pages 478\u2013484.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Composite Devices\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Definition\n    </strong>\n    : A\n    <strong>\n     composite device\n    </strong>\n    is one that supports multiple functions, appearing as several devices to the host. More details are found on pages 21 and 103\u2013104.\n   </li>\n<li>\n<strong>\n     Enumeration Process\n    </strong>\n    : The enumeration process for composite devices is explained on pages 90\u201391.\n   </li>\n<li>\n<strong>\n     Driver Identification\n    </strong>\n    : Information on finding drivers for composite devices is available on pages 274\u2013275.\n   </li>\n<li>\n<strong>\n     Identification Strings\n    </strong>\n    : The\n    <strong>\n     identification strings\n    </strong>\n    for composite devices are discussed on pages 272\u2013273.\n   </li>\n<li>\n<strong>\n     Layered Drivers\n    </strong>\n    : Layered drivers for composite devices are explained on page 239.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Compound Devices\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Overview\n    </strong>\n    : A\n    <strong>\n     compound device\n    </strong>\n    is a device that acts as multiple devices in one package. More information can be found on page 21.\n   </li>\n<li>\n<strong>\n     Bus-Powered Compound Devices\n    </strong>\n    : These devices draw power from the USB bus (461).\n   </li>\n<li>\n<strong>\n     Hubs in Compound Devices\n    </strong>\n    : The use of\n    <strong>\n     hubs\n    </strong>\n    within compound devices is explained on pages 434 and 450.\n   </li>\n<li>\n<strong>\n     Peripheral-Host Configurations\n    </strong>\n    :\n    <strong>\n     Compound devices\n    </strong>\n    can be used in peripheral-host PC configurations (19, 20).\n   </li>\n<li>\n<strong>\n     Speed Issues\n    </strong>\n    : Potential\n    <strong>\n     speed issues\n    </strong>\n    in compound devices are mentioned on page 28.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Computer Ports\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    See the section on\n    <strong>\n     ports\n    </strong>\n    for more details.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Conductors\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Conductors\n    </strong>\n    for USB are discussed from pages 518\u2013520.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Configuration Descriptor\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     configuration descriptor\n    </strong>\n    is crucial for device enumeration and setup. Details are found on pages 94, 95, 101\u2013103.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Connect Bus State\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     Connect bus state\n    </strong>\n    is mentioned on page 492.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Connectors\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Connectors\n    </strong>\n    for USB devices are explained from pages 520\u2013523, including specifics for\n    <strong>\n     On-The-Go (OTG) devices\n    </strong>\n    (542\u2013544).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Content Security Class\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     Content Security class\n    </strong>\n    is discussed in relation to USB devices and encryption (179, 198\u2013200).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Control Endpoints\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Control endpoints\n    </strong>\n    are used for USB control transfers, with details on how they function (38).\n   </li>\n<li>\n    The\n    <strong>\n     HID control transfers\n    </strong>\n    and their endpoints are discussed on pages 321\u2013322.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Control Transfers\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Control transfers\n    </strong>\n    are a type of USB transfer used to manage device configuration and control. Refer to pages 40, 41, 46, 61 for details.\n   </li>\n<li>\n<strong>\n     Availability\n    </strong>\n    : Information on the\n    <strong>\n     availability\n    </strong>\n    and functionality of control transfers is discussed on page 62.\n   </li>\n<li>\n<strong>\n     Error Handling\n    </strong>\n    : How\n    <strong>\n     error handling\n    </strong>\n    works in control transfers is explained on pages 68, 124\u2013125.\n   </li>\n<li>\n<strong>\n     Data Stages\n    </strong>\n    : Control transfers include different stages, including the\n    <strong>\n     Data stage\n    </strong>\n    (46, 62\u201365).\n   </li>\n<li>\n<strong>\n     Requests\n    </strong>\n    : Common\n    <strong>\n     control requests\n    </strong>\n    such as\n    <strong>\n     Control Read\n    </strong>\n    and\n    <strong>\n     Control Write\n    </strong>\n    are covered on pages 126\u2013139.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Cost of USB\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     cost\n    </strong>\n    of implementing USB technology is discussed on page 6.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    CPUs in USB Devices\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Embedded CPUs\n    </strong>\n    in USB controllers are discussed (154\u2013164), and their role in USB communication.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Cyclic Redundancy Check (CRC)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     CRC\n    </strong>\n    is used to verify data integrity in USB communication (56\u201357).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Crystals\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The role of\n    <strong>\n     crystals\n    </strong>\n    in USB controllers for clock generation is mentioned on pages 498\u2013499.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Cypress Semiconductor\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     CY7C67200 EZ-OTG\n    </strong>\n    controller chip is discussed for OTG (548\u2013549).\n   </li>\n<li>\n<strong>\n     EZ-USB chip family\n    </strong>\n    and its use in USB applications (155, 157\u2013162).\n   </li>\n<li>\n<strong>\n     enCoRe\n    </strong>\n    microcontrollers for USB development (155, 163).\n   </li>\n</ul>\n</li>\n</ul>\n<hr/>\n<p>\n This section of the index references essential components and processes such as control transfers, compliance testing, and composite devices. It also includes insights into specific manufacturers like\n <strong>\n  Cypress Semiconductor\n </strong>\n and their various USB chipsets.\n</p>\n"}, "Page 578": {"response": "<h3>\n Index (Continued)\n</h3>\n<p>\n This section of the index includes references to specific topics such as\n <strong>\n  WirelessUSB\n </strong>\n ,\n <strong>\n  debugging tools\n </strong>\n ,\n <strong>\n  device descriptors\n </strong>\n , and other critical USB-related elements like\n <strong>\n  data flow\n </strong>\n and\n <strong>\n  development kits\n </strong>\n .\n</p>\n<hr/>\n<h4>\n D (Continued)\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    WirelessUSB\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     WirelessUSB\n    </strong>\n    is discussed on pages 530\u2013533, and it refers to Cypress Semiconductor\u2019s wireless USB technology, designed for low power, short-range communication.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    D2XX Direct Driver\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     D2XX Direct Driver\n    </strong>\n    is used for communication between USB devices and Windows applications without the need for standard USB drivers. Refer to pages 421\u2013426 for its usage and details.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Data Encoding\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Non-Return to Zero Inverted (NRZI)\n    </strong>\n    encoding with\n    <strong>\n     bit stuffing\n    </strong>\n    is a method used to encode data for USB communication, ensuring data integrity. Details are covered under\n    <strong>\n     data encoding\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Data Flow\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Direction Codes\n    </strong>\n    : These codes specify the direction of data flow in USB transactions. They are referenced on pages 39, 41, and 45.\n   </li>\n<li>\n<strong>\n     Role of Host\n    </strong>\n    : The\n    <strong>\n     host\n    </strong>\n    plays a central role in data flow, managing the transfer of data between devices and the system (24).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Data J &amp; K Bus States\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Data J bus state\n    </strong>\n    and\n    <strong>\n     Data K bus state\n    </strong>\n    are terms used to define certain signaling states in high-speed USB communications. They are explained on pages 490\u2013491.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Data Memory\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Data memory is referenced as part of the\n    <strong>\n     USB controllers\n    </strong>\n    (147).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Data Packets\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Data packets\n    </strong>\n    are the units of data transferred between USB devices. They are discussed on pages 44, 45, 46, 47, and 49\u201350, and include:\n    <ul>\n<li>\n<strong>\n       Token packets\n      </strong>\n      : Carry the header information for the transaction.\n     </li>\n<li>\n<strong>\n       Handshake packets\n      </strong>\n      : Indicate the success or failure of a transfer.\n     </li>\n<li>\n<strong>\n       Data stage\n      </strong>\n      : The actual data transfer occurs here (46, 120\u2013121).\n     </li>\n<li>\n<strong>\n       Data toggles\n      </strong>\n      : Control mechanisms that manage the data flow during transfers (57\u201359).\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Data Stage\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     Data stage\n    </strong>\n    is an important part of the\n    <strong>\n     control transfer\n    </strong>\n    structure. It is explained on pages 46, 120\u2013121 and includes the\n    <strong>\n     Control Write requests\n    </strong>\n    (125\u2013126). It handles the\n    <strong>\n     data packets\n    </strong>\n    ,\n    <strong>\n     handshake packets\n    </strong>\n    , and\n    <strong>\n     token packets\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Data Types (Visual Basic vs. .NET Framework)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Differences between\n    <strong>\n     data types\n    </strong>\n    in\n    <strong>\n     Visual Basic\n    </strong>\n    and the\n    <strong>\n     .NET Framework\n    </strong>\n    are explored on page 288.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    DDK (Driver Development Kit)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     DDK\n    </strong>\n    is essential for creating USB drivers and is discussed on page 30.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Debug Descriptor\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     debug descriptor\n    </strong>\n    is a part of USB device descriptors used for debugging purposes. It is mentioned on pages 95 and 113.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Debugging Tools\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Various\n    <strong>\n     debugging tools\n    </strong>\n    for USB development are covered on pages 30 and 151\u2013152.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Default Control Pipe\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     Default Control Pipe\n    </strong>\n    is essential for control transfers, particularly for\n    <strong>\n     device configuration\n    </strong>\n    and management. It is referenced on pages 40, 62, and 66.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Delimiter Item\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     Delimiter Item\n    </strong>\n    is part of USB message structure and is discussed on pages 371\u2013372.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Descriptors\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Descriptors\n    </strong>\n    provide essential information about USB devices and their functionality. They are an integral part of the\n    <strong>\n     enumeration process\n    </strong>\n    (89\u201390). Key types of descriptors include:\n    <ul>\n<li>\n<strong>\n       Device Descriptor\n      </strong>\n      : Describes the device and includes details such as vendor ID (94, 95, 96\u201399).\n     </li>\n<li>\n<strong>\n       Configuration Descriptor\n      </strong>\n      : Provides information about the device\u2019s power requirements and functionality (94, 95, 101\u2013103).\n     </li>\n<li>\n<strong>\n       Interface Descriptor\n      </strong>\n      : Defines the interfaces the device supports (94, 95, 106\u2013108).\n     </li>\n<li>\n<strong>\n       Endpoint Descriptor\n      </strong>\n      : Provides details about the device\u2019s endpoints, including direction and type (94, 95, 108\u2013112).\n     </li>\n<li>\n<strong>\n       HID Descriptor\n      </strong>\n      : Specific to the\n      <strong>\n       Human Interface Device\n      </strong>\n      class, found on pages 326\u2013328.\n     </li>\n<li>\n<strong>\n       Video Class Descriptor\n      </strong>\n      : Relevant for video devices (223\u2013225).\n     </li>\n<li>\n<strong>\n       Vendor-Specific Descriptors\n      </strong>\n      : Custom descriptors defined by the device manufacturer (94\u201395, 324\u2013325).\n     </li>\n<li>\n<strong>\n       OTG Descriptors\n      </strong>\n      : For\n      <strong>\n       On-The-Go\n      </strong>\n      devices (95, 113, 545\u2013546).\n     </li>\n<li>\n<strong>\n       String Descriptors\n      </strong>\n      : Contain readable text like the device's name (94, 95, 112\u2013113).\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Designator Items\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Designator items\n    </strong>\n    are used in USB device structures. These include:\n    <ul>\n<li>\n<strong>\n       Designator Index Item\n      </strong>\n      (371\u2013372).\n     </li>\n<li>\n<strong>\n       Designator Maximum Item\n      </strong>\n      (371\u2013372).\n     </li>\n<li>\n<strong>\n       Designator Minimum Item\n      </strong>\n      (371\u2013372).\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Detachable Cables\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The use of\n    <strong>\n     detachable cables\n    </strong>\n    in USB setups is covered on page 524.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    DeVaSys Embedded Systems USB 12C/IO Board\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Information on the\n    <strong>\n     DeVaSys Embedded Systems USB 12C/IO board\n    </strong>\n    is available on pages 152\u2013153.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    USB Developers\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     USB Benefits\n    </strong>\n    : The advantages of using USB for device communication, including high speed and ease of use, are outlined on pages 6\u20139.\n   </li>\n<li>\n<strong>\n     USB Challenges\n    </strong>\n    : Some challenges USB developers face are discussed on pages 12\u201313, including power management and device compatibility.\n   </li>\n<li>\n<strong>\n     USB Limitations\n    </strong>\n    : The limitations of USB, such as distance and bandwidth, are noted on pages 10\u201312.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Development Kits\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Development kits\n    </strong>\n    from chip manufacturers provide the necessary tools for building USB devices. They are discussed on pages 151\u2013152.\n   </li>\n<li>\n<strong>\n     Printed-Circuit Board (PCB) Alternatives\n    </strong>\n    : Alternative ways to build USB devices without traditional PCBs are mentioned on pages 152\u2013154.\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Device Controllers\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    USB\n    <strong>\n     device controllers\n    </strong>\n    manage data flow between USB devices and the host. Key elements and development requirements are covered on pages 148\u2013164.\n   </li>\n<li>\n<strong>\n     Debugging Tools\n    </strong>\n    : Tools to aid in debugging USB controller setups are discussed (151\u2013154).\n   </li>\n<li>\n<strong>\n     Driver Choices\n    </strong>\n    : The\n    <strong>\n     driver choices\n    </strong>\n    for USB controllers, including custom vs. standard drivers, are explained (151).\n   </li>\n<li>\n<strong>\n     Controllers with Embedded CPUs\n    </strong>\n    : USB controllers with embedded\n    <strong>\n     CPUs\n    </strong>\n    are covered on pages 154\u2013164.\n   </li>\n</ul>\n</li>\n</ul>\n<hr/>\n<p>\n This section of the index continues to highlight crucial aspects of USB development, including detailed descriptions of descriptors, debugging tools, device controllers, and development kits. It offers valuable references for understanding the structure and function of USB devices and how to create and debug them effectively.\n</p>\n"}, "Page 579": {"response": "<h3>\n USB Devices: Overview, Development, and Drivers\n</h3>\n<p>\n This section covers essential aspects of USB devices, including their development, types, drivers, and tools for managing them. It delves into the processes of detecting, identifying, and testing devices, as well as considerations for their use and power management.\n</p>\n<hr/>\n<h4>\n USB Devices\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Definition\n   </strong>\n   : USB devices are hardware components that interface with a host through the Universal Serial Bus. They can be\n   <strong>\n    bus-powered\n   </strong>\n   or\n   <strong>\n    self-powered\n   </strong>\n   , impacting their power requirements and configuration. Specific details on power management, such as\n   <strong>\n    low-power vs. high-power\n   </strong>\n   devices, are found on pages 457, 460, and 462.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Types\n   </strong>\n   : There are two main types of USB devices:\n  </p>\n<ul>\n<li>\n<strong>\n     Composite Devices\n    </strong>\n    : These devices are made up of multiple interfaces, often grouped to form a single device, and require specialized handling in the enumeration process (pages 21, 90\u201393).\n   </li>\n<li>\n<strong>\n     Compound Devices\n    </strong>\n    : These involve multiple devices that operate independently but are connected in a single unit, often with hubs (pages 19\u201321, 434, 450, 461).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Speed and Power Considerations\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    USB devices are classified by their\n    <strong>\n     speed\n    </strong>\n    (low-speed vs. high-speed), and\n    <strong>\n     power\n    </strong>\n    (bus-powered or self-powered). Understanding these characteristics is crucial for determining device compatibility and system performance (pages 28\u201329, 457\u2013460).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Enumeration Process\n   </strong>\n   : The\n   <strong>\n    enumeration process\n   </strong>\n   is vital for identifying and configuring USB devices when they are attached. It involves identifying the device\u2019s descriptors, assigning endpoints, and setting up communication (pages 86\u201393).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Detecting Device Attachment and Removal\n   </strong>\n   : The system can detect when a device is connected or removed. Proper handling of this event is essential for smooth operation. Tools for\n   <strong>\n    detecting attachment\n   </strong>\n   and\n   <strong>\n    removal\n   </strong>\n   are covered in detail on pages 306\u2013318.\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Developing USB Devices\n   </strong>\n   : Developing USB devices involves selecting the right controllers and hardware, writing the necessary software, and testing for compliance. The development process is outlined on pages 29\u201332.\n  </p>\n</li>\n</ul>\n<h4>\n Device Drivers\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    About Device Drivers\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Device drivers\n    </strong>\n    are crucial software components that enable the host to communicate with USB devices. These drivers can be\n    <strong>\n     generic\n    </strong>\n    or\n    <strong>\n     custom\n    </strong>\n    , depending on the device's requirements. Custom drivers are created to handle specific hardware needs, while generic drivers offer broad compatibility (pages 233\u2013237).\n   </li>\n<li>\n<strong>\n     Creating Drivers\n    </strong>\n    : Drivers can be created using a\n    <strong>\n     driver toolkit\n    </strong>\n    or\n    <strong>\n     Windows Driver Kit (WDK)\n    </strong>\n    , as well as by writing\n    <strong>\n     custom drivers\n    </strong>\n    for more specialized devices (pages 247\u2013249).\n   </li>\n<li>\n<strong>\n     Digitally Signed Drivers\n    </strong>\n    : For security and stability, drivers may be\n    <strong>\n     digitally signed\n    </strong>\n    (pages 486\u2013487).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Driver Types\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Layered Driver Model\n    </strong>\n    : USB drivers follow a layered model, where different layers handle different aspects of communication (pages 234\u2013242).\n   </li>\n<li>\n<strong>\n     Selecting Drivers\n    </strong>\n    : When selecting drivers, it\u2019s crucial to ensure that they match the device\u2019s capabilities and requirements, especially when dealing with\n    <strong>\n     speed-limiting factors\n    </strong>\n    like bandwidth constraints (pages 279\u2013280, 422\u2013426).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Device Driver Information\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Device Manager\n    </strong>\n    :\n    <strong>\n     Device Manager\n    </strong>\n    provides a graphical interface to view, manage, and troubleshoot USB devices. Through it, users can enable or disable\n    <strong>\n     remote wakeup\n    </strong>\n    capabilities or view detailed\n    <strong>\n     device properties\n    </strong>\n    (pages 253\u2013257, 468).\n   </li>\n<li>\n<strong>\n     Viewing and Selecting Drivers\n    </strong>\n    : Users can view information on drivers, their versions, and their status, making it essential for troubleshooting and managing devices (pages 254\u2013256).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Driver Installation\n   </strong>\n   : The\n   <strong>\n    Windows search process\n   </strong>\n   ensures that the correct driver is selected during device attachment. The process includes searching for\n   <strong>\n    INF files\n   </strong>\n   that define device configurations (pages 279\u2013280).\n  </p>\n</li>\n</ul>\n<h4>\n Device Descriptors and Device Interfaces\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Device Descriptors\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Device descriptors\n    </strong>\n    provide detailed information about a USB device, including its capabilities, manufacturer, and configuration. These are essential during the\n    <strong>\n     enumeration\n    </strong>\n    and\n    <strong>\n     driver installation\n    </strong>\n    processes (pages 94\u201399, 102\u2013103).\n   </li>\n<li>\n<strong>\n     Device Qualifier Descriptor\n    </strong>\n    : This descriptor provides information about the device\u2019s speed and functionality and is part of the overall device configuration (pages 94, 99\u2013101).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Device Interfaces\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Device Interface Classes\n    </strong>\n    : These classes define the types of interfaces a device uses. Examples include the\n    <strong>\n     Human Interface Device (HID)\n    </strong>\n    class and\n    <strong>\n     Audio class\n    </strong>\n    . Each device interface has its own\n    <strong>\n     GUID\n    </strong>\n    (Globally Unique Identifier), which is used for registering and managing device notifications (pages 291\u2013295).\n   </li>\n<li>\n<strong>\n     GUIDs\n    </strong>\n    : GUIDs play a critical role in identifying specific device interfaces and are necessary for interacting with the device via\n    <strong>\n     device interface pointers\n    </strong>\n    (pages 249\u2013252, 291).\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n Detecting and Identifying Devices\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Device Detection\n   </strong>\n   : Tools and APIs are available to detect devices attached to the system. This involves monitoring\n   <strong>\n    device paths\n   </strong>\n   and using\n   <strong>\n    GUIDs\n   </strong>\n   to identify devices correctly (pages 281\u2013303).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Enumerating Devices\n   </strong>\n   : The\n   <strong>\n    enumeration process\n   </strong>\n   ensures that devices are correctly identified and configured by the host system. This includes matching devices with appropriate drivers and handling their power and communication capabilities (pages 86\u201393).\n  </p>\n</li>\n</ul>\n<h4>\n Testing and Compliance\n</h4>\n<ul>\n<li>\n<strong>\n   Device Testing\n  </strong>\n  : Compliance testing is a necessary step in ensuring that USB devices meet all\n  <strong>\n   USB specifications\n  </strong>\n  . This includes testing for things like\n  <strong>\n   data integrity\n  </strong>\n  ,\n  <strong>\n   power consumption\n  </strong>\n  , and proper communication (pages 477\u2013487).\n  <ul>\n<li>\n<strong>\n     USB Testing Tools\n    </strong>\n    : Tools for testing and debugging devices are an essential part of the development cycle and can aid in validating device performance and behavior.\n   </li>\n</ul>\n</li>\n</ul>\n<hr/>\n<p>\n This section provides a comprehensive understanding of how USB devices, drivers, and descriptors interact. It explains the process of developing, identifying, and testing devices, as well as the importance of selecting the right drivers for optimal functionality.\n</p>\n"}, "Page 580": {"response": "<h3>\n Tools, Drivers, and Testing in USB Development\n</h3>\n<p>\n This section explains various tools, drivers, and methods involved in the USB development process. It covers device setup, testing, debugging, and device management through tools like\n <strong>\n  Device Manager\n </strong>\n and\n <strong>\n  Ellisys USB Explorer\n </strong>\n .\n</p>\n<hr/>\n<h4>\n USB Tools for Testing and Debugging\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    USB Testing Tools\n   </strong>\n   : Testing and debugging tools are crucial for verifying USB devices' performance and behavior during development. Tools like\n   <strong>\n    Ellisys USB Explorer\n   </strong>\n   protocol analyzer help monitor and analyze USB traffic, providing insights into communication protocols and identifying issues (pages 263\u2013265, 473\u2013475).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Device Manager\n   </strong>\n   : In\n   <strong>\n    Device Manager\n   </strong>\n   , you can view detailed information about connected USB devices, including their status, properties, and drivers. This tool is useful for troubleshooting and managing devices in Windows (pages 254\u2013257).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Debugging USB Devices\n   </strong>\n   : Proper debugging involves using tools to trace communication, manage drivers, and ensure the device behaves as expected. The section also addresses tools for viewing device-related information in the\n   <strong>\n    Windows registry\n   </strong>\n   (pages 258\u2013259).\n  </p>\n</li>\n</ul>\n<hr/>\n<h4>\n Device Drivers and Setup\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Device Setup Classes and GUIDs\n   </strong>\n   : When developing or installing USB devices, it is essential to understand\n   <strong>\n    device setup classes\n   </strong>\n   and\n   <strong>\n    GUIDs\n   </strong>\n   (Globally Unique Identifiers). These identifiers help the operating system match a device with its appropriate drivers and configure it correctly.\n  </p>\n<ul>\n<li>\n<strong>\n     Device Setup GUIDs\n    </strong>\n    : These GUIDs are defined for specific devices and match them with the right drivers during the installation process (pages 249\u2013251). The registry entries for these GUIDs are key for device setup and management (pages 259\u2013260).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Driver Development Kit (DDK)\n   </strong>\n   : Developers use the\n   <strong>\n    Driver Development Kit (DDK)\n   </strong>\n   for creating custom drivers for USB devices. It provides the necessary resources and tools to write drivers that are compatible with the Windows operating system (page 30).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Driver Keys\n   </strong>\n   : In the\n   <strong>\n    Windows registry\n   </strong>\n   ,\n   <strong>\n    driver keys\n   </strong>\n   define how a driver interacts with the system. These keys are essential for device enumeration and functionality (pages 260\u2013262).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Driver X USB Toolkit\n   </strong>\n   : This toolkit is another tool for driver development, helping developers build drivers that ensure proper communication between USB devices and the host (page 231).\n  </p>\n</li>\n</ul>\n<hr/>\n<h4>\n USB Devices: Types and Speed\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Dual-Speed Devices\n   </strong>\n   : Some USB devices support multiple speeds. The system must be able to\n   <strong>\n    detect the speed\n   </strong>\n   of these devices during enumeration to ensure correct communication (page 116).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Device Setup Class for Disk Drives\n   </strong>\n   : Disk drives, as part of the USB storage class, follow a specific\n   <strong>\n    device setup class\n   </strong>\n   , ensuring they are correctly detected and set up by the system (page 251).\n  </p>\n</li>\n</ul>\n<hr/>\n<h4>\n Error Handling and Communication\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Error Handling in USB Transfers\n   </strong>\n   : During data transfer, errors can occur in different types of transfers, such as\n   <strong>\n    bulk\n   </strong>\n   ,\n   <strong>\n    control\n   </strong>\n   ,\n   <strong>\n    interrupt\n   </strong>\n   , and\n   <strong>\n    isochronous\n   </strong>\n   . Each transfer type has its own error-handling mechanisms to ensure smooth communication.\n  </p>\n<ul>\n<li>\n    In\n    <strong>\n     bulk transfers\n    </strong>\n    , errors are handled by checking for data integrity and retries (pages 71\u201372).\n   </li>\n<li>\n    In\n    <strong>\n     control transfers\n    </strong>\n    , error detection focuses on\n    <strong>\n     status stages\n    </strong>\n    and ensuring data integrity (page 68).\n   </li>\n<li>\n    For\n    <strong>\n     isochronous transfers\n    </strong>\n    , real-time data flow must be maintained, with error handling ensuring no data loss or delays (page 80).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    ERR PID and Handshake\n   </strong>\n   : The\n   <strong>\n    ERR PID\n   </strong>\n   (Packet Identifier) is a signal used for error detection in USB communication. The\n   <strong>\n    ERR handshake code\n   </strong>\n   identifies errors during the transfer and is used for debugging and ensuring data correctness (pages 48\u201353).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    End-of-Packet (EOP) Signal\n   </strong>\n   : The\n   <strong>\n    EOP signal\n   </strong>\n   marks the end of a data packet and is critical for the system to identify when a transfer is complete. It plays a role in managing\n   <strong>\n    resume states\n   </strong>\n   and ensures proper synchronization (pages 48\u201349, 497\u2013498).\n  </p>\n</li>\n</ul>\n<hr/>\n<h4>\n EEPROM and Memory Types\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    EEPROM (Electrically Erasable Programmable ROM)\n   </strong>\n   :\n   <strong>\n    EEPROM\n   </strong>\n   is a type of memory used in USB devices to store configuration data and firmware. It can be electrically erased and reprogrammed, making it useful for storing device-specific information that needs to be updated.\n  </p>\n<ul>\n<li>\n<strong>\n     EEPROM Programming\n    </strong>\n    : This process involves writing data to the EEPROM using specific commands, which can be crucial during device setup or firmware updates (pages 146\u2013147, 429\u2013432).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    EPROM (Erasable Programmable ROM)\n   </strong>\n   : Similar to EEPROM,\n   <strong>\n    EPROM\n   </strong>\n   is used for storing data in a device. However, EPROM needs to be physically erased before being rewritten, unlike EEPROM (page 146).\n  </p>\n</li>\n</ul>\n<hr/>\n<h4>\n USB Communication: States and Transitions\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Bus States\n   </strong>\n   : USB communication involves various bus states, each representing a particular phase in data transfer or device operation. Some important bus states include:\n  </p>\n<ul>\n<li>\n<strong>\n     Differential 1 and Differential 2 Bus States\n    </strong>\n    : These are part of high-speed USB communication and refer to the electrical states used to transmit data (page 490).\n   </li>\n<li>\n<strong>\n     Disconnect Bus State\n    </strong>\n    : This state indicates that a device has been disconnected from the bus (pages 492).\n   </li>\n<li>\n<strong>\n     End-of-High-speed-Packet (HSEOP)\n    </strong>\n    : This bus state marks the end of a high-speed data packet, signaling that the device can transition to the next phase (page 494).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Power Management and Suspend\n   </strong>\n   : Power management is crucial in USB devices. Devices can enter a\n   <strong>\n    suspended state\n   </strong>\n   to conserve power when not actively communicating with the host, and they can be resumed when needed (pages 459\u2013466).\n  </p>\n</li>\n</ul>\n<hr/>\n<h4>\n Wireless and Ethernet Comparisons\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    WirelessUSB\n   </strong>\n   : Some USB devices use\n   <strong>\n    WirelessUSB\n   </strong>\n   , a technology that enables wireless communication over USB. This is particularly useful for applications where wired connections are impractical, such as remote sensors and portable devices (pages 530\u2013534).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Ethernet vs. USB\n   </strong>\n   :\n   <strong>\n    Ethernet\n   </strong>\n   and\n   <strong>\n    USB\n   </strong>\n   are often compared in terms of speed and functionality. USB generally offers higher ease of use, portability, and device variety, while Ethernet is preferred for networking and longer-distance connections (pages 3, 10).\n  </p>\n</li>\n</ul>\n<hr/>\n<p>\n This section provides a detailed breakdown of essential USB development tools, error handling in communication, device setup, and the various states of USB bus activity. It also covers key aspects of memory types like EEPROM and compares USB to other communication technologies like Ethernet.\n</p>\n"}, "Page 581": {"response": "<h3>\n USB Features, Transfers, and Driver Tools\n</h3>\n<p>\n This section explains USB features, types of transfers, and details on how devices interact with USB drivers. It also covers technical terms and protocols related to USB communication, including specifics on\n <strong>\n  feature reports\n </strong>\n ,\n <strong>\n  frame numbers\n </strong>\n , and\n <strong>\n  device requests\n </strong>\n .\n</p>\n<hr/>\n<h4>\n Feature Items and Reports\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Feature Items\n   </strong>\n   : These are specific data points related to USB devices, typically seen in\n   <strong>\n    feature reports\n   </strong>\n   . These include settings or configurations that a device supports and can be queried or modified during communication (pages 356\u2013360).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Feature Reports\n   </strong>\n   : These reports contain the actual data associated with\n   <strong>\n    feature items\n   </strong>\n   . There are two primary functions:\n  </p>\n<ul>\n<li>\n<strong>\n     Reading from Devices\n    </strong>\n    : Feature reports allow the host to retrieve device information (pages 404\u2013405).\n   </li>\n<li>\n<strong>\n     Writing to Devices\n    </strong>\n    : These reports can also be used to send configuration or setting changes to USB devices (pages 402\u2013404).\n   </li>\n</ul>\n</li>\n</ul>\n<hr/>\n<h4>\n USB Transfer Types\n</h4>\n<ul>\n<li>\n<strong>\n   Transfer Types\n  </strong>\n  : There are several transfer types in USB communication, each serving a distinct purpose and characterized by how data is moved between the host and the device:\n  <ul>\n<li>\n<strong>\n     Bulk Transfers\n    </strong>\n    : Used for large data packets, typically for devices like printers and scanners.\n   </li>\n<li>\n<strong>\n     Control Transfers\n    </strong>\n    : Handle setup and command requests, like getting device descriptors.\n   </li>\n<li>\n<strong>\n     Interrupt Transfers\n    </strong>\n    : Handle small, time-sensitive data, used in devices like keyboards or mice.\n   </li>\n<li>\n<strong>\n     Isochronous Transfers\n    </strong>\n    : Used for continuous data flow with precise timing, such as audio and video streaming.\n   </li>\n</ul>\n</li>\n</ul>\n<hr/>\n<h4>\n Frames and Frame Numbers\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Frames\n   </strong>\n   : A\n   <strong>\n    frame\n   </strong>\n   is the smallest unit of USB data transmission. Frames occur in all types of USB transfers and play a role in defining the structure of data packets.\n  </p>\n<ul>\n<li>\n    Frames are used to organize the transmission, with each frame containing specific\n    <strong>\n     frame numbers\n    </strong>\n    and other timing elements to maintain proper synchronization (pages 48, 66\u201367, 71\u201375).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Frame Numbers\n   </strong>\n   : These are crucial for determining when a particular frame was transmitted within a series of frames, helping in maintaining the timing accuracy of data transfers (pages 499\u2013501).\n  </p>\n</li>\n</ul>\n<hr/>\n<h4>\n FireWire and USB Comparison\n</h4>\n<ul>\n<li>\n<strong>\n   FireWire 800 vs. USB\n  </strong>\n  :\n  <strong>\n   FireWire 800\n  </strong>\n  and\n  <strong>\n   USB\n  </strong>\n  are both popular interfaces for connecting devices. However, FireWire offers higher data transfer rates (up to 800 Mbps) but has less widespread support compared to USB. USB, on the other hand, is more versatile and widely used for a variety of peripheral devices (page 3).\n </li>\n</ul>\n<hr/>\n<h4>\n Firmware and Memory Types\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Firmware\n   </strong>\n   : Firmware refers to the software programmed into a device's hardware, like a microcontroller, to control its operations. USB devices often have firmware stored in non-volatile memory like\n   <strong>\n    flash memory\n   </strong>\n   or\n   <strong>\n    EEPROM\n   </strong>\n   , allowing them to be updated as needed (page 146).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Flash Memory\n   </strong>\n   : This type of memory is commonly used in USB devices for storing firmware or other critical data. It is non-volatile, meaning data is preserved even when the device is powered off (page 146).\n  </p>\n</li>\n</ul>\n<hr/>\n<h4>\n Full-Speed USB\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Full Speed USB\n   </strong>\n   :\n   <strong>\n    Full-speed USB\n   </strong>\n   refers to the USB 2.0 standard, which supports data transfer rates of up to 12 Mbps. This is slower than\n   <strong>\n    high-speed USB (480 Mbps)\n   </strong>\n   , but still suitable for many applications (page 5).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Full-Speed Bus States\n   </strong>\n   : USB bus communication includes different states, such as data transfer and idle states, which vary depending on the data speed (pages 490\u2013492).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Full-Speed Transceivers\n   </strong>\n   : These are the components in the USB device or host that enable communication at\n   <strong>\n    full-speed\n   </strong>\n   . They manage the signaling and data transmission (pages 508\u2013512).\n  </p>\n</li>\n</ul>\n<hr/>\n<h4>\n Device Drivers and Communication\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Device Drivers\n   </strong>\n   : USB devices require drivers to communicate with a host computer. The\n   <strong>\n    D2XX Direct driver\n   </strong>\n   is one of the specialized drivers provided by\n   <strong>\n    Future Technology Devices International (FTDI)\n   </strong>\n   for their USB devices. These drivers help establish communication between the host and specific FTDI devices, such as\n   <strong>\n    FT232BM\n   </strong>\n   and\n   <strong>\n    FT245BM\n   </strong>\n   chips (pages 421\u2013426).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Generic Drivers\n   </strong>\n   : For certain devices, a generic driver can be used. These drivers are basic and can work with a wide range of USB devices, simplifying the development process (pages 231, 239, 248).\n  </p>\n</li>\n</ul>\n<hr/>\n<h4>\n USB Requests and Hub Communication\n</h4>\n<ul>\n<li>\n<strong>\n   USB Requests\n  </strong>\n  : USB communication involves several\n  <strong>\n   requests\n  </strong>\n  made between the host and the device to control and configure them. Some important requests include:\n  <ul>\n<li>\n<strong>\n     Get_Configuration Request\n    </strong>\n    : Retrieves the current configuration of a device (page 128).\n   </li>\n<li>\n<strong>\n     Get_Descriptor Request\n    </strong>\n    : Fetches detailed information about the device, such as device descriptors (pages 94, 128).\n   </li>\n<li>\n<strong>\n     Get_Port_Status Request\n    </strong>\n    : Retrieves the status of USB ports, useful for debugging or managing devices connected to a hub (pages 444\u2013454).\n   </li>\n</ul>\n</li>\n</ul>\n<hr/>\n<h4>\n GPIB and USB Comparison\n</h4>\n<ul>\n<li>\n<strong>\n   GPIB (General Purpose Interface Bus)\n  </strong>\n  vs. USB:\n  <strong>\n   GPIB\n  </strong>\n  is an older interface commonly used in instrumentation, whereas\n  <strong>\n   USB\n  </strong>\n  is more modern and offers broader compatibility with a variety of devices. USB is faster, more versatile, and more commonly used for connecting peripheral devices (page 3).\n </li>\n</ul>\n<hr/>\n<p>\n This section highlights the critical concepts and protocols necessary for understanding and working with USB devices, including transfer types, feature reports, frame numbers, and the comparison between different communication technologies like\n <strong>\n  FireWire\n </strong>\n and\n <strong>\n  USB\n </strong>\n . It also discusses device drivers, hub communication, and important USB requests that facilitate device setup and management.\n</p>\n"}, "Page 582": {"response": "<h3>\n GUIDs, Communication Handles, and HID Functions\n</h3>\n<p>\n This section explores key elements of USB communication, including\n <strong>\n  Globally Unique Identifiers (GUIDs)\n </strong>\n , communication handles, handshake processes, and a variety of\n <strong>\n  Human Interface Device (HID)\n </strong>\n functions. It covers the technical terms, protocols, and related API functions for efficient interaction with USB devices.\n</p>\n<hr/>\n<h4>\n Globally Unique Identifiers (GUIDs)\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    GUIDs Overview\n   </strong>\n   : GUIDs are unique identifiers used to ensure distinct recognition of devices, interfaces, and setups across various systems. These are vital in the USB system to ensure proper communication between devices and software.\n  </p>\n<ul>\n<li>\n<strong>\n     Device Interface GUIDs\n    </strong>\n    : These are GUIDs associated with specific device interfaces, used to identify devices and establish communication links (pages 249\u2013252, 292\u2013293).\n   </li>\n<li>\n<strong>\n     Device Setup GUIDs\n    </strong>\n    : GUIDs also identify the setup of devices, helping in configuration and installation processes (pages 249\u2013251, 259\u2013267).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Windows Registry and GUIDs\n   </strong>\n   : GUIDs are stored in the Windows registry, linking them to particular devices or configurations. The registry keys related to GUIDs help identify device characteristics and driver assignments (pages 259\u2013260).\n  </p>\n</li>\n</ul>\n<hr/>\n<h4>\n Communication Handles\n</h4>\n<ul>\n<li>\n<strong>\n   Opening and Closing Communication Handles\n  </strong>\n  : Communication handles are crucial for the data transfer process between a host and a device. A handle must be opened to initiate communication and closed once the transfer is complete.\n  <ul>\n<li>\n<strong>\n     Opening Handles\n    </strong>\n    : To start communication with a USB device, the handle is opened (pages 303\u2013306).\n   </li>\n<li>\n<strong>\n     Closing Handles\n    </strong>\n    : When the communication is complete, it is important to properly close the handle to avoid unnecessary resource consumption (page 306).\n   </li>\n</ul>\n</li>\n</ul>\n<hr/>\n<h4>\n Handshake Process and Status Codes\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Handshake Packets\n   </strong>\n   : Handshakes ensure successful communication by signaling the readiness and acknowledgment of data transfer. These packets are used during each phase of data exchange.\n  </p>\n<ul>\n<li>\n<strong>\n     Handshake Phases\n    </strong>\n    : These occur at different points during transactions to manage the flow of data, confirming the state of each transfer (pages 44\u201353, 120\u2013123).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Handshaking\n   </strong>\n   : The handshaking process controls the flow of communication between devices and the host, and it can be handled by either hardware or software, depending on the system configuration.\n  </p>\n<ul>\n<li>\n<strong>\n     Hardware vs. Software\n    </strong>\n    : Hardware-based handshaking is typically faster, while software-based handshaking allows for more flexibility. Status codes (pages 52\u201355) are used to identify the success or failure of each handshake.\n   </li>\n</ul>\n</li>\n</ul>\n<hr/>\n<h4>\n HID (Human Interface Device) Functions\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    HID API Functions\n   </strong>\n   : HID devices, such as keyboards, mice, and other input devices, use specific API functions to interact with USB systems. These functions facilitate retrieving and sending data, configuring device settings, and handling input and output reports.\n  </p>\n<ul>\n<li>\n<p>\n<strong>\n      Key API Functions\n     </strong>\n     :\n    </p>\n<ul>\n<li>\n<strong>\n       HidD_GetAttributes\n      </strong>\n      : Retrieves the attributes of an HID device (pages 384\u2013383, 381\u2013382).\n     </li>\n<li>\n<strong>\n       HidD_GetFeature/SetFeature\n      </strong>\n      : These functions read and write feature reports, enabling communication with HID devices like gaming controllers or touchpads (pages 378\u2013404).\n     </li>\n<li>\n<strong>\n       HidD_GetReport/GetInputReport\n      </strong>\n      : Used to read input reports from HID devices, such as reading button presses from a mouse or keyboard (pages 378\u2013379, 400).\n     </li>\n<li>\n<strong>\n       HidD_SetOutputReport\n      </strong>\n      : Sends output reports to HID devices, such as sending feedback to a device based on user input (pages 378\u2013379).\n     </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n      Additional Functions\n     </strong>\n     :\n    </p>\n<ul>\n<li>\n<strong>\n       HidP_GetCaps\n      </strong>\n      : Retrieves the capabilities of an HID device, including the types of data it can send and receive (pages 377\u2013385).\n     </li>\n<li>\n<strong>\n       HidP_GetButtons\n      </strong>\n      : Retrieves button data from a device, like a mouse or joystick (pages 379\u2013380).\n     </li>\n<li>\n<strong>\n       HidP_GetButtonCaps\n      </strong>\n      : Provides information about the button capabilities of a device (pages 376\u2013377).\n     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Writing to and Reading from HID Devices\n   </strong>\n   : These functions handle the input and output of data through\n   <strong>\n    feature reports\n   </strong>\n   and\n   <strong>\n    input reports\n   </strong>\n   , both critical in managing the interaction with HID devices.\n  </p>\n<ul>\n<li>\n<strong>\n     Reading Feature and Input Reports\n    </strong>\n    : These are used to fetch information or data states from HID devices (pages 376\u2013387).\n   </li>\n<li>\n<strong>\n     Writing Feature and Output Reports\n    </strong>\n    : These are used to send data or settings to the HID device, such as configuring device modes or sending control data (pages 392\u2013404).\n   </li>\n</ul>\n</li>\n</ul>\n<hr/>\n<h4>\n Additional Concepts\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    Hardware IDs\n   </strong>\n   : These identifiers help the operating system recognize specific hardware. They are stored in the Windows registry and used to match devices with the appropriate drivers (pages 272\u2013274).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Hardware Keys in Windows Registry\n   </strong>\n   : The registry also stores\n   <strong>\n    hardware keys\n   </strong>\n   , which play a role in recognizing and configuring hardware components (pages 258\u2013261).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Hardware Protocol Analyzers\n   </strong>\n   : These tools are used to monitor and analyze USB communication, helping with debugging and ensuring that devices function correctly (pages 472\u2013475).\n  </p>\n</li>\n</ul>\n<hr/>\n<p>\n This section provides a deep dive into essential components for working with USB devices, particularly focusing on\n <strong>\n  GUIDs\n </strong>\n ,\n <strong>\n  communication handles\n </strong>\n , and\n <strong>\n  HID-related API functions\n </strong>\n . Understanding these concepts is crucial for both device developers and engineers looking to work with USB devices effectively.\n</p>\n"}, "Page 583": {"response": "<h3>\n HID API Functions and High-Speed USB Bus States\n</h3>\n<p>\n This section explains\n <strong>\n  Human Interface Device (HID)\n </strong>\n API functions and high-speed USB bus states. It provides insights into how HID devices interact with USB systems through specialized functions, as well as details on USB's high-speed communication protocols.\n</p>\n<hr/>\n<h4>\n HID API Functions\n</h4>\n<p>\n The\n <strong>\n  HID API functions\n </strong>\n are designed to help manage communication between HID devices (like keyboards, mice, and joysticks) and the host computer. These functions handle various operations, from setting button states to retrieving usage information.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Key API Functions\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     HidP_GetSpecificButtonCaps\n    </strong>\n    : Retrieves button capabilities for HID devices, such as buttons on a game controller (page 377).\n   </li>\n<li>\n<strong>\n     HidP_GetSpecificValueCaps\n    </strong>\n    : Gets specific value capabilities for an HID device (page 377).\n   </li>\n<li>\n<strong>\n     HidP_GetUsages and GetUsagesEx\n    </strong>\n    : These functions retrieve usage data for a device, showing what actions or controls the device supports (page 380).\n   </li>\n<li>\n<strong>\n     HidP_GetUsageValue and GetUsageValueArray\n    </strong>\n    : Functions used to get specific usage values for a device (page 379).\n   </li>\n<li>\n<strong>\n     HidP_GetValueCaps\n    </strong>\n    : Retrieves the value capabilities for a device (pages 377, 388).\n   </li>\n<li>\n<strong>\n     HidP_SetButtons and SetData\n    </strong>\n    : These functions set the button states or data for an HID device (pages 379, 380).\n   </li>\n<li>\n<strong>\n     HidP_TranslateUsagesToI8042ScanCodes\n    </strong>\n    : Converts usage data to I8042 scan codes, used in older keyboard systems (page 377).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Additional Functions\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     HidP_UsageAndPageListDifference\n    </strong>\n    : This function helps to identify the difference in usage and page lists (page 377).\n   </li>\n<li>\n<strong>\n     HidRegisterMinidriver\n    </strong>\n    : Registers a minimal driver for HID devices (page 381).\n   </li>\n</ul>\n</li>\n</ul>\n<p>\n These API functions enable comprehensive control over HID devices, including setting buttons, getting device values, and interacting with usage data.\n</p>\n<hr/>\n<h4>\n HID Class Overview\n</h4>\n<p>\n The\n <strong>\n  Human Interface Device (HID) class\n </strong>\n includes devices that users directly interact with, such as keyboards, mice, and game controllers. HID devices can send and receive reports to and from the host computer.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Identifying and Designating HID Devices\n   </strong>\n   : Devices are identified as HID devices through descriptors. These descriptors are key to understanding the capabilities and functions of the HID (pages 323\u2013330).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    HID Reports\n   </strong>\n   : HID devices communicate through reports. There are\n   <strong>\n    feature reports\n   </strong>\n   ,\n   <strong>\n    input reports\n   </strong>\n   , and\n   <strong>\n    output reports\n   </strong>\n   that provide and receive data from the host.\n  </p>\n<ul>\n<li>\n<strong>\n     Receiving Reports\n    </strong>\n    : Reports can be received via\n    <strong>\n     control transfers\n    </strong>\n    (pages 347\u2013348) or\n    <strong>\n     interrupt transfers\n    </strong>\n    (pages 343\u2013345).\n   </li>\n<li>\n<strong>\n     Sending Reports\n    </strong>\n    : Reports can also be sent via\n    <strong>\n     control transfers\n    </strong>\n    (pages 345\u2013348) or\n    <strong>\n     interrupt transfers\n    </strong>\n    (pages 340\u2013342).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    HID Descriptors\n   </strong>\n   : These define the capabilities of HID devices. They include class descriptors, report descriptors, and usage descriptors (pages 323\u2013328). HID devices must comply with specific firmware and hardware requirements for full functionality (pages 321\u2013323).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    HID Limitations\n   </strong>\n   : While HID devices are extremely versatile, they do have limitations in terms of data rate and the types of reports they can manage (pages 320\u2013321).\n  </p>\n</li>\n</ul>\n<hr/>\n<h4>\n High-Speed USB Bus States\n</h4>\n<p>\n The\n <strong>\n  high-speed USB\n </strong>\n protocol supports faster data transfers and is essential for performance in more data-intensive devices.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    High-Speed Bus States\n   </strong>\n   : High-speed USB operates in several distinct bus states:\n  </p>\n<ul>\n<li>\n<strong>\n     High-speed Data J &amp; Data K\n    </strong>\n    : These states represent data transmission at high speeds (page 493).\n   </li>\n<li>\n<strong>\n     High-speed Differential 1 &amp; 2\n    </strong>\n    : These states handle differential signaling during high-speed data transfers (pages 492\u2013493).\n   </li>\n<li>\n<strong>\n     High-speed Disconnect and Idle\n    </strong>\n    : The disconnect state occurs when the connection is inactive, while the idle state is used when no data is being transmitted (pages 494).\n   </li>\n<li>\n<strong>\n     High-speed Squelch\n    </strong>\n    : This state is used to suppress unwanted signals on the bus (page 494).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    High-Speed Transceivers\n   </strong>\n   : Transceivers in high-speed USB systems facilitate faster data transmission rates (pages 512\u2013517). These components are designed to handle the specific voltage and current requirements for high-speed communication.\n  </p>\n</li>\n</ul>\n<hr/>\n<h4>\n Host Computers and Power Management\n</h4>\n<ul>\n<li>\n<strong>\n   Host Computers\n  </strong>\n  : The\n  <strong>\n   host computer\n  </strong>\n  is the central device in the USB system, managing the communication between itself and various connected devices.\n  <ul>\n<li>\n<strong>\n     Bus Speed Support\n    </strong>\n    : Hosts can support different USB speeds, such as full-speed and high-speed USB (pages 36\u201337).\n   </li>\n<li>\n<strong>\n     Power Management\n    </strong>\n    : USB devices rely on the host to supply power, with specific requirements for\n    <strong>\n     bus-powered\n    </strong>\n    and\n    <strong>\n     self-powered\n    </strong>\n    devices (pages 24\u201325, 460\u2013467).\n   </li>\n<li>\n<strong>\n     PC-to-PC Communication\n    </strong>\n    : USB can also be used for\n    <strong>\n     PC-to-PC communication\n    </strong>\n    , allowing direct data exchange between two computers (pages 229\u2013230).\n   </li>\n</ul>\n</li>\n</ul>\n<hr/>\n<p>\n This section highlights important API functions and bus states essential for managing\n <strong>\n  Human Interface Devices (HIDs)\n </strong>\n and\n <strong>\n  high-speed USB\n </strong>\n communication. It also underscores the role of the\n <strong>\n  host computer\n </strong>\n in managing power and speed requirements for efficient data transfer. Understanding these elements is crucial for both developers and engineers working with USB devices.\n</p>\n"}, "Page 584": {"response": "<h3>\n Host Controllers, Hubs, and USB Device Communication\n</h3>\n<p>\n This section explores the role of\n <strong>\n  host controllers\n </strong>\n ,\n <strong>\n  hubs\n </strong>\n , and the essential infrastructure for\n <strong>\n  USB devices\n </strong>\n to communicate effectively. It details how data is managed and routed through different layers of the USB system, and the responsibilities of each component involved.\n</p>\n<hr/>\n<h4>\n Host Controllers\n</h4>\n<p>\n<strong>\n  Host controllers\n </strong>\n play a vital role in USB systems, acting as the central communication hub between the host computer and connected devices. There are various types of host controllers, each with specific functions and responsibilities in the data transfer process.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Types of Host Controllers\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     OHCI (Open Host Controller Interface)\n    </strong>\n    and\n    <strong>\n     UHCI (Universal Host Controller Interface)\n    </strong>\n    : These controllers are used for managing the USB data flow, with the OHCI primarily handling high-speed transfers and UHCI for compatibility with USB 1.1 devices (pages 241\u20132).\n   </li>\n<li>\n<strong>\n     Responsibilities\n    </strong>\n    : Host controllers are responsible for managing the flow of data between devices and the host. This includes ensuring that the correct data packets are sent to the right devices and coordinating the communication process between multiple devices (pages 245\u2013246).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Host Controller Drivers\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    These drivers are software components that allow the host controller to communicate with the operating system. They handle the interface between the hardware and the USB system (page 23).\n   </li>\n<li>\n    Microsoft provides standard host-controller drivers, and additional drivers from other companies, such as\n    <strong>\n     Transdimension\n    </strong>\n    , can offer specific functionalities (pages 479, 548).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Host Negotiation Protocol (HNP)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    This protocol facilitates\n    <strong>\n     host-to-device\n    </strong>\n    negotiations in systems where the host might need to switch roles or devices can take over the host role temporarily (pages 539\u2013541, 545).\n   </li>\n</ul>\n</li>\n</ul>\n<hr/>\n<h4>\n USB Hubs\n</h4>\n<p>\n USB\n <strong>\n  hubs\n </strong>\n are intermediary devices that allow multiple USB devices to connect to a single USB port on the host computer. They play a crucial role in expanding the number of available connections and facilitating communication across the system.\n</p>\n<ul>\n<li>\n<p>\n<strong>\n    Hub Types and Functions\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Bus-powered hubs\n    </strong>\n    : These hubs derive power directly from the USB bus and can support low-power devices (pages 434, 459\u2013462).\n   </li>\n<li>\n<strong>\n     Self-powered hubs\n    </strong>\n    : These hubs use an external power source to supply power to connected devices, allowing them to support higher power-demanding devices (page 462).\n   </li>\n<li>\n<strong>\n     Role of Repeaters\n    </strong>\n    : Hubs act as repeaters by amplifying signals to extend the USB bus and allow for longer cable lengths (pages 435\u2013438).\n   </li>\n<li>\n<strong>\n     Transaction Translators\n    </strong>\n    : In USB hubs, transaction translators are responsible for converting data between different USB speeds (pages 438\u2013444).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Hub Descriptors and Requests\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Hubs communicate with the host via\n    <strong>\n     hub-class descriptors\n    </strong>\n    (pages 448\u2013450). These descriptors describe the capabilities of the hub, such as the number of ports and power options.\n   </li>\n<li>\n<strong>\n     Hub requests\n    </strong>\n    allow the host to interact with the hub and retrieve information about its status or configure its settings (pages 444, 451\u2013452).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Over-Current Protection\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    USB hubs feature over-current protection, which ensures that devices do not draw more power than the system can safely provide. This protects both the hub and the connected devices (page 462\u2013463).\n   </li>\n</ul>\n</li>\n</ul>\n<hr/>\n<h4>\n USB Devices and Power Management\n</h4>\n<p>\n Power management is a critical aspect of the USB system, ensuring that devices receive the appropriate amount of power without overloading the system.\n</p>\n<ul>\n<li>\n<strong>\n   Power Options\n  </strong>\n  :\n  <ul>\n<li>\n    USB hubs and devices support various\n    <strong>\n     power options\n    </strong>\n    , including low-power and bus-powered configurations (pages 461\u2013463).\n   </li>\n<li>\n<strong>\n     Power Switching\n    </strong>\n    : High-performance hubs and devices can switch between different power modes to optimize energy consumption (page 463).\n   </li>\n</ul>\n</li>\n</ul>\n<hr/>\n<h4>\n USB Device Enumeration and Topology\n</h4>\n<p>\n When a new device is connected to the USB, the\n <strong>\n  enumeration process\n </strong>\n begins. This process identifies the device, assigns it a unique address, and sets up necessary communication parameters (page 91). The\n <strong>\n  tiered-star topology\n </strong>\n describes how USB devices are connected through hubs, with the root hub serving as the central connection point (page 18).\n</p>\n<hr/>\n<h4>\n Host Wire Adapters (HWA)\n</h4>\n<p>\n<strong>\n  Host wire adapters (HWA)\n </strong>\n are used in wireless USB communication systems, serving as the bridge between wireless and traditional USB connections (page 533).\n</p>\n<hr/>\n<h4>\n Summary of Key Concepts\n</h4>\n<ul>\n<li>\n<strong>\n   Host Controllers\n  </strong>\n  : Manage data flow between the computer and USB devices.\n </li>\n<li>\n<strong>\n   USB Hubs\n  </strong>\n  : Expand USB connections and provide power management features.\n </li>\n<li>\n<strong>\n   Power Management\n  </strong>\n  : Ensures USB devices operate within safe power limits.\n </li>\n<li>\n<strong>\n   Device Enumeration\n  </strong>\n  : Identifies and configures new devices when connected.\n </li>\n<li>\n<strong>\n   Host Wire Adapters\n  </strong>\n  : Enable wireless USB communication.\n </li>\n</ul>\n<p>\n Understanding these components is crucial for ensuring seamless data transfer and connectivity across USB systems. These devices and protocols work together to enable efficient, high-speed communication in modern computing environments.\n</p>\n"}, "Page 585": {"response": ""}, "Page 586": {"response": "<h3>\n USB Devices, Interfaces, and Related Technologies\n</h3>\n<p>\n This section covers various\n <strong>\n  USB interfaces\n </strong>\n and their characteristics,\n <strong>\n  microcontroller\n </strong>\n usage in USB systems,\n <strong>\n  USB device setup classes\n </strong>\n , and the importance of\n <strong>\n  Windows support\n </strong>\n for USB. It also touches on\n <strong>\n  USB descriptors\n </strong>\n like the\n <strong>\n  Microsoft OS descriptor\n </strong>\n and the\n <strong>\n  USB logo\n </strong>\n .\n</p>\n<hr/>\n<h4>\n USB Descriptors and Items\n</h4>\n<p>\n<strong>\n  Logical Items\n </strong>\n such as\n <strong>\n  Logical Maximum\n </strong>\n and\n <strong>\n  Logical Minimum\n </strong>\n are used to describe the possible values that an item can have. These are particularly important when describing features and input/output items in\n <strong>\n  Human Interface Devices (HID)\n </strong>\n (pages 362\u2013365).\n</p>\n<ul>\n<li>\n<strong>\n   Logical Maximum/Minimum\n  </strong>\n  : Define the range of values that an item can have, such as the maximum and minimum pressure values for a stylus or joystick (pages 362\u2013365).\n </li>\n<li>\n<strong>\n   Long Items\n  </strong>\n  : These refer to items that store long data values, such as those found in certain\n  <strong>\n   HID reports\n  </strong>\n  (pages 354\u2013355).\n </li>\n</ul>\n<hr/>\n<h4>\n USB Logo and Icon\n</h4>\n<p>\n The\n <strong>\n  USB logo\n </strong>\n is a visual mark that identifies compliant USB products. It is an essential part of USB branding and marketing.\n</p>\n<ul>\n<li>\n<strong>\n   USB Logo\n  </strong>\n  : This logo is used on devices that meet the USB standard, signaling compatibility and compliance (pages 477, 484\u2013485).\n </li>\n<li>\n<strong>\n   USB Icon\n  </strong>\n  : Another graphic representation that signifies USB functionality on devices and systems (pages 522, 523).\n </li>\n</ul>\n<hr/>\n<h4>\n USB Speeds and Transceivers\n</h4>\n<ul>\n<li>\n<strong>\n   Low-Speed USB\n  </strong>\n  : Defined as a transfer rate of 1.5 Mbps, this is commonly used for simple devices like keyboards or mice (page 5).\n  <ul>\n<li>\n<strong>\n     Low-Speed Bus States\n    </strong>\n    : There are several low-speed bus states, such as\n    <strong>\n     Keep Alive Signal\n    </strong>\n    (pages 48\u201349), which ensure that devices maintain their connection even during idle periods (pages 490\u2013492).\n   </li>\n<li>\n<strong>\n     Low-Speed Transceivers\n    </strong>\n    : Specialized transceivers are used for low-speed USB devices (pages 508\u2013512).\n   </li>\n</ul>\n</li>\n</ul>\n<hr/>\n<h4>\n Microcontrollers and USB\n</h4>\n<p>\n Microcontrollers play a crucial role in managing USB device functions, often handling data transfer between the USB device and the host.\n</p>\n<ul>\n<li>\n<strong>\n   Microchip Technology\n  </strong>\n  : Known for producing microcontrollers used in USB devices, such as the\n  <strong>\n   PIC16C745\n  </strong>\n  and\n  <strong>\n   PIC16C765\n  </strong>\n  microcontrollers, which are used in devices like USB-to-serial adapters (pages 155, 157, 408\u2013421).\n </li>\n<li>\n<strong>\n   Microcontrollers\n  </strong>\n  : These chips handle the data and control logic of USB devices, enabling devices like\n  <strong>\n   keyboards, mice\n  </strong>\n  , and\n  <strong>\n   USB hubs\n  </strong>\n  to communicate with a host system (page 9).\n </li>\n</ul>\n<hr/>\n<h4>\n USB Transfer Types and Microframes\n</h4>\n<p>\n In USB communications,\n <strong>\n  microframes\n </strong>\n play an essential role in determining the timing and structure of data transfers, especially for\n <strong>\n  isochronous\n </strong>\n and\n <strong>\n  interrupt transfers\n </strong>\n .\n</p>\n<ul>\n<li>\n<strong>\n   Microframes\n  </strong>\n  : USB operates on a 1ms frame-based system, and transfers are managed within these microframes. For example, in\n  <strong>\n   bulk transfers\n  </strong>\n  , data is transmitted over multiple microframes, ensuring accurate delivery and timing (pages 24, 35\u201336, 48, 73\u201380).\n </li>\n<li>\n<strong>\n   Interrupt and Isochronous Transfers\n  </strong>\n  : These are types of USB transfers that rely on accurate timing. Microframes help manage the\n  <strong>\n   synchronization\n  </strong>\n  of data transmission, particularly in real-time systems like video or audio streaming (pages 73\u201375, 76\u201379).\n </li>\n</ul>\n<hr/>\n<h4>\n USB in Windows and Microsoft Technologies\n</h4>\n<p>\n<strong>\n  Microsoft\n </strong>\n plays a significant role in USB development through its support for USB in\n <strong>\n  Windows\n </strong>\n operating systems and its contribution to\n <strong>\n  USB driver models\n </strong>\n .\n</p>\n<ul>\n<li>\n<strong>\n   Windows USB Drivers\n  </strong>\n  : Windows operating systems use\n  <strong>\n   Windows Driver Model (WDM)\n  </strong>\n  drivers for USB devices, ensuring compatibility and efficient communication between the USB device and the system (pages 237\u2013247).\n  <ul>\n<li>\n<strong>\n     WDM Drivers\n    </strong>\n    : These drivers are responsible for managing the USB hardware and software, ensuring that data is transferred correctly between devices (pages 237\u2013247).\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Microsoft OS Descriptor\n  </strong>\n  : A USB descriptor used to provide additional details about the device to Windows, enabling features like automatic driver installation (page 114).\n </li>\n<li>\n<strong>\n   Microsoft Intermediate Language (MSIL)\n  </strong>\n  : A low-level language used in\n  <strong>\n   .NET programming\n  </strong>\n  for USB-related development, enabling cross-platform applications and efficient handling of USB data (pages 282\u2013284).\n </li>\n</ul>\n<hr/>\n<h4>\n USB Interfaces and Setup Classes\n</h4>\n<p>\n Several\n <strong>\n  device setup classes\n </strong>\n are defined in the USB specification, each supporting a different category of USB devices.\n</p>\n<ul>\n<li>\n<strong>\n   Mass Storage Class\n  </strong>\n  : This class supports devices like USB flash drives and external hard drives. It allows devices to function similarly to traditional storage systems (pages 179, 208\u2013213).\n </li>\n<li>\n<strong>\n   MIDIStreaming Interface\n  </strong>\n  : Used for\n  <strong>\n   MIDI\n  </strong>\n  devices like musical instruments and controllers, this interface allows for real-time data streaming (pages 185\u2013188).\n </li>\n</ul>\n<hr/>\n<h4>\n Windows and USB Compatibility\n</h4>\n<p>\n<strong>\n  Windows OS\n </strong>\n provides comprehensive support for USB, ensuring that devices can be recognized and used seamlessly.\n</p>\n<ul>\n<li>\n<strong>\n   Multi-tasking in Windows\n  </strong>\n  : The ability to handle multiple processes simultaneously is crucial for USB device management, especially for high-bandwidth devices (pages 83\u201384).\n </li>\n<li>\n<strong>\n   USB Support on Macintosh\n  </strong>\n  :\n  <strong>\n   Macintosh\n  </strong>\n  computers also support USB, ensuring compatibility across different platforms (pages 7\u20138).\n </li>\n</ul>\n<hr/>\n<h4>\n Logging Events During Device Installation\n</h4>\n<p>\n Logging is crucial during device installation to monitor and troubleshoot issues that may arise.\n</p>\n<ul>\n<li>\n<strong>\n   Logging Installation Events\n  </strong>\n  : The installation process of USB devices often involves logging key events to track the status and identify potential problems during setup (page 277).\n </li>\n</ul>\n<hr/>\n<h3>\n Summary\n</h3>\n<p>\n The\n <strong>\n  USB Logo\n </strong>\n and\n <strong>\n  interface descriptors\n </strong>\n are crucial for device recognition and compliance. USB operates at various speeds, with low-speed systems using specific transceivers and bus states to ensure stable communication.\n <strong>\n  Microcontrollers\n </strong>\n are at the heart of USB devices, managing data transfer and device control. Windows, through its\n <strong>\n  WDM drivers\n </strong>\n , provides support for USB devices, while also offering advanced tools like\n <strong>\n  MSIL\n </strong>\n for custom development. Understanding these components ensures smooth and effective USB communication.\n</p>\n"}, "Page 587": {"response": "<h3>\n USB Communication, Devices, and Protocols\n</h3>\n<p>\n This section explores key concepts related to\n <strong>\n  USB communication protocols\n </strong>\n , the\n <strong>\n  Open Host Controller Interface (OHCI)\n </strong>\n ,\n <strong>\n  On-The-Go (OTG)\n </strong>\n devices, and\n <strong>\n  error handling\n </strong>\n in USB transactions, among other related topics.\n</p>\n<hr/>\n<h4>\n USB Handshakes and Data Communication\n</h4>\n<p>\n<strong>\n  USB Handshakes\n </strong>\n are an essential part of the communication process in USB transactions. They help manage data flow between the host and the device.\n</p>\n<ul>\n<li>\n<strong>\n   NAK (Negative Acknowledge) Handshake\n  </strong>\n  : This is used when a device cannot process data at the moment. It sends a\n  <strong>\n   NAK\n  </strong>\n  signal to the host, indicating that the transaction should be retried later (pages 48, 52, 53, 55\u201356).\n </li>\n<li>\n<strong>\n   NYET (Not Yet) Handshake\n  </strong>\n  : This is used in high-speed transactions when a device needs more time to respond. It indicates that the transaction isn't ready but will be completed shortly (pages 48, 52, 53, 54\u201355).\n </li>\n</ul>\n<p>\n These handshakes are part of the\n <strong>\n  transaction phases\n </strong>\n in USB data transfer, including the\n <strong>\n  token phase\n </strong>\n ,\n <strong>\n  data phase\n </strong>\n , and\n <strong>\n  handshake phase\n </strong>\n .\n</p>\n<hr/>\n<h4>\n On-The-Go (OTG) Devices\n</h4>\n<p>\n<strong>\n  On-The-Go (OTG)\n </strong>\n devices enable direct communication between two devices without the need for a host. This allows for peer-to-peer data transfers, such as between a smartphone and a USB stick.\n</p>\n<ul>\n<li>\n<strong>\n   OTG Capabilities\n  </strong>\n  : OTG devices can act as either a host or a device, depending on the situation. They are particularly useful for mobile devices that need to connect with peripherals like USB drives or keyboards (pages 536\u2013538).\n </li>\n<li>\n<strong>\n   OTG Connectors and Cables\n  </strong>\n  : OTG devices use special connectors and cables that facilitate bidirectional communication. This flexibility enables devices like smartphones to directly connect to a variety of USB peripherals (pages 542\u2013544).\n </li>\n<li>\n<strong>\n   OTG Controllers\n  </strong>\n  : The\n  <strong>\n   Cypress CY7C67200 EZ-OTG\n  </strong>\n  and\n  <strong>\n   Philips ISP1362\n  </strong>\n  are examples of\n  <strong>\n   OTG controller chips\n  </strong>\n  that manage the connection between devices in OTG mode (pages 545\u2013549).\n </li>\n<li>\n<strong>\n   OTG Descriptor\n  </strong>\n  : This descriptor is used to indicate that a device is capable of OTG functionality, and it defines the capabilities and limitations of OTG support (pages 95, 113, 545\u2013546).\n </li>\n</ul>\n<hr/>\n<h4>\n USB Protocols: Packets and Transactions\n</h4>\n<p>\n<strong>\n  USB Packets\n </strong>\n consist of several components that manage data transfer between devices and hosts. These include data, handshake, and token packets, which each play a role in ensuring that data is transmitted correctly.\n</p>\n<ul>\n<li>\n<strong>\n   Packet IDs (PIDs)\n  </strong>\n  : Each packet in USB communication is identified by a\n  <strong>\n   Packet ID (PID)\n  </strong>\n  . Common PIDs include:\n  <ul>\n<li>\n<strong>\n     ERR\n    </strong>\n    : Indicates an error during communication.\n   </li>\n<li>\n<strong>\n     PING\n    </strong>\n    : Used to check the status of a device.\n   </li>\n<li>\n<strong>\n     SPLIT\n    </strong>\n    : Used in\n    <strong>\n     high-speed transactions\n    </strong>\n    involving multiple devices.\n   </li>\n<li>\n<strong>\n     PRE\n    </strong>\n    : Signals the start of a transaction (pages 45\u201346, 48\u201350).\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Handshake Packets\n  </strong>\n  : These packets signal the success or failure of a transaction and include NAK, NYET, and others, ensuring the reliable transmission of data (pages 44\u201350).\n </li>\n<li>\n<strong>\n   Transaction Phases\n  </strong>\n  : USB transactions are broken into three main phases: the\n  <strong>\n   token phase\n  </strong>\n  , the\n  <strong>\n   data phase\n  </strong>\n  , and the\n  <strong>\n   handshake phase\n  </strong>\n  . Each phase involves different types of packets (pages 45\u201351).\n </li>\n<li>\n<strong>\n   Inter-packet Delay\n  </strong>\n  : The time delay between sending multiple packets, which can affect the overall communication speed (page 501).\n </li>\n</ul>\n<hr/>\n<h4>\n Error Handling in USB\n</h4>\n<p>\n<strong>\n  Error Handling\n </strong>\n is crucial in USB communication to ensure data integrity and reliability.\n</p>\n<ul>\n<li>\n<strong>\n   Error Checking\n  </strong>\n  : USB uses\n  <strong>\n   error checking\n  </strong>\n  in the form of handshake packets, such as\n  <strong>\n   NAK\n  </strong>\n  and\n  <strong>\n   NYET\n  </strong>\n  , to indicate if a transaction needs to be retried or adjusted (pages 57\u201359).\n </li>\n<li>\n<strong>\n   Data Toggle\n  </strong>\n  : A method to track and manage data integrity by toggling a bit between consecutive transactions (page 57).\n </li>\n</ul>\n<hr/>\n<h4>\n Memory and Programming in USB\n</h4>\n<p>\n<strong>\n  Memory\n </strong>\n and\n <strong>\n  programming\n </strong>\n aspects are essential when dealing with USB devices, especially for device setup and data handling.\n</p>\n<ul>\n<li>\n<strong>\n   OTP (One-Time Programmable) ROM\n  </strong>\n  : Used in USB devices,\n  <strong>\n   OTP ROM\n  </strong>\n  allows data to be programmed once and cannot be modified afterward. This is commonly used for device identification and setup (pages 146, 149).\n </li>\n</ul>\n<hr/>\n<h4>\n USB Interfaces: OHCI and USB Standards\n</h4>\n<p>\n<strong>\n  OHCI (Open Host Controller Interface)\n </strong>\n is one of the USB host controller standards, primarily used for low-speed and full-speed devices.\n</p>\n<ul>\n<li>\n<strong>\n   OHCI Standard\n  </strong>\n  : Developed by\n  <strong>\n   National Semiconductor\n  </strong>\n  ,\n  <strong>\n   OHCI\n  </strong>\n  is one of the primary protocols for managing USB data transmission, particularly for devices that do not require high data throughput (pages 239, 241).\n </li>\n</ul>\n<hr/>\n<h4>\n Over-Current Protection\n</h4>\n<p>\n<strong>\n  Over-Current Protection\n </strong>\n is crucial in USB systems to prevent damage to devices and hosts due to excessive power draw.\n</p>\n<ul>\n<li>\n<strong>\n   Over-Current Protection\n  </strong>\n  : Devices are designed to handle over-current situations by cutting off power or sending a notification if the current exceeds safe limits (pages 462\u2013463).\n </li>\n</ul>\n<hr/>\n<h4>\n Parallel Ports and Converters\n</h4>\n<p>\n USB can also be used to bridge connections between\n <strong>\n  parallel ports\n </strong>\n and other systems.\n</p>\n<ul>\n<li>\n<strong>\n   Parallel Port Converters\n  </strong>\n  : These converters allow communication between USB and older parallel ports, enabling USB-enabled systems to interface with legacy devices (page 229).\n </li>\n</ul>\n<hr/>\n<h3>\n Summary\n</h3>\n<p>\n This section covers the essential aspects of\n <strong>\n  USB communication\n </strong>\n , including\n <strong>\n  handshakes\n </strong>\n (NAK, NYET),\n <strong>\n  OTG devices\n </strong>\n ,\n <strong>\n  packet IDs\n </strong>\n , and\n <strong>\n  error handling\n </strong>\n .\n <strong>\n  On-The-Go (OTG)\n </strong>\n functionality provides flexible peer-to-peer communication between devices, while\n <strong>\n  OHCI\n </strong>\n manages host-controller data transfers. Additionally, key topics like\n <strong>\n  OTP ROM memory\n </strong>\n ,\n <strong>\n  over-current protection\n </strong>\n , and\n <strong>\n  parallel port converters\n </strong>\n contribute to the comprehensive understanding of USB technology and its applications.\n</p>\n"}, "Page 588": {"response": "<h3>\n USB Power, Ports, and Devices\n</h3>\n<p>\n This section focuses on important\n <strong>\n  USB power management\n </strong>\n , the types of\n <strong>\n  ports\n </strong>\n used for USB connections,\n <strong>\n  programming\n </strong>\n considerations for USB devices, and specific\n <strong>\n  controllers\n </strong>\n from various manufacturers. It also covers key\n <strong>\n  protocol analysis tools\n </strong>\n and components like\n <strong>\n  microcontrollers\n </strong>\n used in USB device development.\n</p>\n<hr/>\n<h4>\n USB Power Management\n</h4>\n<p>\n USB power management is essential for proper device functionality and energy efficiency.\n</p>\n<ul>\n<li>\n<strong>\n   Power Consumption\n  </strong>\n  : USB devices vary in power consumption, depending on their function. This can affect the performance of both the host and the device. USB devices can be\n  <strong>\n   bus-powered\n  </strong>\n  or\n  <strong>\n   self-powered\n  </strong>\n  (pages 455\u2013469).\n </li>\n<li>\n<strong>\n   Power Supplies\n  </strong>\n  : USB power is typically supplied through\n  <strong>\n   bus-powered devices\n  </strong>\n  or\n  <strong>\n   self-powered devices\n  </strong>\n  . The power from the USB bus is often limited, with each device drawing a specific amount of current (pages 455\u2013458). Devices must manage their power requirements effectively to avoid overloading the system.\n </li>\n<li>\n<strong>\n   Power Switching\n  </strong>\n  : Some USB devices are capable of switching between bus power and self-power modes. This is essential for managing energy consumption and ensuring devices do not exceed their power limits (page 463).\n </li>\n</ul>\n<hr/>\n<h4>\n USB Ports and Connectors\n</h4>\n<p>\n USB devices use different types of\n <strong>\n  ports\n </strong>\n for connection, which determine how data and power are exchanged.\n</p>\n<ul>\n<li>\n<strong>\n   USB Ports\n  </strong>\n  : The\n  <strong>\n   USB port\n  </strong>\n  is the physical interface through which a device connects to a host or hub. The port is responsible for both\n  <strong>\n   data transmission\n  </strong>\n  and\n  <strong>\n   power distribution\n  </strong>\n  (page 21).\n </li>\n<li>\n<strong>\n   Parallel Ports\n  </strong>\n  : Though less common today,\n  <strong>\n   parallel ports\n  </strong>\n  are still used for certain legacy devices. These ports can be adapted to USB with special converters (page 229).\n </li>\n<li>\n<strong>\n   Indicators for Ports\n  </strong>\n  :\n  <strong>\n   USB port indicators\n  </strong>\n  show the status of the port, including whether the port is active or has power, helping users quickly understand the port\u2019s state (pages 453\u2013454).\n </li>\n</ul>\n<hr/>\n<h4>\n USB Device Programming and Controllers\n</h4>\n<p>\n USB device development often requires working with specific\n <strong>\n  microcontrollers\n </strong>\n and\n <strong>\n  controllers\n </strong>\n that manage communication and functionality.\n</p>\n<ul>\n<li>\n<strong>\n   Microcontrollers\n  </strong>\n  : Common\n  <strong>\n   microcontrollers\n  </strong>\n  used in USB devices include the\n  <strong>\n   PIC16F877\n  </strong>\n  ,\n  <strong>\n   PIC18F4550\n  </strong>\n  , and\n  <strong>\n   PIC16C745\n  </strong>\n  . These microcontrollers manage data transfer and device behavior. For example, the\n  <strong>\n   PIC16F877\n  </strong>\n  is used in examples involving the\n  <strong>\n   FT232BM\n  </strong>\n  device controller (pages 155, 156\u2013157, 338\u2013349).\n </li>\n<li>\n<strong>\n   Device Programmable Memory\n  </strong>\n  : USB devices often include\n  <strong>\n   program memory\n  </strong>\n  , such as\n  <strong>\n   EPROM\n  </strong>\n  or\n  <strong>\n   flash memory\n  </strong>\n  , for storing device configurations and program code (pages 145\u2013147).\n </li>\n<li>\n<strong>\n   Controller Chips\n  </strong>\n  : Companies like\n  <strong>\n   Philips\n  </strong>\n  and\n  <strong>\n   Prolific Technology\n  </strong>\n  produce controller chips such as the\n  <strong>\n   ISP1181B\n  </strong>\n  and\n  <strong>\n   NET2272\n  </strong>\n  , which help manage the communication between USB devices and hosts (pages 166\u2013170, 153\u2013154).\n </li>\n</ul>\n<hr/>\n<h4>\n Protocol Analyzers and Development Tools\n</h4>\n<p>\n For effective USB development and troubleshooting,\n <strong>\n  protocol analyzers\n </strong>\n are essential tools. These devices capture and analyze the data traffic between the host and USB devices.\n</p>\n<ul>\n<li>\n<strong>\n   Protocol Analyzers\n  </strong>\n  : Tools like the\n  <strong>\n   Ellisys USB Explorer\n  </strong>\n  help developers understand how data is being transmitted over USB. These tools are particularly useful in debugging and ensuring that devices are communicating correctly (pages 471\u2013475).\n </li>\n<li>\n<strong>\n   Software Tools\n  </strong>\n  : Software protocol analyzers complement the hardware analyzers, providing a detailed view of USB communication and helping developers monitor transaction traffic in real-time (pages 475\u2013477).\n </li>\n</ul>\n<hr/>\n<h4>\n USB Product Identification\n</h4>\n<p>\n Each USB device has a\n <strong>\n  Product ID (PID)\n </strong>\n that uniquely identifies it, which can be crucial for development, troubleshooting, and customization.\n</p>\n<ul>\n<li>\n<strong>\n   Product ID (PID)\n  </strong>\n  : The\n  <strong>\n   PID\n  </strong>\n  is a unique identifier for each USB device. It can be used in combination with a\n  <strong>\n   Vendor ID (VID)\n  </strong>\n  to identify the manufacturer and model of the device (pages 272, 274\u2013275).\n </li>\n<li>\n<strong>\n   INF Files\n  </strong>\n  :\n  <strong>\n   INF files\n  </strong>\n  play an essential role in identifying devices and configuring drivers. The\n  <strong>\n   PID\n  </strong>\n  is often included in\n  <strong>\n   INF files\n  </strong>\n  to assist with proper device installation on Windows operating systems (pages 269, 278).\n </li>\n<li>\n<strong>\n   Customizing Product IDs\n  </strong>\n  : Developers can also\n  <strong>\n   customize the PID\n  </strong>\n  to create a unique identifier for their devices, facilitating easier management and identification in custom setups (pages 429, 486).\n </li>\n</ul>\n<hr/>\n<h4>\n USB Device Emulation and Legacy Hardware\n</h4>\n<p>\n USB support can be extended to\n <strong>\n  legacy hardware\n </strong>\n through emulation.\n</p>\n<ul>\n<li>\n<strong>\n   Emulating Devices\n  </strong>\n  : Some systems can emulate USB devices to work with legacy hardware, allowing older devices to communicate through USB ports. This feature is particularly useful for integrating modern systems with older technology (pages 153\u2013154).\n </li>\n<li>\n<strong>\n   Legacy Hardware\n  </strong>\n  : Some\n  <strong>\n   legacy hardware\n  </strong>\n  may not natively support USB but can be adapted using special USB interfaces or adapters, extending the life of older equipment and integrating it with modern USB technology (pages 11\u201312).\n </li>\n</ul>\n<hr/>\n<h3>\n Summary\n</h3>\n<p>\n In this section, we covered various aspects of USB communication, focusing on\n <strong>\n  power management\n </strong>\n ,\n <strong>\n  ports\n </strong>\n ,\n <strong>\n  device programming\n </strong>\n , and\n <strong>\n  protocol analysis tools\n </strong>\n . USB devices rely on effective power consumption management, and the USB port plays a crucial role in data and power transmission.\n <strong>\n  Microcontrollers\n </strong>\n and\n <strong>\n  controller chips\n </strong>\n are fundamental in the development and operation of USB devices. Additionally,\n <strong>\n  protocol analyzers\n </strong>\n help developers troubleshoot and optimize USB communication.\n</p>\n"}, "Page 589": {"response": "<h3>\n USB Functions, Memory, and Requests\n</h3>\n<p>\n This section explains key\n <strong>\n  USB functions\n </strong>\n like\n <strong>\n  API calls\n </strong>\n for managing communication,\n <strong>\n  memory types\n </strong>\n in USB devices,\n <strong>\n  requests\n </strong>\n used in device communication, and components like the\n <strong>\n  root hub\n </strong>\n and\n <strong>\n  repeaters\n </strong>\n that enable proper USB operation.\n</p>\n<hr/>\n<h4>\n USB API Functions\n</h4>\n<p>\n The\n <strong>\n  API functions\n </strong>\n allow developers to interact with USB devices by sending and receiving data, managing reports, and handling device notifications.\n</p>\n<ul>\n<li>\n<strong>\n   ReadFile API Function\n  </strong>\n  : This function is used for reading data from USB devices. It provides access to reading input reports and managing communication data. It is essential for\n  <strong>\n   handling data transfer\n  </strong>\n  in HID devices (pages 376, 379, 392\u2013401).\n </li>\n<li>\n<strong>\n   RegisterDeviceNotification API Function\n  </strong>\n  : This function allows an application to register for notifications regarding\n  <strong>\n   device changes\n  </strong>\n  . It is crucial for managing dynamic device interactions (pages 307\u2013311). The function can be used in\n  <strong>\n   Visual Basic\n  </strong>\n  and\n  <strong>\n   Visual C++\n  </strong>\n  code.\n </li>\n</ul>\n<hr/>\n<h4>\n USB Memory and Registers\n</h4>\n<p>\n USB devices use various types of memory to store configuration data, firmware, and device-specific information.\n</p>\n<ul>\n<li>\n<strong>\n   Read-Only Memory (ROM)\n  </strong>\n  : ROM is a type of memory used to store firmware that cannot be altered by regular processes. USB devices often use\n  <strong>\n   read-only memory\n  </strong>\n  for storing configuration data (page 146).\n </li>\n<li>\n<strong>\n   Registers in USB Controllers\n  </strong>\n  : USB controllers use\n  <strong>\n   registers\n  </strong>\n  to manage device communication and functionality. These registers store essential data for the operation of the device (pages 144\u2013145).\n </li>\n</ul>\n<hr/>\n<h4>\n USB Requests\n</h4>\n<p>\n USB devices communicate with the host using\n <strong>\n  requests\n </strong>\n . These are standardized commands used to configure devices, manage device features, or retrieve information from devices.\n</p>\n<ul>\n<li>\n<strong>\n   Standard Requests\n  </strong>\n  : These include requests like\n  <strong>\n   Get_Configuration\n  </strong>\n  ,\n  <strong>\n   Get_Descriptor\n  </strong>\n  ,\n  <strong>\n   Set_Address\n  </strong>\n  , and\n  <strong>\n   Set_Configuration\n  </strong>\n  that help configure and retrieve information from USB devices (pages 128, 133\u2013136).\n </li>\n<li>\n<strong>\n   Vendor-Specific Requests\n  </strong>\n  : Some devices use\n  <strong>\n   vendor-specific requests\n  </strong>\n  for manufacturer-specific functions or features that go beyond the standard USB protocol (page 140).\n </li>\n<li>\n<strong>\n   Feature Requests\n  </strong>\n  : The\n  <strong>\n   Clear_Feature\n  </strong>\n  and\n  <strong>\n   Set_Feature\n  </strong>\n  requests allow the host to enable or disable specific device features, while other requests like\n  <strong>\n   Synch_Frame\n  </strong>\n  are used for synchronization (pages 128\u2013132, 139).\n </li>\n</ul>\n<hr/>\n<h4>\n Report Management in HID Devices\n</h4>\n<p>\n HID (Human Interface Devices) communicate using\n <strong>\n  reports\n </strong>\n . Reports include data like mouse movements, keyboard presses, or other device-specific information. Various\n <strong>\n  report-related items\n </strong>\n describe the format and structure of these reports.\n</p>\n<ul>\n<li>\n<strong>\n   Report Descriptors\n  </strong>\n  :\n  <strong>\n   HID report descriptors\n  </strong>\n  define the structure and size of data used in HID communication. They include items like\n  <strong>\n   Report ID\n  </strong>\n  ,\n  <strong>\n   Report Size\n  </strong>\n  , and\n  <strong>\n   Report Count\n  </strong>\n  to describe the data (pages 328\u2013330).\n </li>\n<li>\n<strong>\n   Reading and Writing Reports\n  </strong>\n  : Functions like\n  <strong>\n   ReadFile\n  </strong>\n  manage reading\n  <strong>\n   input reports\n  </strong>\n  from devices, while\n  <strong>\n   writing output reports\n  </strong>\n  involves sending data to devices using functions that support different transfer types (control and interrupt transfers) (pages 389\u2013401).\n </li>\n<li>\n<strong>\n   Data Conversion\n  </strong>\n  : When reading reports, the raw data often needs to be\n  <strong>\n   converted\n  </strong>\n  into usable formats or\n  <strong>\n   units\n  </strong>\n  (pages 365\u2013369).\n </li>\n</ul>\n<hr/>\n<h4>\n USB Components\n</h4>\n<ul>\n<li>\n<strong>\n   Root Hub\n  </strong>\n  : The\n  <strong>\n   root hub\n  </strong>\n  is the central connection point for USB devices on the host system. It handles communication with devices directly connected to the system and manages power distribution (pages 17\u201323, 86, 254, 434, 461).\n </li>\n<li>\n<strong>\n   Repeaters\n  </strong>\n  :\n  <strong>\n   USB repeaters\n  </strong>\n  extend the reach of USB signals, helping devices communicate over longer distances than what the standard USB specification allows (pages 435\u2013438).\n </li>\n</ul>\n<hr/>\n<h4>\n Power Management and Bus States\n</h4>\n<p>\n USB devices must manage their\n <strong>\n  power\n </strong>\n and\n <strong>\n  bus states\n </strong>\n effectively for proper operation.\n</p>\n<ul>\n<li>\n<strong>\n   Remote Wakeup\n  </strong>\n  : Some devices have the ability to\n  <strong>\n   wake up\n  </strong>\n  from a low-power state using the\n  <strong>\n   remote wakeup feature\n  </strong>\n  . This can be\n  <strong>\n   enabled or disabled\n  </strong>\n  based on the device\u2019s needs (pages 464\u2013468). For\n  <strong>\n   OTG devices\n  </strong>\n  , this feature allows power-saving modes while still maintaining functionality (page 542).\n </li>\n<li>\n<strong>\n   Bus State Resumption\n  </strong>\n  : USB devices must also handle\n  <strong>\n   resuming bus states\n  </strong>\n  after a\n  <strong>\n   reset\n  </strong>\n  or sleep mode. The\n  <strong>\n   Resume state\n  </strong>\n  ensures proper continuation of communication (page 491).\n </li>\n</ul>\n<hr/>\n<h4>\n Additional Technical Concepts\n</h4>\n<ul>\n<li>\n<strong>\n   Resistor Types\n  </strong>\n  :\n  <strong>\n   Pull-up\n  </strong>\n  and\n  <strong>\n   pull-down resistors\n  </strong>\n  are crucial for proper signal transmission and device detection. They help ensure devices can communicate correctly, particularly when determining the state of a line (pages 446, 509\u2013513).\n </li>\n<li>\n<strong>\n   Report Items\n  </strong>\n  : In addition to basic report descriptors, there are other important items like\n  <strong>\n   Global\n  </strong>\n  ,\n  <strong>\n   Local\n  </strong>\n  , and\n  <strong>\n   Main item types\n  </strong>\n  that describe the structure of data in\n  <strong>\n   HID reports\n  </strong>\n  (pages 361\u2013373).\n </li>\n</ul>\n<hr/>\n<h3>\n Summary\n</h3>\n<p>\n This section outlined key USB functionality, including\n <strong>\n  API functions\n </strong>\n for reading and managing data,\n <strong>\n  memory types\n </strong>\n like ROM for storing device information, and\n <strong>\n  USB requests\n </strong>\n for device configuration. We also discussed the structure and management of\n <strong>\n  HID reports\n </strong>\n and the components like the\n <strong>\n  root hub\n </strong>\n and\n <strong>\n  repeaters\n </strong>\n that support USB operation.\n <strong>\n  Power management\n </strong>\n and\n <strong>\n  bus state\n </strong>\n handling are also critical for USB devices to ensure reliability and efficient operation.\n</p>\n"}, "Page 590": {"response": "<h3>\n Key USB Concepts: Interfaces, Requests, and Protocols\n</h3>\n<p>\n This section focuses on\n <strong>\n  USB-related interfaces\n </strong>\n such as\n <strong>\n  RS-232\n </strong>\n and\n <strong>\n  RS-485\n </strong>\n ,\n <strong>\n  USB requests\n </strong>\n , and the\n <strong>\n  Session Request Protocol (SRP)\n </strong>\n , as well as key components and tools for USB device management, including\n <strong>\n  serial interface engines (SIEs)\n </strong>\n and\n <strong>\n  shielding\n </strong>\n .\n</p>\n<hr/>\n<h4>\n RS-232 and RS-485 Interfaces\n</h4>\n<ul>\n<li>\n<strong>\n   RS-232\n  </strong>\n  : This is a\n  <strong>\n   serial communication standard\n  </strong>\n  typically used for connecting computers and peripheral devices.\n  <strong>\n   Converters\n  </strong>\n  between\n  <strong>\n   RS-232\n  </strong>\n  and USB are used to enable communication between devices that utilize different communication protocols (pages 11, 227\u2013229).\n  <strong>\n   RS-232\n  </strong>\n  uses\n  <strong>\n   single-ended lines\n  </strong>\n  , which are more prone to noise (page 527).\n  <ul>\n<li>\n<strong>\n     RS-232 vs. USB\n    </strong>\n    : USB offers better noise immunity, higher data transfer rates, and more efficient power management compared to\n    <strong>\n     RS-232\n    </strong>\n    (pages 3, 10, 22).\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   RS-485\n  </strong>\n  : Another\n  <strong>\n   serial communication standard\n  </strong>\n  typically used for industrial applications.\n  <strong>\n   Converters\n  </strong>\n  are also available to interface\n  <strong>\n   RS-485\n  </strong>\n  with USB systems (page 11).\n  <ul>\n<li>\n<strong>\n     RS-485 vs. USB\n    </strong>\n    : Like RS-232,\n    <strong>\n     RS-485\n    </strong>\n    is generally slower and uses differential signaling, whereas USB is designed for higher speeds and greater device interoperability (pages 3, 10).\n   </li>\n</ul>\n</li>\n</ul>\n<hr/>\n<h4>\n USB Requests\n</h4>\n<p>\n<strong>\n  USB requests\n </strong>\n are specific commands sent between the host and device to configure or control USB devices. Below are key requests and their functions:\n</p>\n<ul>\n<li>\n<strong>\n   Set_Address\n  </strong>\n  : Assigns a device address for identification (page 128).\n </li>\n<li>\n<strong>\n   Set_Configuration\n  </strong>\n  : Configures the device\u2019s initial configuration (page 128).\n </li>\n<li>\n<strong>\n   Set_Descriptor\n  </strong>\n  : Modifies a descriptor, which provides device or configuration information (page 128).\n </li>\n<li>\n<strong>\n   Set_Feature\n  </strong>\n  : Enables or disables a specific feature for the device (page 128).\n </li>\n<li>\n<strong>\n   Set_Hub_Feature\n  </strong>\n  : Configures a feature of a hub (page 451).\n </li>\n<li>\n<strong>\n   Set_Idle\n  </strong>\n  : Sets the idle state of a device (page 331).\n </li>\n<li>\n<strong>\n   Set_Interface\n  </strong>\n  : Configures the device interface (page 128).\n </li>\n<li>\n<strong>\n   Set_Port_Feature\n  </strong>\n  : Modifies port-specific features on a hub (page 451).\n </li>\n<li>\n<strong>\n   Set_Protocol\n  </strong>\n  : Defines the protocol used by a device (page 331).\n </li>\n<li>\n<strong>\n   Set_Report\n  </strong>\n  : Sets a report for an HID device (page 331).\n </li>\n</ul>\n<hr/>\n<h4>\n Session Request Protocol (SRP)\n</h4>\n<p>\n The\n <strong>\n  Session Request Protocol (SRP)\n </strong>\n is a key part of\n <strong>\n  Wireless USB\n </strong>\n . It allows devices to communicate over short-range wireless connections, specifically for\n <strong>\n  On-The-Go (OTG) devices\n </strong>\n . SRP helps devices manage communication when not directly connected to a host system (pages 541\u2013542, 545).\n</p>\n<hr/>\n<h4>\n Serial Interface Engines (SIEs)\n</h4>\n<p>\n<strong>\n  Serial Interface Engines (SIEs)\n </strong>\n are crucial components that facilitate\n <strong>\n  USB data communication\n </strong>\n . They handle protocol management, enabling efficient communication between devices.\n</p>\n<ul>\n<li>\n<strong>\n   Microchip PIC18F4550\n  </strong>\n  : The PIC18F4550 microcontroller integrates an SIE to support USB connectivity, allowing communication between the\n  <strong>\n   host and device\n  </strong>\n  (page 157).\n </li>\n<li>\n<strong>\n   USB Controllers\n  </strong>\n  : SIEs are present in USB controllers to manage data transfer and ensure proper handling of USB transactions (page 143).\n </li>\n<li>\n<strong>\n   PC-to-PC Communication\n  </strong>\n  : SIEs also play a role in enabling\n  <strong>\n   peer-to-peer communication\n  </strong>\n  between two PCs over USB (page 230).\n </li>\n</ul>\n<hr/>\n<h4>\n Shielding and Signal Integrity\n</h4>\n<p>\n Maintaining\n <strong>\n  signal quality\n </strong>\n is critical for USB communication to prevent data loss or corruption, especially as the signal travels over cables.\n</p>\n<ul>\n<li>\n<strong>\n   Shielding\n  </strong>\n  :\n  <strong>\n   Shielding\n  </strong>\n  prevents electromagnetic interference (EMI) from disrupting the signal and is crucial for maintaining signal integrity (pages 528\u2013529).\n </li>\n<li>\n<strong>\n   Signal Quality Factors\n  </strong>\n  :\n  <ul>\n<li>\n<strong>\n     Edge Rate Factor\n    </strong>\n    : Affects how quickly signals transition from one state to another, which influences the clarity of the signal (page 529).\n   </li>\n<li>\n<strong>\n     Twisted Pairs\n    </strong>\n    : Used to reduce noise and improve signal quality by carrying complementary signals (pages 527\u2013528).\n   </li>\n<li>\n<strong>\n     Galvanic Isolation\n    </strong>\n    : Isolates electrical circuits to prevent damage from voltage spikes and maintain signal integrity (pages 529\u2013530).\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Signal Voltages\n  </strong>\n  : USB operates at specific voltage levels, typically\n  <strong>\n   3.3V\n  </strong>\n  or\n  <strong>\n   5V\n  </strong>\n  , to ensure proper data transmission (pages 517\u2013518).\n </li>\n</ul>\n<hr/>\n<h4>\n Power Management for USB Devices\n</h4>\n<p>\n USB devices can be either\n <strong>\n  self-powered\n </strong>\n or\n <strong>\n  bus-powered\n </strong>\n .\n <strong>\n  Self-powered devices\n </strong>\n use their own power source, such as a battery or external power supply, while\n <strong>\n  bus-powered devices\n </strong>\n draw power directly from the host.\n</p>\n<ul>\n<li>\n<strong>\n   Self-Powered Devices\n  </strong>\n  : These devices include features like\n  <strong>\n   over-current protection\n  </strong>\n  and\n  <strong>\n   power switching\n  </strong>\n  to ensure safe operation and efficient power consumption (pages 456\u2013459, 462\u2013463).\n </li>\n</ul>\n<hr/>\n<h4>\n Tools and Hardware for USB Development\n</h4>\n<ul>\n<li>\n<p>\n<strong>\n    SBAE-30 Analyzer/Exerciser\n   </strong>\n   : This tool is used for testing and analyzing USB systems. It can exercise the USB protocol, checking for compliance and helping in debugging USB systems (page 477).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    SetupDi API Functions\n   </strong>\n   : These\n   <strong>\n    Windows API functions\n   </strong>\n   allow developers to interact with device interfaces and retrieve detailed information about connected USB devices.\n  </p>\n<ul>\n<li>\n<strong>\n     SetupDiEnumDeviceInterfaces\n    </strong>\n    : Enumerates all device interfaces for a specified device (pages 295\u2013298).\n   </li>\n<li>\n<strong>\n     SetupDiGetDeviceInterfaceDetail\n    </strong>\n    : Retrieves detailed information about a specific device interface (pages 298\u2013301).\n   </li>\n<li>\n<strong>\n     SetupDiDestroyDeviceInfoList\n    </strong>\n    : Cleans up and frees memory used for device information lists (page 292).\n   </li>\n</ul>\n</li>\n</ul>\n<hr/>\n<h3>\n Summary\n</h3>\n<p>\n This section covered essential\n <strong>\n  USB interfaces\n </strong>\n like\n <strong>\n  RS-232\n </strong>\n and\n <strong>\n  RS-485\n </strong>\n , along with key\n <strong>\n  USB requests\n </strong>\n used for device configuration and management. The\n <strong>\n  Session Request Protocol (SRP)\n </strong>\n and\n <strong>\n  serial interface engines (SIEs)\n </strong>\n were discussed, highlighting their roles in\n <strong>\n  Wireless USB\n </strong>\n and\n <strong>\n  USB controllers\n </strong>\n . Additionally, we covered the importance of\n <strong>\n  signal integrity\n </strong>\n through\n <strong>\n  shielding\n </strong>\n and\n <strong>\n  signal quality factors\n </strong>\n , as well as how\n <strong>\n  self-powered devices\n </strong>\n manage power efficiently. Lastly, tools like the\n <strong>\n  SBAE-30 Analyzer\n </strong>\n and\n <strong>\n  SetupDi API functions\n </strong>\n were introduced as key resources for USB development and debugging.\n</p>\n"}, "Page 591": {"response": "<h3>\n USB Transactions, Protocols, and Debugging Tools\n</h3>\n<p>\n This section covers key elements of USB communication, including\n <strong>\n  transactions\n </strong>\n ,\n <strong>\n  protocol analyzers\n </strong>\n ,\n <strong>\n  USB topologies\n </strong>\n , and\n <strong>\n  test modes\n </strong>\n . It also highlights relevant tools and features for debugging and analyzing USB systems, including\n <strong>\n  test and measurement classes\n </strong>\n ,\n <strong>\n  traffic generators\n </strong>\n , and\n <strong>\n  transaction translators\n </strong>\n .\n</p>\n<hr/>\n<h4>\n USB Transactions\n</h4>\n<p>\n USB transactions are the fundamental units of data exchange between devices and hosts. A transaction consists of four key phases:\n</p>\n<ol>\n<li>\n<strong>\n   Token Phase\n  </strong>\n  : A token packet is used to initiate communication, containing information about the type of transfer (e.g., IN, OUT, or Setup).\n </li>\n<li>\n<strong>\n   Data Phase\n  </strong>\n  : This phase carries the actual data to or from the device.\n </li>\n<li>\n<strong>\n   Handshake Phase\n  </strong>\n  : After the data is transmitted, a handshake packet is sent to confirm that the transaction was successful or if there was an error (e.g., NAK, STALL).\n </li>\n<li>\n<strong>\n   Status Phase\n  </strong>\n  : This final phase involves a status packet indicating the completion or result of the transaction (page 45-51, 122-124).\n </li>\n</ol>\n<p>\n A\n <strong>\n  split transaction\n </strong>\n allows for more efficient communication in systems where data transfer speeds need to be maintained, particularly in high-speed USB (pages 50-51, 439-442).\n</p>\n<hr/>\n<h4>\n USB Topologies\n</h4>\n<p>\n The\n <strong>\n  USB network topology\n </strong>\n refers to the physical arrangement of USB devices in a system. The two primary USB topologies are:\n</p>\n<ul>\n<li>\n<strong>\n   Star Topology\n  </strong>\n  : In this setup, each USB device is connected directly to a central\n  <strong>\n   hub\n  </strong>\n  . It is the most common USB connection structure (pages 18-19).\n </li>\n<li>\n<strong>\n   Tiered-Star Topology\n  </strong>\n  : This variation features multiple layers of hubs, expanding the network by cascading hubs (page 18).\n </li>\n</ul>\n<p>\n Both topologies enable efficient device management and support multiple devices.\n</p>\n<hr/>\n<h4>\n USB Protocol Analyzers\n</h4>\n<p>\n<strong>\n  USB protocol analyzers\n </strong>\n are essential for monitoring and analyzing USB traffic to ensure proper communication and troubleshoot potential issues. Tools such as\n <strong>\n  SourceUSB\n </strong>\n (from Sourcequest, Inc.) and other\n <strong>\n  software protocol analyzers\n </strong>\n allow developers to capture and analyze the data packets being exchanged (pages 475-477).\n</p>\n<ul>\n<li>\n<strong>\n   SourceUSB software analyzer\n  </strong>\n  : This tool specifically helps in debugging USB communication by examining the protocol and data exchanged between devices (pages 476-477).\n </li>\n</ul>\n<hr/>\n<h4>\n Test Modes and Debugging\n</h4>\n<p>\n<strong>\n  Test modes\n </strong>\n are used to ensure the correct functionality of USB devices and troubleshoot issues during development:\n</p>\n<ul>\n<li>\n<strong>\n   Test_Force Enable\n  </strong>\n  : Forces the device to enter test mode (page 503).\n </li>\n<li>\n<strong>\n   Test_K\n  </strong>\n  : A test mode used for signaling in USB 2.0 (page 503).\n </li>\n<li>\n<strong>\n   Test_Packet\n  </strong>\n  : Verifies the packet structure and integrity (page 503).\n </li>\n<li>\n<strong>\n   Test_SEO_NAK\n  </strong>\n  : Used to simulate a\n  <strong>\n   Single-Ended Zero (SE0)\n  </strong>\n  condition and test how a device reacts to NAK responses (pages 502-503).\n </li>\n</ul>\n<p>\n<strong>\n  Entering and exiting test modes\n </strong>\n are critical steps in validating a USB device\u2019s behavior, particularly during development and troubleshooting (page 502).\n</p>\n<hr/>\n<h4>\n Traffic Generators\n</h4>\n<p>\n<strong>\n  Traffic generators\n </strong>\n are tools used to simulate data flow and generate traffic across a USB connection for testing and validation. These generators can simulate various types of transactions, such as\n <strong>\n  data transfers\n </strong>\n , to ensure that devices can handle real-world traffic conditions (page 477).\n</p>\n<hr/>\n<h4>\n Session Request Protocol (SRP)\n</h4>\n<p>\n The\n <strong>\n  Session Request Protocol (SRP)\n </strong>\n is important for\n <strong>\n  Wireless USB\n </strong>\n communication. It allows devices to request a session to begin data communication over a wireless link, typically in\n <strong>\n  OTG devices\n </strong>\n (pages 541-542, 545).\n</p>\n<hr/>\n<h4>\n Token Packets and SPLIT PIDs\n</h4>\n<p>\n<strong>\n  Token packets\n </strong>\n are used to initiate communication between devices, providing essential information such as the type of transfer (IN, OUT, or Setup). These packets are fundamental in the\n <strong>\n  token phase\n </strong>\n of transactions (pages 44, 45, 118, 121-123).\n <strong>\n  SPLIT PIDs\n </strong>\n are used in\n <strong>\n  split transactions\n </strong>\n to break up large data transfers into manageable chunks (pages 48-49).\n</p>\n<hr/>\n<h4>\n USB Suspend and Resume States\n</h4>\n<p>\n USB devices can enter\n <strong>\n  Suspend\n </strong>\n or\n <strong>\n  Resume\n </strong>\n states to manage power effectively:\n</p>\n<ul>\n<li>\n<strong>\n   Suspend State\n  </strong>\n  : The device enters a low-power mode when the host is not actively communicating with it (pages 447, 464\u2013466).\n </li>\n<li>\n<strong>\n   Resume State\n  </strong>\n  : The device can return to an active state when communication resumes (page 466).\n </li>\n</ul>\n<p>\n Both states help optimize the power consumption of USB devices, especially when they are idle or waiting for communication.\n</p>\n<hr/>\n<h3>\n Summary\n</h3>\n<p>\n This section has explored various key concepts related to\n <strong>\n  USB transactions\n </strong>\n ,\n <strong>\n  topologies\n </strong>\n ,\n <strong>\n  protocol analyzers\n </strong>\n , and\n <strong>\n  test modes\n </strong>\n . It discussed the phases of\n <strong>\n  USB transactions\n </strong>\n , including token, data, handshake, and status phases, as well as\n <strong>\n  split transactions\n </strong>\n that allow for more efficient data handling. The\n <strong>\n  USB topology\n </strong>\n was also explained, highlighting\n <strong>\n  star\n </strong>\n and\n <strong>\n  tiered-star\n </strong>\n structures. For development and debugging,\n <strong>\n  USB protocol analyzers\n </strong>\n and\n <strong>\n  test modes\n </strong>\n are essential tools, while\n <strong>\n  traffic generators\n </strong>\n simulate traffic patterns to test USB systems. Additionally, we covered\n <strong>\n  Suspend\n </strong>\n and\n <strong>\n  Resume states\n </strong>\n that help manage device power consumption effectively.\n</p>\n"}, "Page 592": {"response": "<h3>\n USB Transceivers, Transfers, and Specifications\n</h3>\n<p>\n This section focuses on\n <strong>\n  USB transceivers\n </strong>\n ,\n <strong>\n  transfer types\n </strong>\n , and key\n <strong>\n  USB specifications\n </strong>\n . It includes details on the different USB speeds and types of transfers, as well as references to important tools, utilities, and standards that developers and users need to understand.\n</p>\n<hr/>\n<h4>\n USB Transceivers\n</h4>\n<p>\n USB transceivers are crucial components for enabling data communication between USB devices and hosts. These are responsible for transmitting and receiving data, converting signals between digital and analog forms. There are three main types of transceivers based on speed:\n</p>\n<ol>\n<li>\n<strong>\n   Low-Speed Transceivers\n  </strong>\n  : Operate at 1.5 Mbps, mainly used in simple devices like keyboards or mice (pages 508-510).\n </li>\n<li>\n<strong>\n   Full-Speed Transceivers\n  </strong>\n  : Operate at 12 Mbps, commonly used for general-purpose USB devices (pages 508-512).\n </li>\n<li>\n<strong>\n   High-Speed Transceivers\n  </strong>\n  : Operate at 480 Mbps, typically used in devices that require faster data transfers, such as external hard drives (pages 512-517).\n </li>\n</ol>\n<p>\n Differences between\n <strong>\n  low-speed\n </strong>\n and\n <strong>\n  full-speed\n </strong>\n transceivers are notable in their data rate capacities and application areas (pages 508-510).\n</p>\n<hr/>\n<h4>\n USB Transfers\n</h4>\n<p>\n USB data communication relies on\n <strong>\n  transfers\n </strong>\n , which are categorized into various types based on the nature of the data and how it is transferred. Key types of USB transfers include:\n</p>\n<ul>\n<li>\n<strong>\n   Bulk Transfers\n  </strong>\n  : Used for large amounts of data that do not require real-time performance, like file transfers (refer to bulk transfers section).\n </li>\n<li>\n<strong>\n   Control Transfers\n  </strong>\n  : Manage device configuration and setup, used for tasks such as requesting descriptors (pages 34, 40).\n </li>\n<li>\n<strong>\n   Interrupt Transfers\n  </strong>\n  : Used for short, time-sensitive messages, such as keyboard or mouse events (refer to interrupt transfers section).\n </li>\n<li>\n<strong>\n   Isochronous Transfers\n  </strong>\n  : Handle data streams that require guaranteed delivery at consistent rates, such as audio or video streaming (pages 34, 40).\n </li>\n</ul>\n<p>\n These transfers are the building blocks of communication in the\n <strong>\n  USB protocol\n </strong>\n (pages 37-51, 243-247). Successful transfer communication relies on elements like ensuring proper signal quality, handling errors, and choosing the right type of transfer for specific use cases.\n</p>\n<hr/>\n<h4>\n Ensuring Successful Transfers\n</h4>\n<p>\n To ensure\n <strong>\n  successful USB transfers\n </strong>\n , several factors come into play:\n</p>\n<ul>\n<li>\n<strong>\n   Signal Quality\n  </strong>\n  : Issues like noise and improper voltage can hinder communication (pages 525-530).\n </li>\n<li>\n<strong>\n   Transfer Speed\n  </strong>\n  : Factors like cable quality, distance, and device compatibility can limit speed (pages 80-84).\n </li>\n<li>\n<strong>\n   Device Drivers\n  </strong>\n  : Proper drivers are essential for managing transfer requests and ensuring communication success (pages 235-237).\n </li>\n</ul>\n<hr/>\n<h4>\n USB Specifications and Compliance\n</h4>\n<p>\n There are several\n <strong>\n  USB specifications\n </strong>\n that outline how USB devices and systems should function, ensuring compatibility and performance:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    USB 1.x Specification\n   </strong>\n   : The first iteration of USB, supporting\n   <strong>\n    low\n   </strong>\n   and\n   <strong>\n    full speeds\n   </strong>\n   (1.5 Mbps and 12 Mbps, respectively). The\n   <strong>\n    USB 1.x\n   </strong>\n   specification also sets requirements for\n   <strong>\n    cables\n   </strong>\n   and\n   <strong>\n    hub descriptors\n   </strong>\n   (pages 14-15, 524-525, 448).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    USB 2.0 Specification\n   </strong>\n   : The updated version of USB that introduced\n   <strong>\n    high-speed\n   </strong>\n   transfers at 480 Mbps. It also includes updates for descriptors to make them compliant with the new standard (pages 15-16, 524-525, 448).\n  </p>\n</li>\n</ol>\n<hr/>\n<h4>\n USB Tools and Utilities\n</h4>\n<p>\n Several\n <strong>\n  tools and utilities\n </strong>\n are used to verify and ensure the correct functioning of USB systems:\n</p>\n<ul>\n<li>\n<strong>\n   USB Command Verifier (USBCV)\n  </strong>\n  : A tool for testing USB devices and ensuring they meet compliance standards. It checks if a device adheres to USB specifications (pages 479-481).\n </li>\n<li>\n<strong>\n   USB-IF Compliance Program\n  </strong>\n  : The USB Implementers Forum (USB-IF) runs a\n  <strong>\n   compliance program\n  </strong>\n  that helps developers test and certify devices to meet USB standards (pages 478-484).\n </li>\n</ul>\n<hr/>\n<h4>\n USB Device Setup and Drivers\n</h4>\n<p>\n The setup of\n <strong>\n  USB devices\n </strong>\n involves configuring and installing necessary drivers.\n <strong>\n  Device setup classes\n </strong>\n organize USB devices into categories, such as\n <strong>\n  HID\n </strong>\n or\n <strong>\n  audio devices\n </strong>\n , and each class may have specific requirements for descriptors and drivers (pages 251).\n</p>\n<p>\n<strong>\n  USB drivers\n </strong>\n play a critical role in facilitating communication between the host and devices, managing data transfers, and ensuring that requests are correctly processed (pages 274-276).\n</p>\n<hr/>\n<h3>\n Summary\n</h3>\n<p>\n This section provides an overview of the key aspects of\n <strong>\n  USB communication\n </strong>\n , including transceivers, transfer types, and relevant specifications. It explains the different types of\n <strong>\n  USB transceivers\n </strong>\n for various speeds, such as low-speed, full-speed, and high-speed, and explores the different\n <strong>\n  transfer types\n </strong>\n used in USB systems, such as control, bulk, interrupt, and isochronous transfers. The section also highlights important\n <strong>\n  USB specifications\n </strong>\n (1.x and 2.0) and introduces tools like the\n <strong>\n  USB Command Verifier\n </strong>\n (USBCV) and\n <strong>\n  USB-IF Compliance Program\n </strong>\n to help ensure proper functionality and compliance with USB standards.\n</p>\n"}, "Page 593": {"response": "<h3>\n USB and Other Technologies Comparison, Drivers, and Visual Basic .NET API Integration\n</h3>\n<p>\n This section provides an overview of\n <strong>\n  USB technology\n </strong>\n , comparing it with various other interfaces, while detailing\n <strong>\n  driver management\n </strong>\n and the use of\n <strong>\n  Visual Basic .NET\n </strong>\n for working with USB-related APIs. It also covers essential topics such as\n <strong>\n  Vendor IDs\n </strong>\n and\n <strong>\n  Video Class\n </strong>\n specifications.\n</p>\n<hr/>\n<h4>\n USB vs. Other Technologies\n</h4>\n<p>\n USB has a variety of advantages and limitations when compared to other communication technologies. Here are the main comparisons:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Ease of Use\n   </strong>\n   : USB offers significant\n   <strong>\n    ease of use\n   </strong>\n   for both developers and users, making it highly popular for connecting peripheral devices like printers, keyboards, and storage devices (pages 2-5).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Speed\n   </strong>\n   : USB speeds are a crucial consideration. USB 1.x operates at 12 Mbps, while USB 2.0 reaches 480 Mbps, making it suitable for high-speed data transfer, though it has limitations compared to other high-speed technologies like\n   <strong>\n    FireWire 800\n   </strong>\n   (pages 5, 15-16).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Physical Components\n   </strong>\n   : The\n   <strong>\n    physical components\n   </strong>\n   of USB, including cables, connectors, and hubs, make it a highly versatile and efficient system. USB uses a\n   <strong>\n    tiered-star topology\n   </strong>\n   and a\n   <strong>\n    hub-and-spoke\n   </strong>\n   design for device connections (pages 17-22).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Comparison to Other Interfaces\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     RS-232\n    </strong>\n    : USB offers higher data speeds and more flexibility in connecting multiple devices compared to traditional RS-232 serial connections (pages 3, 10, 22).\n   </li>\n<li>\n<strong>\n     RS-485\n    </strong>\n    : Both are serial communication standards, but USB provides higher data speeds and better device interconnectivity (pages 3, 10).\n   </li>\n<li>\n<strong>\n     Ethernet\n    </strong>\n    : While Ethernet is ideal for networking, USB excels in simpler device connections and plug-and-play support (pages 3, 10, 17).\n   </li>\n<li>\n<strong>\n     I2C, SPI\n    </strong>\n    : USB surpasses these interfaces in terms of scalability, ease of use, and data rates (pages 3).\n   </li>\n<li>\n<strong>\n     IEEE Standards (488 and 1394)\n    </strong>\n    : Compared to\n    <strong>\n     IEEE-488\n    </strong>\n    (GPIB) and\n    <strong>\n     IEEE-1394\n    </strong>\n    (FireWire), USB is simpler and widely supported, with fewer limitations for consumer devices (pages 3, 10, 16-17).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Limitations\n   </strong>\n   : Despite its benefits, USB has limitations, including cable length restrictions and power delivery constraints, especially at higher speeds (pages 10-12).\n  </p>\n</li>\n</ol>\n<hr/>\n<h4>\n Vendor ID and Customization\n</h4>\n<p>\n The\n <strong>\n  Vendor ID (VID)\n </strong>\n is essential for identifying devices and ensuring compatibility across systems. Here are key points about Vendor IDs:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Usage in Device IDs\n   </strong>\n   : Vendor IDs are used to create\n   <strong>\n    device IDs\n   </strong>\n   for specific USB devices, ensuring proper identification and functionality (pages 272, 274-275).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Customization\n   </strong>\n   : Developers can\n   <strong>\n    customize\n   </strong>\n   the Vendor ID for specific applications, particularly when using chips like the\n   <strong>\n    FTDI\n   </strong>\n   controllers, enabling specific device recognition and configuration (pages 429, 424-426).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Reading Vendor Information\n   </strong>\n   : Tools and API functions allow developers to\n   <strong>\n    read Vendor IDs\n   </strong>\n   and\n   <strong>\n    Product IDs\n   </strong>\n   from the\n   <strong>\n    Windows registry\n   </strong>\n   or via API calls for communication with the device (pages 258-259, 380-384).\n  </p>\n</li>\n</ol>\n<hr/>\n<h4>\n Video Class Specifications\n</h4>\n<p>\n The\n <strong>\n  Video Class\n </strong>\n is part of the USB specifications that define how video devices, such as webcams or video capture devices, communicate over USB. Key aspects include:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Interfaces\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     VideoControl Interface\n    </strong>\n    : Handles video-specific settings, like frame rate and resolution (pages 223-224).\n   </li>\n<li>\n<strong>\n     VideoStreaming Interface\n    </strong>\n    : Manages the actual streaming of video data (pages 224-225).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Descriptors\n   </strong>\n   : The\n   <strong>\n    Video Class\n   </strong>\n   uses specialized descriptors for defining device capabilities and configuration (pages 223-225).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Video Chips and Documentation\n   </strong>\n   : Various\n   <strong>\n    video chips\n   </strong>\n   and associated documentation are available for developers working with USB video devices (pages 222-223).\n  </p>\n</li>\n</ol>\n<hr/>\n<h4>\n Virtual COM Port (VCP) Driver\n</h4>\n<p>\n The\n <strong>\n  Virtual COM Port (VCP)\n </strong>\n driver enables the use of USB devices as if they were standard serial COM ports. This driver facilitates communication between a USB device and software that expects serial port communication. Key details include:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Driver Functionality\n   </strong>\n   : VCP drivers make it possible to use USB-connected devices like microcontrollers or GPS receivers, which would otherwise use RS-232 serial connections (pages 174, 198, 227).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Vendor-Specific Use\n   </strong>\n   : The driver can be customized for specific\n   <strong>\n    vendor IDs\n   </strong>\n   to support unique devices with serial communication needs (pages 421, 426).\n  </p>\n</li>\n</ol>\n<hr/>\n<h4>\n Visual Basic .NET API Integration\n</h4>\n<p>\n<strong>\n  Visual Basic .NET (VB.NET)\n </strong>\n provides a straightforward way for developers to interact with USB devices using APIs. Some important points for integrating USB operations include:\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    API Calls\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    VB.NET allows\n    <strong>\n     calling API functions\n    </strong>\n    to interact with USB devices, handle device changes, and read/write data (pages 282-283, 296-297).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Managing Device Connections\n   </strong>\n   : Developers can\n   <strong>\n    capture device change messages\n   </strong>\n   ,\n   <strong>\n    close communications\n   </strong>\n   , and manage\n   <strong>\n    device notifications\n   </strong>\n   (pages 311-318).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Extracting Information\n   </strong>\n   : Functions like\n   <strong>\n    HidD_GetAttributes\n   </strong>\n   and\n   <strong>\n    HidD_SetFeature\n   </strong>\n   are used to get and set device attributes (pages 382-383, 405-406).\n  </p>\n</li>\n<li>\n<p>\n<strong>\n    Passing Structures\n   </strong>\n   : When passing structures for\n   <strong>\n    device capabilities\n   </strong>\n   or data, developers use\n   <strong>\n    ByRef\n   </strong>\n   and\n   <strong>\n    ByVal\n   </strong>\n   for efficient data handling in VB.NET (pages 289, 290).\n  </p>\n</li>\n</ol>\n<hr/>\n<h3>\n Summary\n</h3>\n<p>\n This section offers a comprehensive overview of USB technology and how it compares to other systems. It covers key topics like the\n <strong>\n  Vendor ID\n </strong>\n system,\n <strong>\n  Video Class\n </strong>\n devices, the\n <strong>\n  VCP driver\n </strong>\n , and using\n <strong>\n  Visual Basic .NET\n </strong>\n for interacting with USB devices. Understanding these components is essential for developers who work with USB devices, especially for device identification, communication, and integration in various applications.\n</p>\n"}, "Page 594": {"response": "<h3>\n Windows API, Device Notifications, and Driver Models for USB Integration\n</h3>\n<p>\n This section provides an overview of integrating USB devices with various Windows operating systems and programming environments like\n <strong>\n  Visual Basic .NET\n </strong>\n ,\n <strong>\n  Visual C++\n </strong>\n , and\n <strong>\n  Visual C# .NET\n </strong>\n . It also discusses key tools like\n <strong>\n  Windows Device Manager\n </strong>\n , the\n <strong>\n  Windows Driver Model (WDM)\n </strong>\n , and key concepts like\n <strong>\n  Windows registry\n </strong>\n and\n <strong>\n  troubleshooting USB issues\n </strong>\n .\n</p>\n<hr/>\n<h4>\n Using Windows API Functions\n</h4>\n<p>\n Windows provides a set of\n <strong>\n  API functions\n </strong>\n that can be used to manage and interact with USB devices in applications. These functions are essential for device communication, managing reports, and handling events like device changes.\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    API Functions Overview\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    In\n    <strong>\n     Visual Basic .NET\n    </strong>\n    , API functions allow developers to interact with USB devices for actions like\n    <strong>\n     writing output reports\n    </strong>\n    and managing device paths (pages 286-291).\n   </li>\n<li>\n    In\n    <strong>\n     Visual C++\n    </strong>\n    , API functions are also used for reading input reports, handling\n    <strong>\n     device capabilities\n    </strong>\n    , and managing\n    <strong>\n     communications\n    </strong>\n    (pages 284-286).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Key Functions\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     HidD_GetAttributes\n    </strong>\n    : Retrieves information about a USB device, such as Vendor ID and Product ID (pages 381-382).\n   </li>\n<li>\n<strong>\n     HidD_GetFeature\n    </strong>\n    : Retrieves a device\u2019s feature report (pages 404).\n   </li>\n<li>\n<strong>\n     HidP_GetCaps\n    </strong>\n    : Gets the capabilities of a USB device, such as button count for HID devices (pages 386).\n   </li>\n<li>\n<strong>\n     Writing Output and Feature Reports\n    </strong>\n    : Functions are available to send reports back to devices (pages 390, 402-403).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Device Change Notifications\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    In\n    <strong>\n     Visual C++\n    </strong>\n    and\n    <strong>\n     Visual Basic .NET\n    </strong>\n    , applications can\n    <strong>\n     register for device change notifications\n    </strong>\n    , allowing them to be alerted when devices are connected or disconnected (pages 308-318).\n   </li>\n</ul>\n</li>\n</ol>\n<hr/>\n<h4>\n Visual C++ and C# .NET Integration\n</h4>\n<p>\n Windows development environments like\n <strong>\n  Visual C++\n </strong>\n and\n <strong>\n  Visual C# .NET\n </strong>\n provide more flexibility for working with USB devices using API calls.\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Visual C++\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Offers direct integration with Windows API functions for handling\n    <strong>\n     device change messages\n    </strong>\n    ,\n    <strong>\n     device path names\n    </strong>\n    , and other device interactions (pages 282-283, 284-286).\n   </li>\n<li>\n    Functions such as\n    <strong>\n     HidD_GetPreparsedData\n    </strong>\n    and\n    <strong>\n     HidD_SetFeature\n    </strong>\n    allow developers to configure device settings and retrieve data buffers (pages 384-402).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Visual C# .NET\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    Similar to\n    <strong>\n     Visual C++\n    </strong>\n    ,\n    <strong>\n     C#\n    </strong>\n    allows the calling of API functions but with easier syntax and integration with .NET frameworks (pages 282-284).\n   </li>\n</ul>\n</li>\n</ol>\n<hr/>\n<h4>\n Windows Device Manager and Troubleshooting\n</h4>\n<p>\n The\n <strong>\n  Windows Device Manager\n </strong>\n is a key tool for managing and troubleshooting USB devices.\n</p>\n<ol>\n<li>\n<p>\n<strong>\n    Viewing Device Information\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     Device Manager\n    </strong>\n    allows users and developers to\n    <strong>\n     view device properties\n    </strong>\n    , including the USB devices connected to the system (pages 253-257).\n   </li>\n<li>\n<strong>\n     Properties pages\n    </strong>\n    provide detailed device information, such as device driver and status (pages 257, 279).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Troubleshooting\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     Remote Wakeup Issues\n    </strong>\n    : Devices that support remote wakeup might face troubleshooting problems in systems like\n    <strong>\n     Windows Me\n    </strong>\n    and\n    <strong>\n     Windows 98\n    </strong>\n    . Problems can occur with power management or device states (pages 469).\n   </li>\n<li>\n<strong>\n     Power Issues\n    </strong>\n    : Managing USB power settings is critical for preventing issues with\n    <strong>\n     device communication\n    </strong>\n    and\n    <strong>\n     USB suspend/resume states\n    </strong>\n    (pages 460-469).\n   </li>\n</ul>\n</li>\n</ol>\n<hr/>\n<h4>\n Windows Driver Models and Development\n</h4>\n<ol>\n<li>\n<p>\n<strong>\n    Windows Driver Model (WDM)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     WDM\n    </strong>\n    is used for creating\n    <strong>\n     USB device drivers\n    </strong>\n    on Windows platforms. It provides a consistent way for developers to create drivers that can handle\n    <strong>\n     USB events\n    </strong>\n    and ensure compatibility across different Windows versions (pages 237-247).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    WHQL (Windows Hardware Quality Labs)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n<strong>\n     WHQL\n    </strong>\n    testing ensures that drivers and devices are certified to work with\n    <strong>\n     Windows operating systems\n    </strong>\n    . Drivers passing WHQL certification are marked with the\n    <strong>\n     Windows logo\n    </strong>\n    (pages 484-487).\n   </li>\n</ul>\n</li>\n<li>\n<p>\n<strong>\n    Windows Driver Development Kit (DDK)\n   </strong>\n   :\n  </p>\n<ul>\n<li>\n    The\n    <strong>\n     Windows DDK\n    </strong>\n    provides tools and libraries to help developers create, test, and deploy USB drivers for Windows operating systems (pages 30, 237).\n   </li>\n</ul>\n</li>\n</ol>\n<hr/>\n<h4>\n Windows Operating Systems Support for USB\n</h4>\n<p>\n Windows has progressively added\n <strong>\n  USB support\n </strong>\n over the years, and different versions have specific considerations for USB integration:\n</p>\n<ol>\n<li>\n<strong>\n   USB Support in Windows Versions\n  </strong>\n  :\n  <ul>\n<li>\n<strong>\n     Windows 98\n    </strong>\n    : Early versions of Windows with\n    <strong>\n     USB 1.x\n    </strong>\n    support (pages 7-8, 14).\n   </li>\n<li>\n<strong>\n     Windows 2000 and XP\n    </strong>\n    : These versions provided\n    <strong>\n     better USB support\n    </strong>\n    , including faster speeds and compatibility with\n    <strong>\n     USB 2.0\n    </strong>\n    (pages 7-8, 180).\n   </li>\n<li>\n<strong>\n     Windows Server 2003\n    </strong>\n    : Added\n    <strong>\n     USB support\n    </strong>\n    similar to other modern operating systems (pages 7-8).\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   System Registry\n  </strong>\n  :\n  <ul>\n<li>\n<strong>\n     Windows Registry\n    </strong>\n    stores crucial information about USB devices, including\n    <strong>\n     device paths\n    </strong>\n    ,\n    <strong>\n     driver keys\n    </strong>\n    , and\n    <strong>\n     service information\n    </strong>\n    (pages 257-262). Developers use the registry to access detailed device configurations for debugging and management.\n   </li>\n</ul>\n</li>\n</ol>\n<hr/>\n<h3>\n Summary\n</h3>\n<p>\n This section provides essential insights into integrating\n <strong>\n  USB devices\n </strong>\n with Windows-based systems using API functions in various programming languages, including\n <strong>\n  Visual Basic .NET\n </strong>\n ,\n <strong>\n  Visual C++\n </strong>\n , and\n <strong>\n  Visual C# .NET\n </strong>\n . Additionally, it covers key tools for managing and troubleshooting USB devices, such as the\n <strong>\n  Windows Device Manager\n </strong>\n and\n <strong>\n  Windows Driver Model (WDM)\n </strong>\n . Understanding these concepts is vital for developing reliable USB device applications, troubleshooting device issues, and ensuring compatibility across different\n <strong>\n  Windows operating systems\n </strong>\n .\n</p>\n"}, "Page 595": {"response": "<h3>\n Wireless USB, Device Toolkits, and API Functions\n</h3>\n<p>\n This section explores key tools and technologies for managing USB devices, including\n <strong>\n  wireless USB\n </strong>\n ,\n <strong>\n  winDriver USB Device toolkit\n </strong>\n , and essential\n <strong>\n  Windows API functions\n </strong>\n .\n</p>\n<hr/>\n<h4>\n Wireless USB and Related Technologies\n</h4>\n<p>\n<strong>\n  Wireless USB\n </strong>\n is a technology designed to enable USB-like communication without the need for physical cables. It leverages wireless protocols to offer similar functionality to traditional wired USB but with the flexibility of wireless connectivity.\n</p>\n<ol>\n<li>\n<strong>\n   Wireless USB Specification\n  </strong>\n  :\n  <ul>\n<li>\n    The\n    <strong>\n     Wireless USB\n    </strong>\n    standard allows high-speed data transfer over short distances. It was developed by the\n    <strong>\n     Wireless USB Promoter Group\n    </strong>\n    (page 533) and aims to provide the same performance as wired USB connections, but wirelessly (page 16).\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Wireless Connections\n  </strong>\n  :\n  <ul>\n<li>\n    Wireless USB technology facilitates seamless connections between devices and hosts, allowing communication across various types of\n    <strong>\n     wireless bridges\n    </strong>\n    (page 534).\n   </li>\n<li>\n<strong>\n     WirelessUSB\n    </strong>\n    (Cypress) and other wireless USB implementations use similar principles for\n    <strong>\n     communication over short-range wireless channels\n    </strong>\n    (pages 530-533).\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   ZigBee\n  </strong>\n  :\n  <ul>\n<li>\n<strong>\n     ZigBee\n    </strong>\n    is a wireless communication standard often used for low-power, low-data-rate applications and can be integrated with wireless USB solutions (page 534).\n   </li>\n</ul>\n</li>\n</ol>\n<hr/>\n<h4>\n winDriver USB Device Toolkit\n</h4>\n<p>\n The\n <strong>\n  winDriver USB Device Toolkit\n </strong>\n is a software solution designed to simplify the development of USB drivers for Windows. It allows developers to manage USB device communication and interactions with minimal coding effort.\n</p>\n<ul>\n<li>\n  The toolkit provides functions and pre-built drivers to help integrate\n  <strong>\n   USB devices\n  </strong>\n  into applications, particularly those that require custom or specialized drivers (page 248).\n </li>\n</ul>\n<hr/>\n<h4>\n WM_DEVICECHANGE Message\n</h4>\n<p>\n The\n <strong>\n  WM_DEVICECHANGE\n </strong>\n message is part of the Windows messaging system and is used for detecting changes in the device configuration, such as when a USB device is connected or removed.\n</p>\n<ol>\n<li>\n<strong>\n   Usage\n  </strong>\n  :\n  <ul>\n<li>\n    When a device is plugged into or removed from a Windows system, the\n    <strong>\n     WM_DEVICECHANGE\n    </strong>\n    message is triggered, notifying applications about the change (pages 307, 311).\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Implementation\n  </strong>\n  :\n  <ul>\n<li>\n    Applications that interact with USB devices can listen for this message to dynamically adjust their operations in response to hardware changes.\n   </li>\n</ul>\n</li>\n</ol>\n<hr/>\n<h4>\n WriteFile API Function\n</h4>\n<p>\n The\n <strong>\n  WriteFile\n </strong>\n function is a critical part of the Windows API, allowing applications to write data to files or directly to device interfaces, such as\n <strong>\n  USB devices\n </strong>\n .\n</p>\n<ul>\n<li>\n  It is commonly used to send\n  <strong>\n   output reports\n  </strong>\n  or data from an application to a USB device, facilitating communication in programs that manage USB peripherals (pages 376, 379, 389-392).\n </li>\n</ul>\n<hr/>\n<h3>\n Summary\n</h3>\n<p>\n This section outlines the technologies and tools associated with\n <strong>\n  USB\n </strong>\n communication, especially focusing on the wireless version of USB, device management, and API functions.\n <strong>\n  Wireless USB\n </strong>\n provides a method for wire-free device communication, leveraging standards like\n <strong>\n  ZigBee\n </strong>\n for low-power wireless links. The\n <strong>\n  winDriver USB Device Toolkit\n </strong>\n simplifies USB driver development, while the\n <strong>\n  WM_DEVICECHANGE\n </strong>\n message allows applications to detect USB device changes in real-time. Additionally, the\n <strong>\n  WriteFile\n </strong>\n function is vital for transmitting data to USB devices in Windows-based applications.\n</p>\n"}}