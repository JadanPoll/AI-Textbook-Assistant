{"Page 1": {"response": "<h3>\n Pacbot Design Documentation\n</h3>\n<p>\n <strong>\n  Last Updated:\n </strong>\n September 5, 2024\n</p>\n<h4>\n Overview\n</h4>\n<p>\n The\n <strong>\n  Pacbot\n </strong>\n is an autonomous robot designed for navigating complex environments. This documentation outlines its design principles, components, and functionalities.\n</p>\n<h4>\n Key Components\n</h4>\n<ol>\n <li>\n  <p>\n   <strong>\n    Chassis\n   </strong>\n  </p>\n  <ul>\n   <li>\n    <strong>\n     Material:\n    </strong>\n    Lightweight aluminum for durability.\n   </li>\n   <li>\n    <strong>\n     Design:\n    </strong>\n    Compact and modular to facilitate easy upgrades.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Navigation System\n   </strong>\n  </p>\n  <ul>\n   <li>\n    <strong>\n     Sensors:\n    </strong>\n    Utilizes\n    <strong>\n     LiDAR\n    </strong>\n    ,\n    <strong>\n     cameras\n    </strong>\n    , and\n    <strong>\n     ultrasonic sensors\n    </strong>\n    for real-time mapping.\n   </li>\n   <li>\n    <strong>\n     Algorithm:\n    </strong>\n    Implements\n    <strong>\n     SLAM (Simultaneous Localization and Mapping)\n    </strong>\n    for effective navigation.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Power Supply\n   </strong>\n  </p>\n  <ul>\n   <li>\n    <strong>\n     Battery Type:\n    </strong>\n    Lithium-ion for long-lasting performance.\n   </li>\n   <li>\n    <strong>\n     Charging:\n    </strong>\n    Automatic docking station for self-recharging.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Control System\n   </strong>\n  </p>\n  <ul>\n   <li>\n    <strong>\n     Microcontroller:\n    </strong>\n    Central unit that processes data from sensors.\n   </li>\n   <li>\n    <strong>\n     Software:\n    </strong>\n    Open-source platform for customizable programming.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Communication\n   </strong>\n  </p>\n  <ul>\n   <li>\n    <strong>\n     Protocols:\n    </strong>\n    Supports\n    <strong>\n     Wi-Fi\n    </strong>\n    and\n    <strong>\n     Bluetooth\n    </strong>\n    for remote operation and monitoring.\n   </li>\n   <li>\n    <strong>\n     User Interface:\n    </strong>\n    Web-based dashboard for real-time status updates.\n   </li>\n  </ul>\n </li>\n</ol>\n<h4>\n Functionality\n</h4>\n<ul>\n <li>\n  <strong>\n   Autonomous Navigation:\n  </strong>\n  Pacbot can navigate and adapt to obstacles without human intervention.\n </li>\n <li>\n  <strong>\n   Mapping:\n  </strong>\n  Creates detailed maps of its environment, updating in real time.\n </li>\n <li>\n  <strong>\n   Remote Control:\n  </strong>\n  Can be operated manually when needed via the user interface.\n </li>\n</ul>\n<h4>\n Applications\n</h4>\n<ul>\n <li>\n  <strong>\n   Industrial:\n  </strong>\n  Used in warehouses for inventory management.\n </li>\n <li>\n  <strong>\n   Research:\n  </strong>\n  Assists in environmental studies by mapping terrains.\n </li>\n <li>\n  <strong>\n   Home Use:\n  </strong>\n  Potential for household tasks like cleaning and monitoring.\n </li>\n</ul>\n<h4>\n Maintenance\n</h4>\n<ul>\n <li>\n  <strong>\n   Regular Updates:\n  </strong>\n  Keep software updated for optimal performance.\n </li>\n <li>\n  <strong>\n   Routine Checks:\n  </strong>\n  Inspect sensors and battery health regularly to ensure reliability.\n </li>\n</ul>\n<h3>\n Conclusion\n</h3>\n<p>\n The Pacbot is designed for efficiency and adaptability in various environments, utilizing advanced technology for navigation, mapping, and operation.\n</p>\n<p>\n Feel free to ask for more specific details or clarifications!\n</p>\n"}, "Page 2": {"response": "<h3>\n Table of Contents\n</h3>\n<h4>\n Software High-level\n</h4>\n<ol>\n <li>\n  <p>\n   <strong>\n    System Overview\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Overview of the software architecture and components.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Environment Setup\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Instructions for preparing the development environment.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Setup for Game Simulation\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Steps to configure the game simulation environment.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Setup for Reinforcement Learning\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Guide for establishing reinforcement learning settings.\n   </li>\n  </ul>\n </li>\n</ol>\n<h4>\n Game Server\n</h4>\n<ul>\n <li>\n  Manages game instances and interactions.\n </li>\n</ul>\n<h4>\n Game \u201cEngine\u201d\n</h4>\n<ul>\n <li>\n  Core component that drives game mechanics.\n </li>\n</ul>\n<h4>\n Web Server\n</h4>\n<ul>\n <li>\n  Hosts the web interface for user interaction.\n </li>\n</ul>\n<h4>\n Game Clients\n</h4>\n<ol>\n <li>\n  <p>\n   <strong>\n    Web Client\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Interface for users to interact with the game via a browser.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Bot Client\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Interface used by AI agents to participate in games.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Client Body\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Core functionality for both web and bot clients.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Decision Module\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Makes decisions based on game state and strategy.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Helper Classes\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Additional classes to support functionality in clients.\n   </li>\n  </ul>\n </li>\n</ol>\n<h4>\n Computer Vision Client\n</h4>\n<ul>\n <li>\n  Processes visual data for decision-making and navigation.\n </li>\n</ul>\n<h4>\n Path Planning\n</h4>\n<ol>\n <li>\n  <p>\n   <strong>\n    Heuristic Path Planning\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Uses heuristics for efficient route finding.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Normal Path Planning\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Standard algorithms for determining paths.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Surrounded Mode\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Strategy for navigating when surrounded by obstacles.\n   </li>\n  </ul>\n </li>\n</ol>\n<h4>\n Other Details\n</h4>\n<ul>\n <li>\n  Additional information relevant to the software and functionality.\n </li>\n</ul>\n<h3>\n Reinforcement Learning Path Planning\n</h3>\n<ol>\n <li>\n  <p>\n   <strong>\n    RL Model\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Framework for training agents through reinforcement learning.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Old Training Environment\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Previous setup for training models.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Server-based Training Environment (unfinished)\n   </strong>\n  </p>\n  <ul>\n   <li>\n    In-progress system for training on a server.\n   </li>\n  </ul>\n </li>\n</ol>\n<h4>\n Testing\n</h4>\n<ol>\n <li>\n  <p>\n   <strong>\n    Simulate a Game Using the Game Server\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Instructions to test game scenarios via the game server.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Simulate a Game With the Training Environment\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Methods for testing in the training context.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Other Game Details\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Additional aspects of game mechanics and settings.\n   </li>\n  </ul>\n </li>\n</ol>\n<h3>\n Game Modes\n</h3>\n<ul>\n <li>\n  Different configurations for gameplay experiences.\n </li>\n</ul>\n<h3>\n Software Low-level\n</h3>\n<ol>\n <li>\n  <p>\n   <strong>\n    System Overview\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Detailed view of low-level software components.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Localization\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Techniques for determining position and orientation.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Communication\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Protocols for data exchange between components.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Movement\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Control systems for bot navigation.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Subtasks\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Breakdown of tasks for efficient processing.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    RTOS (Real-Time Operating System)\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Manages real-time operations and scheduling.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    MCL (Monte Carlo Localization)\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Probabilistic method for localization.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Trajectories\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Paths that bots follow in the environment.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Comms\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Communication systems between various software components.\n   </li>\n  </ul>\n </li>\n</ol>\n<p>\n Feel free to ask if you need more details on any specific section!\n</p>\n"}, "Page 3": {"response": "<h3>\n Electrical\n</h3>\n<h4>\n Pacbot Board Description (2023-2024)\n</h4>\n<ul>\n <li>\n  <strong>\n   Overview:\n  </strong>\n  The latest version of the\n  <strong>\n   Pacbot board\n  </strong>\n  designed for enhanced functionality and efficiency.\n </li>\n <li>\n  <strong>\n   Key Features:\n  </strong>\n  <ul>\n   <li>\n    Improved\n    <strong>\n     power management\n    </strong>\n    for extended battery life.\n   </li>\n   <li>\n    Upgraded\n    <strong>\n     microcontroller\n    </strong>\n    for better processing capabilities.\n   </li>\n   <li>\n    Enhanced\n    <strong>\n     sensor integration\n    </strong>\n    for improved navigation.\n   </li>\n  </ul>\n </li>\n</ul>\n<h4>\n Pacbot Board Images (2023-2024)\n</h4>\n<ul>\n <li>\n  Visual documentation of the current board design, showcasing:\n  <ul>\n   <li>\n    <strong>\n     Component layout\n    </strong>\n    for easy identification.\n   </li>\n   <li>\n    <strong>\n     Connections\n    </strong>\n    for sensors and modules.\n   </li>\n  </ul>\n </li>\n</ul>\n<h4>\n Past Board Description (2022-2023)\n</h4>\n<ul>\n <li>\n  <strong>\n   Overview:\n  </strong>\n  Description of the previous board version used in Pacbot.\n </li>\n <li>\n  <strong>\n   Key Features:\n  </strong>\n  <ul>\n   <li>\n    Basic power management and processing features.\n   </li>\n   <li>\n    Initial sensor setup for navigation and communication.\n   </li>\n  </ul>\n </li>\n</ul>\n<h4>\n Past Board Images (2022-2023)\n</h4>\n<ul>\n <li>\n  Images of the earlier board design to compare with the current version:\n  <ul>\n   <li>\n    Highlighted differences in component arrangement and design.\n   </li>\n  </ul>\n </li>\n</ul>\n<h4>\n Lighting Board Description\n</h4>\n<ul>\n <li>\n  <strong>\n   Functionality:\n  </strong>\n  Dedicated board for controlling lighting systems in Pacbot.\n </li>\n <li>\n  <strong>\n   Features:\n  </strong>\n  <ul>\n   <li>\n    <strong>\n     LED integration\n    </strong>\n    for visual feedback.\n   </li>\n   <li>\n    Control of different lighting patterns based on operational status.\n   </li>\n  </ul>\n </li>\n</ul>\n<h3>\n Mechanical\n</h3>\n<ul>\n <li>\n  Overview of the mechanical components that support the Pacbot's structure and movement.\n </li>\n <li>\n  Key aspects include:\n  <ul>\n   <li>\n    <strong>\n     Chassis design\n    </strong>\n    for durability and lightweight mobility.\n   </li>\n   <li>\n    <strong>\n     Motor systems\n    </strong>\n    for effective movement and maneuverability.\n   </li>\n   <li>\n    <strong>\n     Mounting systems\n    </strong>\n    for securing electronic components and sensors.\n   </li>\n  </ul>\n </li>\n</ul>\n<p>\n If you need more specific information or details on any part, let me know!\n</p>\n"}, "Page 4": {"response": "<h3>\n Software High-level\n</h3>\n<h4>\n System Overview\n</h4>\n<p>\n The\n <strong>\n  Pacbot game\n </strong>\n comprises several software components that work together seamlessly:\n</p>\n<ul>\n <li>\n  <p>\n   <strong>\n    Game Server:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Hosts and runs the game.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Web Client:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Connects to the server to display the game on a screen.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Computer Vision Client:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Detects the bot\u2019s location in the arena and communicates this information to the server.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Bot Client:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Operates on a laptop and connects to the server for game information.\n   </li>\n   <li>\n    Sends decisions made by the computer to the robot (the robot itself is not directly connected to the server).\n   </li>\n  </ul>\n </li>\n</ul>\n<p>\n As part of the\n <strong>\n  software high-level team\n </strong>\n , you will primarily focus on these systems without direct interaction with hardware.\n</p>\n<h4>\n Environment Setup\n</h4>\n<h5>\n Setup for Game Simulation\n</h5>\n<ol>\n <li>\n  <p>\n   <strong>\n    Python Installation:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Download and install\n    <strong>\n     Python\n    </strong>\n    (version\n    <strong>\n     3.10\n    </strong>\n    or higher is required for the bot client).\n   </li>\n   <li>\n    Python is essential for running the bot client, even for simulation without the robot.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    GoLang Installation:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Download and install\n    <strong>\n     GoLang\n    </strong>\n    (latest stable version).\n   </li>\n   <li>\n    GoLang is required for running the game server.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Node.js Installation:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Download and install\n    <strong>\n     Node.js\n    </strong>\n    (latest stable version).\n   </li>\n   <li>\n    Node.js is used for visualizing the game simulation.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Clone the Repository:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Use the following link to clone the\n    <strong>\n     Pacbot-2 repository\n    </strong>\n    :\n    <ul>\n     <li>\n      <a href=\"https://github.com/Pacbot-Competition/Pacbot-2\" rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n       Pacbot\n       -2\n       GitHub\n       Repository\n      </a>\n     </li>\n    </ul>\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Install Python Packages:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Navigate to the\n    <code>\n     bot_client\n    </code>\n    folder and run:\n    bash\n    Copy code\n    <code class=\"!whitespace-pre hljs language-bash\">\n     pip install -r requirements.txt\n    </code>\n   </li>\n   <li>\n    This command installs the necessary Python packages.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Compile the Server:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Go to the\n    <code>\n     server\n    </code>\n    folder and execute:\n    bash\n    Copy code\n    <code class=\"!whitespace-pre hljs language-bash\">\n     go build\n    </code>\n   </li>\n   <li>\n    This compiles the game server.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Install Node Modules:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Move to the\n    <code>\n     web_client\n    </code>\n    folder and run:\n    bash\n    Copy code\n    <code class=\"!whitespace-pre hljs language-bash\">\n     npm install\n    </code>\n   </li>\n   <li>\n    This installs relevant Node.js modules.\n   </li>\n  </ul>\n </li>\n</ol>\n<h5>\n Setup for Reinforcement Learning\n</h5>\n<ul>\n <li>\n  Follow specific instructions provided for setting up the reinforcement learning environment.\n </li>\n</ul>\n<p>\n Feel free to ask if you need more details or have specific questions!\n</p>\n"}, "Page 5": {"response": "<h3>\n Game Server\n</h3>\n<p>\n The\n <strong>\n  game server\n </strong>\n for Pacbot is primarily developed in\n <strong>\n  GoLang\n </strong>\n by Princeton. While you may not modify the server directly, understanding its functions is crucial for designing\n <strong>\n  reinforcement learning (RL) training environments\n </strong>\n and the\n <strong>\n  bot client\n </strong>\n .\n</p>\n<ul>\n <li>\n  <strong>\n   Server Code Location:\n  </strong>\n  Access the game server code in the Pacbot-2 repository:\n  <ul>\n   <li>\n    <a href=\"https://github.com/Pacbot-Competition/Pacbot-2/tree/main/server\" rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n     Pacbot\n     -2\n     Game\n     Server\n     Code\n    </a>\n   </li>\n  </ul>\n </li>\n</ul>\n<h3>\n Game \u201cEngine\u201d\n</h3>\n<p>\n The\n <strong>\n  game engine\n </strong>\n simulates the entire Pacbot game, with the server determining all game elements except the bot\u2019s location. Key responsibilities of the server include:\n</p>\n<ol>\n <li>\n  <strong>\n   Calculating Ghost Behavior:\n  </strong>\n  Determines the ghost's path, position, and state (frightened or normal).\n </li>\n <li>\n  <strong>\n   Managing Game Modes:\n  </strong>\n  Controls whether the ghost is in\n  <strong>\n   scatter mode\n  </strong>\n  or\n  <strong>\n   chase mode\n  </strong>\n  .\n </li>\n <li>\n  <strong>\n   Recording Pellets and Powerups:\n  </strong>\n  Tracks the state of pellets and power-ups throughout the game.\n </li>\n <li>\n  <strong>\n   Spawning Bonus Items:\n  </strong>\n  Manages the appearance and behavior of cherries (bonus items).\n </li>\n <li>\n  <strong>\n   Calculating Scores:\n  </strong>\n  Keeps track of player scores.\n </li>\n <li>\n  <strong>\n   Game Controls:\n  </strong>\n  Handles game state changes like pausing, resuming, and resetting.\n </li>\n <li>\n  <strong>\n   Tracking Pacbot Data:\n  </strong>\n  Monitors relevant data like remaining lives.\n </li>\n <li>\n  <strong>\n   Serializing Game State:\n  </strong>\n  Prepares game state data for communication with clients.\n </li>\n <li>\n  <strong>\n   Logging Issues:\n  </strong>\n  Records errors and connection problems.\n </li>\n <li>\n  <strong>\n   Calculating Game States:\n  </strong>\n  Manages time ticks, current level, and other game states.\n </li>\n</ol>\n<p>\n The game engine can be interacted with via the command prompt or the web client depending on the situation.\n</p>\n<h3>\n Web Server\n</h3>\n<p>\n The\n <strong>\n  web server\n </strong>\n facilitates socket communication with various clients. Its main tasks include:\n</p>\n<ul>\n <li>\n  <strong>\n   Sending Game Data:\n  </strong>\n  Sends serialized game states to clients, providing essential game information.\n </li>\n <li>\n  <strong>\n   Receiving Client Data:\n  </strong>\n  Accepts data from specific clients, such as the computer vision client.\n </li>\n</ul>\n<p>\n The web server differentiates between\n <strong>\n  trusted clients\n </strong>\n and\n <strong>\n  untrusted clients\n </strong>\n :\n</p>\n<ul>\n <li>\n  <strong>\n   Trusted Clients:\n  </strong>\n  Come from the same IP as the server and can send data directly (e.g., a bot client simulating a game on your laptop).\n </li>\n <li>\n  <strong>\n   Untrusted Clients:\n  </strong>\n  Operate from separate IP addresses and can only receive game data from the server.\n </li>\n</ul>\n<h3>\n Game Clients\n</h3>\n<p>\n Multiple\n <strong>\n  game clients\n </strong>\n interact with the server and run independently of the server application. Most clients are developed in\n <strong>\n  Python\n </strong>\n , and the Harvard team has provided\n <strong>\n  helper classes\n </strong>\n to simplify the process of decoding serialized game data.\n</p>\n<p>\n If you need further clarification or details on any aspect, let me know!\n</p>\n"}, "Page 6": {"response": "<h3>\n Web Client\n</h3>\n<ul>\n <li>\n  <p>\n   <strong>\n    Web Client Code Location:\n   </strong>\n   You can find the web client code here:\n  </p>\n  <ul>\n   <li>\n    <a href=\"https://github.com/Pacbot-Competition/Pacbot-2/tree/main/web_client\" rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n     Pacbot\n     -2\n     Web\n     Client\n     Code\n    </a>\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Overview:\n   </strong>\n   The\n   <strong>\n    web client\n   </strong>\n   is a web application that visualizes the Pacbot game. It displays:\n  </p>\n  <ul>\n   <li>\n    The score.\n   </li>\n   <li>\n    An arena design reminiscent of classic\n    <strong>\n     Pacman\n    </strong>\n    arcade games.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Interaction with Server:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    The web client allows you to interact with the server.\n   </li>\n   <li>\n    A circular element on the left side serves as the\n    <strong>\n     game clock\n    </strong>\n    and\n    <strong>\n     pause/resume\n    </strong>\n    button.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Functionality:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    The web client is built using\n    <strong>\n     Svelte\n    </strong>\n    and can run independently of the server (though without dynamic movement).\n   </li>\n   <li>\n    If no bot client is connected, you can still start and play the game using the arrow keys.\n   </li>\n  </ul>\n </li>\n</ul>\n<hr/>\n<h3>\n Bot Client\n</h3>\n<ul>\n <li>\n  <p>\n   <strong>\n    Bot Client Code Location:\n   </strong>\n   Access the example bot client code here:\n  </p>\n  <ul>\n   <li>\n    <a href=\"https://github.com/Pacbot-Competition/Pacbot-2/tree/main/bot_client\" rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n     Pacbot\n     -2\n     Bot\n     Client\n     Code\n    </a>\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Purpose:\n   </strong>\n   The\n   <strong>\n    bot client\n   </strong>\n   allows you to control the robot and interact with the server. In a live game, its main functions include:\n  </p>\n  <ul>\n   <li>\n    Receiving information from the server.\n   </li>\n   <li>\n    Sending instructions to the robot for its next move.\n   </li>\n  </ul>\n </li>\n</ul>\n<hr/>\n<h3>\n Client Body\n</h3>\n<ul>\n <li>\n  <p>\n   <strong>\n    Client Body Code Location:\n   </strong>\n   View the example client body code here:\n  </p>\n  <ul>\n   <li>\n    <a href=\"https://github.com/Pacbot-Competition/Pacbot-2/blob/main/bot_client/pacbotClient.py\" rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n     Pacbot\n     -2\n     Client\n     Body\n     Example\n    </a>\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Functionality:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    The client body manages\n    <strong>\n     asynchronous socket communication\n    </strong>\n    with the server.\n   </li>\n   <li>\n    It is responsible for decoding game data into a\n    <strong>\n     GameState object\n    </strong>\n    , which the\n    <strong>\n     Decision Module\n    </strong>\n    uses for easy access to game information.\n   </li>\n   <li>\n    It also initiates the\n    <strong>\n     asynchronous execution loops\n    </strong>\n    .\n   </li>\n  </ul>\n </li>\n</ul>\n<hr/>\n<h3>\n Decision Module\n</h3>\n<ul>\n <li>\n  <p>\n   <strong>\n    Decision Module Code Location:\n   </strong>\n   Check the example decision module code here:\n  </p>\n  <ul>\n   <li>\n    <a href=\"https://github.com/Pacbot-Competition/Pacbot-2/blob/main/bot_client/decisionModule.py\" rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n     Pacbot\n     -2\n     Decision\n     Module\n     Example\n    </a>\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Overview:\n   </strong>\n   The\n   <strong>\n    Decision Module\n   </strong>\n   calculates the robot's next move regardless of the strategy employed. Key points include:\n  </p>\n  <ul>\n   <li>\n    The calculation occurs within the\n    <strong>\n     decisionLoop()\n    </strong>\n    function.\n   </li>\n   <li>\n    The example provided instructs the robot to always move\n    <strong>\n     right\n    </strong>\n    .\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Socket Communication:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Communication with the robot (not the server) typically happens in the Decision Module, rather than the client body.\n   </li>\n   <li>\n    This method is preferred due to the complexities of sending decisions back and forth, given the asynchronous nature of the execution loops.\n   </li>\n  </ul>\n </li>\n</ul>\n<hr/>\n<p>\n If you have any questions or need further clarification on any part, let me know!\n</p>\n"}, "Page 7": {"response": "<h3>\n Helper Classes\n</h3>\n<ul>\n <li>\n  <p>\n   <strong>\n    Location:\n   </strong>\n   The helper classes are found in the same folder as the example client body and decision module.\n  </p>\n </li>\n <li>\n  <p>\n   <strong>\n    Key Class:\n    <code>\n     gameState.py\n    </code>\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Contains the\n    <strong>\n     GameState class\n    </strong>\n    , which provides crucial game information, such as:\n    <ul>\n     <li>\n      <strong>\n       Ghost Positions:\n      </strong>\n      Where ghosts are located in the game.\n     </li>\n     <li>\n      <strong>\n       Bot Location:\n      </strong>\n      The bot's current position (in coordinates, though not very precise).\n     </li>\n     <li>\n      <strong>\n       Current Game Mode:\n      </strong>\n      Status of the game (e.g., chase mode, scatter mode).\n     </li>\n    </ul>\n   </li>\n   <li>\n    This class can also predict future ghost moves, but you must calculate them using the provided function.\n   </li>\n  </ul>\n </li>\n</ul>\n<hr/>\n<h3>\n Computer Vision Client\n</h3>\n<ul>\n <li>\n  <strong>\n   Overview:\n  </strong>\n  There are two types of\n  <strong>\n   computer vision (CV) clients\n  </strong>\n  :\n  <ol>\n   <li>\n    <p>\n     <strong>\n      Harvard CV Client:\n     </strong>\n    </p>\n    <ul>\n     <li>\n      Code location:\n      <ul>\n       <li>\n        <a href=\"https://github.com/Pacbot-Competition/Pacbot-2/tree/main/cv_client\" rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n         Harvard\n         CV\n         Client\n        </a>\n       </li>\n      </ul>\n     </li>\n     <li>\n      Includes helpful\n      <strong>\n       CV tutorials\n      </strong>\n      .\n     </li>\n     <li>\n      Uses a marker-based tracking method.\n     </li>\n    </ul>\n   </li>\n   <li>\n    <p>\n     <strong>\n      Our CV Client:\n     </strong>\n    </p>\n    <ul>\n     <li>\n      Code location:\n      <ul>\n       <li>\n        <a href=\"https://github.com/iRobotics-Pacbot-2023-2024/Computer-Vision\" rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n         Our\n         CV\n         Client\n        </a>\n       </li>\n      </ul>\n     </li>\n     <li>\n      Utilizes\n      <strong>\n       OpenCV filters\n      </strong>\n      to isolate retroreflectors from the input.\n     </li>\n     <li>\n      Identifies retroreflectors and converts their positions into coordinates for Pacbot.\n     </li>\n     <li>\n      The main processing occurs in\n      <code>\n       cv_locater.py\n      </code>\n      , which contains essential code and comments.\n     </li>\n     <li>\n      Although the method is basic and can be improved, it aims for speed to effectively track faster-moving targets, supported by previous experimental results.\n     </li>\n     <li>\n      The\n      <code>\n       cvClient.py\n      </code>\n      file communicates results back to the server and follows a structure similar to the bot client body.\n     </li>\n    </ul>\n   </li>\n  </ol>\n </li>\n</ul>\n<hr/>\n<h3>\n Heuristic Path Planning\n</h3>\n<ul>\n <li>\n  <strong>\n   Decision Module Location:\n  </strong>\n  <ul>\n   <li>\n    The decision module for heuristic path planning can be found here:\n    <ul>\n     <li>\n      <a href=\"https://github.com/iRobotics-Pacbot-2023-2024/High-Level/blob/main/oldHeuristicsPort/oldDecisionModule.py\" rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n       Heuristic\n       Path\n       Planning\n       Module\n      </a>\n     </li>\n    </ul>\n   </li>\n  </ul>\n </li>\n</ul>\n<hr/>\n<h3>\n Normal Path Planning\n</h3>\n<ul>\n <li>\n  <strong>\n   Overview:\n  </strong>\n  The normal path planning algorithm works by:\n  <ul>\n   <li>\n    Traversing the\n    <strong>\n     action tree\n    </strong>\n    to explore potential paths.\n   </li>\n   <li>\n    Calculating a\n    <strong>\n     score for each path\n    </strong>\n    based on various coefficients (to be discussed in the next section).\n   </li>\n  </ul>\n </li>\n</ul>\n<hr/>\n<p>\n If you have more questions or need further details on any topic, feel free to ask!\n</p>\n"}, "Page 8": {"response": "<p>\n Here are detailed and concise notes on the\n <strong>\n  Surrounded Mode\n </strong>\n and\n <strong>\n  Heuristics Path Planning\n </strong>\n for the Pacbot, emphasizing key concepts:\n</p>\n<h3>\n<strong>\n  Heuristics Path Planning\n </strong>\n</h3>\n<ul>\n<li>\n<strong>\n   Objective:\n  </strong>\n  To navigate the Pacbot effectively by evaluating possible paths based on various game elements.\n </li>\n<li>\n<strong>\n   Scoring System:\n  </strong>\n<ul>\n<li>\n<strong>\n     Positive Scores:\n    </strong>\n    Gained from collecting\n    <strong>\n     pellets\n    </strong>\n    and\n    <strong>\n     power-ups\n    </strong>\n    .\n   </li>\n<li>\n<strong>\n     Negative Scores:\n    </strong>\n    Assigned when approaching\n    <strong>\n     non-frightened ghosts\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n</ul>\n<h3>\n<strong>\n  Surrounded Mode\n </strong>\n</h3>\n<ul>\n<li>\n<strong>\n   Purpose:\n  </strong>\n  Addresses the limitation of heuristic path planning where the Pacbot tends to hide in corners when surrounded by ghosts.\n </li>\n<li>\n<strong>\n   Problem:\n  </strong>\n  The heuristic maximizes distance from ghosts, leading to cornering instead of navigating between them.\n </li>\n</ul>\n<h4>\n<strong>\n  Implementation:\n </strong>\n</h4>\n<ul>\n<li>\n<strong>\n   Detection Methods:\n  </strong>\n<ul>\n<li>\n    Uses\n    <code>\n     _is_surrounded\n    </code>\n    and\n    <code>\n     _is_surrounded_state\n    </code>\n    to identify when the Pacbot is about to be surrounded.\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Escape Route Calculation:\n  </strong>\n<ul>\n<li>\n    Simulates future ghost actions with\n    <code>\n     _simulate_surrounded_action\n    </code>\n    .\n   </li>\n<li>\n    Traverses possible paths to find an escape route.\n   </li>\n<li>\n    If an escape route is found, it is queued for movement instructions, overriding standard heuristic actions.\n   </li>\n</ul>\n</li>\n</ul>\n<h4>\n<strong>\n  Challenges:\n </strong>\n</h4>\n<ol>\n<li>\n<strong>\n   Calculation Intensity:\n  </strong>\n<ul>\n<li>\n    Route finding can take\n    <strong>\n     1-2 seconds\n    </strong>\n    in worst-case scenarios, potentially rendering the escape ineffective.\n   </li>\n<li>\n    Need to shorten path search duration, which may yield\n    <strong>\n     sub-optimal routes\n    </strong>\n    .\n   </li>\n</ul>\n</li>\n<li>\n<strong>\n   Performance Mismatch:\n  </strong>\n<ul>\n<li>\n    Works well in simulations, doubling bot performance.\n   </li>\n<li>\n    Real-world execution has higher delays than expected, leading to failures in escape routes.\n   </li>\n<li>\n    Future adjustments may enhance synchronization between software and hardware to improve effectiveness.\n   </li>\n</ul>\n</li>\n</ol>\n<h3>\n<strong>\n  Adjustable Coefficients in Heuristics Path Planning\n </strong>\n</h3>\n<ul>\n<li>\n<strong>\n   Key Parameters:\n  </strong>\n<ul>\n<li>\n<strong>\n     PELLET_WEIGHT:\n    </strong>\n    Importance of collecting pellets.\n   </li>\n<li>\n<strong>\n     GHOST_WEIGHT:\n    </strong>\n    Risk associated with proximity to ghosts.\n   </li>\n<li>\n<strong>\n     FRIGHTENED_GHOST_WEIGHT:\n    </strong>\n    Benefits of chasing frightened ghosts.\n   </li>\n<li>\n<strong>\n     GHOST_CUTOFF:\n    </strong>\n    Distance at which ghosts become a threat.\n   </li>\n<li>\n<strong>\n     GHOST_FRIGHTENED_CUTOFF:\n    </strong>\n    Distance when ghosts become frightened.\n   </li>\n<li>\n<strong>\n     CHERRY_WEIGHT:\n    </strong>\n    Value of bonus items (cherries).\n   </li>\n<li>\n<strong>\n     REVERSE_WEIGHT:\n    </strong>\n    Impact of moving backward.\n   </li>\n<li>\n<strong>\n     SURROUNDED_WEIGHT:\n    </strong>\n    Consideration for being surrounded.\n   </li>\n<li>\n<strong>\n     SURROUND_RADIUS:\n    </strong>\n    Proximity threshold for detecting surrounding ghosts.\n   </li>\n<li>\n<strong>\n     SURROUND_DIFF:\n    </strong>\n    Variation in surrounding situations.\n   </li>\n</ul>\n</li>\n</ul>\n<h3>\n<strong>\n  Additional Resources\n </strong>\n</h3>\n<ul>\n<li>\n<strong>\n   Code Access:\n  </strong>\n  The implementation details can be found in the\n  <a href=\"https://github.com/iRobotics-Pacbot-2023-2024/High-Level/blob/main/oldHeuristicsPort/oldDecisionModule.py\" rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n   old\n   decision\n   module\n   code\n  </a>\n  .\n </li>\n<li>\n<strong>\n   Testing Data:\n  </strong>\n  Coefficient tuning data can be referenced in\n  <strong>\n   Pacbot Old Heuristics Tuning\n  </strong>\n  .\n </li>\n</ul>\n<p>\n This structured summary highlights the main aspects of the Surrounded Mode and heuristics path planning for the Pacbot, providing clarity on the challenges and configurations involved.\n</p>\n"}, "Page 9": {"response": "<h3>\n Heuristic Path Planning: Key Value\n</h3>\n<ul>\n <li>\n  <strong>\n   Important Value:\n  </strong>\n  The coefficient\n  <strong>\n   FRIGHTENED_GHOST_WEIGHT = 2\n  </strong>\n  is notable.\n  <ul>\n   <li>\n    <strong>\n     Comparison:\n    </strong>\n    This is significantly higher than the typical value of\n    <strong>\n     0.3\n    </strong>\n    .\n   </li>\n   <li>\n    <strong>\n     Effect:\n    </strong>\n    This adjustment makes Pacbot more aggressive when ghosts are frightened, prioritizing the pursuit of frightened ghosts over collecting pellets or avoiding non-frightened ghosts.\n   </li>\n   <li>\n    <strong>\n     Potential Reward:\n    </strong>\n    Successfully eating consecutive frightened ghosts can lead to high point combos, as each ghost eaten in succession yields exponentially more points.\n   </li>\n   <li>\n    <strong>\n     Term:\n    </strong>\n    This aggressive strategy is referred to as\n    <strong>\n     ALL IN MODE\n    </strong>\n    , which contributed to high scores during the\n    <strong>\n     2024 competition\n    </strong>\n    .\n   </li>\n  </ul>\n </li>\n</ul>\n<hr/>\n<h3>\n Reinforcement Learning Path Planning\n</h3>\n<h4>\n RL Model\n</h4>\n<ul>\n <li>\n  <strong>\n   Status:\n  </strong>\n  The details regarding the RL model are currently marked as\n  <strong>\n   TODO\n  </strong>\n  and are not provided.\n </li>\n</ul>\n<hr/>\n<h4>\n Old Training Environment\n</h4>\n<ul>\n <li>\n  <p>\n   <strong>\n    Location:\n   </strong>\n   The old training environment can be found here:\n  </p>\n  <ul>\n   <li>\n    <a href=\"https://github.com/iRobotics-Pacbot-2023-2024/High-Level/tree/main/RL/pacbotEnvOld\" rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n     Old\n     Training\n     Environment\n    </a>\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Overview:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Built using\n    <strong>\n     OpenAI Gym\n    </strong>\n    and\n    <strong>\n     Pygame\n    </strong>\n    , this environment replicates the original Pacman game using a\n    <strong>\n     tick-based system\n    </strong>\n    .\n   </li>\n   <li>\n    It shares functionality with the game server but may exhibit inconsistencies, such as differing ghost behaviors.\n   </li>\n   <li>\n    The server employs a more real-time simulation approach rather than a tick-based system.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Objective:\n   </strong>\n   The goal is to create an environment that reflects the bot\u2019s real-life performance more accurately for effective model training.\n  </p>\n </li>\n</ul>\n<hr/>\n<h4>\n Server-based Training Environment (Unfinished)\n</h4>\n<ul>\n <li>\n  <p>\n   <strong>\n    Purpose:\n   </strong>\n   The server-based training environment aims to connect the server with the RL model, allowing for direct training on more accurate data.\n  </p>\n  <ul>\n   <li>\n    This approach is intended to avoid the need to completely remake the training environment since the old one is outdated.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Challenges:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    <strong>\n     Asynchronous Issues:\n    </strong>\n    The environment faces difficulties due to asynchronous processes.\n   </li>\n   <li>\n    <strong>\n     Parallel Training:\n    </strong>\n    Conducting parallel training is particularly challenging as this environment relies on the server.\n   </li>\n   <li>\n    Each instance requires a unique executable, which introduces additional complications.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Code Location:\n   </strong>\n   You can find the code for this environment here:\n  </p>\n  <ul>\n   <li>\n    <a href=\"https://github.com/iRobotics-Pacbot-2023-2024/High-Level/tree/main/RL/pacbotEnvServer\" rel=\"noopener\" style=\"--streaming-animation-state: var(--batch-play-state-1); --animation-rate: var(--batch-play-rate-1);\" target=\"_new\">\n     Server\n     -based\n     Training\n     Environment\n    </a>\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Functionality:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    The environment utilizes a basic bot client to:\n    <ul>\n     <li>\n      Retrieve information from the server.\n     </li>\n     <li>\n      Send actions back to the server.\n     </li>\n    </ul>\n   </li>\n   <li>\n    The received data is then decoded into observations suitable for the\n    <strong>\n     OpenAI Gym\n    </strong>\n    environment.\n   </li>\n  </ul>\n </li>\n</ul>\n<p>\n If you have any questions or need further clarification, just let me know!\n</p>\n"}, "Page 10": {"response": "<h3>\n Testing\n</h3>\n<h4>\n Simulating a Game Using the Game Server\n</h4>\n<ol>\n <li>\n  <p>\n   <strong>\n    Setup Completion:\n   </strong>\n   Ensure you have completed the simulation setup.\n  </p>\n </li>\n <li>\n  <p>\n   <strong>\n    Start the Game Server:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Navigate to the\n    <strong>\n     server\n    </strong>\n    folder.\n   </li>\n   <li>\n    Look for the file named\n    <strong>\n     pacbot_server.exe\n    </strong>\n    .\n    <ul>\n     <li>\n      If it's not present, run the command\n      <code>\n       go build\n      </code>\n      again. If issues persist, seek assistance.\n     </li>\n    </ul>\n   </li>\n   <li>\n    In the command line or bash, type:\n    Copy code\n    <code class=\"!whitespace-pre hljs\">\n     pacbot_server.exe\n    </code>\n   </li>\n   <li>\n    Note: The command line won't show any output; this is normal.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Launch the Web Client:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Open a new command line instance and go to the\n    <strong>\n     web_client\n    </strong>\n    folder.\n   </li>\n   <li>\n    Type:\n    arduino\n    Copy code\n    <code class=\"!whitespace-pre hljs language-arduino\">\n     npm run dev\n    </code>\n   </li>\n   <li>\n    Follow the link provided to access the web application, typically running at\n    <strong>\n     localhost:5173\n    </strong>\n    .\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Start the Bot Client:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Open another command line instance and go to the\n    <strong>\n     bot_client\n    </strong>\n    folder.\n   </li>\n   <li>\n    Type:\n    Copy code\n    <code class=\"!whitespace-pre hljs\">\n     python pacbotClient.py\n    </code>\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Begin Simulation:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    With everything running, click the circle in the web application to start the simulation!\n   </li>\n  </ul>\n </li>\n</ol>\n<hr/>\n<h4>\n Simulating a Game With the Training Environment\n</h4>\n<ol>\n <li>\n  <p>\n   <strong>\n    Setup Completion:\n   </strong>\n   Ensure the environment setup is complete.\n  </p>\n </li>\n <li>\n  <p>\n   <strong>\n    Using the Old Environment:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    If working with the\n    <strong>\n     pacbotEnvOld\n    </strong>\n    folder, run either:\n    <ul>\n     <li>\n      <code>\n       playEnv.py\n      </code>\n      for user control.\n     </li>\n     <li>\n      <code>\n       testEnv.py\n      </code>\n      for model control (you may need to adjust\n      <code>\n       testEnv.py\n      </code>\n      to properly allow your model to input actions).\n     </li>\n    </ul>\n   </li>\n  </ul>\n </li>\n</ol>\n<hr/>\n<h3>\n Other Game Details\n</h3>\n<h4>\n Game Modes\n</h4>\n<ul>\n <li>\n  <p>\n   <strong>\n    Two Modes:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    <strong>\n     Scatter Mode:\n    </strong>\n    <ul>\n     <li>\n      In this mode, ghosts target the four corners of the arena.\n     </li>\n     <li>\n      After reaching these targets, they switch to chase mode.\n     </li>\n    </ul>\n   </li>\n   <li>\n    <strong>\n     Chase Mode:\n    </strong>\n    <ul>\n     <li>\n      Ghosts actively pursue Pacbot.\n     </li>\n    </ul>\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Activation:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Scatter mode begins at the start of the game and reactivates at specific times during gameplay.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Power-Ups:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Collecting a power-up frightens the ghosts, triggering them to enter chase mode.\n   </li>\n   <li>\n    Caution: Picking up power-ups early in the game can backfire, as it makes ghosts aggressive more quickly, potentially wasting the power-up.\n   </li>\n  </ul>\n </li>\n</ul>\n<p>\n For more details on ghost behavior, you may refer to the specified resources.\n</p>\n<p>\n If you have any further questions or need additional clarification, feel free to ask!\n</p>\n"}, "Page 11": {"response": "<h3>\n Software Low-level\n</h3>\n<h4>\n System Overview\n</h4>\n<p>\n The\n <strong>\n  Low-Level\n </strong>\n team plays a crucial role in supporting the robot\u2019s decision-making process by providing necessary data and executing the strategic decisions made by the\n <strong>\n  High-Level\n </strong>\n team. Their responsibilities can be categorized into three main areas:\n</p>\n<ol>\n <li>\n  <strong>\n   Localization\n  </strong>\n </li>\n <li>\n  <strong>\n   Movement\n  </strong>\n </li>\n <li>\n  <strong>\n   Communication\n  </strong>\n </li>\n</ol>\n<hr/>\n<h4>\n Localization\n</h4>\n<ul>\n <li>\n  <p>\n   <strong>\n    Primary Method:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    The robot\u2019s location is primarily tracked through\n    <strong>\n     Odometry\n    </strong>\n    (also known as\n    <strong>\n     Dead Reckoning\n    </strong>\n    ), which involves measuring the rotation of the robot's wheels at a high frequency to derive its path.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Kinematic Equations:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    This process uses kinematic equations to calculate the robot's movement based on wheel rotation data.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Increased Accuracy:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    To improve accuracy, the team employs\n    <strong>\n     Sensor Fusion\n    </strong>\n    , which integrates data from multiple sources.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Inertial Measurement Unit (IMU):\n   </strong>\n  </p>\n  <ul>\n   <li>\n    The IMU consists of:\n    <ul>\n     <li>\n      <strong>\n       Gyroscope:\n      </strong>\n      Measures the robot's heading with minimal drift (loss of accuracy over time).\n     </li>\n     <li>\n      <strong>\n       Accelerometer:\n      </strong>\n      Measures acceleration.\n     </li>\n     <li>\n      <strong>\n       Magnetometer:\n      </strong>\n      Measures orientation relative to magnetic fields.\n     </li>\n    </ul>\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Benefits of Sensor Fusion:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    By combining data from the IMU with odometric data, the robot can achieve a higher degree of accuracy in determining its heading and location. This mitigates errors that can accumulate over time due to slippage or other factors.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Challenges with Dead Reckoning:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    The main drawback of dead reckoning is that errors can build up over time, especially under high acceleration, leading to unusable data.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Mitigation Strategy:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    To counteract the issues with dead reckoning, the team is implementing a\n    <strong>\n     Monte Carlo algorithm\n    </strong>\n    that uses an array of distance sensors to derive the robot's location more accurately.\n   </li>\n  </ul>\n </li>\n</ul>\n<hr/>\n<p>\n If you have any questions or need further clarification, feel free to ask!\n</p>\n"}, "Page 12": {"response": "<h3>\n Software Low-level\n</h3>\n<h4>\n Communication\n</h4>\n<ul>\n <li>\n  <p>\n   <strong>\n    Current System:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    The communication system primarily uses\n    <strong>\n     WiFi\n    </strong>\n    for data transmission between the robot and the laptop.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Future Considerations:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    There is a plan to potentially switch to\n    <strong>\n     LoRa\n    </strong>\n    technology for lower latency communication. This is critical because the laptop directs the robot's movements and needs real-time updates on its location.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    MCL Localization Needs:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    With an\n    <strong>\n     MCL (Monte Carlo Localization)\n    </strong>\n    system, it's necessary to stream\n    <strong>\n     Time of Flight (TOF)\n    </strong>\n    data to the laptop and then send the computed location back to the robot.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Challenges in Multithreading:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    In a multithreaded environment, like the\n    <strong>\n     ESP32\n    </strong>\n    , it's essential to aggregate data from various tasks before sending it back to the laptop, adding complexity to the communication system.\n   </li>\n  </ul>\n </li>\n</ul>\n<hr/>\n<h4>\n Movement\n</h4>\n<ul>\n <li>\n  <p>\n   <strong>\n    Input Parameters:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    The movement system receives two main inputs:\n    <ul>\n     <li>\n      <strong>\n       Cardinal Direction:\n      </strong>\n      The direction the robot should move.\n     </li>\n     <li>\n      <strong>\n       Minimum Stopping Distance:\n      </strong>\n      The distance required for the robot to stop.\n     </li>\n    </ul>\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Trajectory Generation:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Based on these inputs, the system generates a\n    <strong>\n     trajectory\n    </strong>\n    , which includes:\n    <ul>\n     <li>\n      <strong>\n       Position Profile:\n      </strong>\n      Where the robot should move.\n     </li>\n     <li>\n      <strong>\n       Velocity Profile:\n      </strong>\n      The speed at which the robot should travel.\n     </li>\n     <li>\n      <strong>\n       Acceleration Profile:\n      </strong>\n      How quickly the robot should accelerate or decelerate.\n     </li>\n    </ul>\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Motor Control System:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    The generated profiles are sent to the motor control system, which adjusts the power supplied to each wheel to match the desired motion behavior.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Interruption Support:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    The movement system must support interruptions. If the\n    <strong>\n     High-Level\n    </strong>\n    system decides on a different direction, the movement system should quickly adapt to this new command.\n   </li>\n  </ul>\n </li>\n</ul>\n<hr/>\n<h4>\n Subtasks\n</h4>\n<ul>\n <li>\n  <strong>\n   RTOS:\n  </strong>\n  Real-Time Operating System to manage tasks and timing.\n </li>\n <li>\n  <strong>\n   MCL:\n  </strong>\n  Monte Carlo Localization for accurate positioning.\n </li>\n <li>\n  <strong>\n   Trajectories:\n  </strong>\n  Planning paths that include position, velocity, and acceleration.\n </li>\n <li>\n  <strong>\n   Comms:\n  </strong>\n  Communication systems for data transfer between components.\n </li>\n</ul>\n<p>\n If you need further details or clarifications on any section, let me know!\n</p>\n"}, "Page 13": {"response": "<h3>\n Electrical Overview of Pacbot Board (2023-2024)\n</h3>\n<h4>\n Purpose and Design\n</h4>\n<ul>\n <li>\n  The\n  <strong>\n   PCB (Printed Circuit Board)\n  </strong>\n  is designed for\n  <strong>\n   power management\n  </strong>\n  and\n  <strong>\n   component organization\n  </strong>\n  .\n </li>\n <li>\n  It serves as a mounting platform for sensors and motor breakout boards sourced from companies like\n  <strong>\n   Adafruit\n  </strong>\n  and\n  <strong>\n   Pololu\n  </strong>\n  .\n </li>\n <li>\n  The board is powered by a\n  <strong>\n   300 mAh battery\n  </strong>\n  .\n </li>\n</ul>\n<h4>\n Key Components\n</h4>\n<ul>\n <li>\n  <strong>\n   Kicad Files:\n  </strong>\n  Past years' PCB files are available in the GitHub repository.\n </li>\n <li>\n  <strong>\n   Parts List:\n  </strong>\n  A complete list of components can be accessed online.\n </li>\n</ul>\n<h4>\n Power Management\n</h4>\n<ul>\n <li>\n  The PCB includes a power management system that:\n  <ul>\n   <li>\n    <strong>\n     Steps Down Voltage:\n    </strong>\n    Converts high battery voltage (12V) to a lower voltage (3.3V) using the\n    <strong>\n     Pololu S7V8F3\n    </strong>\n    voltage regulator.\n   </li>\n   <li>\n    <strong>\n     Voltage Supervision:\n    </strong>\n    The\n    <strong>\n     TPS3847\n    </strong>\n    voltage supervisor from\n    <strong>\n     Texas Instruments\n    </strong>\n    monitors the battery voltage to prevent damage to the\n    <strong>\n     LiPo battery\n    </strong>\n    .\n    <ul>\n     <li>\n      If the battery voltage drops below a certain threshold, the supervisor triggers a reset signal.\n     </li>\n     <li>\n      This signal is connected to the gate of an\n      <strong>\n       NMOS\n      </strong>\n      transistor, which controls a relay.\n     </li>\n     <li>\n      When activated, the relay cuts off power to the system to prevent battery degradation.\n     </li>\n    </ul>\n   </li>\n  </ul>\n </li>\n</ul>\n<h4>\n Microcontroller and Sensors\n</h4>\n<ul>\n <li>\n  <p>\n   The\n   <strong>\n    ESP32\n   </strong>\n   microcontroller handles communication with sensors and actuators to track the robot\u2019s orientation and control movement.\n  </p>\n </li>\n <li>\n  <p>\n   <strong>\n    Sensors Used:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    <strong>\n     IMU (Inertial Measurement Unit):\n    </strong>\n    Provides orientation data using:\n    <ul>\n     <li>\n      <strong>\n       3-axis Accelerometers\n      </strong>\n     </li>\n     <li>\n      <strong>\n       Gyroscopes\n      </strong>\n     </li>\n     <li>\n      <strong>\n       Magnetometers\n      </strong>\n     </li>\n    </ul>\n   </li>\n   <li>\n    <strong>\n     TOF (Time of Flight) Sensors:\n    </strong>\n    Measure distance by calculating the time it takes for laser beams to return to the sensor.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Communication:\n   </strong>\n   Both IMU and TOF sensors connect to the ESP32 using an\n   <strong>\n    I2C\n   </strong>\n   line, which is pulled high for stability.\n  </p>\n </li>\n</ul>\n<h4>\n Motors and Motor Drivers\n</h4>\n<ul>\n <li>\n  The robot uses\n  <strong>\n   four 12V brushed motors\n  </strong>\n  for movement.\n </li>\n <li>\n  <strong>\n   Motor Drivers:\n  </strong>\n  <ul>\n   <li>\n    The ESP32 connects to these drivers, which are powered directly by the battery.\n   </li>\n   <li>\n    They control:\n    <ul>\n     <li>\n      <strong>\n       Speed\n      </strong>\n      and\n      <strong>\n       Direction\n      </strong>\n      of each motor.\n     </li>\n     <li>\n      Operating modes like\n      <strong>\n       Braking\n      </strong>\n      and\n      <strong>\n       Coasting\n      </strong>\n      .\n     </li>\n    </ul>\n   </li>\n  </ul>\n </li>\n <li>\n  <strong>\n   Motor Encoders:\n  </strong>\n  Each motor is equipped with encoders that provide feedback on:\n  <ul>\n   <li>\n    Direction and speed of rotation.\n   </li>\n   <li>\n    These encoders are connected to the ESP32 for real-time data.\n   </li>\n  </ul>\n </li>\n</ul>\n<h3>\n Summary\n</h3>\n<p>\n The Pacbot board is engineered for efficient power management, robust sensor integration, and precise motor control, ensuring optimal performance for the robot. Key components include the ESP32 microcontroller, IMU and TOF sensors, voltage regulation systems, and motor drivers, all working together to enhance the robot's navigati\n</p>\n"}, "Page 14": {"response": "<h3>\n Pacbot Board Images (2023-2024)\n</h3>\n<h4>\n Overview\n</h4>\n<ul>\n <li>\n  The\n  <strong>\n   Pacbot Board Images\n  </strong>\n  for the 2023-2024 season visually represent the design and layout of the PCB (Printed Circuit Board).\n </li>\n <li>\n  These images provide a clear understanding of how components are organized and connected.\n </li>\n</ul>\n<h4>\n Key Elements in the Images\n</h4>\n<ol>\n <li>\n  <p>\n   <strong>\n    Component Layout:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    The images show the positioning of key components such as:\n    <ul>\n     <li>\n      <strong>\n       Microcontroller (ESP32)\n      </strong>\n     </li>\n     <li>\n      <strong>\n       Voltage Regulators (Pololu S7V8F3)\n      </strong>\n     </li>\n     <li>\n      <strong>\n       Voltage Supervisor (TPS3847)\n      </strong>\n     </li>\n     <li>\n      <strong>\n       IMU and TOF Sensors\n      </strong>\n     </li>\n     <li>\n      <strong>\n       Motor Drivers\n      </strong>\n     </li>\n     <li>\n      <strong>\n       Relay and NMOS Transistor\n      </strong>\n     </li>\n    </ul>\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Power Management System:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Illustrations may highlight the circuit paths for:\n    <ul>\n     <li>\n      Voltage stepping down from 12V to 3.3V.\n     </li>\n     <li>\n      The connection of the voltage supervisor that monitors battery levels.\n     </li>\n    </ul>\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Sensor Connections:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Images detail how the\n    <strong>\n     IMU\n    </strong>\n    and\n    <strong>\n     TOF sensors\n    </strong>\n    connect to the ESP32 via the\n    <strong>\n     I2C line\n    </strong>\n    .\n   </li>\n   <li>\n    The layout may show the wiring for optimal signal integrity.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Motor Configuration:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    Visuals likely depict the arrangement of the\n    <strong>\n     brushed motors\n    </strong>\n    and their respective\n    <strong>\n     motor drivers\n    </strong>\n    .\n   </li>\n   <li>\n    Feedback from\n    <strong>\n     motor encoders\n    </strong>\n    can also be illustrated to show how they connect to the ESP32.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Relay System:\n   </strong>\n  </p>\n  <ul>\n   <li>\n    The relay setup for cutting off power based on battery voltage may be illustrated, showing how the NMOS transistor controls the relay.\n   </li>\n  </ul>\n </li>\n</ol>\n<h4>\n Importance of Images\n</h4>\n<ul>\n <li>\n  These images are crucial for:\n  <ul>\n   <li>\n    <strong>\n     Troubleshooting:\n    </strong>\n    They help in identifying component placements and connections.\n   </li>\n   <li>\n    <strong>\n     Documentation:\n    </strong>\n    Serve as a reference for future modifications or repairs.\n   </li>\n   <li>\n    <strong>\n     Education:\n    </strong>\n    Assist new team members in understanding the board layout and function.\n   </li>\n  </ul>\n </li>\n</ul>\n<h3>\n Summary\n</h3>\n<p>\n The Pacbot Board Images for 2023-2024 serve as a visual guide to the PCB's design, showcasing the layout and interconnections of various components essential for the robot's functionality. They are vital for troubleshooting, documentation, and educational purposes.\n</p>\n"}, "Page 15": {"response": "<p>\n Sure! Please provide the content you'd like me to restate and simplify for you.\n</p>\n"}, "Page 16": {"response": "<h3>\n Past Board Description (2022 - 2023)\n</h3>\n<ul>\n <li>\n  <strong>\n   Main Components\n  </strong>\n  : This board utilizes a\n  <strong>\n   Raspberry Pi\n  </strong>\n  instead of the\n  <strong>\n   ESP32\n  </strong>\n  .\n </li>\n <li>\n  <strong>\n   Functionality\n  </strong>\n  :\n  <ul>\n   <li>\n    The\n    <strong>\n     Raspberry Pi\n    </strong>\n    is responsible for relaying information from a computer to the\n    <strong>\n     Teensy\n    </strong>\n    microcontroller.\n   </li>\n   <li>\n    The\n    <strong>\n     Teensy\n    </strong>\n    manages low-level control of the robot.\n   </li>\n  </ul>\n </li>\n <li>\n  <strong>\n   Consistency\n  </strong>\n  : Other components of the robot remain unchanged from the current model.\n </li>\n</ul>\n<h3>\n Past Board Images (2022 - 2023)\n</h3>\n<ul>\n <li>\n  <strong>\n   Visual Reference\n  </strong>\n  : Images from this period can help visualize the board's layout and components but are not provided in this context.\n </li>\n</ul>\n<p>\n This summary outlines the significant changes and roles of components in the board used from 2022 to 2023.\n</p>\n"}, "Page 17": {"response": "<h3>\n Lighting Board Description\n</h3>\n<ul>\n <li>\n  <strong>\n   Purpose\n  </strong>\n  : The\n  <strong>\n   lighting board\n  </strong>\n  is designed to control the lighting systems of the robot.\n </li>\n <li>\n  <strong>\n   Components\n  </strong>\n  :\n  <ul>\n   <li>\n    <strong>\n     LEDs\n    </strong>\n    : The board typically features various\n    <strong>\n     LED lights\n    </strong>\n    for visibility and signaling.\n   </li>\n   <li>\n    <strong>\n     Drivers\n    </strong>\n    :\n    <strong>\n     LED drivers\n    </strong>\n    regulate the power and brightness of the LEDs.\n   </li>\n  </ul>\n </li>\n <li>\n  <strong>\n   Control\n  </strong>\n  : The lighting board is usually controlled by a\n  <strong>\n   microcontroller\n  </strong>\n  or through connections with other boards (like the Raspberry Pi or Teensy) to enable dynamic lighting effects based on game states or robot actions.\n </li>\n <li>\n  <strong>\n   Power Supply\n  </strong>\n  : It is powered by the main battery of the robot, ensuring it operates efficiently without draining additional power sources.\n </li>\n <li>\n  <strong>\n   Integration\n  </strong>\n  : The lighting board is integrated with the robot\u2019s overall architecture, allowing for synchronization with movement and other functions.\n </li>\n</ul>\n<p>\n This summary outlines the key features and functions of the lighting board, emphasizing its role in the robot's operation.\n</p>\n"}, "Page 18": {"response": "<h3>\n Mechanical Overview\n</h3>\n<ul>\n <li>\n  <p>\n   <strong>\n    Structure\n   </strong>\n   : The\n   <strong>\n    mechanical design\n   </strong>\n   of the robot provides stability and support for all components. It includes a chassis that houses the electronics and sensors.\n  </p>\n </li>\n <li>\n  <p>\n   <strong>\n    Materials\n   </strong>\n   : Commonly used materials include lightweight yet durable options like\n   <strong>\n    aluminum\n   </strong>\n   or\n   <strong>\n    plastic\n   </strong>\n   , which reduce weight while maintaining strength.\n  </p>\n </li>\n <li>\n  <p>\n   <strong>\n    Mobility\n   </strong>\n   :\n  </p>\n  <ul>\n   <li>\n    The robot typically utilizes\n    <strong>\n     wheeled locomotion\n    </strong>\n    , allowing for agile movement across the arena.\n   </li>\n   <li>\n    <strong>\n     Brushed motors\n    </strong>\n    drive the wheels, providing sufficient torque for quick acceleration and maneuverability.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Sensors\n   </strong>\n   : Mechanical components are integrated with various\n   <strong>\n    sensors\n   </strong>\n   :\n  </p>\n  <ul>\n   <li>\n    <strong>\n     IMU (Inertial Measurement Unit)\n    </strong>\n    : Measures orientation and motion, crucial for navigation.\n   </li>\n   <li>\n    <strong>\n     TOF (Time of Flight) sensors\n    </strong>\n    : Detect distances to obstacles, enhancing the robot's ability to avoid collisions.\n   </li>\n  </ul>\n </li>\n <li>\n  <p>\n   <strong>\n    Assembly\n   </strong>\n   : The robot\u2019s components are assembled using standard fasteners, allowing for easy maintenance and upgrades.\n  </p>\n </li>\n <li>\n  <p>\n   <strong>\n    Cooling\n   </strong>\n   : If necessary, the design may incorporate\n   <strong>\n    ventilation\n   </strong>\n   or\n   <strong>\n    heat sinks\n   </strong>\n   to prevent overheating of electronic components during operation.\n  </p>\n </li>\n</ul>\n<p>\n This summary highlights the key aspects of the robot's mechanical design, emphasizing its structural integrity, mobility, and integration wi\n</p>\n"}}